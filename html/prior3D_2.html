<div class="container">

<table style="width: 100%;"><tr>
<td>coherence</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Coherence metrics</h2>

<h3>Description</h3>

<p>Coherence metrics
</p>


<h3>Usage</h3>

<pre><code class="language-R">coherence(x, w, metric = "sa", normalize = TRUE, plot = TRUE, addlines = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>Output of <b>Compare_2D_3D</b> function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>Integer indicating square window dimensions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>

<p>Cohension metric to use. It must be one of <code>"sa"</code>, <code>"sku"</code> and <code>"rao"</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>

<p>If <code>TRUE</code>, then sum of solutions is normalized at a <code class="reqn">[0,1]</code> scale.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>

<p>If <code>TRUE</code>, then coherence maps are ploted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addlines</code></td>
<td>

<p>If <code>TRUE</code>, then border lines from <code>maps::map</code> are ploted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments passed in function, based on metric choice. See more in Details.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>"sa"</code> and <code>"sku"</code> are derived from <code>geodiv::focal_metrics</code> and
in ellipsis (<code>...</code>) further arguments of
<code>geodiv::focal_metrics</code>  are passed.
</p>
<p><code>metric = "rao"</code> is derived from <code>rasterdiv::paRao</code> and in ellipsis
(<code>...</code>) further arguments of <code>rasterdiv::paRao</code> are passed.
</p>


<h3>Value</h3>

<p><code>numeric</code> vector with 2D and 3D metrics. The result maps are optionally
ploted.
</p>


<h3>References</h3>

<p>Rocchini, Duccio, Matteo Marcantonio, Daniele Da Re, Giovanni Bacaro, Enrico Feoli, Giles
Foody, Reinhard Furrer, et al. 2021. "From zero to infinity: Minimum to maximum diversity
of the planet by spatio-parametric Raoâ€™s quadratic entropy." Global Ecology and
Biogeography 30 (5): 2315.
<a href="https://doi.org/10.1111/geb.13270">doi:10.1111/geb.13270</a>.
</p>
<p>Rocchini, Duccio, Elisa Thouverai, Matteo Marcantonio, Martina Iannacito, Daniele Da Re,
Michele Torresani, Giovanni Bacaro, et al. 2021. "rasterdiv - An Information Theory
tailored R package for measuring ecosystem heterogeneity from space: To the origin and
back." Methods in Ecology and Evolution 12 (6): 2195.
<a href="https://doi.org/10.1111/2041-210X.13583">doi:10.1111/2041-210X.13583</a>.
</p>
<p>Smith, Annie C., Phoebe Zarnetske, Kyla Dahlin, Adam Wilson, and Andrew Latimer. 2023.
Geodiv: Methods for Calculating Gradient Surface Metrics.
<a href="https://CRAN.R-project.org/package=geodiv">
https://CRAN.R-project.org/package=geodiv</a>.
</p>
<p>Becker OScbRA, Minka ARWRvbRBEbTP, Deckmyn. A (2023). maps: Draw
Geographical Maps. R package version 3.4.2,
<a href="https://CRAN.R-project.org/package=maps">
https://CRAN.R-project.org/package=maps</a>
</p>


<h3>See Also</h3>

<p><code>Compare_2D_3D</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## This example requires commercial solver from 'gurobi' package for
## portfolio = "gap". Else replace it with e.g. portfolio = "shuffle" for using
## a free solver like the one from 'highs' package.

biodiv_raster &lt;- get_biodiv_raster()
depth_raster &lt;- get_depth_raster()
data(biodiv_df)

out_2D_3D &lt;- Compare_2D_3D(biodiv_raster = biodiv_raster,
                           depth_raster = depth_raster,
                           breaks = c(0, -40, -200, -2000, -Inf),
                           biodiv_df = biodiv_df,
                           budget_percents = seq(0, 1, 0.1),
                           budget_weights = "richness",
                           threads = parallel::detectCores(),
                           portfolio = "gap",
                           portfolio_opts = list(number_solutions = 10))

coherence(out_2D_3D, w = 3, metric = "sa")
coherence(out_2D_3D, w = 3, metric = "sku")
coherence(out_2D_3D, w = 3, metric = "rao")

## End(Not run)
</code></pre>


</div>
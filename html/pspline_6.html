<div class="container">

<table style="width: 100%;"><tr>
<td>smooth.Pspline</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit a Polynomial Smoothing Spline of Arbitrary Order
</h2>

<h3>Description</h3>

<p>Returns an object of class <code>"smooth.Pspline"</code> which is a natural 
polynomial smooth of the input data of order fixed by the user.
</p>


<h3>Usage</h3>

<pre><code class="language-R">smooth.Pspline(x, y, w=rep(1, length(x)), norder=2, df=norder + 2, 
               spar=0, method=1)
sm.spline(x, y, w, cv=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>values of the predictor variable.  These must be strictly increasing,
and there must be at least <code>2*norder + 1</code> of them.
</p>
<p><code>sm.spline</code> provides a simplified interface, in which the <code>x</code>
values can be unsorted, or a list with components <code>"x"</code> and
<code>"y"</code> or a two-column matrix or a complex vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>one or more sets of response variable values.  If there is one
response variable, <code>y</code> is an array of the same length as <code>x</code>; if more
than one, then <code>y</code> is a matrix with <code>length(x)</code> rows and number of
columns equal to the number of variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>vector of positive weights for smoothing of the same length as <code>x</code>.
If measurements at different values of <code>x</code> have different
variances, <code>w</code>
should be inversely proportional to the variances.  The default is
that all weights are one.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norder</code></td>
<td>

<p>the order of the spline.  <code>norder = 2</code> gives the cubic smoothing
spline, and more generally the smoothing function is a piecewise
polynomial of degree <code>2*norder - 1</code>.  If derivatives are to be
computed from the smoothing using <code>predict.smooth.Pspline</code>, the order
should be one or two more than the highest order of derivative.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>

<p>a number which specifies the degrees of freedom = trace(S).  Here S is
the implicit smoothing matrix.  <code>df</code> controls the amount of smoothing
if <code>method = 2</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spar</code></td>
<td>

<p>the usual smoothing parameter for smoothing splines, which is the
coefficient of the integrated squared derivative of order <code>norder</code>.
<code>spar</code> controls the amount of smoothing if <code>method = 1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv</code></td>
<td>
<p>logical: should ordinary cross-validation be used (true) or
generalized cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>the method for controlling the amount of smoothing.  <code>method = 1</code> uses
the value supplied for <code>spar</code>.  <code>method = 2</code> adjusts <code>spar</code> so that the
degrees of freedom is equal to <code>df</code>.  <code>method = 3</code> adjusts <code>spar</code> so
that the generalized cross-validation criterion is minimized.
<code>method = 4</code> adjusts <code>spar</code> so that the ordinary cross-validation criterion is
minimized.  If <code>method = 3</code> or <code>method = 4</code>, <code>spar</code> defines the initial
value for the minimization algorithm if positive; otherwise an
internally generated value is used.
</p>
<p><code>sm.spline</code> chooses this automatically based on the supplied values
and that of <code>cv</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments to be passed to <code>smooth.Pspline</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The method produces results similar to function <code>smooth.spline</code>, but
the smoothing function is a natural smoothing spline rather than a B-spline
smooth, and as a consequence will differ slightly for <code>norder = 2</code> over the
initial and final intervals.  
</p>
<p>The main extension is the possibility of setting the order of
derivative to be penalized, so that derivatives of any order can be
computed using the companion function <code>predict.smooth.Pspline</code>.  The
algorithm is of order N, meaning that the number of floating point
operations is proportional to the number of values being smoothed.
Note that the argument values must be strictly increasing, a condition
that is not required by <code>smooth.spline</code>.
</p>
<p>Note that the appropriate or minimized value of the smoothing parameter
<code>spar</code> will depend heavily on the order; the larger the order, the smaller
this parameter will tend to be.
</p>


<h3>Value</h3>

<p>an object of class <code>"smooth.Pspline"</code> is returned, consisting of the fitted
smoothing spline evaluated at the supplied data, some fitting criteria
and constants.  This object contains the information necessary to evaluate
the smoothing spline or one of its derivatives at arbitrary argument
values using <code>predict.smooth.Pspline</code>.  The components of the returned
list are
</p>
<table>
<tr style="vertical-align: top;">
<td><code>norder</code></td>
<td>

<p>the order of the spline  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>values of the predictor variable
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ysmth</code></td>
<td>

<p>a matrix with <code>length(x)</code> rows, each column of which contains
the smoothed response variable values for the corresponding column of <code>y</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lev</code></td>
<td>

<p>leverage values, which are the diagonal elements of the smoother matrix S.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gcv</code></td>
<td>

<p>generalized cross-validation criterion value
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv</code></td>
<td>

<p>ordinary cross-validation criterion value
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>

<p>a number which supplies the degrees of freedom = trace(S) rather than
a smoothing parameter.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spar</code></td>
<td>

<p>the final smoothing parameter for smoothing splines.  This
is unchanged if <code>method = 1</code>, but adjusted otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>

<p>the call that produced the fit.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Heckman, N. and Ramsay, J. O. (1996) Spline smoothing with model based
penalties.  McGill University, unpublished manuscript.
</p>


<h3>See Also</h3>

<p><code>predict.smooth.Pspline</code>, <code>smooth.spline</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(cars)
attach(cars)
plot(speed, dist, main = "data(cars)  &amp;  smoothing splines")
cars.spl &lt;- sm.spline(speed, dist)
cars.spl
lines(cars.spl, col = "blue")
lines(sm.spline(speed, dist, df=10), lty=2, col = "red")
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>plspm.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Basic results for Partial Least Squares Path Modeling</h2>

<h3>Description</h3>

<p>Estimate path models with latent variables by partial
least squares approach without providing the full list of
results as <code>plspm()</code>. This might be helpful when
doing simulations, intensive computations, or when you
don't want the whole enchilada.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  plspm.fit(Data, path_matrix, blocks, modes = NULL,
    scaling = NULL, scheme = "centroid", scaled = TRUE,
    tol = 1e-06, maxiter = 100, plscomp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Data</code></td>
<td>
<p>matrix or data frame containing the manifest
variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path_matrix</code></td>
<td>
<p>A square (lower triangular) boolean
matrix representing the inner model (i.e. the path
relationships betwenn latent variables).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blocks</code></td>
<td>
<p>list of vectors with column indices or
column names from <code>Data</code> indicating the sets of
manifest variables forming each block (i.e. which
manifest variables correspond to each block).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>
<p>optional list of string vectors indicating
the type of measurement scale for each manifest variable
specified in <code>blocks</code>. <code>scaling</code> must be
specified when working with non-metric variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modes</code></td>
<td>
<p>character vector indicating the type of
measurement for each block. Possible values are:
<code>"A", "B", "newA", "PLScore", "PLScow"</code>. The length
of <code>modes</code> must be equal to the length of
<code>blocks</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scheme</code></td>
<td>
<p>string indicating the type of inner
weighting scheme. Possible values are <code>"centroid"</code>,
<code>"factorial"</code>, or <code>"path"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaled</code></td>
<td>
<p>whether manifest variables should be
standardized. Only used when <code>scaling = NULL</code>. When
(<code>TRUE</code> data is scaled to standardized values
(mean=0 and variance=1). The variance is calculated
dividing by <code>N</code> instead of <code>N-1</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>decimal value indicating the tolerance
criterion for the iterations (<code>tol=0.000001</code>). Can
be specified between 0 and 0.001.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>integer indicating the maximum number of
iterations (<code>maxiter=100</code> by default). The minimum
value of <code>maxiter</code> is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plscomp</code></td>
<td>
<p>optional vector indicating the number of
PLS components (for each block) to be used when handling
non-metric data (only used if <code>scaling</code> is
provided)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>plspm.fit</code> performs the basic PLS algorithm and
provides limited results (e.g. outer model, inner model,
scores, and path coefficients). <br></p>
<p>The argument <code>path_matrix</code> is a matrix of zeros and
ones that indicates the structural relationships between
latent variables. <code>path_matrix</code> must be a lower
triangular matrix; it contains a 1 when column <code>j</code>
affects row <code>i</code>, 0 otherwise. <br></p>


<h3>Value</h3>

<p>An object of class <code>"plspm"</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>outer_model</code></td>
<td>
<p>Results of the outer model. Includes:
outer weights, standardized loadings, communalities, and
redundancies</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inner_model</code></td>
<td>
<p>Results of the inner (structural)
model. Includes: path coeffs and R-squared for each
endogenous latent variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>Matrix of latent variables used to estimate
the inner model. If <code>scaled=FALSE</code> then
<code>scores</code> are latent variables calculated with the
original data (non-stardardized). If <code>scaled=TRUE</code>
then <code>scores</code> and <code>latents</code> have the same
values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path_coefs</code></td>
<td>
<p>Matrix of path coefficients (this
matrix has a similar form as <code>path_matrix</code>)</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Gaston Sanchez, Giorgio Russolillo
</p>


<h3>References</h3>

<p>Tenenhaus M., Esposito Vinzi V., Chatelin Y.M., and Lauro
C. (2005) PLS path modeling. <em>Computational
Statistics &amp; Data Analysis</em>, <b>48</b>, pp. 159-205.
</p>
<p>Lohmoller J.-B. (1989) <em>Latent variables path
modeling with partial least squares.</em> Heidelberg:
Physica-Verlag.
</p>
<p>Wold H. (1985) Partial Least Squares. In: Kotz, S.,
Johnson, N.L. (Eds.), <em>Encyclopedia of Statistical
Sciences</em>, Vol. 6. Wiley, New York, pp. 581-591.
</p>
<p>Wold H. (1982) Soft modeling: the basic design and some
extensions. In: K.G. Joreskog &amp; H. Wold (Eds.),
<em>Systems under indirect observations: Causality,
structure, prediction</em>, Part 2, pp. 1-54. Amsterdam:
Holland.
</p>


<h3>See Also</h3>

<p><code>innerplot</code>, <code>plot.plspm</code>,
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
 ## typical example of PLS-PM in customer satisfaction analysis
 ## model with six LVs and reflective indicators

 # load dataset satisfaction
 data(satisfaction)

 # inner model matrix
 IMAG = c(0,0,0,0,0,0)
 EXPE = c(1,0,0,0,0,0)
 QUAL = c(0,1,0,0,0,0)
 VAL = c(0,1,1,0,0,0)
 SAT = c(1,1,1,1,0,0)
 LOY = c(1,0,0,0,1,0)
 sat_path = rbind(IMAG, EXPE, QUAL, VAL, SAT, LOY)

 # outer model list
 sat_blocks = list(1:5, 6:10, 11:15, 16:19, 20:23, 24:27)

 # vector of reflective modes
 sat_modes = rep("A", 6)

 # apply plspm.fit
 satpls = plspm.fit(satisfaction, sat_path, sat_blocks, sat_modes,
     scaled=FALSE)

 # summary of results
 summary(satpls)

 # default plot (inner model)
 plot(satpls)
 
## End(Not run)
</code></pre>


</div>
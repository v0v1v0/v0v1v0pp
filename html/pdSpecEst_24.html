<div class="container">

<table style="width: 100%;"><tr>
<td>pdSpecEst2D</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Intrinsic wavelet HPD time-varying spectral estimation</h2>

<h3>Description</h3>

<p><code>pdSpecEst2D</code> calculates a <code class="reqn">(d,d)</code>-dimensional HPD wavelet-denoised time-varying spectral matrix estimator
by applying the following steps to an initial noisy HPD time-varying spectral estimate (obtained with e.g., <code>pdPgram2D</code>):
</p>

<ol>
<li>
<p> a forward intrinsic AI wavelet transform, with <code>WavTransf2D</code>,
</p>
</li>
<li>
<p> (tree-structured) thresholding of the wavelet coefficients, with <code>pdCART</code>,
</p>
</li>
<li>
<p> an inverse intrinsic AI wavelet transform, with <code>InvWavTransf2D</code>.
</p>
</li>
</ol>
<p>The complete estimation procedure is described in more detail in Chapter 5 of (Chau 2018).
</p>


<h3>Usage</h3>

<pre><code class="language-R">pdSpecEst2D(P, order = c(3, 3), metric = "Riemannian", alpha = 1,
  return_val = "f", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>a (<code class="reqn">d,d,n1,n2</code>)-dimensional array of HPD matrices corresponding to a rectangular surface of <code class="reqn">(d,d)</code>-dimensional HPD matrices
of size <code class="reqn">n_1 \times n_2</code>, with <code class="reqn">n_1 = 2^{J_1}</code> and <code class="reqn">n_2 = 2^{J_2}</code> for some <code class="reqn">J_1, J_2 &gt; 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>a 2-dimensional numeric vector <code class="reqn">(1,1) \le</code> <code>order</code> <code class="reqn">\le (9,9)</code> corresponding to the marginal
orders of the intrinsic 2D AI refinement scheme, defaults to <code>order = c(3, 3)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>the metric that the space of HPD matrices is equipped with. The default choice is <code>"Riemannian"</code>,
but this can also be one of: <code>"logEuclidean"</code>, <code>"Cholesky"</code>, <code>"rootEuclidean"</code> or
<code>"Euclidean"</code>. See also the Details section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>an optional tuning parameter in the wavelet thresholding procedure. The penalty (or sparsity)
parameter in the tree-structured wavelet thresholding procedure in <code>pdCART</code> is set to <code>alpha</code>
times the estimated universal threshold, defaults to <code>alpha = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_val</code></td>
<td>
<p>an optional argument that specifies whether the denoised spectral estimator
is returned or not. See the Details section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments for internal use.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The input array <code>P</code> corresponds to an initial noisy HPD time-varying spectral estimate of the (<code class="reqn">d, d</code>)-dimensional
spectral matrix at a time-frequency grid of size <code class="reqn">m_1 \times m_2</code>, with <code class="reqn">m_1, m_2</code> dyadic numbers. This can be e.g.,
a multitaper HPD time-varying periodogram given as output by the function <code>pdPgram2D</code>.<br><code>P</code> is transformed to the wavelet domain by the function <code>WavTransf2D</code>, which applies an intrinsic
2D AI wavelet transform based on a metric specified by the user. The noise is removed by tree-structured
thresholding of the wavelet coefficients based on the trace of the whitened coefficients with <code>pdCART</code> by
minimization of a <em>complexity penalized residual sum of squares</em> (CPRESS) criterion via the fast tree-pruning algorithm
in (Donoho 1997). The penalty (i.e., sparsity) parameter in the optimization procedure is set equal to <code>alpha</code>
times the universal threshold, where the noise variance of the traces of the whitened wavelet
coefficients are determined from the finest wavelet scale. See Chapter 5 of (Chau 2018)
for further details. <br>
The function computes the forward and inverse intrinsic 2D AI wavelet transform in the space of HPD matrices equipped with
one of the following metrics: (i) the affine-invariant Riemannian metric (default) as detailed in e.g., (Bhatia 2009)[Chapter 6]
or (Pennec et al. 2006); (ii) the log-Euclidean metric, the Euclidean inner product between matrix logarithms;
(iii) the Cholesky metric, the Euclidean inner product between Cholesky decompositions; (iv) the Euclidean metric; or
(v) the root-Euclidean metric. The default choice of metric (affine-invariant Riemannian) satisfies several useful properties
not shared by the other metrics, see (Chau and von
Sachs 2019) or (Chau 2018) for more details. Note that this comes
at the cost of increased computation time in comparison to one of the other metrics. <br>
If <code>return_val = 'f'</code> the thresholded wavelet coefficients are transformed back to the time-frequency domain by
the inverse intrinsic 2D AI wavelet transform via <code>InvWavTransf2D</code>, returning the wavelet-denoised
HPD time-varying spectral estimate.
</p>


<h3>Value</h3>

<p>The function returns a list with the following five components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>f </code></td>
<td>
<p> a (<code class="reqn">d,d,m1,m2</code>)-dimensional array of HPD matrices, corresponding to the HPD wavelet-denoised estimate
on the same resolution grid of size <code class="reqn">m_1 \times m_2</code> as specified by the input array <code>P</code>. If <code>return_val != 'f'</code>, the
inverse wavelet transform of the thresholded wavelet coefficients is not computed and <code>f</code> is set equal to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D </code></td>
<td>
<p> the 2D pyramid of threshold wavelet coefficients. This is a list of arrays, where each array contains the rectangular grid
(<code class="reqn">d,d</code>)-dimensional thresholded wavelet coefficients from the coarsest wavelet scale <code>j = 0</code> up to the finest
wavelet scale <code>j = jmax</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M0 </code></td>
<td>
<p> a numeric array containing the midpoint(s) at the coarsest scale <code>j = 0</code> in the 2D midpoint pyramid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree.weights </code></td>
<td>
<p> a list of logical values specifying which coefficients to keep, with each list component
corresponding to an individual wavelet scale starting from the coarsest wavelet scale <code>j = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D.raw </code></td>
<td>
<p> the 2D pyramid of non-thresholded wavelet coefficients in the same format as the component <code>$D</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Bhatia R (2009).
<em>Positive Definite Matrices</em>.
Princeton University Press, New Jersey.<br><br> Chau J (2018).
<em>Advances in Spectral Analysis for Multivariate, Nonstationary and Replicated Time Series</em>.
phdthesis, Universite catholique de Louvain.<br><br> Chau J, von
Sachs R (2019).
“Intrinsic wavelet regression for curves of Hermitian positive definite matrices.”
<em>Journal of the American Statistical Association</em>.
doi: <a href="https://doi.org/10.1080/01621459.2019.1700129">10.1080/01621459.2019.1700129</a>.<br><br> Donoho D (1997).
“CART and best-ortho-basis: a connection.”
<em>The Annals of Statistics</em>, <b>25</b>(5), 1870–1911.<br><br> Pennec X, Fillard P, Ayache N (2006).
“A Riemannian framework for tensor computing.”
<em>International Journal of Computer Vision</em>, <b>66</b>(1), 41–66.
</p>


<h3>See Also</h3>

<p><code>pdPgram2D</code>, <code>WavTransf2D</code>, <code>InvWavTransf2D</code>, <code>pdCART</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
P &lt;- rExamples2D(c(2^6, 2^6), 2, example = "tvar")$P
f &lt;- pdSpecEst2D(P)

## End(Not run)

</code></pre>


</div>
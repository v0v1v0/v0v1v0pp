<div class="container">

<table style="width: 100%;"><tr>
<td>CauRuimet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Robust estimation of within group varinace-covariance</h2>

<h3>Description</h3>

<p> Gives a robust estimate of an unknown within group covariance, aiming either to look
for dense groups or to sparse groups (outliers) according to <em>local variance and weighting
function</em> choice.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> CauRuimet(Z,ker=1,m0=1,withingroup=TRUE,
              loc=substitute(apply(Z,2,mean,trim=.1)),matrixmethod=TRUE, Nrandom=3000)

        </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ker</code></td>
<td>
<p>either numerical or a function:
if numerical the weighting function is <code class="reqn">e^{(-ker \;t)}</code>, otherwise
<br> ker=function(t){return(expression)} is a positive decreasing function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m0</code></td>
<td>

<p>is a graph of neighbourhood or another proximity matrix, the hadamard product of the proximities
will be operated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withingroup</code></td>
<td>

<p>logical,if <code>TRUE</code> the aim is to give a robust estimate for dense groups, if <code>FALSE</code> the
aim is to give a robust estimate for outliers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc</code></td>
<td>

<p>a vector of locations or a function using mean, median, to give an estimate of it</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrixmethod</code></td>
<td>
<p>if <code>TRUE</code> (only with <code>withingroup</code>) uses some matrix computation rather
than double looping as suggests the formula below </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nrandom</code></td>
<td>
<p>if <code>Nrandom &lt; dim(Z)[1]</code>) uses  only  a <code>Nrandom</code> sample from rows of <code>Z</code> and  
<code>m0</code> if applicable.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When withingroup is <code>TRUE</code>, local(defined by the weighting) variance formula is returned, aiming
at finding dense groups: </p>
<p style="text-align: center;"><code class="reqn">W_l=\frac{\sum_{i=1}^{n-1}\sum_{j=i+1}^n
m0_{ij}ker(d^2_{S^-}(Z_i,Z_j))(Z_i-Z_j)'(Z_i-Z_j)}{\sum_{i=1}^{n-1}\sum_{j=i+1}^n
m0_{ij}ker(d^2_{S^-}(Z_i,Z_j))}</code>
</p>
<p> where <code class="reqn">d^2_{S^-}( . , .)</code> is the squared euclidian distance with
<code class="reqn">S^-</code> the inverse of a robust sample covariance (i.e. using <code>loc</code> instead of the mean) ;
if <code>FALSE</code> robust Total weighted variance or if <code>m0</code> not 1  Global weighted variance, is returned:
</p>
<p style="text-align: center;"><code class="reqn">W_o=\frac{\sum_{i=1}^nker(d^2_{S^-}(Z_i,\tilde{Z}))(Z_i-\tilde{Z})'(Z_i-\tilde{Z})}
 {\sum_{i=1}^n  ker(d^2_{S^-}(Z_i,\tilde{Z}))}</code>
</p>

<p style="text-align: center;"><code class="reqn">W_g=\frac{\sum_{i=1}^{n-1}\sum_{j=i+1}^n
m0_{ij}.ker(d^2_{S^-}(Z_i,Z_j))(Z_i-\tilde{Z})'(Z_j-\tilde{Z})}
 {\sum_{i=1}^{n-1}\sum_{j=i+1}^n
m0_{ij}ker(d^2_{S^-}(Z_i,Z_j))}</code>
</p>

<p>where <code class="reqn">\tilde{Z}</code> is the vector <code>loc</code>.
<br>
If <code>m0</code> is a graph of neighbourhood and ker is the function returning 1 (no proximity due to
distance is used) the function will return (when <code>withingroup=TRUE</code>) the <em>local
variance-covariance</em> matrix as define in Lebart(1969). </p>


<h3>Value</h3>

<p>a matrix</p>


<h3>Note</h3>

<p>As mentioned by Caussinus and Ruiz a good strategy to reveal dense groups with generalised PCA
would be to reveal outliers first using the metric <code class="reqn">W_o^{-1}</code> and remove them before using the
metric <code class="reqn">W_l^{-1}</code>. Based on theoretical considerations they recommand for  the choice of
<code>ker</code>, with the decreasing function <code class="reqn">e^{(-ker \;t)}</code>: a lower bound of 1 if
<code>withingroup</code> and something fairly small say in the interval [0.05;0.3] otherwise.
</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Caussinus, H and Ruiz, A (1990) <em>Interesting Projections of Multidimensional Data by Means of
Generalized Principal Components Analysis</em>. COMPSTAT90, Physica-Verlag, Heidelberg,121-126.
</p>
<p>Faraj, A (1994) <em>Interpretation tools for Generalized Discriminant Analysis</em>.In: New
Approches in Classification and Data Analysis, Springer-Verlag, 286-291, Heidelberg.
</p>
<p>Lebart, L (1969) <em>Analyse statistique de la contiguit&lt;e9&gt;e</em>.Publication de l'Institut de
Statistiques Universitaire de Paris, XVIII,81-112.
</p>
<p>Leibovici D (2008) <em>Spatio-temporal Multiway Decomposition using Principal Tensor Analysis on k-modes: the R package <span class="pkg">PTAk</span></em>
. to be submitted soon at Journal of Statisticcal Software.
</p>


<h3>See Also</h3>

<p><code>SVDgen</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
 data(iris)
  iris2 &lt;- as.matrix(iris[,1:4])
  dimnames(iris2)[[1]] &lt;- as.character(iris[,5])

 D2 &lt;- CauRuimet(iris2,ker=1,withingroup=TRUE)
 D2 &lt;- Powmat(D2,(-1))
 iris2 &lt;- sweep(iris2,2,apply(iris2,2,mean))
 res &lt;- SVDgen(iris2,D2=D2,D1=1)
 plot(res,nb1=1,nb2=2,cex=1,mod=1,Zcol=list(c(rep(1,50),rep(2,50),rep(3,50))))
 summary(res,testvar=0)

 # the same in a demo function
 # source(paste(R.home(),"/library/PTAk/demo/CauRuimet.R",sep=""))
 # demo.CauRuimet(ker=4,withingroup=TRUE,openX11s=FALSE)
 # demo.Cauruimet(ker=0.15,withingroup=FALSE,openX11s=FALSE)
</code></pre>


</div>
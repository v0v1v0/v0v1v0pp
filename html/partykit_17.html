<div class="container">

<table style="width: 100%;"><tr>
<td>partysplit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Binary and Multiway Splits </h2>

<h3>Description</h3>

<p>A class for representing multiway splits and functions 
for computing on splits.
</p>


<h3>Usage</h3>

<pre><code class="language-R">partysplit(varid, breaks = NULL, index = NULL, right = TRUE, 
    prob = NULL, info = NULL)
kidids_split(split, data, vmatch = 1:length(data), obs = NULL)
character_split(split, data = NULL, 
    digits = getOption("digits") - 2)
varid_split(split)
breaks_split(split)
index_split(split)
right_split(split)
prob_split(split)
info_split(split)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>varid</code></td>
<td>
<p> an integer specifying the variable to split in, i.e., 
a column number in <code>data</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p> a numeric vector of split points. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p> an integer vector containing a contiguous sequence 
from one to the number of kid nodes. May contain <code>NA</code>s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>right</code></td>
<td>
<p> a logical, indicating if the intervals defined by 
<code>breaks</code> should be closed on the
right (and open on the left) or vice versa.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p> a numeric vector representing a probability distribution 
over kid nodes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p> additional information. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p> an object of class <code>partysplit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> a <code>list</code> or <code>data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vmatch</code></td>
<td>
<p> a permutation of the variable numbers in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs</code></td>
<td>
<p> a logical or integer vector indicating a subset of the 
observations in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p> minimal number of significant digits.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A split is basically a function that maps data, 
more specifically a partitioning variable,
to a set of integers indicating the kid nodes to send observations to. 
Objects of class <code>partysplit</code> describe such a function and can
be set-up via the <code>partysplit()</code> constructor.
The variables are available in a <code>list</code> or <code>data.frame</code> 
(here called <code>data</code>) and <code>varid</code> specifies the 
partitioning variable, i.e., the variable or list element to split in. 
The constructor <code>partysplit()</code> doesn't have access 
to the actual data, i.e., doesn't <em>estimate</em> splits.
</p>
<p><code>kidids_split(split, data)</code> actually partitions the data
<code>data[obs,varid_split(split)]</code> and assigns an integer (giving the
kid node number) to each observation. If <code>vmatch</code> is given,
the variable <code>vmatch[varid_split(split)]</code> is used.
</p>
<p><code>character_split()</code> returns a character representation
of its <code>split</code> argument. The remaining functions 
defined here are accessor functions for <code>partysplit</code> 
objects.
</p>
<p>The numeric vector <code>breaks</code> defines how the range of 
the partitioning variable (after coercing to a numeric via 
<code>as.numeric</code>) is divided into intervals 
(like in <code>cut</code>) and may be 
<code>NULL</code>. These intervals are represented by the
numbers one to <code>length(breaks) + 1</code>.
</p>
<p><code>index</code> assigns these <code>length(breaks) + 1</code> 
intervals to one of at least two kid nodes. Thus, <code>index</code>
is a vector of integers where each element corresponds
to one element in a list <code>kids</code> containing <code>partynode</code>
objects, see <code>partynode</code> for details. The vector
<code>index</code> may contain <code>NA</code>s, in that case, the corresponding
values of the splitting variable are treated as missings (for
example factor levels that are not present in the learning sample).
Either <code>breaks</code> or <code>index</code> must be given.
When <code>breaks</code> is <code>NULL</code>, it is assumed that
the partitioning variable itself has storage mode <code>integer</code>
(e.g., is a <code>factor</code>).
</p>
<p><code>prob</code> defines a probability distribution over
all kid nodes which is used for random splitting
when a deterministic split isn't possible (due to missing 
values, for example).
</p>
<p><code>info</code> takes arbitrary user-specified information.
</p>


<h3>Value</h3>

<p>The constructor <code>partysplit()</code> returns an object of class <code>partysplit</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>varid</code></td>
<td>
<p> an integer specifying the variable to split in, i.e., 
a column number in <code>data</code>, </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p> a numeric vector of split points, </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p> an integer vector containing a contiguous sequence 
from one to the number of kid nodes,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>right</code></td>
<td>
<p> a logical, indicating if the intervals defined by 
<code>breaks</code> should be closed on the
right (and open on the left) or vice versa</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p> a numeric vector representing a probability distribution 
over kid nodes, </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p> additional information. </p>
</td>
</tr>
</table>
<p><code>kidids_split()</code> returns an integer vector describing
the partition of the observations into kid nodes.
</p>
<p><code>character_split()</code> gives a character representation of the
split and the remaining functions return the corresponding slots
of <code>partysplit</code> objects.
</p>


<h3>References</h3>

 
<p>Hothorn T, Zeileis A (2015).
partykit: A Modular Toolkit for Recursive Partytioning in R.
<em>Journal of Machine Learning Research</em>, <b>16</b>, 3905â€“3909.
</p>


<h3>See Also</h3>

<p><code>cut</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data("iris", package = "datasets")

## binary split in numeric variable `Sepal.Length'
sl5 &lt;- partysplit(which(names(iris) == "Sepal.Length"),
    breaks = 5)
character_split(sl5, data = iris)
table(kidids_split(sl5, data = iris), iris$Sepal.Length &lt;= 5)

## multiway split in numeric variable `Sepal.Width', 
## higher values go to the first kid, smallest values 
## to the last kid
sw23 &lt;- partysplit(which(names(iris) == "Sepal.Width"),    
    breaks = c(3, 3.5), index = 3:1)	
character_split(sw23, data = iris)    
table(kidids_split(sw23, data = iris), 
    cut(iris$Sepal.Width, breaks = c(-Inf, 2, 3, Inf)))   

## binary split in factor `Species'
sp &lt;- partysplit(which(names(iris) == "Species"),
    index = c(1L, 1L, 2L))
character_split(sp, data = iris)
table(kidids_split(sp, data = iris), iris$Species)

## multiway split in factor `Species'
sp &lt;- partysplit(which(names(iris) == "Species"), index = 1:3)
character_split(sp, data = iris)
table(kidids_split(sp, data = iris), iris$Species)

## multiway split in numeric variable `Sepal.Width'
sp &lt;- partysplit(which(names(iris) == "Sepal.Width"), 
    breaks = quantile(iris$Sepal.Width))
character_split(sp, data = iris)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>InvWavTransf2D</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Inverse AI wavelet transform for surface of HPD matrices</h2>

<h3>Description</h3>

<p><code>InvWavTransf2D</code> computes the inverse intrinsic average-interpolation (AI) wavelet
transform mapping an array of coarsest-scale HPD midpoints combined with a 2D pyramid of Hermitian
wavelet coefficients to a surface in the manifold of HPD matrices equipped with a metric specified by the
user, as described in Chapter 5 of (Chau 2018). This is the inverse operation of the
function <code>WavTransf2D</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">InvWavTransf2D(D, M0, order = c(3, 3), jmax, metric = "Riemannian",
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>a list of arrays containing the 2D pyramid of wavelet coefficients, where each array contains the
(<code class="reqn">d,d</code>)-dimensional wavelet coefficients from the coarsest wavelet scale <code>j = 0</code> up to the finest
wavelet scale <code>j = jmax</code>. This is the same format as the <code>$D</code> component given as output by
<code>WavTransf2D</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M0</code></td>
<td>
<p>a numeric array containing the midpoint(s) at the coarsest scale <code>j = 0</code> in the 2D midpoint pyramid.
This is the same format as the <code>$M0</code> component given as output by <code>WavTransf2D</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>a 2-dimensional numeric vector <code class="reqn">(1,1) \le</code> <code>order</code> <code class="reqn">\le (9,9)</code> corresponding to the marginal
orders of the intrinsic 2D AI refinement scheme, defaults to <code>order = c(3, 3)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jmax</code></td>
<td>
<p>the maximum scale (resolution) up to which the 2D surface of HPD midpoints (i.e. scaling coefficients) are
reconstructed. If <code>jmax</code> is not specified it is set equal to the resolution in the finest wavelet scale
<code>jmax = length(D)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>the metric that the space of HPD matrices is equipped with. The default choice is <code>"Riemannian"</code>,
but this can also be one of: <code>"logEuclidean"</code>, <code>"Cholesky"</code>, <code>"rootEuclidean"</code> or
<code>"Euclidean"</code>. See also the Details section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments for internal use.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The input list of arrays <code>D</code> and array <code>M0</code> correspond to a 2D pyramid of wavelet coefficients and
the coarsest-scale HPD midpoints respectively, both are structured in the same way as in the output of
<code>WavTransf2D</code>. As in the forward AI wavelet transform, the marginal refinement orders should be smaller
or equal to 9, and the function computes the wavelet transform using a fast wavelet refinement scheme based on weighted
intrinsic averages with pre-determined weights as explained in Chapter 5 of (Chau 2018). By default
<code>WavTransf2D</code> computes the inverse intrinsic 2D AI wavelet transform equipping the space of HPD matrices with (i)
the affine-invariant Riemannian metric as detailed in e.g., (Bhatia 2009)[Chapter 6] or (Pennec et al. 2006).
Instead, the space of HPD matrices can also be equipped with one of the following metrics; (ii) the Log-Euclidean metric, the
Euclidean inner product between matrix logarithms; (iii) the Cholesky metric, the Euclidean inner product between Cholesky
decompositions; (iv) the Euclidean metric and (v) the root-Euclidean metric. The default choice of metric (affine-invariant Riemannian)
satisfies several useful properties not shared by the other metrics, see (Chau 2018) for more details. Note that this
comes at the cost of increased computation time in comparison to one of the other metrics.
</p>


<h3>Value</h3>

<p>Returns a (<code class="reqn">d, d, n_1, n_2</code>)-dimensional array corresponding to a rectangular surface of size <code class="reqn">n_1</code> by
<code class="reqn">n_2</code> of (<code class="reqn">d,d</code>)-dimensional HPD matrices.
</p>


<h3>References</h3>

<p>Bhatia R (2009).
<em>Positive Definite Matrices</em>.
Princeton University Press, New Jersey.<br><br> Chau J (2018).
<em>Advances in Spectral Analysis for Multivariate, Nonstationary and Replicated Time Series</em>.
phdthesis, Universite catholique de Louvain.<br><br> Pennec X, Fillard P, Ayache N (2006).
“A Riemannian framework for tensor computing.”
<em>International Journal of Computer Vision</em>, <b>66</b>(1), 41–66.
</p>


<h3>See Also</h3>

<p><code>WavTransf2D</code>, <code>pdSpecEst2D</code>, <code>pdNeville</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">P &lt;- rExamples2D(c(2^4, 2^4), 2, example = "tvar")
P.wt &lt;- WavTransf2D(P$f) ## forward transform
P.f &lt;- InvWavTransf2D(P.wt$D, P.wt$M0) ## backward transform
all.equal(P.f, P$f)

</code></pre>


</div>
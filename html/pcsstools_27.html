<div class="container">

<table style="width: 100%;"><tr>
<td>pcsslm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Approximate a linear model using PCSS</h2>

<h3>Description</h3>

<p><code>pcsslm</code> approximates a linear model of a combination of variables using
precomputed summary statistics.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pcsslm(formula, pcss = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class formula whose dependent variable is a 
combination of variables and logical | operators. 
All model terms must have appropriate PCSS in <code>pcss</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pcss</code></td>
<td>
<p>a list of precomputed summary statistics. In all cases, this
should include <code>n</code>: the sample size, <code>means</code>: a named vector of
predictor and response means, and <code>covs</code>: a named covariance matrix
including all predictors and responses. See Details for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments. See Details for more information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>pcsslm</code> parses the input <code>formula</code>'s dependent variable for 
functions such as sums (<code>+</code>), products (<code>*</code>), or logical 
operators (<code>|</code> and <code>&amp;</code>).
It then identifies models the combination of variables using one of
<code>model_combo</code>, <code>model_product</code>, 
<code>model_or</code>, <code>model_and</code>, or 
<code>model_prcomp</code>.
</p>
<p>Different precomputed summary statistics are needed inside <code>pcss</code>
depending on the function that combines the dependent variable.
</p>

<ul>
<li>
<p> For linear combinations (and principal component analysis), only
<code>n</code>, <code>means</code>, and <code>covs</code> are required
</p>
</li>
<li>
<p> For products and logical combinations, the additional items
<code>predictors</code> and <code>responses</code> are required.
These are named lists of objects of class <code>predictor</code>
generated by <code>new_predictor</code>, with a <code>predictor</code>
object for each independent variable in <code>predictors</code> and
each dependent variable in <code>responses</code>.
However, if only modeling the product or logical combination of 
only two variables, <code>responses</code> can be <code>NULL</code> without
consequence.
</p>
</li>
</ul>
<p>If modeling a principal component score of a set of variables, include 
the argument <code>comp</code> where <code>comp</code> is an integer indicating which 
principal component score to analyze. Optional logical arguments 
<code>center</code> and <code>standardize</code> determine if responses should be
centered and standardized before principal components are calculated. 
</p>
<p>If modeling a linear combination, include the argument <code>phi</code>, a named
vector of linear weights for each variable in the dependent variable in 
formula.
</p>
<p>If modeling a product, include the argument <code>response</code>, a character
equal to either <code>"continuous"</code> or <code>"binary"</code>. If <code>"binary"</code>,
specialized approximations are performed to estimate means and variances.
</p>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td>
</tr>
</table>
<h3>References</h3>


<p>Wolf JM, Westra J, Tintle N (2021).
“Using Summary Statistics to Model Multiplicative Combinations of Initially Analyzed Phenotypes With a Flexible Choice of Covariates.”
<em>Frontiers in Genetics</em>, <b>12</b>, 1962.
ISSN 1664-8021, <a href="https://doi.org/10.3389/fgene.2021.745901">doi:10.3389/fgene.2021.745901</a>, <a href="https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full">https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full</a>.
</p>
<p>Wolf JM, Barnard M, Xia X, Ryder N, Westra J, Tintle N (2020).
“Computationally efficient, exact, covariate-adjusted genetic principal component analysis by leveraging individual marker summary statistics from large biobanks.”
<em>Pacific Symposium on Biocomputing</em>, <b>25</b>, 719–730.
ISSN 2335-6928, <a href="https://doi.org/10.1142/9789811215636_0063">doi:10.1142/9789811215636_0063</a>, <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/</a>.
</p>
<p>Gasdaska A, Friend D, Chen R, Westra J, Zawistowski M, Lindsey W, Tintle N (2019).
“Leveraging summary statistics to make inferences about complex phenotypes in large biobanks.”
<em>Pacific Symposium on Biocomputing</em>, <b>24</b>, 391–402.
ISSN 2335-6928, <a href="https://doi.org/10.1142/9789813279827_0036">doi:10.1142/9789813279827_0036</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/30963077/">https://pubmed.ncbi.nlm.nih.gov/30963077/</a>.
</p>



<h3>See Also</h3>

<p><code>model_combo</code>, <code>model_product</code>, 
<code>model_or</code>, <code>model_and</code>, and 
<code>model_prcomp</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Principal Component Analysis
ex_data &lt;- pcsstools_example[c("g1", "x1", "y1", "y2", "y3")]
pcss &lt;- list(
  means = colMeans(ex_data),
  covs = cov(ex_data),
  n = nrow(ex_data)
)

pcsslm(y1 + y2 + y3 ~ g1 + x1, pcss = pcss, comp = 1)

## Linear combination of variables
ex_data &lt;- pcsstools_example[c("g1", "g2", "y1", "y2")]
pcss &lt;- list(
  means = colMeans(ex_data),
  covs = cov(ex_data),
  n = nrow(ex_data)
)

pcsslm(y1 + y2 ~ g1 + g2, pcss = pcss, phi = c(1, -1))
summary(lm(y1 - y2 ~ g1 + g2, data = ex_data))

## Product of variables
ex_data &lt;- pcsstools_example[c("g1", "x1", "y4", "y5", "y6")]

pcss &lt;- list(
  means = colMeans(ex_data),
  covs = cov(ex_data),
  n = nrow(ex_data),
  predictors = list(
    g1 = new_predictor_snp(maf = mean(ex_data$g1) / 2),
    x1 = new_predictor_normal(mean = mean(ex_data$x1), sd = sd(ex_data$x1))
  ),
  responses = lapply(
    colMeans(ex_data)[3:length(colMeans(ex_data))], 
    new_predictor_binary
  )
)

pcsslm(y4 * y5 * y6 ~ g1 + x1, pcss = pcss, response = "binary")
summary(lm(y4 * y5 * y6 ~ g1 + x1, data = ex_data))

## Disjunct (OR statement) of variables
ex_data &lt;- pcsstools_example[c("g1", "x1", "y4", "y5")]

pcss &lt;- list(
  means = colMeans(ex_data),
  covs = cov(ex_data),
  n = nrow(ex_data),
  predictors = list(
    g1 = new_predictor_snp(maf = mean(ex_data$g1) / 2),
    x1 = new_predictor_normal(mean = mean(ex_data$x1), sd = sd(ex_data$x1))
  )
)
pcsslm(y4 | y5 ~ g1 + x1, pcss = pcss) 
summary(lm(y4 | y5 ~ g1 + x1, data = ex_data))

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>new_p</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create new pdqr-function</h2>

<h3>Description</h3>

<p>Functions for creating new pdqr-functions based on numeric sample or data
frame describing distribution. They construct appropriate "x_tbl" metadata based on the input and then create pdqr-function (of
corresponding pdqr class) defined by that "x_tbl".
</p>


<h3>Usage</h3>

<pre><code class="language-R">new_p(x, type, ...)

new_d(x, type, ...)

new_q(x, type, ...)

new_r(x, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric vector or data frame with appropriate columns (see "Data
frame input" section).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of pdqr-function. Should be one of "discrete"
or "continuous".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Extra arguments for density().</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Data frame input <code>x</code> is treated as having enough information for
creating (including normalization of "y" column) an "x_tbl" metadata. For
more details see "Data frame input" section.
</p>
<p>Numeric input is transformed into data frame which is then used as "x_tbl"
metadata (for more details see "Numeric input" section):
</p>

<ul>
<li>
<p> If <code>type</code> is <code>"discrete"</code> then <code>x</code> is viewed as sample from distribution
that can produce only values from <code>x</code>. Input is tabulated and normalized to
form "x_tbl" metadata.
</p>
</li>
<li>
<p> If <code>type</code> is <code>"continuous"</code> then:
</p>

<ul>
<li>
<p> If <code>x</code> has 1 element, output distribution represents a <strong>dirac-like</strong>
distribution which is an approximation to singular dirac distribution.
</p>
</li>
<li>
<p> If <code>x</code> has more than 1 element, output distribution represents a
<strong>density estimation</strong> with density() treating <code>x</code> as
sample.
</p>
</li>
</ul>
</li>
</ul>
<h3>Value</h3>

<p>A pdqr-function of corresponding class ("p" for
<code>new_p()</code>, etc.) and type.
</p>


<h3>Numeric input</h3>

<p>If <code>x</code> is a numeric vector, it is transformed into a data frame which is then
used as "x_tbl" metadata to create pdqr-function of
corresponding class.
</p>
<p>First, all <code>NaN</code>, <code>NA</code>, and infinite values are removed with warnings. If
there are no elements left, error is thrown. Then data frame is created in
the way which depends on the <code>type</code> argument.
</p>
<p><strong>For "discrete" type</strong> elements of filtered <code>x</code> are:
</p>

<ul>
<li>
<p> Rounded to 10th digit to avoid numerical representation issues (see Note
in <code>==</code>'s help page).
</p>
</li>
<li>
<p> Tabulated (all unique values are counted). Output data frame has three
columns: "x" with unique values, "prob" with normalized (divided by sum)
counts, "cumprob" with cumulative sum of "prob" column.
</p>
</li>
</ul>
<p><strong>For "continuous" type</strong> output data frame has columns "x", "y", "cumprob".
Choice of algorithm depends on the number of <code>x</code> elements:
</p>

<ul>
<li>
<p> If <code>x</code> has 1 element, an "x_tbl" metadata describes <strong>dirac-like</strong>
"continuous" pdqr-function. It is implemented as triangular peak with center
at <code>x</code>'s value and width of <code>2e-8</code> (see Examples). This is an approximation
of singular dirac distribution. Data frame has columns "x" with value
<code>c(x-1e-8, x, x+1e-8)</code>, "y" with value <code>c(0, 1e8, 0)</code> normalized to have
total integral of "x"-"y" points of 1, "cumprob" <code>c(0, 0.5, 1)</code>.
</p>
</li>
<li>
<p> If <code>x</code> has more than 1 element, it serves as input to
density(x, ...) for density estimation (here arguments in
<code>...</code> of <code style="white-space: pre;">⁠new_*()⁠</code> serve as extra arguments to <code>density()</code>). The output's "x"
element is used as "x" column in output data frame. Column "y" is taken as
"y" element of <code>density()</code> output, normalized so that piecewise-linear
function passing through "x"-"y" points has total integral of 1. Column
"cumprob" has cumulative probability of piecewise-linear d-function.
</p>
</li>
</ul>
<h3>Data frame input</h3>

<p>If <code>x</code> is a data frame, it should have numeric columns appropriate for
"x_tbl" metadata of input <code>type</code>: "x", "prob" for "discrete"
<code>type</code> and "x", "y" for "continuous" type ("cumprob" column will be computed
inside <code style="white-space: pre;">⁠new_*()⁠</code>). To become an appropriate "x_tbl" metadata, input data
frame is ordered in increasing order of "x" column and then <strong>imputed</strong> in
the way which depends on the <code>type</code> argument.
</p>
<p><strong>For "discrete" type</strong>:
</p>

<ul>
<li>
<p> Values in column "x" are rounded to 10th digit to avoid numerical
representation issues (see Note in <code>==</code>'s help page).
</p>
</li>
<li>
<p> If there are duplicate values in "x" column, they are "squashed" into one
having sum of their probability in "prob" column.
</p>
</li>
<li>
<p> Column "prob" is normalized by its sum to have total sum of 1.
</p>
</li>
<li>
<p> Column "cumprob" is computed as cumulative sum of "prob" column.
</p>
</li>
</ul>
<p><strong>For "continuous" type</strong> column "y" is normalized so that piecewise-linear
function passing through "x"-"y" points has total integral of 1. Column
"cumprob" has cumulative probability of piecewise-linear d-function.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(101)
x &lt;- rnorm(10)

# Type "discrete": `x` values are directly tabulated
my_d_dis &lt;- new_d(x, "discrete")
meta_x_tbl(my_d_dis)
plot(my_d_dis)

# Type "continuous": `x` serves as input to `density()`
my_d_con &lt;- new_d(x, "continuous")
head(meta_x_tbl(my_d_con))
plot(my_d_con)

# Data frame input
## Values in "prob" column will be normalized automatically
my_p_dis &lt;- new_p(data.frame(x = 1:4, prob = 1:4), "discrete")
## As are values in "y" column
my_p_con &lt;- new_p(data.frame(x = 1:3, y = c(0, 10, 0)), "continuous")

# Using bigger bandwidth in `density()`
my_d_con_2 &lt;- new_d(x, "continuous", adjust = 2)
plot(my_d_con, main = "Comparison of density bandwidths")
lines(my_d_con_2, col = "red")

# Dirac-like "continuous" pdqr-function is created if `x` is a single number
meta_x_tbl(new_d(1, "continuous"))
</code></pre>


</div>
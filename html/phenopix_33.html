<div class="container">

<table style="width: 100%;"><tr>
<td>KlostermanFit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit a double logistic equation to a vector according to 
Klosterman et al. (2014) 
</h2>

<h3>Description</h3>

<p>This function fits a double logistic curve to observed values using the
function as described in klosterman et al. (2014), eq 7. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">KlostermanFit(ts, which = "light", uncert = FALSE, nrep = 100, 
ncores='all', sf=quantile(ts, probs=c(0.05, 0.95), na.rm=TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ts</code></td>
<td>

<p>A ts or zoo object with gcc data. index(ts) must be numeric days of
year (doys) or a POSIXct vector
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>

<p>A character to be chosen between 'light' (default) and 'heavy'. See details. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncert</code></td>
<td>

<p>Should uncertainty be estimated?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrep</code></td>
<td>

<p>Number of relications to estimate uncertainty, defaults to 100. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>

<p>Number of processors to be used in parallel computation, defaults to 'all' which will accidentally slow down any other activity on your computer. Otherwise set the number of processors you want to use in parallelization. 

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code>greenProcess</code> sf is automatically calculated.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function estimates parameters of the double logistic equation from
Klosterman et al. 2014. Two optimization procedures are available. If 
which='light' (the default) equation parameters are optimized using the 
function <code>optim</code> and computation is faster, whereas if which='heavy' 
the optimization procedure calls the function <code>nsl</code> and is based on 
a greater number of iteractions with different first guesses for parameters. 
This option is about ten times slower than the light one.  
</p>


<h3>Value</h3>

<p>A list containing the following items. 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>A list as returned by the function FitDoubleLogGu</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncertainty</code></td>
<td>
<p>A list containing a zoo data.frame with the
uncertainty predicted values, and a dataframe containing the
respective uncertainty curve parameters</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Klosterman ST, Hufkens K, Gray JM, Melaas E, Sonnentag O, Lavine I, Mitchell L, 
Norman R, Friedl MA, Richardson A D (2014) Evaluating remote sensing of deciduous 
forest phenology at multiple spatial scales using PhenoCam imagery, Biogeosciences, 
11, 4305-4320, doi:10.5194/bg-11-4305-2014.
</p>


<h3>See Also</h3>

<p><code>FitDoubleLogKlLight</code>
<code>FitDoubleLogKlHeavy</code>

</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(zoo)
data(bartlett2009.filtered)
## fit without uncertainty estimation
fitted.kl1 &lt;- KlostermanFit(bartlett2009.filtered, which='light')
fitted.kl2 &lt;- KlostermanFit(bartlett2009.filtered, which='heavy')
## check fitting
plot(bartlett2009.filtered)
lines(fitted.kl1$fit$predicted, col='red')
lines(fitted.kl2$fit$predicted, col='blue')
legend('topleft',col=c('red', 'blue'), lty=1, 
  legend=c('light', 'heavy'), bty='n')

## End(Not run)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>write.Structure</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Write Genotypes in Structure 2.3 Format</h2>

<h3>Description</h3>

<p>Given a dataset stored in a <code>genambig</code> object,
<code>write.Structure</code> produces a text file of the genotypes in a format
readable by Structure 2.2 and higher.  The user specifies the overall
ploidy of the file, while the ploidy of each sample is extracted from
the <code>genambig</code> object.  <code>PopInfo</code> and other data can
optionally be written to the file as well.
</p>


<h3>Usage</h3>

<pre><code class="language-R">write.Structure(object, ploidy, file="",
                samples = Samples(object), loci = Loci(object),
                writepopinfo = TRUE, extracols = NULL,
                missingout = -9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>genambig</code> object containing the data to write to
the file.  There must be non-<code>NA</code> values of <code>Ploidies</code>
(and <code>PopInfo</code> if <code>writepopinfo == TRUE</code>) for
<code>samples</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ploidy</code></td>
<td>
<p>PLOIDY for Structure, <em>i.e.</em> how many rows per individual
to write.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>A character string specifying where the file should be written.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samples</code></td>
<td>
<p>An optional character vector listing the names of samples to be
written to the file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loci</code></td>
<td>
<p>An optional character vector listing the names of the loci to be
written to the file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>writepopinfo</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, indicating whether to
write values from the <code>PopInfo</code> slot of <code>object</code> to the file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extracols</code></td>
<td>
<p>An array, with the first dimension names
corresponding to <code>samples</code>, of PopData, PopFlag, LocData, Phenotype,
or other values to be included in the extra columns in the file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missingout</code></td>
<td>
<p>The number used to indicate missing data.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Structure 2.2 and higher can process autopolyploid microsatellite data,
although 2.3.3 or higher is recommended for its improvements on
polyploid handling.  The input format of Structure requires that
each locus take up one column and that each individual take up as
many rows as the parameter PLOIDY.  Because of the multiple rows per
sample, each sample name must be duplicated, as well as any
population, location, or phenotype data.  Partially heterozygous
genotypes also must have one arbitrary allele duplicated up to the
ploidy of the sample, and samples that have a lower ploidy than that
used in the file (for mixed polyploid data sets) must have a missing
data symbol inserted to fill in the extra rows.  Additionally, if
some samples have more alleles than PLOIDY (if you are using a lower
PLOIDY to save processing time, or if there are extra alleles from
scoring errors), some alleles must be randomly removed from the data.
<code>write.Structure</code> performs this duplication, insertion, and random
deletion of data.
</p>
<p>The sample names from <code>samples</code> will be used as row
names in the Structure file.  Each sample name should only be in the
vector <code>samples</code> once, because <code>write.Structure</code> will duplicate
the sample names a number of times as dictated by <code>ploidy</code>.
</p>
<p>In writing genotypes to the file, <code>write.Structure</code> compares the number
of alleles in the genotype, the ploidy of the sample*locus as stored in
<code>Ploidies</code>, and the ploidy of the file as stored in
<code>ploidy</code>, and does one of six things (for a given sample x and
locus loc):
</p>
<p>1) If <code>Ploidies(object,x,loc)</code> is greater than or equal to
<code>ploidy</code>, and
<code>length(Genotype(object, x, loc))</code> is equal to <code>ploidy</code>, the
genotype data are used as is.
</p>
<p>2) If <code>Ploidies(object,x,loc)</code> is greater than or equal to
<code>ploidy</code>, and
<code>length(Genotype(object, x, loc))</code> is less than <code>ploidy</code>,
the first allele is
duplicated as many times as necessary for there to be as many alleles
as <code>ploidy</code>.
</p>
<p>3) If <code>Ploidies(object,x,loc)</code> is greater than or equal to
<code>ploidy</code>, and <code>length(Genotype(object, x, loc))</code> is greater
than <code>ploidy</code>, a random sample of
the alleles, without replacement, is used as the genotype.
</p>
<p>4) If <code>Ploidies(object,x,loc)</code> is less than <code>ploidy</code>, and
<code>length(Genotype(object, x, loc))</code> is equal to
<code>Ploidies(object,x,loc)</code>, the genotype
data are used as is and missing data symbols are inserted in the extra
rows.
</p>
<p>5) If <code>Ploidies(object,x,loc)</code> is less than <code>ploidy</code>, and
<code>length(Genotype(object, x, loc))</code> is less than
<code>Ploidies(object,x,loc)</code>, the first
allele is duplicated as many times as necessary for there to be as
many alleles as <code>Ploidies(object,x,loc)</code>, and missing data symbols
are inserted in the extra rows.
</p>
<p>6) If <code>Ploidies(object,x,loc)</code> is less than <code>ploidy</code>, and
<code>length(Genotype(object, x, loc))</code> is greater than
<code>Ploidies(object,x,loc)</code>, a random
sample, without replacement, of <code>Ploidies(object)[x]</code> alleles is
used, and
missing data symbols are inserted in the extra rows. (Alleles are
removed even though there is room for them in the file.)
</p>
<p>Two of the header rows that are optional for Structure are written by
<code>write.Structure</code>.  These are ‘Marker Names’, containing the
names of loci supplied in <code>gendata</code>, and ‘Recessive
Alleles’, which contains the missing data symbol once for each locus.
This indicates to the program that all alleles are codominant with
copy number ambiguity.
</p>


<h3>Value</h3>

<p>No value is returned, but instead a file is written at the path specified.
</p>


<h3>Note</h3>

<p>If <code>extracols</code> is a character array, make sure none of the
elements contain white space.</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark</p>


<h3>References</h3>

<p><a href="https://web.stanford.edu/group/pritchardlab/structure_software/release_versions/v2.3.4/structure_doc.pdf">https://web.stanford.edu/group/pritchardlab/structure_software/release_versions/v2.3.4/structure_doc.pdf</a>
</p>
<p>Hubisz, M. J., Falush, D., Stephens, M. and Pritchard, J. K. (2009)
Inferring weak population structure with the assistance of sample
group information.  <em>Molecular Ecology Resources</em> <b>9</b>, 1322-1332.
</p>
<p>Falush, D., Stephens, M. and Pritchard, J. K.  (2007)
Inferences of population structure using multilocus genotype data:
dominant markers and null alleles.  <em>Molecular Ecology Notes</em>
<b>7</b>, 574-578.
</p>


<h3>See Also</h3>

<p><code>read.Structure</code>, <code>write.GeneMapper</code>,
<code>write.GenoDive</code>, <code>write.SPAGeDi</code>,
<code>write.ATetra</code>, <code>write.Tetrasat</code>,
<code>write.POPDIST</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># input genotype data (this is usually done by reading a file)
mygendata &lt;- new("genambig", samples = c("ind1","ind2","ind3",
                                         "ind4","ind5","ind6"),
                 loci = c("locus1","locus2"))
Genotypes(mygendata) &lt;- array(list(c(100,102,106,108,114,118),c(102,110),
                      c(98,100,104,108,110,112,116),c(102,106,112,118),
                      c(104,108,110),c(-9),
                      c(204),c(206,208,210,212,220,224,226),
                      c(202,206,208,212,214,218),c(200,204,206,208,212),
                      c(-9),c(202,206)),
                 dim=c(6,2))
Ploidies(mygendata) &lt;- c(6,6,6,4,4,4)
# Note that some of the above genotypes have more or fewer alleles than
# the ploidy of the sample.

# create a vector of sample names to be used.  Note that this excludes
#  ind6.
mysamples &lt;- c("ind1","ind2","ind3","ind4","ind5")

# Create an array containing data for additional columns to be written
# to the file.  You might also prefer to just read this and the ploidies
# in from a file.
myexcols &lt;- array(data=c(1,2,1,2,1,1,1,0,0,0),dim=c(5,2),
                  dimnames=list(mysamples, c("PopData","PopFlag")))

# Write the Structure file, with six rows per individual.
# Since outfile="", the data will be written to the console instead of a file.
write.Structure(mygendata, 6, "", samples = mysamples, writepopinfo = FALSE,
                extracols = myexcols)
</code></pre>


</div>
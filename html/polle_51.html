<div class="container">

<table style="width: 100%;"><tr>
<td>policy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Policy-class</h2>

<h3>Description</h3>

<p>A function of inherited class "policy" takes a policy
data object as input and returns the policy actions for every observation
for every (observed) stage.
</p>


<h3>Details</h3>

<p>A policy can either be defined directly by the user using
policy_def or a policy can be fitted using policy_learn
(or policy_eval). policy_learn returns a policy_object from which
the policy can be extracted using get_policy.
</p>


<h3>Value</h3>

<p>data.table::data.table with keys <code>id</code> and <code>stage</code> and
action variable <code>d</code>.
</p>


<h3>S3 generics</h3>

<p>The following S3 generic functions are available for an object of class
<code>policy</code>:
</p>

<dl>
<dt><code>print</code></dt>
<dd>
<p>Baisc print function</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">### Two stages:
d &lt;- sim_two_stage(5e2, seed=1)
pd &lt;- policy_data(d,
                  action = c("A_1", "A_2"),
                  covariates = list(L = c("L_1", "L_2"),
                                    C = c("C_1", "C_2")),
                  utility = c("U_1", "U_2", "U_3"))

# defining a dynamic policy:
p &lt;- policy_def(
  function(L) (L&gt;0)*1,
  reuse = TRUE
)
p
head(p(pd), 5)

# V-restricted (Doubly Robust) Q-learning:
# specifying the learner:
pl &lt;- policy_learn(type = "drql",
                   control = control_drql(qv_models = q_glm(formula = ~ C)))

# fitting the policy (object):
po &lt;- pl(policy_data = pd,
         q_models = q_glm(),
         g_models = g_glm())

p &lt;- get_policy(po)
p

head(p(pd))
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>CPBADecomposition</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Cluster and Propensity-based Approximation decomposition for adajcency matrixes.
</h2>

<h3>Description</h3>

<p>Given an adjacency matrix and cluster assignments, this function calculates
either the conformity factors or the propensities of each node.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CPBADecomposition(adjacency,
                  clustering,
                  nClusters = NULL,
                  objectiveFunction = c("Poisson", "L2norm"),
                  dropUnassigned = TRUE,
                  unassignedLabel = 0,
                  unassignedMethod = "average",
                  accelerated = TRUE,
                  parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>adjacency</code></td>
<td>

<p>A square symmetric matrix giving either the number of connections between two nodes (for Poisson
objective function) or the weighted connections (between 0 and 1) between each pair of nodes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustering</code></td>
<td>

<p>A vector with element per node containing the cluster assignments for each node. If a single cluster
decomposition is desired, an alternative is to set <code>nClusters=1</code> (see below).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nClusters</code></td>
<td>
<p> If the user wishes to input trivial clustering to calculate a "pure propensity"
decomposition, this variable can be set to 1. Any other non-NULL value is considered invalid; 
use <code>clusters</code> to specify a non-trivial clustering.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objectiveFunction</code></td>
<td>
<p> Specifies the objective function for the Cluster and Propensity-based
Approximation. Valid choices are (unique abbreviations of) "Poisson" and "L2norm". 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropUnassigned</code></td>
<td>
<p> Logical: should unassigned nodes be excluded from the clustering? Unassigned nodes
can be present in initial clustering or blocks (if given), and internal pre-partitioning and initial
clustering can also lead to unassigned nodes. If <code>dropUnassigned</code> is <code>TRUE</code>, these nodes are
excluded from the calls to <code>propensityClustering</code>.
Otherwise these nodes will be assigned to the nearest
cluster within each block and be clustered using <code>propensityClustering</code> in each block.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unassignedLabel</code></td>
<td>
<p> Label in input <code>clustering</code> that is reserved for
unassigned objects. For clusterings with numeric lables this is typically (but not always) 0. Note that this
must a valid value - missing value <code>NA</code> will not work. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unassignedMethod</code></td>
<td>
<p> If <code>dropUnassigned</code> is <code>FALSE</code>, this argument sepcifies the method 
to assign unassigned objects to the nearest cluster. Valid values are (unique abbreviations) of "average",
"single", and "complete". In analogy with hierarchical clustering, each node will be assigned to the cluster
with which it has the highest average, maximum, and minimum adjacency, respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accelerated</code></td>
<td>
<p>Logical: should an accelerated algorithm be used? In general the accelerated method is
preferable. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Logical: should parallel calculation be used? At present the parallel calculation is not
fully implemented and the function falls back to standard accelerated calculation, with a warning.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If a single cluster is specified, the approximation is known as "Pure Propensity". 
</p>
<p>If unassigned nodes are present in the clustering and they are dropped before the CPBA calculation, their
propensities, mean values and tail p-values are returned as NA.
</p>


<h3>Value</h3>

<p>Returns the following list of items.
</p>

<table>
<tr style="vertical-align: top;">
<td><code>Propensity </code></td>
<td>
<p>Gives the propensities (or conformities) of each node.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IntermodularAdjacency </code></td>
<td>
<p>Gives the intermodular adjacencies or the conformities between clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Factorizability </code></td>
<td>
<p>Gives the factorizability of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2Norm or Loglik</code></td>
<td>
<p>The L2 Norm (for L2 norm objective function) or the log-likelihood (for Poisson
objetive function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ExpectedAdjancency</code></td>
<td>
<p>A distance structure representing the lower triangle of the symmetric matrix of estimated 
values of the adjacency matrix using the Propensity and IntermodularAdjacency.  
If the Poisson updates are used,
the returned values are the estimate means of the distribution.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EdgePvalues</code></td>
<td>
<p> A distance structure representing the lower triangle of the symmetric matrix of
the tail probabilities under the Poisson distribution.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>John Michael Ranola, Peter Langfelder, Steve Horvath, Kenneth Lange
</p>


<h3>References</h3>

<p>Ranola et. al. (2010) A Poisson Model for Random Multigraphs. Bioinformatics 26(16):2004-2001.
Ranola JM, Langfelder P, Lange K, Horvath S (2013) Cluster and propensity based approximation of a network.
BMC Bioinformatics, in press.
</p>


<h3>See Also</h3>

<p>propensityClustering
</p>


<h3>Examples</h3>

<pre><code class="language-R">
nNodes=50
nClusters=5
#We would like to use L2Norm instead of Loglikelihood
objective = "L2norm"

ADJ&lt;-matrix(runif(nNodes*nNodes),ncol=nNodes)
for(i in 1:(length(ADJ[1,])-1)){
		for(j in i:length(ADJ[,1])){
			ADJ[i,j]=ADJ[j,i]
		}
	}

for(i in 1:length(ADJ[1,])) ADJ[i,i]=0 

Results&lt;-propensityClustering(
              adjacency = ADJ,
              objectiveFunction = objective,
              initialClusters = NULL,
              nClusters = nClusters,
              fastUpdates = FALSE)

Results2&lt;-CPBADecomposition(adjacency = ADJ, clustering = Results$Clustering, 
                            objectiveFunction = objective)

Results3&lt;-propensityClustering( adjacency = ADJ,
              objectiveFunction = objective,
              initialClusters = NULL,
              nClusters = nClusters,
              fastUpdates = TRUE)

</code></pre>


</div>
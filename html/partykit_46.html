<div class="container">

<table style="width: 100%;"><tr>
<td>party</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Recursive Partytioning </h2>

<h3>Description</h3>

<p>A class for representing decision trees and corresponding
accessor functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">party(node, data, fitted = NULL, terms = NULL, names = NULL, 
    info = NULL)
## S3 method for class 'party'
names(x)
## S3 replacement method for class 'party'
names(x) &lt;- value
data_party(party, id = 1L)
## Default S3 method:
data_party(party, id = 1L)
node_party(party)
is.constparty(party)
is.simpleparty(party)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>node</code></td>
<td>
<p> an object of class <code>partynode</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> a (potentially empty) <code>data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted</code></td>
<td>
<p> an optional <code>data.frame</code> with <code>nrow(data)</code> 
rows (only if <code>nrow(data) != 0</code> and 
containing at least the fitted terminal node identifiers
as element <code>(fitted)</code>. In addition, weights
may be contained as element <code>(weights)</code> and 
responses as <code>(response)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p> an optional <code>terms</code> object.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p> an optional vector of names to be assigned to each node of <code>node</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p> additional information. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> an object of class <code>party</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>party</code></td>
<td>
<p> an object of class <code>party</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>a character vector of up to the same length as <code>x</code>, or
<code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p> a node identifier.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Objects of class <code>party</code> basically consist of a <code>partynode</code>
object representing the tree structure in a recursive way and 
data. The <code>data</code> argument takes a <code>data.frame</code> which, however,
might have zero columns. Optionally, a <code>data.frame</code> with at least one
variable <code>(fitted)</code> containing the terminal node numbers of 
data used for fitting the tree may be specified along with a
<code>terms</code> object or any additional (currently unstructured)
information as <code>info</code>. Argument <code>names</code> defines names
for all nodes in <code>node</code>.
</p>
<p>Method <code>names</code> can be used to extract or alter names for nodes.
Function <code>node_party</code> returns the <code>node</code> element of a
<code>party</code> object. Further methods for <code>party</code> objects
are documented in <code>party-methods</code> and 
<code>party-predict</code>. Trees of various flavors can be coerced
to <code>party</code>, see <code>party-coercion</code>.
</p>
<p>Two classes inherit from class <code>party</code> and impose additional
assumptions on the structure of this object:
Class <code>constparty</code> requires that the <code>fitted</code> slot
contains a partitioning of the learning sample as a factor <code>("fitted")</code>
and the response values of all observations in the learning sample
as <code>("response")</code>. This structure is most flexible and 
allows for graphical display of the response values in terminal
nodes as well as for computing predictions based on 
arbitrary summary statistics.
</p>
<p>Class <code>simpleparty</code> assumes that certain pre-computed information
about the distribution of the response variable is contained
in the <code>info</code> slot nodes. At the moment, no formal
class is used to describe this information.
</p>


<h3>Value</h3>

<p>The constructor returns an object of class <code>party</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>node</code></td>
<td>
<p> an object of class <code>partynode</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> a (potentially empty) <code>data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted</code></td>
<td>
<p> an optional <code>data.frame</code> with <code>nrow(data)</code> 
rows (only if <code>nrow(data) != 0</code> and 
containing at least the fitted terminal node identifiers
as element <code>(fitted)</code>. In addition, weights
may be contained as element <code>(weights)</code> and 
responses as <code>(response)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p> an optional <code>terms</code> object.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p> an optional vector of names to be assigned to each node of <code>node</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p> additional information. </p>
</td>
</tr>
</table>
<p><code>names</code> can be used to set and retrieve names of nodes and 
<code>node_party</code> returns an object of class <code>partynode</code>.
<code>data_party</code> returns a data frame with observations contained in node
<code>id</code>.
</p>


<h3>References</h3>

 
<p>Hothorn T, Zeileis A (2015).
partykit: A Modular Toolkit for Recursive Partytioning in R.
<em>Journal of Machine Learning Research</em>, <b>16</b>, 3905â€“3909.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### data ###
## artificial WeatherPlay data
data("WeatherPlay", package = "partykit")
str(WeatherPlay)


### splits ###
## split in overcast, humidity, and windy
sp_o &lt;- partysplit(1L, index = 1:3)
sp_h &lt;- partysplit(3L, breaks = 75)
sp_w &lt;- partysplit(4L, index = 1:2)

## query labels
character_split(sp_o)


### nodes ###
## set up partynode structure
pn &lt;- partynode(1L, split = sp_o, kids = list(
  partynode(2L, split = sp_h, kids = list(
    partynode(3L, info = "yes"),
    partynode(4L, info = "no"))),
  partynode(5L, info = "yes"),
  partynode(6L, split = sp_w, kids = list(
    partynode(7L, info = "yes"),
    partynode(8L, info = "no")))))
pn


### tree ###
## party: associate recursive partynode structure with data
py &lt;- party(pn, WeatherPlay)
py
plot(py)


### variations ###
## tree stump
n1 &lt;- partynode(id = 1L, split = sp_o, kids = lapply(2L:4L, partynode))
print(n1, data = WeatherPlay)

## query fitted nodes and kids ids
fitted_node(n1, data = WeatherPlay)
kidids_node(n1, data = WeatherPlay)

## tree with full data sets
t1 &lt;- party(n1, data = WeatherPlay)

## tree with empty data set
party(n1, data = WeatherPlay[0, ])

## constant-fit tree
t2 &lt;- party(n1, 
  data = WeatherPlay,
  fitted = data.frame(
    "(fitted)" = fitted_node(n1, data = WeatherPlay),
    "(response)" = WeatherPlay$play,
    check.names = FALSE),
  terms = terms(play ~ ., data = WeatherPlay),
)
t2 &lt;- as.constparty(t2)
t2
plot(t2)
</code></pre>


</div>
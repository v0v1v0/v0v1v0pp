<div class="container">

<table style="width: 100%;"><tr>
<td>binomial.logistic.Bayes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian estimation for the binomial logistic model</h2>

<h3>Description</h3>

<p>This function performs Bayesian estimation for a geostatistical binomial logistic model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">binomial.logistic.Bayes(
  formula,
  units.m,
  coords,
  data,
  ID.coords = NULL,
  control.prior,
  control.mcmc,
  kappa,
  low.rank = FALSE,
  knots = NULL,
  messages = TRUE,
  mesh = NULL,
  SPDE = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class <code>formula</code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>units.m</code></td>
<td>
<p>an object of class <code>formula</code> indicating the binomial denominators.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>an object of class <code>formula</code> indicating the geographic coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ID.coords</code></td>
<td>
<p>vector of ID values for the unique set of spatial coordinates obtained from <code>create.ID.coords</code>. These must be provided if, for example, spatial random effects are defined at household level but some of the covariates are at individual level. <b>Warning</b>: the household coordinates must all be distinct otherwise see <code>jitterDupCoords</code>. Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.prior</code></td>
<td>
<p>output from <code>control.prior</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.mcmc</code></td>
<td>
<p>output from <code>control.mcmc.Bayes</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>value for the shape parameter of the Matern covariance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>low.rank</code></td>
<td>
<p>logical; if <code>low.rank=TRUE</code> a low-rank approximation is required. Default is <code>low.rank=FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>if <code>low.rank=TRUE</code>, <code>knots</code> is a matrix of spatial knots used in the low-rank approximation. Default is <code>knots=NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mesh</code></td>
<td>
<p>an object obtained as result of a call to the function <code>inla.mesh.2d</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SPDE</code></td>
<td>
<p>logical; if <code>SPDE=TRUE</code> the SPDE approximation for the Gaussian spatial model is used. Default is <code>SPDE=FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs Bayesian estimation for the parameters of the geostatistical binomial logistic model. Conditionally on a zero-mean stationary Gaussian process <code class="reqn">S(x)</code> and mutually independent zero-mean Gaussian variables <code class="reqn">Z</code> with variance <code>tau2</code>, the linear predictor assumes the form
</p>
<p style="text-align: center;"><code class="reqn">\log(p/(1-p)) = d'\beta + S(x) + Z,</code>
</p>

<p>where <code class="reqn">d</code> is a vector of covariates with associated regression coefficients <code class="reqn">\beta</code>. The Gaussian process <code class="reqn">S(x)</code> has isotropic Matern covariance function (see <code>matern</code>) with variance <code>sigma2</code>, scale parameter <code>phi</code> and shape parameter <code>kappa</code>.
</p>
<p><b>Priors definition.</b> Priors can be defined through the function <code>control.prior</code>. The hierarchical structure of the priors is the following. Let <code class="reqn">\theta</code> be the vector of the covariance parameters <code>c(sigma2,phi,tau2)</code>; then each component of <code class="reqn">\theta</code> has independent priors freely defined by the user. However, in  <code>control.prior</code> uniform and log-normal priors are also available as default priors for each of the covariance parameters. To remove the nugget effect <code class="reqn">Z</code>, no prior should be defined for <code>tau2</code>. Conditionally on <code>sigma2</code>, the vector of regression coefficients <code>beta</code> has a multivariate Gaussian prior with mean <code>beta.mean</code> and covariance matrix <code>sigma2*beta.covar</code>, while in the low-rank approximation the covariance matrix is simply <code>beta.covar</code>.
</p>
<p><b>Updating the covariance parameters with a Metropolis-Hastings algorithm.</b> In the MCMC algorithm implemented in <code>binomial.logistic.Bayes</code>, the transformed parameters </p>
<p style="text-align: center;"><code class="reqn">(\theta_{1}, \theta_{2}, \theta_{3})=(\log(\sigma^2)/2,\log(\sigma^2/\phi^{2 \kappa}), \log(\tau^2))</code>
</p>
<p> are independently updated using a Metropolis Hastings algorithm. At the <code class="reqn">i</code>-th iteration, a new value is proposed for each from a univariate Gaussian distrubion with variance <code class="reqn">h_{i}^2</code> that is tuned using the following adaptive scheme </p>
<p style="text-align: center;"><code class="reqn">h_{i} = h_{i-1}+c_{1}i^{-c_{2}}(\alpha_{i}-0.45),</code>
</p>
<p> where <code class="reqn">\alpha_{i}</code> is the acceptance rate at the <code class="reqn">i</code>-th iteration, 0.45 is the optimal acceptance rate for a univariate Gaussian distribution, whilst <code class="reqn">c_{1} &gt; 0</code> and <code class="reqn">0 &lt; c_{2} &lt; 1</code> are pre-defined constants. The starting values <code class="reqn">h_{1}</code> for each of the parameters <code class="reqn">\theta_{1}</code>, <code class="reqn">\theta_{2}</code> and <code class="reqn">\theta_{3}</code> can be set using the function <code>control.mcmc.Bayes</code> through the arguments <code>h.theta1</code>, <code>h.theta2</code> and <code>h.theta3</code>. To define values for <code class="reqn">c_{1}</code> and <code class="reqn">c_{2}</code>, see the documentation of <code>control.mcmc.Bayes</code>.
</p>
<p><b>Hamiltonian Monte Carlo.</b> The MCMC algorithm in <code>binomial.logistic.Bayes</code> uses a Hamiltonian Monte Carlo (HMC) procedure to update the random effect <code class="reqn">T=d'\beta + S(x) + Z</code>; see Neal (2011) for an introduction to HMC. HMC makes use of a postion vector, say <code class="reqn">t</code>, representing the random effect <code class="reqn">T</code>, and a momentum vector, say <code class="reqn">q</code>, of the same length of the position vector, say <code class="reqn">n</code>. Hamiltonian dynamics also have a physical interpretation where the states of the system are described by the position of a puck and its momentum (its mass times its velocity). The Hamiltonian function is then defined as a function of <code class="reqn">t</code> and <code class="reqn">q</code>, having the form <code class="reqn">H(t,q) = -\log\{f(t | y, \beta, \theta)\} + q'q/2</code>, where <code class="reqn">f(t | y, \beta, \theta)</code> is the conditional distribution of <code class="reqn">T</code> given the data <code class="reqn">y</code>, the regression parameters <code class="reqn">\beta</code> and covariance parameters <code class="reqn">\theta</code>. The system of Hamiltonian equations then defines the evolution of the system in time, which can be used to implement an algorithm for simulation from the posterior distribution of <code class="reqn">T</code>. In order to implement the Hamiltonian dynamic on a computer, the Hamiltonian equations must be discretised. The <em>leapfrog method</em> is then used for this purpose, where two tuning parameters should be defined: the stepsize <code class="reqn">\epsilon</code> and the number of steps <code class="reqn">L</code>. These respectively correspond to <code>epsilon.S.lim</code> and <code>L.S.lim</code> in the <code>control.mcmc.Bayes</code> function. However, it is advisable to let <code class="reqn">epsilon</code> and <code class="reqn">L</code> take different random values at each iteration of the HCM algorithm so as to account for the different variances amongst the components of the posterior of <code class="reqn">T</code>. This can be done in <code>control.mcmc.Bayes</code> by defning <code>epsilon.S.lim</code> and <code>L.S.lim</code> as vectors of two elements, each of which represents the lower and upper limit of a uniform distribution used to generate values for  <code>epsilon.S.lim</code> and <code>L.S.lim</code>, respectively.
</p>
<p><b>Using a two-level model to include household-level and individual-level information.</b>
When analysing data from household sruveys, some of the avilable information information might be at household-level (e.g. material of house, temperature) and some at individual-level (e.g. age, gender). In this case, the Gaussian spatial process <code class="reqn">S(x)</code> and the nugget effect <code class="reqn">Z</code> are defined at hosuehold-level in order to account for extra-binomial variation between and within households, respectively.
</p>
<p><b>Low-rank approximation.</b>
In the case of very large spatial data-sets, a low-rank approximation of the Gaussian spatial process <code class="reqn">S(x)</code> might be computationally beneficial. Let <code class="reqn">(x_{1},\dots,x_{m})</code> and <code class="reqn">(t_{1},\dots,t_{m})</code> denote the set of sampling locations and a grid of spatial knots covering the area of interest, respectively. Then <code class="reqn">S(x)</code> is approximated as <code class="reqn">\sum_{i=1}^m K(\|x-t_{i}\|; \phi, \kappa)U_{i}</code>, where <code class="reqn">U_{i}</code> are zero-mean mutually independent Gaussian variables with variance <code>sigma2</code> and <code class="reqn">K(.;\phi, \kappa)</code> is the isotropic Matern kernel (see <code>matern.kernel</code>). Since the resulting approximation is no longer a stationary process (but only approximately), <code>sigma2</code> may take very different values from the actual variance of the Gaussian process to approximate. The function <code>adjust.sigma2</code> can then be used to (approximately) explore the range for <code>sigma2</code>. For example if the variance of the Gaussian process is <code>0.5</code>, then an approximate value for <code>sigma2</code> is <code>0.5/const.sigma2</code>, where <code>const.sigma2</code> is the value obtained with <code>adjust.sigma2</code>.
</p>


<h3>Value</h3>

<p>An object of class "Bayes.PrevMap".
The function <code>summary.Bayes.PrevMap</code> is used to print a summary of the fitted model.
The object is a list with the following components:
</p>
<p><code>estimate</code>: matrix of the posterior samples of the model parameters.
</p>
<p><code>S</code>: matrix of the posterior samples for each component of the random effect.
</p>
<p><code>const.sigma2</code>: vector of the values of the multiplicative factor used to adjust the values of <code>sigma2</code> in the low-rank approximation.
</p>
<p><code>y</code>: binomial observations.
</p>
<p><code>units.m</code>: binomial denominators.
</p>
<p><code>D</code>: matrix of covariarates.
</p>
<p><code>coords</code>: matrix of the observed sampling locations.
</p>
<p><code>kappa</code>: shape parameter of the Matern function.
</p>
<p><code>ID.coords</code>: set of ID values defined through the argument <code>ID.coords</code>.
</p>
<p><code>knots</code>: matrix of spatial knots used in the low-rank approximation.
</p>
<p><code>h1</code>: vector of values taken by the tuning parameter <code>h.theta1</code> at each iteration.
</p>
<p><code>h2</code>: vector of values taken by the tuning parameter <code>h.theta2</code> at each iteration.
</p>
<p><code>h3</code>: vector of values taken by the tuning parameter <code>h.theta3</code> at each iteration.
</p>
<p><code>acc.beta.S</code>: empirical acceptance rate for the regression coefficients and random effects (only if <code>SPDE=TRUE</code>).
</p>
<p><code>mesh</code>: the mesh used in the SPDE approximation.
</p>
<p><code>call</code>: the matched call.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>References</h3>

<p>Diggle, P.J., Giorgi, E. (2019). <em>Model-based Geostatistics for Global Public Health.</em> CRC/Chapman &amp; Hall.
</p>
<p>Giorgi, E., Diggle, P.J. (2017). <em>PrevMap: an R package for prevalence mapping.</em> Journal of Statistical Software. 78(8), 1-29. doi: 10.18637/jss.v078.i08
</p>
<p>Neal, R. M. (2011) <em>MCMC using Hamiltonian Dynamics</em>, In: Handbook of Markov Chain Monte Carlo (Chapter 5), Edited by Steve Brooks, Andrew Gelman, Galin Jones, and Xiao-Li Meng Chapman &amp; Hall / CRC Press.
</p>
<p>Higdon, D. (1998). <em>A process-convolution approach to modeling temperatures in the North Atlantic Ocean.</em> Environmental and Ecological Statistics 5, 173-190.
</p>


<h3>See Also</h3>

<p><code>control.mcmc.Bayes</code>,  <code>control.prior</code>,<code>summary.Bayes.PrevMap</code>, <code>matern</code>, <code>matern.kernel</code>, <code>create.ID.coords</code>.
</p>


</div>
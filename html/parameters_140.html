<div class="container">

<table style="width: 100%;"><tr>
<td>n_clusters</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find number of clusters in your data</h2>

<h3>Description</h3>

<p>Similarly to <code>n_factors()</code> for factor / principal component analysis,
<code>n_clusters()</code> is the main function to find out the optimal numbers of clusters
present in the data based on the maximum consensus of a large number of
methods.
</p>
<p>Essentially, there exist many methods to determine the optimal number of
clusters, each with pros and cons, benefits and limitations. The main
<code>n_clusters</code> function proposes to run all of them, and find out the number of
clusters that is suggested by the majority of methods (in case of ties, it
will select the most parsimonious solution with fewer clusters).
</p>
<p>Note that we also implement some specific, commonly used methods, like the
Elbow or the Gap method, with their own visualization functionalities. See
the examples below for more details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">n_clusters(
  x,
  standardize = TRUE,
  include_factors = FALSE,
  package = c("easystats", "NbClust", "mclust"),
  fast = TRUE,
  nbclust_method = "kmeans",
  n_max = 10,
  ...
)

n_clusters_elbow(
  x,
  standardize = TRUE,
  include_factors = FALSE,
  clustering_function = stats::kmeans,
  n_max = 10,
  ...
)

n_clusters_gap(
  x,
  standardize = TRUE,
  include_factors = FALSE,
  clustering_function = stats::kmeans,
  n_max = 10,
  gap_method = "firstSEmax",
  ...
)

n_clusters_silhouette(
  x,
  standardize = TRUE,
  include_factors = FALSE,
  clustering_function = stats::kmeans,
  n_max = 10,
  ...
)

n_clusters_dbscan(
  x,
  standardize = TRUE,
  include_factors = FALSE,
  method = c("kNN", "SS"),
  min_size = 0.1,
  eps_n = 50,
  eps_range = c(0.1, 3),
  ...
)

n_clusters_hclust(
  x,
  standardize = TRUE,
  include_factors = FALSE,
  distance_method = "correlation",
  hclust_method = "average",
  ci = 0.95,
  iterations = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Standardize the dataframe before clustering (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_factors</code></td>
<td>
<p>Logical, if <code>TRUE</code>, factors are converted to numerical
values in order to be included in the data for determining the number of
clusters. By default, factors are removed, because most methods that
determine the number of clusters need numeric input only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>package</code></td>
<td>
<p>Package from which methods are to be called to determine the
number of clusters. Can be <code>"all"</code> or a vector containing
<code>"easystats"</code>, <code>"NbClust"</code>, <code>"mclust"</code>, and <code>"M3C"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast</code></td>
<td>
<p>If <code>FALSE</code>, will compute 4 more indices (sets <code>index = "allong"</code>
in <code>NbClust</code>). This has been deactivated by default as it is
computationally heavy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbclust_method</code></td>
<td>
<p>The clustering method (passed to <code>NbClust::NbClust()</code>
as <code>method</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_max</code></td>
<td>
<p>Maximal number of clusters to test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to or from other methods. For instance, when
<code>bootstrap = TRUE</code>, arguments like <code>type</code> or <code>parallel</code> are passed down to
<code>bootstrap_model()</code>. Further non-documented arguments are <code>digits</code>,
<code>p_digits</code>, <code>ci_digits</code> and <code>footer_digits</code> to set the number of digits for
the output. If <code>s_value = TRUE</code>, the p-value will be replaced by the
S-value in the output (cf. <em>Rafi and Greenland 2020</em>). <code>pd</code> adds an
additional column with the <em>probability of direction</em> (see
<code>bayestestR::p_direction()</code> for details). <code>groups</code> can be used to group
coefficients. It will be passed to the print-method, or can directly be
used in <code>print()</code>, see documentation in <code>print.parameters_model()</code>.
Furthermore, see 'Examples' for this function. For developers, whose
interest mainly is to get a "tidy" data frame of model summaries, it is
recommended to set <code>pretty_names = FALSE</code> to speed up computation of the
summary table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustering_function, gap_method</code></td>
<td>
<p>Other arguments passed to other
functions. <code>clustering_function</code> is used by <code>fviz_nbclust()</code> and
can be <code>kmeans</code>, <code>cluster::pam</code>, <code>cluster::clara</code>, <code>cluster::fanny</code>, and
more. <code>gap_method</code> is used by <code>cluster::maxSE</code> to extract the optimal
numbers of clusters (see its <code>method</code> argument).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method, min_size, eps_n, eps_range</code></td>
<td>
<p>Arguments for DBSCAN algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance_method</code></td>
<td>
<p>The distance method (passed to <code>dist()</code>). Used by
algorithms relying on the distance matrix, such as <code>hclust</code> or <code>dbscan</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hclust_method</code></td>
<td>
<p>The hierarchical clustering method (passed to <code>hclust()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>Confidence Interval (CI) level. Default to <code>0.95</code> (<code style="white-space: pre;">⁠95%⁠</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>The number of bootstrap replicates. This only apply in the
case of bootstrapped frequentist models.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>There is also a <a href="https://easystats.github.io/see/articles/parameters.html"><code>plot()</code>-method</a> implemented in the <a href="https://easystats.github.io/see/"><strong>see</strong>-package</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(parameters)

# The main 'n_clusters' function ===============================
if (require("mclust", quietly = TRUE) &amp;&amp; require("NbClust", quietly = TRUE) &amp;&amp;
  require("cluster", quietly = TRUE) &amp;&amp; require("see", quietly = TRUE)) {
  n &lt;- n_clusters(iris[, 1:4], package = c("NbClust", "mclust")) # package can be "all"
  n
  summary(n)
  as.data.frame(n) # Duration is the time elapsed for each method in seconds
  plot(n)

  # The following runs all the method but it significantly slower
  # n_clusters(iris[1:4], standardize = FALSE, package = "all", fast = FALSE)
}



x &lt;- n_clusters_elbow(iris[1:4])
x
as.data.frame(x)
plot(x)



#
# Gap method --------------------
if (require("see", quietly = TRUE) &amp;&amp;
  require("cluster", quietly = TRUE) &amp;&amp;
  require("factoextra", quietly = TRUE)) {
  x &lt;- n_clusters_gap(iris[1:4])
  x
  as.data.frame(x)
  plot(x)
}


#
# Silhouette method --------------------------
if (require("factoextra", quietly = TRUE)) {
  x &lt;- n_clusters_silhouette(iris[1:4])
  x
  as.data.frame(x)
  plot(x)
}


#
if (require("dbscan", quietly = TRUE)) {
  # DBSCAN method -------------------------
  # NOTE: This actually primarily estimates the 'eps' parameter, the number of
  # clusters is a side effect (it's the number of clusters corresponding to
  # this 'optimal' EPS parameter).
  x &lt;- n_clusters_dbscan(iris[1:4], method = "kNN", min_size = 0.05) # 5 percent
  x
  head(as.data.frame(x))
  plot(x)

  x &lt;- n_clusters_dbscan(iris[1:4], method = "SS", eps_n = 100, eps_range = c(0.1, 2))
  x
  head(as.data.frame(x))
  plot(x)
}


#
# hclust method -------------------------------
if (require("pvclust", quietly = TRUE)) {
  # iterations should be higher for real analyses
  x &lt;- n_clusters_hclust(iris[1:4], iterations = 50, ci = 0.90)
  x
  head(as.data.frame(x), n = 10) # Print 10 first rows
  plot(x)
}

</code></pre>


</div>
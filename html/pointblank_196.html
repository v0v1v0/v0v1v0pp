<div class="container">

<table style="width: 100%;"><tr>
<td>yaml_exec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Execute all agent and informant YAML tasks</h2>

<h3>Description</h3>

<p>The <code>yaml_exec()</code> function takes all relevant <strong>pointblank</strong> YAML files in a
directory and executes them. Execution involves interrogation of agents for
YAML agents and incorporation of informants for YAML informants. Under the
hood, this uses <code>yaml_agent_interrogate()</code> and <code>yaml_informant_incorporate()</code>
and then <code>x_write_disk()</code> to save the processed objects to an output
directory. These written artifacts can be read in at any later time with the
<code>x_read_disk()</code> function or the <code>read_disk_multiagent()</code> function. This is
useful when data in the target tables are changing and the periodic testing
of such tables is part of a data quality monitoring plan.
</p>
<p>The output RDS files are named according to the object type processed, the
target table, and the date-time of processing. For convenience and
modularity, this setup is ideal when a table store YAML file (typically named
<code>"tbl_store.yml"</code> and produced via the <code>tbl_store()</code> and <code>yaml_write()</code>
workflow) is available in the directory, and when table-prep formulas are
accessed by name through <code>tbl_source()</code>.
</p>
<p>A typical directory of files set up for execution in this way might have the
following contents:
</p>

<ul>
<li>
<p> a <code>"tbl_store.yml"</code> file for holding table-prep formulas (created with
<code>tbl_store()</code> and written to YAML with <code>yaml_write()</code>)
</p>
</li>
<li>
<p> one or more YAML <em>agent</em> files to validate tables (ideally using
<code>tbl_source()</code>)
</p>
</li>
<li>
<p> one or more YAML <em>informant</em> files to provide refreshed metadata on tables
(again, using <code>tbl_source()</code> to reference table preparations is ideal)
</p>
</li>
<li>
<p> an output folder (default is <code>"output"</code>) to save serialized versions of
processed agents and informants
</p>
</li>
</ul>
<p>Minimal example files of the aforementioned types can be found in the
<strong>pointblank</strong> package through the following <code>system.file()</code> calls:
</p>

<ul>
<li> <p><code>system.file("yaml", "agent-small_table.yml", package = "pointblank")</code>
</p>
</li>
<li> <p><code>system.file("yaml", "informant-small_table.yml", package = "pointblank")</code>
</p>
</li>
<li> <p><code>system.file("yaml", "tbl_store.yml", package = "pointblank")</code>
</p>
</li>
</ul>
<p>The directory itself can be accessed using <code>system.file("yaml", package = "pointblank")</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">yaml_exec(
  path = NULL,
  files = NULL,
  write_to_disk = TRUE,
  output_path = file.path(path, "output"),
  keep_tbl = FALSE,
  keep_extracts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>The path that contains the YAML files for agents and informants.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>files</code></td>
<td>
<p>A vector of YAML files to use in the execution workflow. By
default, <code>yaml_exec()</code> will attempt to process every valid YAML file in
<code>path</code> but supplying a vector here limits the scope to the specified files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>write_to_disk</code></td>
<td>
<p>Should the execution workflow include a step that writes
output files to disk? This internally calls <code>x_write_disk()</code> to write RDS
files and uses the base filename of the agent/informant YAML file as part
of the output filename, appending the date-time to the basename.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_path</code></td>
<td>
<p>The output path for any generated output files. By
default, this will be a subdirectory of the provided <code>path</code> called
<code>"output"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_tbl, keep_extracts</code></td>
<td>
<p>For agents, the table may be kept if it is a
data frame object (databases tables will never be pulled for storage) and
<em>extracts</em>, collections of table rows that failed a validation step, may
also be stored. By default, both of these options are set to <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Invisibly returns a named vector of file paths for the input files
that were processed; file output paths (for wherever writing occurred) are
given as the names.
</p>


<h3>Function ID</h3>

<p>11-8
</p>


<h3>See Also</h3>

<p>Other pointblank YAML: 
<code>yaml_agent_interrogate()</code>,
<code>yaml_agent_show_exprs()</code>,
<code>yaml_agent_string()</code>,
<code>yaml_informant_incorporate()</code>,
<code>yaml_read_agent()</code>,
<code>yaml_read_informant()</code>,
<code>yaml_write()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (interactive()) {

# The 'yaml' directory that is
# accessible in the package through
# `system.file()` contains the files
# 1. `agent-small_table.yml`
# 2. `informant-small_table.yml`
# 3. `tbl_store.yml`

# There are references in YAML files
# 1 &amp; 2 to the table store YAML file,
# so, they all work together cohesively

# Let's process the agent and the
# informant YAML files with `yaml_exec()`;
# and we'll specify the working directory
# as the place where the output RDS files
# are written

output_dir &lt;- getwd()

yaml_exec(
  path = system.file(
    "yaml", package = "pointblank"
  ),
  output = output_dir
)

# This generates two RDS files in the
# working directory: one for the agent
# and the other for the informant; each
# of them are automatically time-stamped
# so that periodic execution can be
# safely carried out without risk of
# overwriting 

}

</code></pre>


</div>
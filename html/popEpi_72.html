<div class="container">

<table style="width: 100%;"><tr>
<td>splitLexisDT</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Split case-level observations</h2>

<h3>Description</h3>

<p>Split a <code>Lexis</code> object along one time scale
(as <code>splitLexis</code>) with speed
</p>


<h3>Usage</h3>

<pre><code class="language-R">splitLexisDT(lex, breaks, timeScale, merge = TRUE, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lex</code></td>
<td>
<p>a Lexis object, split or not</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>a vector of <code>[a,b)</code> breaks to split <code>data</code> by</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timeScale</code></td>
<td>
<p>a character string; name of the time scale to split by</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merge</code></td>
<td>
<p>logical; if <code>TRUE</code>, retains all variables 
from the original data - i.e. original variables are
repeated for all the rows by original subject</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>logical; if <code>TRUE</code>, drops all resulting rows 
after expansion that reside outside the time window
defined by the given breaks</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>splitLexisDT</code> is in essence a <span class="pkg">data.table</span> version of
<code>splitLexis</code> or <code>survSplit</code> for splitting along a single
time scale. It requires a Lexis object as input, which may have already
been split along some time scale.
</p>
<p>Unlike <code>splitLexis</code>, <code>splitLexisDT</code> drops observed time outside
the roof and floor of <code>breaks</code> by default - with <code>drop = FALSE</code>
the functions have identical behaviour.
</p>
<p>The <code>Lexis</code> time scale variables can be of any arbitrary 
format, e.g. <code>Date</code>,
fractional years (see <code>cal.yr</code>) and <code>get.yrs</code>,
or other. However, using <code>date</code> variables (from package <span class="pkg">date</span>)
are not recommended, as <code>date</code> variables are always stored as integers,
whereas <code>Date</code> variables (see <code>?as.Date</code>) are typically stored
in double ("numeric") format. This allows for breaking days into fractions
as well, when using e.g. hypothetical years of 365.25 days.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> or <code>data.frame</code> 
(depending on <code>options("popEpi.datatable")</code>; see <code>?popEpi</code>) 
object expanded to accommodate split observations.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other splitting functions: 
<code>lexpand()</code>,
<code>splitMulti()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(Epi)
data("sire", package = "popEpi")
x &lt;- Lexis(data=sire[1000:1100, ], 
           entry = list(fot=0, per=get.yrs(dg_date), age=dg_age), 
           exit=list(per=get.yrs(ex_date)), exit.status=status)
BL &lt;- list(fot=seq(0, 5, by = 3/12), per=c(2008, 2013))

x2 &lt;- splitMulti(x, breaks = BL, drop = FALSE)

x3 &lt;- splitLexisDT(x, breaks = BL$fot, timeScale = "fot", drop = FALSE)
x3 &lt;- splitLexisDT(x3, breaks = BL$per, timeScale = "per", drop = FALSE)

x4 &lt;- splitLexis(x,  breaks = BL$fot, time.scale = "fot")
x4 &lt;- splitLexis(x4, breaks = BL$per, time.scale = "per")
## all produce identical results

## using Date variables
x &lt;- Lexis(data=sire[1000:1100, ], 
           entry = list(fot=0, per=dg_date, age=dg_date-bi_date), 
           exit=list(per=ex_date), exit.status=status)
BL &lt;- list(fot = 0:5*365.25, per = as.Date(c("2008-01-01", "2013-01-01")))

x2 &lt;- splitMulti(x, breaks = BL, drop = FALSE)

x3 &lt;- splitLexisDT(x, breaks = BL$fot, timeScale = "fot", drop = FALSE)
x3 &lt;- splitLexisDT(x3, breaks = BL$per, timeScale = "per", drop = FALSE)

## splitLexis may not work when using Dates
</code></pre>


</div>
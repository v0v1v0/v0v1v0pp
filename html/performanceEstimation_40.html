<div class="container">

<table style="width: 100%;"><tr>
<td>performanceEstimation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Estimate the predictive performance of modeling alternatives on
different predictive tasks
</h2>

<h3>Description</h3>

<p>This function can be used to estimate the predictive performance of
alternative approaches to a set of predictive tasks, using different
estimation methods. This is
a generic function that should work with any modeling approaches provided a
few assumptions are met. The function implements different estimation procedures, namely: cross validation, leave one out cross validation,
hold-out, monte carlo simulations and bootstrap.
</p>


<h3>Usage</h3>

<pre><code class="language-R">performanceEstimation(tasks,workflows,estTask,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tasks</code></td>
<td>

<p>This is a vector of objects of class <code>PredTask</code>, containing the
predictive tasks that will be used in the estimation procedure.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>workflows</code></td>
<td>

<p>This is a vector of objects of class <code>Workflow</code>, containing the
workflows representing different approaches to the predictive tasks,
and whose performance we want to estimate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estTask</code></td>
<td>

<p>This is an object belonging to class
<code>EstimationTask</code>.  It is used to specify the metrics
to be estimated and the method to use to obtain these estimates.  See
section Details for the possible values. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Any further parameters that are to be passed to the lower-level
functions implementing each individual estimation methodology. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The goal of this function is to allow estimating the perfomance of a set
of alternative modelling approaches on a set of predictive tasks. The estimation
can be carried out using different methodologies. All alternative
approaches (which we will refer to as <em>workflows</em>) will be
applied using the same exact data partitions for each  task thus
ensuring the possibility of carrying out paired  comparisons using
adequate statistical tests for checking the significance of the
observed differences in performance.
</p>
<p>The first parameter of this function is a vector of
<code>PredTask</code> objects that define the tasks to use in
the estimation process.
</p>
<p>The second argument is a vector of <code>Workflow</code>
objects. These can be created in two different ways: either directly
by calling the constructor of this class; or by using the
<code>workflowVariants</code> function that can be used to
automatically generate different workflow objects as variants of some
base workflow. Either way there are two types of workflows:
user-defined workflows and what we call "standard" workflows. The
later are workflows that people typically follow to solve predictive
tasks and that are already implemented in this package to facilitate
the task of the user. These standard workflows are implemented in
functions <code>standardWF</code> and
<code>timeseriesWF</code>. When specifying the vector of workflows if
you use (either in the constructor or in the function
<code>workflowVariants</code>) the parameter <code>wf</code> to indicate
which workflow you which to use. If you supply a name different from
the two provided standard workflows the function will assume that this
is a name of a function you have created to implement your own
workflow (see the Examples section for illustrations). In case you
omit the value of the <code>wf</code> parameter the function assumes you
want to use one of the standard workflows and will try to "guess"
which one. Namely, if you provide some value for the parameter
<code>type</code> (either "slide" or "grow"), it will assume that you are
addressing a time series task and thus will set <code>wf</code> to
<code>timeseriesWF</code>. In all other cases will set it to
<code>standardWF</code>.  Summarizing, in terms of workflows you can
use: i) your own user-defined workflows; ii) the standard workflow
implemented by function <code>standardWF</code>; or iii) the standard
time series workflow implementd by <code>timeseriesWF</code>.
</p>
<p>Currently, the function allows for 5 different types of estimation
methods to be used that are specified when you indicate the esitmation
task. These are different  methods for providing
reliable estimates of the true value of the selected evaluation
metrics. Both the metrics and the estimation method are defined
through the value provided in argument <code>estTask</code>. The 5
estimation methodologies are the following:
</p>
<p><em>Cross validation</em>: this type of estimates can be obtained by
providing in <code>estTask</code> argument an object of class
<code>EstimationTask</code> with <code>method</code> set to an
object of class <code>CV</code> (this is the default). More
details on this type of method can be 
obtained in the help page of the class <code>CV</code>.
</p>
<p><em>Leave one out cross validation</em>: this type of estimates can be obtained by
providing in <code>estTask</code> argument an object of class
<code>EstimationTask</code> with <code>method</code> set to an
object of class <code>LOOCV</code>. More
details on this type of method can be 
obtained in the help page of the class <code>LOOCV</code>.
</p>
<p><em>Hold out</em>: this type of estimates can be obtained by
providing in <code>estTask</code> argument an object of class
<code>EstimationTask</code> with <code>method</code> set to an
object of class <code>Holdout</code>. More
details on this type of method can be 
obtained in the help page of the class <code>Holdout</code>.
</p>
<p><em>Monte Carlo</em>: this type of estimates can be obtained by
providing in <code>estTask</code> argument an object of class
<code>EstimationTask</code> with <code>method</code> set to an
object of class <code>MonteCarlo</code>. More
details on this type of method can be 
obtained in the help page of the class <code>MonteCarlo</code>.
</p>
<p><em>Bootstrap</em>: this type of estimates can be obtained by
providing in <code>estTask</code> argument an object of class
<code>EstimationTask</code> with <code>method</code> set to an
object of class <code>Bootstrap</code>. More
details on this type of method can be 
obtained in the help page of the class <code>Bootstrap</code>.
</p>


<h3>Value</h3>

<p>The result of the function is an object of class <code>ComparisonResults</code>.
</p>


<h3>Author(s)</h3>

<p> Luis Torgo <a href="mailto:ltorgo@dcc.fc.up.pt">ltorgo@dcc.fc.up.pt</a> </p>


<h3>References</h3>

<p> Torgo, L. (2014) <em>An Infra-Structure for Performance
Estimation and Experimental Comparison of Predictive Models in R</em>. arXiv:1412.0436 [cs.MS]
<a href="http://arxiv.org/abs/1412.0436">http://arxiv.org/abs/1412.0436</a>  
</p>


<h3>See Also</h3>

<p><code>workflowVariants</code>,
<code>topPerformers</code>,
<code>rankWorkflows</code>,
<code>pairedComparisons</code>,
<code>CV</code>,
<code>LOOCV</code>,
<code>Holdout</code>,
<code>MonteCarlo</code>,
<code>Bootstrap</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Estimating MSE for 3 variants of both
## regression trees and SVMs, on  two data sets, using one repetition
## of 10-fold CV
library(e1071)
library(DMwR)
data(swiss)
data(mtcars)

## Estimating MSE using 10-fold CV for 4 variants of a standard workflow
## using an SVM as base learner and 3 variants of a regression tree. 
res &lt;- performanceEstimation(
  c(PredTask(Infant.Mortality ~ .,swiss),PredTask(mpg ~ ., mtcars)),
  c(workflowVariants(learner="svm",
                     learner.pars=list(cost=c(1,10),gamma=c(0.01,0.5))),
    workflowVariants(learner="rpartXse",
                     learner.pars=list(se=c(0,0.5,1)))
  ),
  EstimationTask(metrics="mse")
  )

## Check a summary of the results
summary(res)

## best performers for each metric and task
topPerformers(res)


## Estimating the accuracy of a default SVM on IRIS using 10 repetitions
## of a 80%-20% Holdout
data(iris)
res1 &lt;- performanceEstimation(PredTask(Species  ~ .,iris),
             Workflow(learner="svm"),
             EstimationTask(metrics="acc",method=Holdout(nReps=10,hldSz=0.2)))
summary(res1)

## Now an example with a user-defined workflow
myWF &lt;- function(form,train,test,wL=0.5,...) {
    require(rpart,quietly=TRUE)
    ml &lt;- lm(form,train)
    mr &lt;- rpart(form,train)
    pl &lt;- predict(ml,test)
    pr &lt;- predict(mr,test)
    ps &lt;- wL*pl+(1-wL)*pr
    list(trues=responseValues(form,test),preds=ps)
}
resmywf &lt;- performanceEstimation(
             PredTask(mpg ~ ., mtcars),
             workflowVariants(wf="myWF",wL=seq(0,1,by=0.1)),
             EstimationTask(metrics="mae",method=Bootstrap(nReps=50))
           )
summary(resmywf)


## End(Not run)

</code></pre>


</div>
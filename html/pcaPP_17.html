<div class="container">

<table style="width: 100%;"><tr>
<td>PCAproj</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Robust Principal Components using the algorithm of Croux and Ruiz-Gazen (2005) </h2>

<h3>Description</h3>

<p>Computes a desired number of (robust) principal components using the algorithm of 
Croux and Ruiz-Gazen (JMVA, 2005). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">PCAproj(x, k = 2, method = c("mad", "sd", "qn"), CalcMethod = c("eachobs",
"lincomb", "sphere"), nmax = 1000, update = TRUE, scores = TRUE, maxit = 5, 
maxhalf = 5, scale = NULL, center = l1median_NLM, zero.tol = 1e-16, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> a numeric matrix or data frame which provides the data for the 
principal components analysis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p> desired number of components to compute </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> scale estimator used to detect the direction with the largest 
variance. Possible values are <code>"sd"</code>, <code>"mad"</code> and <code>"qn"</code>, the 
latter can be called <code>"Qn"</code> too. <code>"mad"</code> is the default value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CalcMethod</code></td>
<td>
<p> the variant of the algorithm to be used. Possible values are
<code>"eachobs"</code>, <code>"lincomb"</code> and <code>"sphere"</code>, with <code>"eachobs"</code> being 
the default. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmax</code></td>
<td>
<p> maximum number of directions to search in each step (only when
using <code>"sphere"</code> or <code>"lincomb"</code> as the <code>CalcMethod</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update</code></td>
<td>
<p> a logical value indicating whether an update algorithm should be 
used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p> a logical value indicating whether the scores of the
principal component should be calculated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p> maximim number of iterations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxhalf</code></td>
<td>
<p> maximum number of steps for angle halving. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p> this argument indicates how the data is to be rescaled. It
can be a function like <code>sd</code> or <code>mad</code> or a vector
of length <code>ncol(x)</code> containing the scale value of each column. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p> this argument indicates how the data is to be centered. It
can be a function like <code>mean</code> or <code>median</code> or a vector
of length <code>ncol(x)</code> containing the center value of each column. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.tol</code></td>
<td>
<p> the zero tolerance used internally for checking 
convergence, etc. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p> a list which elements must be the same as (or a subset of) 
the parameters above. If the control object is supplied, the parameters from 
it will be used and any other given parameters are overridden. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Basically, this algrithm considers the directions of each observation 
through the origin of the centered data as possible projection directions.
As this algorithm has some drawbacks, especially if <code>ncol(x) &gt; nrow(x)</code>
in the data matrix, there are several improvements that can be used with this
algorithm.
</p>

<ul>
<li>
<p> update - An updating step basing on the algorithm for finding the
eigenvectors is added to the algorithm. This can be used with any 
<code>CalcMethod</code>
</p>
</li>
<li>
<p> sphere - Additional search directions are added using random directions.
The random directions are determined using random data points generated from 
a p-dimensional multivariate standard normal distribution. These new data 
points are projected to the unit sphere, giving the new search directions.
</p>
</li>
<li>
<p> lincomb - Additional search directions are added using linear 
combinations of the observations. It is similar to the 
<code>"sphere"</code> - algorithm, but the new data points are generated using linear 
combinations of the original data <code>b_1*x_1 + ... + b_n*x_n</code> where the 
coefficients <code>b_i</code> come from a uniform distribution in the interval 
<code>[0, 1]</code>.
</p>
</li>
</ul>
<p>Similar to the function <code>princomp</code>, there is a <code>print</code> method 
for the these objects that prints the results in a nice format and the <code>plot</code> 
method produces a scree plot (<code>screeplot</code>). There is also a 
<code>biplot</code> method.
</p>


<h3>Value</h3>

<p>The function returns a list of class <code>"princomp"</code>, i.e. a list similar to the 
output of the function <code>princomp</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>sdev</code></td>
<td>
<p>the (robust) standard deviations of the principal components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>the matrix of variable loadings (i.e., a matrix whose columns
contain the eigenvectors).  This is of class <code>"loadings"</code>:
see <code>loadings</code> for its <code>print</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>the means that were subtracted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>the scalings applied to each variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.obs</code></td>
<td>
<p>the number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>if <code>scores = TRUE</code>, the scores of the supplied data on the
principal components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, M. Oliveira, (2007).
Algorithms for Projection-Pursuit Robust Principal Component Analysis,
<em>Chemometrics and Intelligent Laboratory Systems</em>, Vol. 87, pp. 218-225.
</p>


<h3>See Also</h3>

 <p><code>PCAgrid</code>, <code>ScaleAdv</code>, <code>princomp</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">  # multivariate data with outliers
  library(mvtnorm)
  x &lt;- rbind(rmvnorm(200, rep(0, 6), diag(c(5, rep(1,5)))),
             rmvnorm( 15, c(0, rep(20, 5)), diag(rep(1, 6))))
  # Here we calculate the principal components with PCAgrid
  pc &lt;- PCAproj(x, 6)
  # we could draw a biplot too:
  biplot(pc)

  # we could use another calculation method and another objective function, and 
  # maybe only calculate the first three principal components:
  pc &lt;- PCAproj(x, 3, "qn", "sphere")
  biplot(pc)

  # now we want to compare the results with the non-robust principal components
  pc &lt;- princomp(x)
  # again, a biplot for comparision:
  biplot(pc)
</code></pre>


</div>
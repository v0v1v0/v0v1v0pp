<div class="container">

<table style="width: 100%;"><tr>
<td>pad</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pad the datetime column of a data frame</h2>

<h3>Description</h3>

<p><code>pad</code> will fill the gaps in incomplete datetime variables, by figuring out
what the interval of the data is and what instances are missing. It will insert
a record for each of the missing time points. For all
other variables in the data frame a missing value will be inserted at the padded rows.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pad(
  x,
  interval = NULL,
  start_val = NULL,
  end_val = NULL,
  by = NULL,
  group = NULL,
  break_above = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A data frame containing at least one variable of class <code>Date</code>,
<code>POSIXct</code> or <code>POSIXlt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>The interval of the returned datetime variable.
Any character string that would be accepted by <code>seq.Date()</code> or
<code>seq.POSIXt</code>. The only exceptions is "DSTday", which is not accepted.
<code>pad</code> will take care of daylight savings time when regular "day" is used.
When NULL the the interval will be equal to the interval of the datetime variable.
When specified it can only be lower than the interval and step size of the input data.
See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_val</code></td>
<td>
<p>An object of class <code>Date</code>, <code>POSIXct</code> or
<code>POSIXlt</code> that specifies the start of the returned datetime variable.
If NULL it will use the lowest value of the input variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end_val</code></td>
<td>
<p>An object of class <code>Date</code>, <code>POSIXct</code> or
<code>POSIXlt</code> that specifies the end of returned datetime variable.
If NULL it will use the highest value of the input variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>Only needs to be specified when <code>x</code> contains multiple
variables of class <code>Date</code>, <code>POSIXct</code> or <code>POSIXlt</code>.
Indicates which variable to use for padding.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>Optional character vector that specifies the grouping
variable(s). Padding will take place within the different groups. When
interval is not specified, it will be determined applying <code>get_interval</code>
on the datetime variable as a whole, ignoring groups (see last example).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>break_above</code></td>
<td>
<p>Numeric value that indicates the number of rows in millions
above which the function will break. Safety net for situations where the
interval is different than expected and padding yields a very large
dataframe, possibly overflowing memory.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The interval of a datetime variable is the time unit at which the
observations occur. The eight intervals in <code>padr</code> are from high to low
<code>year</code>, <code>quarter</code>, <code>month</code>, <code>week</code>, <code>day</code>,
<code>hour</code>, <code>min</code>, and <code>sec</code>. Since <code>padr</code> v.0.3.0 the
interval is no longer limited to be of a single unit.
(Intervals like 5 minutes, 6 hours, 10 days are possible). <code>pad</code> will
figure out the interval of the input variable and the step size, and will
fill the gaps for the instances that would be expected from the interval and
step size, but are missing in the input data.
Note that when <code>start_val</code> and/or <code>end_val</code> are specified, they are
concatenated with the datetime variable before the interval is determined.
</p>
<p>Rows with missing values in the datetime variables will be retained.
However, they will be moved to the end of the returned data frame.
</p>


<h3>Value</h3>

<p>The data frame <code>x</code> with the datetime variable padded. All
non-grouping variables in the data frame will have missing values at the rows
that are padded. The result will always be sorted on the datetime variable.
If <code>group</code> is not <code>NULL</code> result is sorted on grouping variable(s)
first, then on the datetime variable.
</p>


<h3>Examples</h3>

<pre><code class="language-R">simple_df &lt;- data.frame(day = as.Date(c('2016-04-01', '2016-04-03')),
                        some_value = c(3,4))
pad(simple_df)
pad(simple_df, interval = "day")

library(dplyr) # for the pipe operator
month &lt;- seq(as.Date('2016-04-01'), as.Date('2017-04-01'),
              by = 'month')[c(1, 4, 5, 7, 9, 10, 13)]
month_df &lt;- data.frame(month = month,
                       y = runif(length(month), 10, 20) %&gt;% round)
# forward fill the padded values with tidyr's fill
month_df %&gt;% pad %&gt;% tidyr::fill(y)

# or fill all y with 0
month_df %&gt;% pad %&gt;% fill_by_value(y)

# padding a data.frame on group level
day_var &lt;- seq(as.Date('2016-01-01'), length.out = 12, by = 'month')
x_df_grp &lt;- data.frame(grp1 = rep(LETTERS[1:3], each =4),
                       grp2 = letters[1:2],
                       y    = runif(12, 10, 20) %&gt;% round(0),
                       date = sample(day_var, 12, TRUE)) %&gt;%
 arrange(grp1, grp2, date)

# pad by one grouping var
x_df_grp %&gt;% pad(group = 'grp1')

# pad by two groups vars
x_df_grp %&gt;% pad(group = c('grp1', 'grp2'), interval = "month")

# Using group argument the interval is determined over all the observations,
# ignoring the groups.
x &lt;- data.frame(dt_var = as.Date(c("2017-01-01", "2017-03-01", "2017-05-01",
"2017-01-01", "2017-02-01", "2017-04-01")),
id = rep(1:2, each = 3), val = round(rnorm(6)))
pad(x, group = "id")
# applying pad with do, interval is determined individualle for each group
x %&gt;% group_by(id) %&gt;% do(pad(.))
</code></pre>


</div>
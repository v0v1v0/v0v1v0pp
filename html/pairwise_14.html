<div class="container">

<table style="width: 100%;"><tr>
<td>grm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Graphical Model Check</h2>

<h3>Description</h3>

<p>This function makes the basic calculations for the graphical model check for dicho- or polytomous item response formats. It is more or less a wraper function, internaly calling the function <code>pairSE</code>. Several splitting options are available (see arguments).
</p>


<h3>Usage</h3>

<pre><code class="language-R">grm(
  daten,
  m = NULL,
  w = NULL,
  split = "random",
  splitseed = "no",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>daten</code></td>
<td>
<p>a data.frame or matrix with optionaly named colums (names of items), potentially with missing values, comprising polytomous or dichotomous (or mixed category numbers) responses of <code>n</code> respondents (rows) on <code>k</code> items (colums) coded starting with 0 for lowest category to <em>m</em>-1 for highest category, with <em>m</em> beeing a vector (with length k) with the number of categories for the respective item.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>an integer (will be recycled to a vector of length k) or a vector giving the number of response categories for all items - by default <code>m = NULL</code>, <code>m</code> is calculated from data, assuming that every response category is at least once present in data. For sparse data it is strongly recomended to explicitly define the number of categories by defining this argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>an optional vector of case weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p>Specifies the splitting criterion. Basically there are three different options available - each with several modes - which are controlled by passing the corresponding character expression to the argument. 
</p>
<p>1) Using the rawscore for splitting into subsamples with the following modes: <code>split = "median"</code> median raw score split - high score group and low score group; <code>split = "mean"</code> mean raw score split - high score group and low score group.
</p>
<p>2) Dividing the persons in <code>daten</code> into subsamples with equal size by random allocation with the following modes: <code>split = "random"</code> (which is equivalent to <code>split = "random.2"</code>) divides persons into two subsamples with equal size. In general the number of desired subsamples must be expressed after the dot in the character expression - e.g. <code>split = "random.6"</code> divides persons into 6 subsamples (with equal size) by random allocation etc. 
</p>
<p>3) The third option is using a manifest variable as a splitting criterion. In this case a vector with the same length as number of cases in <code>daten</code> must be passed to the argument grouping the data into subsamples. This vector should be coded as <code>"factor"</code> or a <code>"numeric"</code> integer vector with min = 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splitseed</code></td>
<td>
<p>numeric, used for <code>set.seed(splitseed)</code> for random splitting - see argument <code>split</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical, if <code>verbose = TRUE</code> (default) a message about subsampling is sent to console when calculating standard errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments <code>nsample</code>, <code>size</code>, <code>seed</code>, <code>pot</code> for caling <code>pairSE</code> are passed through - see description for <code>pairSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The data is splitted in two or more subsamples and then item thresholds, the parameter (Sigma) and their standard errors (SE) for the items according the PCM  are calculated for each subsample. Additional arguments (see description of function <code>pairSE</code>) for parameter calculation are passed through. 
</p>
<p>WARNING: When using data based on booklet designs with systematically missing values (by design) you have to ensure that in each of the booklet the maximum raw value to reach is equal while using the raw value as splitting criterion.
</p>


<h3>Value</h3>

<p>A (list) object of class <code>c("grm","list")</code> containing the item difficulty parameter sigma and their standard errors for two or more subsamples.
</p>


<h3>A note on standard errors</h3>

<p>Estimation of standard errors is done by repeated calculation of item parameters for subsamples of the given data. This procedure is mainly controlled by the arguments <code>nsample</code> and <code>size</code> (see arguments). With regard to calculation time, the argument <code>nsample</code> is the 'time killer'. On the other hand, things (estimation of standard errors) will not necessarily get better when choosing large values for <code>nsample</code>. For example choosing <code>nsample=400</code> will only result in minimal change for standard error estimation in comparison to (<code>nsample=30</code>) which is the default setting (see examples).
</p>


<h3>References</h3>

<p>description of function <code>pairSE</code><code>{pairwise}</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(bfiN) # loading example data set

data(bfi_cov) # loading covariates to bfiN data set

# calculating itemparameters and SE for two random allocated subsamples
grm_gen &lt;- grm(daten=bfiN, split = bfi_cov$gender)
summary(grm_gen)
#### plot(grm_gen)

grm_med &lt;- grm(daten=bfiN, split = "median")
summary(grm_med)
#### plot(grm_med)

grm_ran&lt;-grm(daten=bfiN, split = "random") 

summary(grm_ran)

# some examples for plotting options
# plotting item difficulties for two subsamples against each other 
# with elipses for a CI = 95% .
#### plot(grm_ran) 

# using triangles as plotting pattern
#### plot(grm_ran,pch=2) 

#plotting without CI ellipses
#### plot(grm_ran,ci=0,pch=2) 

# plotting with item names
#### plot(grm_ran,itemNames=TRUE) 

# Changing the size of the item names
#### plot(grm_ran,itemNames=TRUE, cex.names = 1.3)

# Changing the color of the CI ellipses
plot(grm_ran,itemNames=TRUE, cex.names = .8, col.error="green")

###### example from details section 'Some Notes on Standard Errors' ########
## Not run: 
grm_def&lt;-grm(daten=bfiN, split = "random",splitseed=13)
plot(grm_def)
######
grm_400&lt;-grm(daten=bfiN, split = "random", splitseed=13 ,nsample=400)
plot(grm_400)

## End(Not run) 


</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>image_segment</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Image segmentation</h2>

<h3>Description</h3>


<ul>
<li> <p><code>image_segment()</code> reduces a color, color near-infrared, or grayscale images
to a segmented image using a given color channel (red, green blue) or even
color indexes (See <code>image_index()</code> for more details). The Otsu's thresholding
method (Otsu, 1979) is used to automatically perform clustering-based image
thresholding.
</p>
</li>
<li> <p><code>image_segment_iter()</code> Provides an iterative image segmentation, returning
the proportions of segmented pixels.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">image_segment(
  img,
  index = NULL,
  r = 1,
  g = 2,
  b = 3,
  re = 4,
  nir = 5,
  threshold = c("Otsu", "adaptive"),
  k = 0.1,
  windowsize = NULL,
  col_background = NULL,
  has_white_bg = FALSE,
  fill_hull = FALSE,
  filter = FALSE,
  invert = FALSE,
  plot = TRUE,
  nrow = NULL,
  ncol = NULL,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE
)

image_segment_iter(
  img,
  nseg = 2,
  index = NULL,
  invert = NULL,
  threshold = NULL,
  k = 0.1,
  windowsize = NULL,
  has_white_bg = FALSE,
  plot = TRUE,
  verbose = TRUE,
  nrow = NULL,
  ncol = NULL,
  parallel = FALSE,
  workers = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>img</code></td>
<td>
<p>An image object or a list of image objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>

<ul>
<li>
<p> For <code>image_segment()</code>, a character value (or a vector of characters)
specifying the target mode for conversion to binary image. See the available
indexes with <code>pliman_indexes()</code>.  See <code>image_index()</code> for more details.
</p>
</li>
<li>
<p> For <code>image_segment_iter()</code> a character or a vector of characters with the
same length of <code>nseg</code>. It can be either an available index (described above)
or any operation involving the RGB values (e.g., <code>"B/R+G"</code>).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r, g, b, re, nir</code></td>
<td>
<p>The red, green, blue, red-edge, and near-infrared bands
of the image, respectively. Defaults to 1, 2, 3, 4, and 5, respectively. If
a multispectral image is provided (5 bands), check the order of bands,
which are frequently presented in the 'BGR' format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>The theshold method to be used.
</p>

<ul>
<li>
<p> By default (<code>threshold = "Otsu"</code>), a threshold value based
on Otsu's method is used to reduce the grayscale image to a binary image. If
a numeric value is informed, this value will be used as a threshold.
</p>
</li>
<li>
<p> If <code>threshold = "adaptive"</code>, adaptive thresholding (Shafait et al. 2008)
is used, and will depend on the <code>k</code> and <code>windowsize</code> arguments.
</p>
</li>
<li>
<p> If any non-numeric value different than <code>"Otsu"</code> and <code>"adaptive"</code> is used,
an iterative section will allow you to choose the threshold based on a
raster plot showing pixel intensity of the index.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>a numeric in the range 0-1. when <code>k</code> is high, local threshold
values tend to be lower. when <code>k</code> is low, local threshold value tend to be
higher.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>windowsize</code></td>
<td>
<p>windowsize controls the number of local neighborhood in
adaptive thresholding. By default it is set to <code>1/3 * minxy</code>, where
<code>minxy</code> is the minimum dimension of the image (in pixels).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_background</code></td>
<td>
<p>The color of the segmented background. Defaults to
<code>NULL</code> (white background).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>has_white_bg</code></td>
<td>
<p>Logical indicating whether a white background is present.
If <code>TRUE</code>, pixels that have R, G, and B values equals to 1 will be
considered as <code>NA</code>. This may be useful to compute an image index for
objects that have, for example, a white background. In such cases, the
background will not be considered for the threshold computation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill_hull</code></td>
<td>
<p>Fill holes in the objects? Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter</code></td>
<td>
<p>Performs median filtering in the binary image? See more at
<code>image_filter()</code>. Defaults to <code>FALSE</code>. Use a positive integer to define the
size of the median filtering. Larger values are effective at removing
noise, but adversely affect edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invert</code></td>
<td>
<p>Inverts the binary image, if desired. For
<code>image_segmentation_iter()</code> use a vector with the same length of <code>nseg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>Show image after processing?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrow, ncol</code></td>
<td>
<p>The number of rows or columns in the plot grid. Defaults to
<code>NULL</code>, i.e., a square grid is produced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Processes the images asynchronously (in parallel) in separate
R sessions running in the background on the same machine. It may speed up
the processing time when <code>image</code> is a list. The number of sections is set
up to 70% of available cores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the maximum
number of parallel processes that can be active at the same time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nseg</code></td>
<td>
<p>The number of iterative segmentation steps to be performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed on to <code>image_segment()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>


<ul>
<li> <p><code>image_segment()</code> returns list containing <code>n</code> objects where <code>n</code> is the
number of indexes used. Each objects contains:
</p>

<ul>
<li> <p><code>image</code> an image with the RGB bands (layers) for the segmented object.
</p>
</li>
<li> <p><code>mask</code> A mask with logical values of 0 and 1 for the segmented image.
</p>
</li>
</ul>
</li>
<li> <p><code>image_segment_iter()</code> returns a list with (1) a data frame with the
proportion of pixels in the segmented images and (2) the segmented images.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>References</h3>

<p>Nobuyuki Otsu, "A threshold selection method from gray-level
histograms". IEEE Trans. Sys., Man., Cyber. 9 (1): 62-66. 1979.
<a href="https://doi.org/10.1109/TSMC.1979.4310076">doi:10.1109/TSMC.1979.4310076</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(pliman)
img &lt;- image_pliman("soybean_touch.jpg", plot = TRUE)
image_segment(img, index = c("R, G, B"))

# adaptive thresholding

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>PoissonBinomial-Distribution</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Poisson Binomial Distribution</h2>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for
the Poisson binomial distribution with probability vector <code>probs</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dpbinom(x, probs, wts = NULL, method = "DivideFFT", log = FALSE)

ppbinom(
  x,
  probs,
  wts = NULL,
  method = "DivideFFT",
  lower.tail = TRUE,
  log.p = FALSE
)

qpbinom(
  p,
  probs,
  wts = NULL,
  method = "DivideFFT",
  lower.tail = TRUE,
  log.p = FALSE
)

rpbinom(n, probs, wts = NULL, method = "DivideFFT", generator = "Sample")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Either a vector of observed numbers of successes or NULL.
If NULL, probabilities of all possible observations are
returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>Vector of probabilities of success of each Bernoulli
trial.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wts</code></td>
<td>
<p>Vector of non-negative integer weights for the input
probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Character string that specifies the method of computation
and must be one of <code>"DivideFFT"</code>, <code>"Convolve"</code>,
<code>"Characteristic"</code>, <code>"Recursive"</code>,
<code>"Mean"</code>, <code>"GeoMean"</code>, <code>"GeoMeanCounter"</code>,
<code>"Poisson"</code>, <code>"Normal"</code> or
<code>"RefinedNormal"</code> (abbreviations are allowed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log, log.p</code></td>
<td>
<p>Logical value indicating if results are given as
logarithms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>Logical value indicating if results are <code class="reqn">P[X \leq x]</code>
(if <code>TRUE</code>; default) or <code class="reqn">P[X &gt; x]</code> (if 
<code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Vector of probabilities for computation of quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of observations. If <code>length(n) &gt; 1</code>, the
length is taken to be the number required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>generator</code></td>
<td>
<p>Character string that specifies the random number
generator and must either be <code>"Sample"</code> (default) or
<code>"Bernoulli"</code> (abbreviations are allowed). See
Details for more information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See the references for computational details. The <em>Divide and Conquer</em>
(<code>"DivideFFT"</code>) and <em>Direct Convolution</em> (<code>"Convolve"</code>)
algorithms are derived and described in Biscarri, Zhao &amp; Brunner (2018). The
<em>Discrete Fourier Transformation of the Characteristic Function</em>
(<code>"Characteristic"</code>), the <em>Recursive Formula</em> (<code>"Recursive"</code>),
the <em>Poisson Approximation</em> (<code>"Poisson"</code>), the
<em>Normal Approach</em> (<code>"Normal"</code>) and the
<em>Refined Normal Approach</em> (<code>"RefinedNormal"</code>) are described in Hong
(2013). The calculation of the <em>Recursive Formula</em> was modified to
overcome the excessive memory requirements of Hong's implementation.
</p>
<p>The <code>"Mean"</code> method is a naive binomial approach using the arithmetic
mean of the probabilities of success. Similarly, the <code>"GeoMean"</code> and
<code>"GeoMeanCounter"</code> procedures are binomial approximations, too, but
they form the geometric mean of the probabilities of success
(<code>"GeoMean"</code>) and their counter probabilities (<code>"GeoMeanCounter"</code>),
respectively.
</p>
<p>In some special cases regarding the values of <code>probs</code>, the <code>method</code>
parameter is ignored (see Introduction vignette).
</p>
<p>Random numbers can be generated in two ways. The <code>"Sample"</code> method
uses <code>R</code>'s <code>sample</code> function to draw random values according to
their probabilities that are calculated by <code>dgpbinom</code>. The
<code>"Bernoulli"</code> procedure ignores the <code>method</code> parameter and
simulates Bernoulli-distributed random numbers according to the probabilities
in <code>probs</code> and sums them up. It is a bit slower than the <code>"Sample"</code>
generator, but may yield better results, as it allows to obtain observations
that cannot be generated by the <code>"Sample"</code> procedure, because
<code>dgpbinom</code> may compute 0-probabilities, due to rounding, if the length
of <code>probs</code> is large and/or its values contain a lot of very small
values.
</p>


<h3>Value</h3>

<p><code>dpbinom</code> gives the density, <code>ppbinom</code> computes the distribution
function, <code>qpbinom</code> gives the quantile function and <code>rpbinom</code>
generates random deviates.
</p>
<p>For <code>rpbinom</code>, the length of the result is determined by <code>n</code>, and
is the lengths of the numerical arguments for the other functions.
</p>


<h3>References</h3>

<p>Hong, Y. (2013). On computing the distribution function for the Poisson
binomial distribution. <em>Computational Statistics &amp; Data Analysis</em>,
<strong>59</strong>, pp. 41-51. <a href="https://doi.org/10.1016/j.csda.2012.10.006">doi:10.1016/j.csda.2012.10.006</a>
</p>
<p>Biscarri, W., Zhao, S. D. and Brunner, R. J. (2018) A simple and fast method
for computing the Poisson binomial distribution.
<em>Computational Statistics and Data Analysis</em>, <strong>31</strong>, pp.
216â€“222. <a href="https://doi.org/10.1016/j.csda.2018.01.007">doi:10.1016/j.csda.2018.01.007</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
pp &lt;- c(0, 0, runif(995), 1, 1, 1)
qq &lt;- seq(0, 1, 0.01)

dpbinom(NULL, pp, method = "DivideFFT")
ppbinom(450:550, pp, method = "DivideFFT")
qpbinom(qq, pp, method = "DivideFFT")
rpbinom(100, pp, method = "DivideFFT")

dpbinom(NULL, pp, method = "Convolve")
ppbinom(450:550, pp, method = "Convolve")
qpbinom(qq, pp, method = "Convolve")
rpbinom(100, pp, method = "Convolve")

dpbinom(NULL, pp, method = "Characteristic")
ppbinom(450:550, pp, method = "Characteristic")
qpbinom(qq, pp, method = "Characteristic")
rpbinom(100, pp, method = "Characteristic")

dpbinom(NULL, pp, method = "Recursive")
ppbinom(450:550, pp, method = "Recursive")
qpbinom(qq, pp, method = "Recursive")
rpbinom(100, pp, method = "Recursive")

dpbinom(NULL, pp, method = "Mean")
ppbinom(450:550, pp, method = "Mean")
qpbinom(qq, pp, method = "Mean")
rpbinom(100, pp, method = "Mean")

dpbinom(NULL, pp, method = "GeoMean")
ppbinom(450:550, pp, method = "GeoMean")
qpbinom(qq, pp, method = "GeoMean")
rpbinom(100, pp, method = "GeoMean")

dpbinom(NULL, pp, method = "GeoMeanCounter")
ppbinom(450:550, pp, method = "GeoMeanCounter")
qpbinom(qq, pp, method = "GeoMeanCounter")
rpbinom(100, pp, method = "GeoMeanCounter")

dpbinom(NULL, pp, method = "Poisson")
ppbinom(450:550, pp, method = "Poisson")
qpbinom(qq, pp, method = "Poisson")
rpbinom(100, pp, method = "Poisson")

dpbinom(NULL, pp, method = "Normal")
ppbinom(450:550, pp, method = "Normal")
qpbinom(qq, pp, method = "Normal")
rpbinom(100, pp, method = "Normal")

dpbinom(NULL, pp, method = "RefinedNormal")
ppbinom(450:550, pp, method = "RefinedNormal")
qpbinom(qq, pp, method = "RefinedNormal")
rpbinom(100, pp, method = "RefinedNormal")

</code></pre>


</div>
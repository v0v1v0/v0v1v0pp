<div class="container">

<table style="width: 100%;"><tr>
<td>find.cor.mat.star</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Finds intermediate correlation matrix
</h2>

<h3>Description</h3>

<p>This function calculates an intermediate correlation matrix for a chosen number of Poisson, binary,
ordinal, and continuous (via Fleishman polynomials) random variables, with specified target
correlations and marginal properties. The correlation matrix follows the order of Poisson, binary, ordinal, continuous.
</p>


<h3>Usage</h3>

<pre><code class="language-R">find.cor.mat.star(cor.mat, no.pois = 0, no.bin = 0, no.ord = 0, 
    no.nonn = 0, pois.list = list(), bin.list = list(), ord.list = list(), 
    is.ord.list.cum = FALSE, nonn.list = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cor.mat</code></td>
<td>

<p>The desired target correlation matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no.pois</code></td>
<td>

<p>The number of Poisson random variables desired. Defaults to 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no.bin</code></td>
<td>

<p>The number of binary random variables desired. Defaults to 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no.ord</code></td>
<td>

<p>The number of ordinal random variables desired. Defaults to 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no.nonn</code></td>
<td>

<p>The number of continuous random variables desired, created using Fleishman polynomials. Defaults to 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pois.list</code></td>
<td>

<p>A list of the lambda values, which must be greater than 0. Length will be equal to no.pois, or an error will be thrown. Defaults to an empty list.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bin.list</code></td>
<td>

<p>A list of vectors containing the probabilities for each variable. Each vector should have 2 entries between 0 and 1 inclusive, and sum to 1. Length must be equal to no.bin. Defaults to an empty list.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ord.list</code></td>
<td>

<p>A list of vectors containing the probabilities for each variable. If is.ord.list.cum is TRUE, each vector should have entries between 0 and 1, in increasing order. Otherwise, each vector should have entries between 0 and 1 inclusive that sum to 1. Length must be equal to no.ord. Defaults to an empty list.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.ord.list.cum</code></td>
<td>

<p>Flag for whether the ordinal list supplied contains cumulative probabilities. Defaults to FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonn.list</code></td>
<td>

<p>A list of vectors containing the first four moments of each variable, in order. If only two parameters are supplied, they will be assumed to be skew and excess kurtosis, with mean = 0 and variance = 1. If only three parameters are supplied, they will be assumed to be variance, skew and excess kurtosis, with mean = 0. If less than two parameters or more than four parameters are supplied for any variable, an error will be raised. Variance must be positive, and excess kurtosis must be greater than or equal to skew^2-2. Length must be equal to no.nonn. Defaults to an empty list.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>First, the target correlation matrix and input parameters are checked using <code>validate.cor.mat</code>.
</p>
<p>Second, the input lists are transformed and combined.
</p>
<p>Third, each entry is tranformed in order.
</p>

<ul>
<li>
<p> Poisson-Poisson entries follow Amatya and Demirtas (2016).
</p>
</li>
<li>
<p> Ordinal/Binary-Ordinal/Binary entries are transformed using a call to <em>ordcont</em> in <span class="pkg">GenOrd</span> package.
</p>
</li>
<li>
<p> Continuous-Continuous entries use the correlation matrix for the underlying Fleishman polynomials.
</p>
</li>
<li>
<p> All mixed entries use the approximation from Demirtas and Hedeker 2016: corr(X, Z) = cor(X, Y) * 
cor(Y, Z) where Y is a standard normal variable. In other words, the association between X and Z is assumed to be fully explained by the association between X and Y and the association between Y and Z.
</p>
</li>
</ul>
<p>Fourth, the resulting matrix is checked for validity. If it is not a valid correlation matrix, a warning message is printed and the nearest valid matrix is returned instead. (<em>nearPD</em> from <span class="pkg">Matrix)</span>
</p>


<h3>Value</h3>

<p>A (no.pois+no.bin+no.ord+no.nonn) by (no.pois+no.bin+no.ord+no.nonn) square matrix, containing the intermediate correlation values.
</p>


<h3>References</h3>

<p>Amatya, A. &amp; Demirtas, H. (2015) Simultaneous generation of multivariate mixed
data with Poisson and normal marginals. <em>Journal of Statistical Computation and Simulation</em> <b>85:15</b>, 3129–3139.
</p>
<p>Demirtas, H. (2014). Joint generation of binary and nonnormal continuous data.
<em>Journal of Biometrics and Biostatistics</em> <b>5:3:1000199</b>, 1–9.
</p>
<p>Demirtas, H. &amp; Hedeker, D. (2011) A practical way for computing approximate
lower and upper correlation bounds. <em>American Statistician</em> <b>65:2</b>, 104–109.
</p>
<p>Demirtas, H. &amp; Hedeker, D. (2016). Computing the point-biserial correlation under
any underlying continuous distribution. <em>Communications in Statistics –
Simulation and Computation</em>, <b>45:8</b>, 2744–2751. 
</p>
<p>Demirtas, H., Hedeker, D. &amp; Mermelstein, R. J. (2012) Simulation of massive public
health data by power polynomials. <em>Statistics in Medicine</em> <b>31:27</b>, 3337–3346.
</p>


<h3>Examples</h3>

<pre><code class="language-R">validate.cor.mat(cor.mat = .3 * diag(3) + .7, no.pois = 3, 
    pois.list = list(.25, .5, 1))
find.cor.mat.star(cor.mat = .3 * diag(3) + .7, no.pois = 3, 
    pois.list = list(.25, .5, 1))

validate.cor.mat(cor.mat = .8 * diag(3) + .2, no.ord = 3, 
    ord.list = list(c(.2, .8), c(.1, .2, .3, .4), c(.8, 0, .1, .1)))
find.cor.mat.star(cor.mat = .8 * diag(3) + .2, no.ord = 3, 
    ord.list = list(c(.2, .8), c(.1, .2, .3, .4), c(.8, 0, .1, .1)))

validate.cor.mat(cor.mat = .5 * diag(3) + .5, no.pois = 1, no.nonn = 1,
    no.ord = 1, pois.list = list(.5), ord.list = list(c(.8, 0, .1, .1)),
    nonn.list = list(c(0, 1, 0, 1)))
find.cor.mat.star(cor.mat = .5 * diag(3) + .5, no.pois = 1, no.nonn = 1,
    no.ord = 1, pois.list = list(.5), ord.list = list(c(.8, 0, .1, .1)),
    nonn.list = list(c(0, 1, 0, 1)))
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>getProfileExtrema</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Profile extrema with BFGS optimization</h2>

<h3>Description</h3>

<p>Evaluate profile extrema for a set of matrices allPsi with full optimization.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getProfileExtrema(f, fprime = NULL, d, allPsi, opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>the function to be evaluated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fprime</code></td>
<td>
<p>derivative of the function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>dimension of the input domain</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allPsi</code></td>
<td>
<p>a list containing the matrices Psi (dim <code class="reqn">pxd</code>) for which to compute the profile extrema</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opts</code></td>
<td>
<p>a list containing the options for this function and the subfunctions getProfileSup_optim, getProfileInf_optim. The options only for getProfileExtrema are
</p>

<ul>
<li>
<p><code>limits:</code>an optional list containing <code>lower</code> and <code>upper</code>, two vectors with the limits of the input space. If NULL then <code>limits=list(upper=rep(1,d),lower=rep(0,d))</code>
</p>
</li>
<li>
<p><code>discretization:</code>an optional integer representing the discretization size for the profile computation for each dimension of eta. Pay attention that this leads to a grid of size <code>discretization^p</code>.
</p>
</li>
<li>
<p><code>heavyReturn:</code>If TRUE returns also all minimizers, default is FALSE.
</p>
</li>
<li>
<p><code>plts:</code>If TRUE and p==1 for all Psi in allPsi, plots the profile functions at each Psi, default is FALSE.
</p>
</li>
<li>
<p><code>verb:</code>If TRUE, outputs intermediate results, default is FALSE.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list of two data frames (min, max) of the evaluations of <code class="reqn">P^sup_Psi f(eta) = sup_{Psi x = \eta} f(x) </code> and <code class="reqn">P^inf_Psi f(eta) = inf_{Psi x = \eta} f(x) </code>
discretized over 50 equally spaced points for each dimension for each Psi in <code>allPsi</code>. This number can be changed by defining it in options$discretization.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Compute the oblique profile extrema with full optimization on 2d example

# Define the function
testF &lt;- function(x,params,v1=c(1,0),v2=c(0,1)){
return(sin(crossprod(v1,x)*params[1]+params[2])+cos(crossprod(v2,x)*params[3]+params[4])-1.5)
}

testFprime &lt;- function(x,params,v1=c(1,0),v2=c(0,1)){
  return(matrix(c(params[1]*v1[1]*cos(crossprod(v1,x)*params[1]+params[2])-
                  params[3]*v2[1]*sin(crossprod(v2,x)*params[3]+params[4]),
                 params[1]*v1[2]*cos(crossprod(v1,x)*params[1]+params[2])-
                  params[3]*v2[2]*sin(crossprod(v2,x)*params[3]+params[4])),ncol=1))
}


# Define the main directions of the function
theta=pi/6
pparams&lt;-c(1,0,10,0)
vv1&lt;-c(cos(theta),sin(theta))
vv2&lt;-c(cos(theta+pi/2),sin(theta+pi/2))

# Define optimizer friendly function
f &lt;-function(x){
return(testF(x,pparams,vv1,vv2))
}
fprime &lt;- function(x){
 return(testFprime(x,pparams,vv1,vv2))
}

# Define list of directions where to evaluate the profile extrema
all_Psi &lt;- list(Psi1=vv1,Psi2=vv2)



# Evaluate profile extrema along directions of all_Psi
allOblique&lt;-getProfileExtrema(f=f,fprime = fprime,d = 2,allPsi = all_Psi,
                              opts = list(plts=FALSE,discretization=100,multistart=8))


# Consider threshold=0
threshold &lt;- 0

# Plot oblique profile extrema functions
plotMaxMin(allOblique,allOblique$Design,threshold = threshold)

## Since the example is two dimensional we can visualize the regions excluded by the profile extrema
# evaluate the function at a grid for plots
inDes&lt;-seq(0,1,,100)
inputs&lt;-expand.grid(inDes,inDes)
outs&lt;-apply(X = inputs,MARGIN = 1,function(x){return(testF(x,pparams,v1=vv1,v2=vv2))})

# obtain the points where the profiles take the threshold value
cccObl&lt;-getChangePoints(threshold = threshold,allRes = allOblique,Design = allOblique$Design)

# visualize the functions and the regions excluded

image(inDes,inDes,matrix(outs,ncol=100),col=grey.colors(20),main="Example and oblique profiles")
contour(inDes,inDes,matrix(outs,ncol=100),add=TRUE,nlevels = 20)
contour(inDes,inDes,matrix(outs,ncol=100),add=TRUE,levels = c(threshold),col=4,lwd=1.5)
plotOblique(cccObl$alwaysEx$`0`[[1]],all_Psi[[1]],col=3)
plotOblique(cccObl$alwaysEx$`0`[[2]],all_Psi[[2]],col=3)
plotOblique(cccObl$neverEx$`0`[[1]],all_Psi[[1]],col=2)
plotOblique(cccObl$neverEx$`0`[[2]],all_Psi[[2]],col=2)


</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>ItemSelection-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
The <code>ItemSelection</code> class implements
<code>Selection</code> for the very common case of selecting
items in a dataset, optionally with weights.
</h2>

<h3>Description</h3>

<p>The <code>ItemSelection</code> class implements
<code>Selection</code> for the very common case of selecting
items in a dataset, optionally with weights.
</p>


<h3>Constructor</h3>

<ul><li>
<p><code>ItemSelection(delegate = NULL)</code>: Constructs an
<code>ItemSelection</code> object with the underlying selection provided
by <code>delegate</code>, which may be a function or any other R
object. If it is not a function, <code>delegate</code> must support the
coercions described in the next section. A good example would be a
logical vector. However, <code>delegate</code> is usually a function
that is invoked whenever the selection is stored or retrieved. If
the function is called with no arguments, it should return the
selection. Otherwise, the argument is the new selection status,
and the function should store it. This is the same semantic as
active bindings. This dynamic
functionality allows proxying of other <code>Selection</code> objects or
external sources, such as a selection model from a GUI toolkit.

</p>
</li></ul>
<h3>Interpreting the Selection</h3>

<p>Any R object can represent the underlying selection, so for simplicity
we recommend that the client interpret the selection through
coercion. Each of these simply delegate to the underlying
selection object, which will need to support all of them for
consistency. The following coercions are supported, where <code>x</code> is
a <code>ItemSelection</code> instance:
</p>

<ul>
<li>
<p><code>which(x)</code>: integer indices of the selected items.
</p>
</li>
<li>
<p><code>as.logical(x)</code>: <code>TRUE</code> where selected.
</p>
</li>
<li>
<p><code>as.integer(x)</code>: usually 0L (unselected) or 1L
(selected), but in general it is a weighting of the selection.
</p>
</li>
<li>
<p><code>as.numeric(x)</code>: similar to <code>as.integer</code>, except
with real values.
</p>
</li>
<li>
<p><code>as.factor(x)</code>: ordinarily this will have two
levels, <code>FALSE</code> and <code>TRUE</code>, although it could have more,
which confers support for multinary selections.
</p>
</li>
</ul>
<h3>Supported Selection Calculus</h3>

<p>All operations mentioned in <code>Selection</code> are
supported: <code>add</code>, <code>subtract</code>, <code>toggle</code>, <code>intersect</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Lawrence</p>


<h3>See Also</h3>

<p><code>Selection</code> for the rest of the details.</p>


<h3>Examples</h3>

<pre><code class="language-R">  ## Assume we have a dataset:
  data(Cars93, package="MASS")
  mf &lt;- mutaframe(Cars93)
  mf$.color &lt;- "gray"
  ## First step is to create a base selection
  sel &lt;- ItemSelection()
  ## Now, link that selection to other cases in same dataset by some variable
  linked_sel &lt;- sel$link(match_any_linker(Cars93["Manufacturer"]))
  ## Finally, scale that linked selection to the data
  linked_sel$scale(function(x, d) {
    d[as.logical(x), ".color"] &lt;- "red"
  }, mf)
  ## To test, select some cases
  cases &lt;- rep(FALSE, nrow(mf))
  cases[seq(1, 10, 2)] &lt;- TRUE
  sel$replace(cases)
</code></pre>


</div>
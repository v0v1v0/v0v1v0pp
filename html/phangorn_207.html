<div class="container">

<table style="width: 100%;"><tr>
<td>simSeq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate sequences.</h2>

<h3>Description</h3>

<p>Simulate sequences from a given evolutionary tree.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simSeq(x, ...)

## S3 method for class 'phylo'
simSeq(x, l = 1000, Q = NULL, bf = NULL,
  rootseq = NULL, type = "DNA", model = NULL, levels = NULL,
  rate = 1, ancestral = FALSE, code = 1, ...)

## S3 method for class 'pml'
simSeq(x, ancestral = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a phylogenetic tree <code>tree</code>, i.e. an object of class
<code>phylo</code> or and object of class <code>pml</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l</code></td>
<td>
<p>The length of the sequence to simulate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>The rate matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bf</code></td>
<td>
<p>Base frequencies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rootseq</code></td>
<td>
<p>A vector of length <code>l</code> containing the root sequence.
If not provided, the root sequence is randomly generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of sequences ("DNA", "AA", "CODON" or "USER").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Amino acid model of evolution to employ, for example "WAG",
"JTT", "Dayhoff" or "LG". For a full list of supported models, type
<code>phangorn:::.aamodels</code>. Ignored if type is not equal to "AA".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>A character vector of the different character tokens.
Ignored unless type = "USER".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rate</code></td>
<td>
<p>A numerical value greater than zero giving the mutation rate
or scaler for edge lengths.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ancestral</code></td>
<td>
<p>Logical specifying whether to return ancestral sequences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>code</code></td>
<td>
<p>The ncbi genetic code number for translation (see details). By
default the standard genetic code is used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>simSeq</code> is a generic function to simulate sequence alignments
along a phylogeny. It is quite flexible and can generate DNA, RNA,
amino acids, codon, morphological or binary sequences.
simSeq can take as input a phylogenetic tree of class <code>phylo</code>,
or a <code>pml</code> object; it will return an object of class <code>phyDat</code>.
There is also a more low level
version, which lacks rate variation, but one can combine different
alignments with their own rates (see example). The rate parameter acts like
a scaler for the edge lengths.
</p>
<p>For codon models <code>type="CODON"</code>, two additional arguments <code>dnds</code>
for the dN/dS ratio and <code>tstv</code> for the transition transversion ratio
can be supplied.
</p>
<p><strong>Defaults:</strong>
</p>
<p>If <code>x</code> is a tree of class <code>phylo</code>, then sequences will be generated
with the default Jukes-Cantor DNA model (<code>"JC"</code>).
</p>
<p>If <code>bf</code> is not specified, then all states will be treated as equally
probable.
</p>
<p>If <code>Q</code> is not specified, then a uniform rate matrix will be employed.
</p>


<h3>Value</h3>

<p><code>simSeq</code> returns an object of class phyDat.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>phyDat</code>, <code>pml</code>, <code>SOWH.test</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
data(Laurasiatherian)
tree &lt;- nj(dist.ml(Laurasiatherian))
fit &lt;- pml(tree, Laurasiatherian, k=4)
fit &lt;- optim.pml(fit, optNni=TRUE, model="GTR", optGamma=TRUE)
data &lt;- simSeq(fit)

## End(Not run)


tree &lt;- rtree(5)
plot(tree)
nodelabels()

# Example for simple DNA alignment
data &lt;- simSeq(tree, l = 10, type="DNA", bf=c(.1,.2,.3,.4), Q=1:6,
               ancestral=TRUE)
as.character(data)


# Example to simulate discrete Gamma rate variation
rates &lt;- discrete.gamma(1,4)
data1 &lt;- simSeq(tree, l = 100, type="AA", model="WAG", rate=rates[1])
data2 &lt;- simSeq(tree, l = 100, type="AA", model="WAG", rate=rates[2])
data3 &lt;- simSeq(tree, l = 100, type="AA", model="WAG", rate=rates[3])
data4 &lt;- simSeq(tree, l = 100, type="AA", model="WAG", rate=rates[4])
data &lt;- c(data1,data2, data3, data4)

write.phyDat(data, file="temp.dat", format="sequential", nbcol = -1,
  colsep = "")
unlink("temp.dat")

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>context</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Analyze context of a node word.</h2>

<h3>Description</h3>

<p>Retrieve the word context of a token, optionally checking for boundaries of a
XML region.
</p>


<h3>Usage</h3>

<pre><code class="language-R">context(.Object, ...)

## S4 method for signature 'slice'
context(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  p_attribute = getOption("polmineR.p_attribute"),
  region = NULL,
  boundary = NULL,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  count = TRUE,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = TRUE,
  ...
)

## S4 method for signature 'partition'
context(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  p_attribute = getOption("polmineR.p_attribute"),
  region = NULL,
  boundary = NULL,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  count = TRUE,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = TRUE,
  ...
)

## S4 method for signature 'subcorpus'
context(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  p_attribute = getOption("polmineR.p_attribute"),
  region = NULL,
  boundary = NULL,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  count = TRUE,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = TRUE,
  ...
)

## S4 method for signature 'matrix'
context(
  .Object,
  corpus,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  left,
  right,
  p_attribute,
  region = NULL,
  boundary = NULL
)

## S4 method for signature 'corpus'
context(
  .Object,
  query,
  cqp = is.cqp,
  p_attribute = getOption("polmineR.p_attribute"),
  region = NULL,
  boundary = NULL,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  count = TRUE,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = TRUE,
  ...
)

## S4 method for signature 'character'
context(
  .Object,
  query,
  cqp = is.cqp,
  p_attribute = getOption("polmineR.p_attribute"),
  region = NULL,
  boundary = NULL,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  count = TRUE,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = TRUE,
  ...
)

## S4 method for signature 'partition_bundle'
context(
  .Object,
  query,
  p_attribute,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'cooccurrences'
context(.Object, query, check = TRUE, complete = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.Object</code></td>
<td>
<p>a partition or a partition_bundle object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p>A query, which may by a character vector or a CQP query.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cqp</code></td>
<td>
<p>defaults to is.cqp-function, or provide TRUE/FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>A <code>logical</code> value, whether to check validity of CQP query using
<code>check_cqp_query</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>left</code></td>
<td>
<p>A single <code>integer</code> value defining the number of tokens to the
left of the query match to include in the context. Advanced usage: (a) If
<code>left</code> is a length-one <code>character</code> vector stating an s-attribute, the
context will be expanded to the (left) boundary of the region where the
match occurs. (b) If <code>left</code> is a named length-one <code>integer</code> vector, this
value is the number regions of the structural attribute referred to by the
vector's name  to the left of the query match that are included in the
context.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>right</code></td>
<td>
<p>A single <code>integer</code> value, a length-one <code>character</code> vector or a
named length-one <code>integer</code> value, with equivalent effects to argument
<code>left</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_attribute</code></td>
<td>
<p>The p-attribute of the query.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>region</code></td>
<td>
<p>An s-attribute, given by a length-one <code>character</code> vector.
The context of query matches will be expanded to the left and right
boundary of the region where the match is located. If arguments <code>left</code> and
<code>right</code> are &gt; 1, the left and right boundaries of the respective number of
regions will be identified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p>If provided, a length-one character vector specifying a
s-attribute. It will be checked that corpus positions do not extend beyond
the region defined by the s-attribute.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stoplist</code></td>
<td>
<p>Exclude match for query if stopword(s) is/are are present in
context. See positivelist for further explanation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>positivelist</code></td>
<td>
<p>A <code>character</code> vector or <code>numeric</code>/<code>integer</code> vector:
include a query hit only if token in positivelist is present. If
positivelist is a <code>character</code> vector, it may include regular expressions
(see parameter regex).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regex</code></td>
<td>
<p>A <code>logical</code> value, defaults to <code>FALSE</code> - whether <code>stoplist</code>
and/or <code>positivelist</code> are regular expressions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>count</code></td>
<td>
<p>logical</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc</code></td>
<td>
<p>Whether to use multicore; if <code>NULL</code> (default), the function will get
the value from the options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Report progress? A <code>logical</code> value, defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>A <code>logical</code> value, whether to show progress bar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corpus</code></td>
<td>
<p>A length-one <code>character</code> vector stating a corpus ID.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>registry</code></td>
<td>
<p>The registry directory with the registry file for <code>corpus</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complete</code></td>
<td>
<p>enhance completely</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For formulating the query, CPQ syntax may be used (see
examples). Statistical tests available are log-likelihood, t-test, pmi.
</p>
<p>If <code>.Object</code> is a <code>matrix</code>, the <code>context</code>-method will call
<code>RcppCWB::region_matrix_context()</code>, the worker behind the
<code>context()</code>-method.
</p>


<h3>Value</h3>

<p>depending on whether a <code>partition</code> or a <code>partition_bundle</code> serves as
input, the return will be a context object, or a <code>context_bundle</code> object.
Note that the number of objects in the <code>context_bundle</code> may differ from the
number of objects in the input <code>bundle</code> object: <code>NULL</code> objects that result
if no hit is obtained are dropped.
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>Examples</h3>

<pre><code class="language-R">use("polmineR")
p &lt;- partition("GERMAPARLMINI", interjection = "speech")
y &lt;- context(p, query = "Integration", p_attribute = "word")
y &lt;- context(p, query = "Integration", p_attribute = "word", positivelist = "Bildung")
y &lt;- context(
  p, query = "Integration", p_attribute = "word",
  positivelist = c("[aA]rbeit.*", "Ausbildung"), regex = TRUE
)
</code></pre>


</div>
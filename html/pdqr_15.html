<div class="container">

<table style="width: 100%;"><tr>
<td>enpoint</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Represent pdqr-function as a set of points</h2>

<h3>Description</h3>

<p>Function <code>enpoint()</code> suggests a reasonable default ways of converting
pdqr-function into a data frame of numerical values (points) with desirable
number of rows. Representation of pdqr-function as a set of numbers helps to
conduct analysis using approaches outside of 'pdqr' package. For example, one
can visually display pdqr-function with some other plotting functionality.
</p>


<h3>Usage</h3>

<pre><code class="language-R">enpoint(f, n_points = 1001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A pdqr-function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_points</code></td>
<td>
<p>Desired number of points in the output. Not used in case of
"discrete" type p-, d-, and q-function <code>f</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Structure of output depends on class and
type of input pdqr-function <code>f</code>:
</p>

<ul>
<li> <p><strong>P-functions</strong> are represented with "x" (for "x" values) and "p" (for
cumulative probability at "x" points) columns:
</p>

<ul>
<li>
<p> For "continuous" type, "x" is taken as an equidistant grid (with
<code>n_points</code> elements) on input's support.
</p>
</li>
<li>
<p> For "discrete" type, "x" is taken directly from "x_tbl" metadata without using <code>n_points</code> argument.
</p>
</li>
</ul>
</li>
<li> <p><strong>D-functions</strong> are represented with "x" column and one more (for values of
d-function at "x" points):
</p>

<ul>
<li>
<p> For "continuous" type, second column is named "y" and is computed as
values of <code>f</code> at elements of "x" column (which is the same grid as in
p-function case).
</p>
</li>
<li>
<p> For "discrete" it is named "prob". Both "x" and "prob" columns are
taken from "x_tbl" metadata.
</p>
</li>
</ul>
</li>
<li> <p><strong>Q-functions</strong> are represented almost as p-functions but in inverse
fashion. Output data frame has "p" (probabilities) and "x" (values of
q-function <code>f</code> at "p" elements) columns.
</p>

<ul>
<li>
<p> For "continuous" type, "p" is computed as equidistant grid (with
<code>n_points</code> elements) between 0 and 1.
</p>
</li>
<li>
<p> For "discrete" type, "p" is taken from "cumprob" column of "x_tbl"
metadata.
</p>
</li>
</ul>
</li>
<li> <p><strong>R-functions</strong> are represented by generating <code>n_points</code> elements from
distribution. Output data frame has columns "n" (consecutive point number,
basically a row number) and "x" (generated elements).
</p>
</li>
</ul>
<p><strong>Note</strong> that the other way to produce points for p-, d-, and q-functions is
to manually construct them with <code>form_regrid()</code> and <code>meta_x_tbl()</code>. However,
this method may slightly change function values due to possible
renormalization inside <code>form_regrid()</code>.
</p>


<h3>Value</h3>

<p>A data frame with <code>n_points</code> (or less, for "discrete" type p-, d-, or
q-function <code>f</code>) rows and two columns with names depending on <code>f</code>'s class
and type.
</p>


<h3>See Also</h3>

<p><code>pdqr_approx_error()</code> for diagnostics of pdqr-function approximation
accuracy.
</p>
<p>Pdqr methods for plot() for a direct plotting of
pdqr-functions.
</p>
<p><code>form_regrid()</code> to change underlying grid of pdqr-function.
</p>


<h3>Examples</h3>

<pre><code class="language-R">d_norm &lt;- as_d(dnorm)
head(enpoint(d_norm))

# Control number of points with `n_points` argument
enpoint(d_norm, n_points = 5)

# Different pdqr classes and types produce different column names in output
colnames(enpoint(new_p(1:2, "discrete")))
colnames(enpoint(new_d(1:2, "discrete")))
colnames(enpoint(new_d(1:2, "continuous")))
colnames(enpoint(new_q(1:2, "continuous")))
colnames(enpoint(new_r(1:2, "continuous")))

# Manual way with different output structure
df &lt;- meta_x_tbl(form_regrid(d_norm, 5))
## Difference in values due to `form_regrid()` renormalization
plot(enpoint(d_norm, 5), type = "l")
lines(df[["x"]], df[["y"]], col = "blue")
</code></pre>


</div>
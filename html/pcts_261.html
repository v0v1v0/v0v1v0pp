<div class="container">

<table style="width: 100%;"><tr>
<td>pcts</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create objects from periodic time series classes</h2>

<h3>Description</h3>

<p>Create objects from periodic time series classes.</p>


<h3>Usage</h3>

<pre><code class="language-R">pcts(x, nseasons, start, ..., keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a time series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nseasons</code></td>
<td>

<p>number of seasons. This argument is ignored by some methods.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>

<p>the starting time of the time series, can be a <code>(cycle,
      season)</code> pair or any object that can be converted to datetime.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>

<p>if <code>TRUE</code> and <code>x</code> is from class <code>"ts"</code>,
<code>"mts"</code>, <code>"zoo"</code>, or <code>"zooreg"</code>, create a periodic
object inheriting from that class.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed on to methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>pcts</code> creates periodic time series objects inheriting from
<code>"PeriodicTimeSeries"</code>. The particular class depends on arguments
<code>x</code> and, in some cases, <code>keep</code>.  The idea is that in normal
use the user does not care about the particular class. See section
‘Methods’ for further details.
</p>
<p>Familiar functions from base-R work with the objects created by
<code>pcts</code>. The help page <code>window</code> describes such methods
and gives examples.
</p>
<p>There are also methods for <code>as</code> for conversion to and from the
time series classes defined in package <span class="pkg">pcts</span>.
</p>


<h3>Value</h3>

<p>an object inheriting from <code>"PeriodicTimeSeries"</code>, the defaults
are <code>"PeriodicTS"</code> for univariate and <code>"PeriodicMTS"</code> and
for multivariate time series.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "numeric", nseasons = "missing")</code></dt>
<dd> </dd>
<dt><code>signature(x = "numeric", nseasons = "numeric")</code></dt>
<dd> </dd>
<dt><code>signature(x = "numeric", nseasons = "BasicCycle")</code></dt>
<dd> 
<p>Creates an object of class <code>"PeriodicTS"</code>, the native class for
univariate periodic time series in package <span class="pkg">"pcts"</span>.
</p>
</dd>
<dt><code>signature(x = "matrix", nseasons = "missing")</code></dt>
<dd> </dd>
<dt><code>signature(x = "matrix", nseasons = "numeric")</code></dt>
<dd> </dd>
<dt><code>signature(x = "matrix", nseasons = "BasicCycle")</code></dt>
<dd>
<p>Creates an object of class <code>"PeriodicMTS"</code>, the native class
for multivariate periodic time series in package <span class="pkg">"pcts"</span>.
</p>
</dd>
<dt><code>signature(x = "data.frame", nseasons = "ANY")</code></dt>
<dd>
<p>Currently this just converts <code>x</code> to matrix and calls
<code>pcts</code> recursively. See the methods with <code>x = "matrix"</code> in
the signature.
</p>
</dd>
<dt><code>signature(x = "ts", nseasons = "missing")</code></dt>
<dd> </dd>
<dt><code>signature(x = "ts", nseasons = "numeric")</code></dt>
<dd>
<p>If <code>keep = TRUE</code> creates an object of class
<code>"PeriodicTS_ts"</code>, otherwise the result is from
<code>"PeriodicTS"</code>. The number of seasons is taken from the
<code>"mts"</code> object. 
</p>
</dd>
<dt><code>signature(x = "mts", nseasons = "missing")</code></dt>
<dd> </dd>
<dt><code>signature(x = "mts", nseasons = "numeric")</code></dt>
<dd>
<p>If <code>keep = TRUE</code> creates an object of class
<code>"PeriodicMTS_ts"</code>, otherwise the result is from
<code>"PeriodicMTS"</code>. The number of seasons is taken from the
<code>"ts"</code> object.
</p>
</dd>
<dt><code>signature(x = "xtsORzoo", nseasons = "missing")</code></dt>
<dd>
<p><code>x</code> needs to be a regular time series, possibly with missing
values for some times (technically, <code>zoo::is.regular(x)</code> should
give TRUE). For daily time series, the cycle is taken to be day of
week or a subcycle of it, most commonly Monday-Friday.
The implementation of this method is incomplete but for daily data
should work as described.
</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code>PeriodicTS</code>,
<code>PeriodicMTS</code>, the two main periodic time series
classes in the package;
</p>
<p><code>dataFranses1996</code>, <code>Fraser2017</code>,
<code>four_stocks_since2016_01_01</code> for further examples;
</p>
<p><code>window</code> for extraction of subsets;
</p>
<p><code>pcApply</code> for applying a function to each season;
</p>
<p><code>Vec</code>,
<code>tsVec</code>,
<code>pcMatrix</code> for extraction of the core data
</p>


<h3>Examples</h3>

<pre><code class="language-R">## convert a ts object, no need for further info
pcts(AirPassengers, 12)

## numeric
v24 &lt;- rnorm(24)
pcts(v24, nseasons = 4)          # generic seasons
pcts(v24, nseasons = BuiltinCycle(4)) # Quarter/Year
ts1 &lt;- pcts(v24, nseasons = BuiltinCycle(4), c(2006, 1)) # Quarter/Year with dates

## select subset of the seasons
window(ts1, seasons = 3:4)

## matrix, multivariate pcts
m24 &lt;- matrix(v24, ncol =3)
colnames(m24) &lt;- c("A", "B", "C")
pcts(m24, nseasons = 4)          # generic seasons
pcts(m24, nseasons = BuiltinCycle(4)) # Quarter/Year
mts1 &lt;- pcts(m24, nseasons = BuiltinCycle(4), c(2006, 1)) # Quarter/Year with dates
mts1

## select subset of the seasons for mutivariate
window(mts1, seasons = 3:4)
</code></pre>


</div>
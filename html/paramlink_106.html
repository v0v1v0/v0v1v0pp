<div class="container">

<table style="width: 100%;"><tr>
<td>linkdat</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Linkdat objects</h2>

<h3>Description</h3>

<p>Functions to create and display 'linkdat' objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">linkdat(
  ped,
  model = NULL,
  map = NULL,
  dat = NULL,
  freq = NULL,
  annotations = NULL,
  missing = 0,
  header = FALSE,
  checkped = TRUE,
  verbose = TRUE,
  ...
)

singleton(id, sex = 1, famid = 1, verbose = FALSE, ...)

## S3 method for class 'linkdat'
print(x, ..., markers)

## S3 method for class 'linkdat'
summary(object, ...)

write.linkdat(
  x,
  prefix = "",
  what = c("ped", "map", "dat", "freq", "model"),
  merlin = FALSE
)

## S3 method for class 'linkdat'
subset(x, subset = x$orig.ids, ..., markers = seq_len(x$nMark))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ped</code></td>
<td>
<p>a matrix, data.frame or a character with the path to a pedigree
file in standard LINKAGE format. (See details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>either a <code>linkdat.model</code> object (typically <code>y$model</code>
for some linkdat object <code>y</code>), or a single integer with the following
meaning: 1 = autosomal dominant; 2 = autosomal recessive; 3 = X-linked
dominant; 4 = X-linked recessive. In each of these cases, the disease is
assumed fully penetrant and the disease allele frequency is set to 0.00001.
If <code>model=NULL</code>, no model is set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>a character with the path to a map file in MERLIN format, or NULL.
If non-NULL, a dat file must also be given (next item).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>a character with the path to a dat file in MERLIN format, or NULL.
(Only needed if <code>map</code> is non-NULL.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq</code></td>
<td>
<p>a character with the path to a allele frequency file in MERLIN
(short) format, or NULL. If NULL, all markers are interpreted as
equifrequent.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>annotations</code></td>
<td>
<p>a list (of the same length and in the same order as the
marker columns in <code>x</code>) of marker annotations. If this is non-NULL,
then all of <code>map, dat, freq</code> should be NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing</code></td>
<td>
<p>the character (of length 1) used for missing alleles. Defaults
to '0'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>header</code></td>
<td>
<p>a logical, relevant only if <code>ped</code> points to a ped file: If
TRUE, the first line of the ped file is skipped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkped</code></td>
<td>
<p>a logical. If FALSE, no checks for pedigree errors are
performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a logical: verbose output or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id, sex</code></td>
<td>
<p>single numerics describing the individual ID and gender of the
singleton.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>famid</code></td>
<td>
<p>a numeric: the family ID of the singleton.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, object</code></td>
<td>
<p>a <code>linkdat</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>markers</code></td>
<td>
<p>a numeric indicating which markers should be included/printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix</code></td>
<td>
<p>a character string giving the prefix of the files. For
instance, if <code>prefix='fam1'</code> and <code>what=c('ped', 'map')</code>, the
files 'fam1.ped' and 'fam1.map' will be created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>a character vector forming a subset of c('ped', 'map', 'dat',
'freq', 'model'), indicating which files should be created. All files are
written in MERLIN style (but see the next item!)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merlin</code></td>
<td>
<p>a logical. If TRUE, the marker alleles are relabeled to
1,2,..., making sure that the generated files are readable by MERLIN (which
does not accept non-numerical allele labels in the frequency file.) If
FALSE (the default) the allele labels are unchanged. In this case, <code>x</code>
should be exactly reproducible from the files. (See examples.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>a numeric containing the individuals in the sub-pedigree to be
extracted. NB: No pedigree checking is done here, so make sure the subset
form a meaningful, closed pedigree.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The file (or matrix or data.frame) <code>ped</code> must describe one or several
pedigrees in standard LINKAGE format, i.e. with the following columns in
correct order:
</p>
<p>1 Family id (optional) (FAMID)
</p>
<p>2 Individual id (ID),
</p>
<p>3 Father id (FID),
</p>
<p>4 Mother id (MID),
</p>
<p>5 Gender (SEX): 1 = male, 2 = female,
</p>
<p>6 Affection status (AFF): 1 = unaffected, 2 = affected, 0 = unknown,
</p>
<p>7 First allele of first marker,
</p>
<p>8 Second allele of first marker,
</p>
<p>9 First allele of second marker,
</p>
<p>a.s.o.
</p>
<p>Only columns 2-6 are mandatory. The first column is automatically interpreted
as family id if it has repeated elements.
</p>
<p>Internally the individuals are relabeled as 1,2,..., but this should rarely
be of concern to the end user. Some pedigree checking is done, but it is
recommended to plot the pedigree before doing any analysis.
</p>
<p>Details on the formats of map, dat and frequency files can be found in the
online MERLIN tutorial: <a href="http://csg.sph.umich.edu/abecasis/Merlin/">http://csg.sph.umich.edu/abecasis/Merlin/</a>
</p>
<p>A singleton is a special <code>linkdat</code> object whose pedigree contains 1
individual. The class attribute of a singleton is <code>c('singleton',
'linkdat')</code>
</p>


<h3>Value</h3>

<p>A <code>linkdat</code> object, or a list of <code>linkdat</code> objects. A
linkdat object is essentially a list with the following entries, some of
which can be NULL.  </p>
<table>
<tr style="vertical-align: top;">
<td><code>pedigree </code></td>
<td>
<p><code>data.frame</code> with 5 columns (ID,
FID, MID, SEX, AFF) describing the pedigree in linkage format. (NB:
Internal labeling used.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orig.ids</code></td>
<td>
<p>the original individual id
labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nInd</code></td>
<td>
<p>the number of individuals in the pedigree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>founders</code></td>
<td>
<p>vector of the founder individuals. (NB: Internal labeling
used.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonfounders</code></td>
<td>
<p>vector of the nonfounder individuals (NB:
Internal labeling used.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hasLoops</code></td>
<td>
<p>a logical: TRUE if the pedigree
is inbred.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subnucs</code></td>
<td>
<p>list containing all (maximal) nuclear families
in the pedigree. Each nuclear family is given as a vector of the form
c(pivot, father, mother, child1, ...), where the pivot is either the id of
the individual linking the nuclear family to the rest of the pedigree, or 0
if there are none. (NB: Internal labeling used.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>markerdata</code></td>
<td>
<p>a list
of <code>marker</code> objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nMark</code></td>
<td>
<p>the number of markers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>available</code></td>
<td>
<p>a numeric vector containing IDs of available individuals.
Used for simulations and plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a <code>linkdat.model</code>
object, essentially a list containing the model parameters. See
<code>setModel</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loop_breakers</code></td>
<td>
<p>a matrix with
original loop breaker ID's in the first column and their duplicates in the
second column. This is set by <code>breakLoops</code>.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>pedCreate</code>, <code>pedModify</code>,
<code>pedParts</code>, <code>setModel</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x = linkdat(toyped, model=1)
x
summary(x)

#### test read/write:
x = modifyMarker(x, 1, alleles=c('B','C'), afreq=c(.9, .1), chrom=2, name='SNP1', pos=123)
write.linkdat(x, prefix='toy')
y = linkdat('toy.ped', map='toy.map', dat='toy.dat', freq='toy.freq', model=1)
unlink(c('toy.ped', 'toy.map', 'toy.dat', 'toy.freq', 'toy.model'))
stopifnot(isTRUE(all.equal(x,y)))

#### test singletons:
w = singleton(id=3, sex=2)
T1 = all.equal(w, linkdat(ped=rbind(c(3,0,0,2,1))))
w = markerSim(w, N=5, alleles=2, afreq=c(0.1,.9))
T2 = all.equal(w, relabel(relabel(w, 10), 3))
T3 = all.equal(w, swapSex(swapSex(w, 3), 3))
T4 = all.equal(w, swapAff(swapAff(w, 3), 3))
stopifnot(T1, T2, T3, T4)

#### several ways of creating the same linkdat object:
alleles = c(157,160,163)
afreq = c(0.3, 0.3, 0.4)
gt10 = c(160, 160)
gt14 = c(160, 163)

z1 = relabel(addOffspring(nuclearPed(1), father=3, noffs=1, aff=2), 10:14)
z1 = addMarker(z1, marker(z1, 10, gt10, 14, gt14, alleles=alleles, afreq=afreq))
z1 = setModel(z1, 2)

z2 = addParents(relabel(nuclearPed(1), 12:14), 12, father=10, mother=11)
z2 = addMarker(z2, rbind(gt10, 0, 0, 0, gt14), alleles=alleles, afreq=afreq)
z2 = setModel(swapAff(z2, 14), 2)

z3 = linkdat(data.frame(ID=10:14, FID=c(0,0,10,0,12), MID=c(0,0,11,0,13),
             SEX=c(1,2,1,2,1), AFF=c(1,1,1,1,2),
             M=c('160/160', '0/0', '0/0', '0/0', '160/163')), model=2)
z3 = modifyMarker(z3, 1, alleles=alleles, afreq=afreq)

write.linkdat(z1, prefix='test')
z4 = linkdat('test.ped', map='test.map', dat='test.dat', freq='test.freq',
             model=2)
z4 = modifyMarker(z4, 1, alleles=alleles, chrom=NA, pos=NA, name=NA)

write.linkdat(z1, prefix='test', merlin=TRUE)
z5 = linkdat('test.ped', map='test.map', dat='test.dat', freq='test.freq',
             model=2)
z5 = modifyMarker(z5, 1, alleles=alleles, chrom=NA, pos=NA, name=NA)

stopifnot(isTRUE(all.equal(z1,z2)), isTRUE(all.equal(z1,z3)),
          isTRUE(all.equal(z1,z4)), isTRUE(all.equal(z1,z5)))
unlink(c('test.ped', 'test.map', 'test.dat', 'test.freq', 'test.model'))

</code></pre>


</div>
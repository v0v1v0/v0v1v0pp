<div class="container">

<table style="width: 100%;"><tr>
<td>ptw</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parametric Time Warping</h2>

<h3>Description</h3>

<p>The main functions of the <code>ptw</code> package, performing
parametric time warping of one or more samples. Features in the
samples are optimally aligned with features in the reference(s). One
may align a single sample to a single reference, several samples to a
single reference, and several samples to several references. In the
latter case, the number of references and samples should be equal. One
may require that all samples are warped with the same warping
function, or one may allow individual warpings for all samples.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ptw(ref, samp, selected.traces,
    init.coef = c(0, 1, 0), try = FALSE,
    warp.type = c("individual", "global"),
    optim.crit = c("WCC", "RMS"),
    mode = c("forward", "backward"),
    smooth.param = ifelse(try, 0, 1e05),
    trwdth = 20, trwdth.res = trwdth,
    verbose = FALSE, ...)
stptw(ref, samp, init.coef = c(0, 1, 0),
      trwdth = 20, trwdth.res = trwdth, 
      nGlobal = ifelse(length(init.coef) &gt; 3, 5, 0),
      ...)
## S3 method for class 'ptw'
summary(object, ...)
## S3 method for class 'ptw'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ref</code></td>
<td>
<p>reference. Either a vector (containing one reference
signal) or a matrix (one reference per row). If
more than one reference is specified, the number of reference
signals must equal the number of sample signals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samp</code></td>
<td>
<p>sample. A vector (containing one sample signal) or a
matrix (one sample per row).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selected.traces</code></td>
<td>
<p>optional vector containing the row numbers to
use from <code>ref</code> (if more than one reference signal is specified)
and <code>samp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.coef</code></td>
<td>
<p>starting coefficients. The first number is the
zeroth-order coefficient (i.e., a constant shift); further numbers
indicate linear, quadratic, ... stretches. The default is to start
from the identity warping using a quadratic function
(<code>c(0, 1, 0)</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>try</code></td>
<td>
<p>if <code>try = TRUE</code>, <code>ptw</code> does not optimize the
warping but returns a <code>ptw</code> object containing the warping for
<code>init.coef</code>. Default: <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warp.type</code></td>
<td>
<p>default is to treat samples and references as single
entities and align them individually and independently. Using the 
argument <code>warp.type = "global"</code> leads to one alignment 
function; the samples are warped simultaneously to the 
reference(s). Also see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.crit</code></td>
<td>
<p>either <code>"WCC"</code> or <code>"RMS"</code>. In both cases,
the optimal value of the alignment leads to a value of 0. For "WCC",
this means that <code>1 - WCC</code> is optimized rather than <code>WCC</code>
(where the optimal value equals 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>either "forward" or "backward": the latter was the
original implementation, basically for a point i in the original
signal predicting the point j in the signal that would be in
position i in the warped signal. The interpretation of the
coefficients is counterintuitive. Therefore the default is
"forward", simply predicting the location (time) in the warped
signal of a particular point. Apart from possible numerical
optimisation issues, both warpings should give the same net result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.param</code></td>
<td>
<p>smoothing parameter for smoothing the reference
and sample when <code>optim.crit</code> equals <code>"RMS"</code>. If no
smoothing is required, set this to 0. The default is to use
smoothing in the optimization mode, and no smoothing otherwise</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trwdth</code></td>
<td>
<p>the width of the triangle in the WCC criterion during
the optimization, given as a number of data points. Default: 20</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trwdth.res</code></td>
<td>
<p>the width of the triangle in the WCC calculation in
the calculation of the quality of the final result. Default: equal
to <code>trwdth</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical, default is <code>FALSE</code>. Whether to give
output during the optimisation, which may be useful for large data
sets</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to optim</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nGlobal</code></td>
<td>
<p>for stick optimisations with more than three
coefficients, a more powerful optimisation method is used
(<code>nloptr</code>: in such cases <code>nGlobal</code> indicates the number of
times this method is employed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, object</code></td>
<td>
<p>an object of class "ptw"</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function <code>ptw</code> and friends is meant for profile data,
where intensities have been recorded at regular time points; function
<code>stptw</code> is meant for lists of peaks, for instance obtained after
peak-picking the profile data. The latter option is less flexible
(Euclidean distance and backward warping have not been implemented,
and only global alignment is possible)
but is much faster, especially for larger data sets.
</p>
<p>In the optimization mode (<code>try = FALSE</code>), the function
optimizes the warping coefficients using the chosen criterion (either
"WCC" or "RMS"). For "RMS", the data are smoothed before the
optimization, but the quality of the final warping is measured on the
unsmoothed data. For "WCC", the warping is performed using 
<code>trwdth</code> as the triangle width, but the quality of the final 
solution is measured using <code>trwdth.res</code>.
</p>
<p>If <code>try = TRUE</code> is used as an argument, the function does not
start an optimization, but just calculates the warping for the given 
warp function (<code>init.coef</code>); if <code>smooth.param</code> is larger 
than zero for the RMS criterion, the RMS of the smoothed patterns is 
calculated. The WCC criterion uses <code>trwidth.res</code> as the triangle 
width in this case. 
</p>
<p>Five situations can be distinguished:
</p>

<ol>
<li>
<p> One sample and one reference: this obviously leads to one warping
function regardless of the setting of <code>warp.type</code>.
</p>
</li>
<li>
<p> Several samples, all warped to the same single reference, each with 
its own warping function: this is the default behaviour
(<code>warp.type = "individual"</code>)
</p>
</li>
<li>
<p> Several samples, warped to an equal number of references
(pair-wise), with their own warping functions: this is the default
behaviour (<code>warp.type = "individual"</code>)
</p>
</li>
<li>
<p> Several samples, warped to one reference, with one warping function 
(<code>warp.type = "global"</code>)
</p>
</li>
<li>
<p> Several samples, warped to an equal number of references
(pair-wise), with one warping function 
(<code>warp.type = "global"</code>)
</p>
</li>
</ol>
<h3>Value</h3>

<p>A list of class "ptw" containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>reference</code></td>
<td>
<p>the reference(s) used as input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample</code></td>
<td>
<p>the sample(s) used as input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warped.sample</code></td>
<td>
<p>the warped sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warp.coef</code></td>
<td>
<p>the warping coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warp.fun</code></td>
<td>
<p>the warped indices (not for <code>stptw</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit.value</code></td>
<td>
<p>the value of the chosen criterion, either "WCC" or "RMS"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.crit</code></td>
<td>
<p>the chosen criterion, either "WCC" or "RMS"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warp.type</code></td>
<td>
<p>the chosen type of warping, either "individual" or
"global"</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jan Gerretzen, Ron Wehrens</p>


<h3>References</h3>

<p>Eilers, P.H.C. (2004) "Parametric Time Warping", Analytical Chemistry, <b>76</b> (2), 404 – 411.
</p>
<p>Bloemberg, T.G., et al. (2010) "Improved parametric time warping for Proteomics", Chemometrics and Intelligent Laboratory Systems, <b>104</b> (1), 65 – 74.
</p>


<h3>See Also</h3>

<p><code>WCC</code>, <code>RMS</code>, <code>select.traces</code>,
<code>gaschrom</code>, <code>lcms</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(gaschrom)
ref &lt;- gaschrom[1,]
samp &lt;- gaschrom[16,]
gaschrom.ptw &lt;- ptw(ref, samp)
summary(gaschrom.ptw)

## same with sticks (peak lists)
refst &lt;- gaschrom.st[1]
sampst &lt;- gaschrom.st[16]
gaschrom.st.ptw &lt;- stptw(refst, sampst, trwdth = 100)
summary(gaschrom.st.ptw)

## Not run: 
## comparison between backward and forward warping
gaschrom.ptw &lt;- ptw(ref, samp, init.coef = c(0, 1, 0, 0), mode = "backward")
summary(gaschrom.ptw)
gaschrom.ptw &lt;- ptw(ref, samp, init.coef = c(-10, 1, 0, 0), mode = "forward")
summary(gaschrom.ptw)

## #############################
## many samples warped on one reference
ref &lt;- gaschrom[1,]
samp &lt;- gaschrom[2:16,]
gaschrom.ptw &lt;-
  ptw(ref, samp, warp.type = "individual", verbose = TRUE,
      optim.crit = "WCC",  trwdth = 100, init.coef = c(0, 1, 0))
summary(gaschrom.ptw)

## "individual" warping not implemented for sticks; do separate warpings
## instead
refst &lt;- gaschrom.st[1]
sampst &lt;- gaschrom.st[2:16]
gaschrom.st.ptw.list &lt;-
  lapply(sampst,
         function(smpl)
           stptw(refst, list(smpl), trwdth = 100, init.coef = c(0, 1, 0)))
t(sapply(gaschrom.st.ptw.list,  "[[", "warp.coef"))
t(sapply(gaschrom.st.ptw.list,  "[[", "crit.value"))

## #############################
## several samples on several references individually
ref &lt;- gaschrom[1:8,]
samp &lt;- gaschrom[9:16,]
gaschrom.ptw &lt;-
  ptw(ref, samp, warp.type = "individual",
      optim.crit = "WCC", trwdth = 100, init.coef = c(0, 1, 0))
summary(gaschrom.ptw)

## stick version
gaschrom.st.ptw.list &lt;-
  mapply(function(x, y)
         stptw(list(x), list(y), trwdth = 100, init.coef = c(0, 1, 0)),
         gaschrom.st[1:8], gaschrom.st[9:16],
         SIMPLIFY = FALSE)
t(sapply(gaschrom.st.ptw.list, coef))

## #############################
## several samples on several references: one, global warping
gaschrom.ptw &lt;- ptw(ref, samp, warp.type = "global",
                    optim.crit = "WCC", init.coef = c(0, 1, 0))
summary(gaschrom.ptw)

refst &lt;- gaschrom.st[1:8]
sampst &lt;- gaschrom.st[9:16]
gaschrom.st.ptw &lt;- stptw(refst, sampst, trwdth=100, init.coef = c(0, 1, 0))
summary(gaschrom.st.ptw)

## #################################################################
## Example of a three-way data set#
## #################################################################

## first bring all samples to the same scale
data(lcms)
lcms.scaled &lt;- aperm(apply(lcms, c(1,3), 
                           function(x) x/mean(x) ), c(2,1,3))
## add zeros to the start and end of the chromatograms
lcms.s.z &lt;- aperm(apply(lcms.scaled, c(1,3), 
                        function(x) padzeros(x, 250) ), c(2,1,3))


## define a global 2nd degree warping
warp1 &lt;- ptw(lcms.s.z[,,2], lcms.s.z[,,3], warp.type="global")
warp.samp &lt;- warp1$warped.sample
warp.samp[is.na(warp.samp)] &lt;- 0
## refine by adding 5th degree warpings for individual chromatograms
warp2 &lt;- ptw(lcms.s.z[,,2], warp.samp, init.coef=c(0,1,0,0,0,0))
warp.samp2 &lt;- warp2$warped.sample
warp.samp2[is.na(warp.samp2)] &lt;- 0
## compare TICs
layout(matrix(1:2,2,1, byrow=TRUE))
plot(colSums(lcms.s.z[,,2]), type="l", ylab = "",
     main = "TIC: original data")
lines(colSums(lcms.s.z[,,3]), col=2, lty=2)
plot(colSums(lcms.s.z[,,2]), type="l", ylab = "",
     main = "TIC: warped data")
lines(colSums(warp.samp2), lty=2, col=2)

## ###########################
## stick version of this warping - note that the peaks have been picked
## from the scaled profiles. Note that here we need to take list
## elements: every sample is a list of mz channels.
warp1.st &lt;- stptw(lcms.pks[[2]], lcms.pks[[3]], trwdth = 100)
summary(warp1.st)

## End(Not run)
</code></pre>


</div>
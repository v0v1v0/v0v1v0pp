<div class="container">

<table style="width: 100%;"><tr>
<td>idw</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Inverse Distance Weighting interpolation
</h2>

<h3>Description</h3>

<p>This function interpolates a list of samples with location and a value to
a table of coordinates, that generally represent a spatial grid. The 
interpolation is based on inverse distance weighting algoritm with three
different methods available for weight calculation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">idw(values, coords, grid, method = "Shepard", p = 2, R = 2, N = 15,
    distFUN = geo.dist, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>

<p>A table of points to be interpolated. Table must contain x and y locations,
and a column of values to be interpolated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>A table wit x and y coordinates of the samples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>

<p>Coordinates of locations to interpolate. It is assumed to be in the same 
order as 'values' table.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>Method to calculate weights for idw. Should be "Shepard" (default), 
"Modified", "Neighbours", or distinctive abreviations of each. See details
section for additional help on each method.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>

<p>The power to use in weight calculation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>

<p>Radius to use with Modified Shepard method.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>

<p>Maximum number of neighbours to use with Shepard with neighbours.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distFUN</code></td>
<td>

<p>Distance function used to calculate distances between locations.
The default is 'geo.dist' which calculates simple euclidean
distances between the locations. This function must have a 'from'
and a 'to' arguments to specify, respectively, the source and
destination localities.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Other arguments to be passed to distFUN.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The IDW interpolation algorithm is commonly used to interpolate genetic
data over a spatial grid. This function provides a simple interface to
interpolate such data with three methods:
</p>

<ol>
<li>
<p><em>Shepard</em>: 
weights are the inverse of the distance between the interpolation
location <code class="reqn">x</code> and the sample points <code class="reqn">x_i</code>, raised to the 
power <code class="reqn">p</code>
</p>
<p style="text-align: center;"><code class="reqn">w(x) = \frac{1}{d(x, x_i)^p}</code>
</p>


</li>
<li>
<p><em>Modified Shepard</em>:
distances are weighted with a search radius <code class="reqn">r</code> to calculate the 
interpolation weights 
</p>
<p style="text-align: center;"><code class="reqn">w(x) = \left(\frac{r-d(x, x_i)}{r.d(x, xi)}\right)^p</code>
</p>


</li>
<li>
<p><em>Shepard with neighbours</em>:
A maximum ammount of <code class="reqn">N</code> neighbours is allowed to the weight 
calculation following Shepard method.

</p>
</li>
</ol>
<h3>Value</h3>

<p>It return a vector for each row of the 'coords' table with the respective
interpolated value.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>References</h3>

<p>Fortin, M. -J. and Dale, M. (2006) <em>Spatial Analysis: A guide for Ecologists</em>. Cambridge: Cambridge University Press.
</p>
<p>Isaaks, E. H. and Srivastava, R. M. (1989) <em>An Introduction to applied geostatistics</em>. New York: Oxford University Press.
</p>
<p>Legendre, P. and Legendre, L. (1998) <em>Numerical ecology</em>. 2nd english edition. Amesterdam: Elsevier
</p>
<p>Vandergast, A. G.,Hathaway, S. A., Fisher, R. N., Boys, J., Bohonak, A. J., 
(2008) Are hotspots evolutionary potential adequately protected in 
southern California? <em>Biological Conservation</em>, <b>141</b>, 1648-1664.
</p>


<h3>See Also</h3>

<p><code>intgen.idw</code>
<code>krig</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(vipers)
data(d.gen)
data(grid)

# interpolate and plot the genetic distances for sample s2 in the d.gen
int &lt;- idw(d.gen[,2], vipers[,1:2], grid)

grid.image(int, grid, main='IDW interpolation', xlab='Longitude', 
           ylab='Latitude', sclab="Genetic distance to sample s2")

points(vipers[,1:2], cex=d.gen[,2]*15+0.2)

# change idw power (i.e. points will have a larger influence in the 
# surroundings)
int &lt;- idw(d.gen[,2], vipers[,1:2], grid, p=5)

result &lt;- data.frame(grid, int)
grid.image(int, grid, main='IDW interpolation', xlab='Longitude', 
           ylab='Latitude', sclab="Genetic distance to sample s2")

points(vipers[,1:2], cex=d.gen[,2]*15+0.2)


# change idw method to "Modified Shepard" and define a maximum 
# neighbour distance
int &lt;- idw(d.gen[,2], vipers[,1:2], grid, 'Modified', R=10)

grid.image(int, grid, main='IDW interpolation', xlab='Longitude', 
           ylab='Latitude', sclab="Genetic distance to sample s2")

points(vipers[,1:2], cex=d.gen[,2]*15+0.2)

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#        Example following methods in Vandergast et al. 2008        #
#            Fit a linear model and recover the residuals           #
# ATENTION:                                                         #
#    1- Vandergast et al. (2008) suggests a RMA instead of a        # 
#       ordinary linear regression as in this example. Try package  # 
#       'lmodel2' or or other similar for RMA linear regression.    #
#    2- This example tests if the package 'geometry' is installed   #
#       to compute midpoints. If TRUE, a Delaunay triangulation is  # 
#       used, similarly to Vandergast et al. (2008). Otherwise,     #
#       midpoints are computed for the combination of all pairs of  #
#       samples.                                                    #
#                                                                   #
# the d.gen and d.real matrices in this example have the same       # 
# column and row order!                                             #
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#

if (is.element('geometry', installed.packages()[,1])) 
    all=FALSE else 
    all=TRUE

mp &lt;- midpoints(vipers[,1:2], all=all)
d.real &lt;- as.matrix(dist(vipers[,1:2]))

fit &lt;- lm(as.vector(d.gen) ~ as.vector(d.real))
resid &lt;- matrix(fit$residuals, nrow(vipers), nrow(vipers))
dimnames(resid) &lt;- dimnames(d.gen)
mp$z &lt;- extract.val(resid, mp[,1:2])

int &lt;- idw(mp[,5], mp[,3:4], grid)

grid.image(int, grid, main='IDW interpolation', 
           xlab='Longitude', ylab='Latitude', 
           sclab="Residuals of genetic vs. real distances")

# plot samples connecting lines
for (i in 1:nrow(mp))
{
    pair &lt;- as.character(unlist(mp[i,1:2]))
    x &lt;- c(vipers[pair[1],1], vipers[pair[2],1])
    y &lt;- c(vipers[pair[1],2], vipers[pair[2],2])
    lines(x, y, lty=2)
}
points(vipers[,1:2], pch=16) # plot samples points in black
points(mp[,3:4], pch=16, col='gray') # plot midpoints in gray

</code></pre>


</div>
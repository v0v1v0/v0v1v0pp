<div class="container">

<table style="width: 100%;"><tr>
<td>fit.subgroup</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting subgroup identification models</h2>

<h3>Description</h3>

<p>Fits subgroup identification model class of Chen, et al (2017)
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit.subgroup(
  x,
  y,
  trt,
  propensity.func = NULL,
  loss = c("sq_loss_lasso", "logistic_loss_lasso", "poisson_loss_lasso",
    "cox_loss_lasso", "owl_logistic_loss_lasso", "owl_logistic_flip_loss_lasso",
    "owl_hinge_loss", "owl_hinge_flip_loss", "sq_loss_lasso_gam",
    "poisson_loss_lasso_gam", "logistic_loss_lasso_gam", "sq_loss_gam",
    "poisson_loss_gam", "logistic_loss_gam", "owl_logistic_loss_gam",
    "owl_logistic_flip_loss_gam", "owl_logistic_loss_lasso_gam",
    "owl_logistic_flip_loss_lasso_gam", "sq_loss_xgboost", "custom"),
  method = c("weighting", "a_learning"),
  match.id = NULL,
  augment.func = NULL,
  fit.custom.loss = NULL,
  cutpoint = 0,
  larger.outcome.better = TRUE,
  reference.trt = NULL,
  retcall = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The design matrix (not including intercept term)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The response vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trt</code></td>
<td>
<p>treatment vector with each element equal to a 0 or a 1, with 1 indicating
treatment status is active.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propensity.func</code></td>
<td>
<p>function that inputs the design matrix x and the treatment vector trt and outputs
the propensity score, ie Pr(trt = 1 | X = x). Function should take two arguments 1) x and 2) trt. See example below.
For a randomized controlled trial this can simply be a function that returns a constant equal to the proportion
of patients assigned to the treatment group, i.e.:
<code>propensity.func = function(x, trt) 0.5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>choice of both the M function from Chen, et al (2017) and potentially the penalty used for variable selection.
All <code>loss</code> options starting with <code>sq_loss</code> use M(y, v) = (v - y) ^ 2, all options starting with <code>logistic_loss</code> use
the logistic loss: M(y, v) = y * log(1 + exp{-v}), and all options starting with <code>cox_loss</code> use the negative partial likelihood loss for the Cox PH model.
All options ending with <code>lasso</code> have a lasso penalty added to the loss for variable selection. <code>sq_loss_lasso_gam</code>
and <code>logistic_loss_lasso_gam</code> first use the lasso to select variables and then fit a generalized additive model
with nonparametric additive terms for each selected variable. <code>sq_loss_gam</code> involves a squared error loss with a generalized additive model and no variable selection.
<code>sq_loss_xgboost</code> involves a squared error loss with a gradient-boosted decision trees model using <code>xgboost</code> for the benefit score; this
allows for flexible estimation using machine learning and can be useful when the underlying treatment-covariate interaction is complex. Must specify
<code>params</code>, <code>nrounds</code>, <code>nfold</code>, and optionally, <code>early_stopping_rounds</code>; see <code>xgb.train</code> for details
</p>

<ul>
<li>
<p><strong>Continuous Outcomes</strong>
</p>

<ul>
<li>
<p><code>"sq_loss_lasso"</code> - M(y, v) = (v - y) ^ 2 with linear model and lasso penalty
</p>
</li>
<li>
<p><code>"owl_logistic_loss_lasso"</code>  - M(y, v) = ylog(1 + exp{-v}) (method of Regularized Outcome Weighted Subgroup Identification)
</p>
</li>
<li>
<p><code>"owl_logistic_flip_loss_lasso"</code>  - M(y, v) = |y|log(1 + exp{-sign(y)v})
</p>
</li>
<li>
<p><code>"owl_hinge_loss"</code>  - M(y, v) = ymax(0, 1 - v) (method of Estimating individualized treatment rules using outcome weighted learning)
</p>
</li>
<li>
<p><code>"owl_hinge_flip_loss"</code>  - M(y, v) = |y|max(0, 1 - sign(y)v) 
</p>
</li>
<li>
<p><code>"sq_loss_lasso_gam"</code> - M(y, v) = (v - y) ^ 2 with variables selected by lasso penalty and generalized additive model fit on the selected variables
</p>
</li>
<li>
<p><code>"sq_loss_gam"</code> - M(y, v) = (v - y) ^ 2 with generalized additive model fit on all variables
</p>
</li>
<li>
<p><code>"owl_logistic_loss_gam"</code>  - M(y, v) = ylog(1 + exp{-v}) with generalized additive model fit on all variables
</p>
</li>
<li>
<p><code>"owl_logistic_flip_loss_gam"</code>  - M(y, v) = |y|log(1 + exp{-sign(y)v}) with generalized additive model fit on all variables
</p>
</li>
<li>
<p><code>"owl_logistic_loss_lasso_gam"</code>  - M(y, v) = ylog(1 + exp{-v}) with variables selected by lasso penalty and generalized additive model fit on the selected variables
</p>
</li>
<li>
<p><code>"owl_logistic_flip_loss_lasso_gam"</code>  - M(y, v) = |y|log(1 + exp{-sign(y)v}) with variables selected by lasso penalty and generalized additive model fit on the selected variables
</p>
</li>
<li>
<p><code>"sq_loss_xgboost"</code> - M(y, v) = (v - y) ^ 2 with gradient-boosted decision trees model
</p>
</li>
</ul>
</li>
<li>
<p><strong>Binary Outcomes</strong>
</p>

<ul>
<li>
<p>All losses for continuous outcomes can be used plus the following:
</p>
</li>
<li>
<p><code>"logistic_loss_lasso"</code> - M(y, v) = -[yv - log(1 + exp{-v})] with with linear model and lasso penalty
</p>
</li>
<li>
<p><code>"logistic_loss_lasso_gam"</code> - M(y, v) = -[yv - log(1 + exp{-v})] with variables selected by lasso penalty and generalized additive model fit on the selected variables
</p>
</li>
<li>
<p><code>"logistic_loss_gam"</code> - M(y, v) = -[yv - log(1 + exp{-v})] with generalized additive model fit on all variables
</p>
</li>
</ul>
</li>
<li>
<p><strong>Count Outcomes</strong>
</p>

<ul>
<li>
<p>All losses for continuous outcomes can be used plus the following:
</p>
</li>
<li>
<p><code>"poisson_loss_lasso"</code> - M(y, v) = -[yv - exp(v)] with with linear model and lasso penalty
</p>
</li>
<li>
<p><code>"poisson_loss_lasso_gam"</code> - M(y, v) = -[yv - exp(v)] with variables selected by lasso penalty and generalized additive model fit on the selected variables
</p>
</li>
<li>
<p><code>"poisson_loss_gam"</code> - M(y, v) = -[yv - exp(v)] with generalized additive model fit on all variables
</p>
</li>
</ul>
</li>
<li>
<p><strong>Time-to-Event Outcomes</strong>
</p>

<ul><li>
<p><code>"cox_loss_lasso"</code> - M corresponds to the negative partial likelihood of the cox model with linear model and additionally a lasso penalty
</p>
</li></ul>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>subgroup ID model type. Either the weighting or A-learning method of Chen et al, (2017)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>match.id</code></td>
<td>
<p>a (character, factor, or integer) vector with length equal to the number of observations in <code>x</code> indicating using integers or
levels of a factor vector which patients are
in which matched groups. Defaults to <code>NULL</code> and assumes the samples are not from a matched cohort. Matched
case-control groups can be created using any method (propensity score matching, optimal matching, etc). If each case
is matched with a control or multiple controls, this would indicate which case-control pairs or groups go together.
If <code>match.id</code> is supplied, then it is unecessary to specify a function via the <code>propensity.func</code> argument.
A quick usage example: if the first patient is a case and the second and third are controls matched to it, and the
fouth patient is a case and the fifth through seventh patients are matched with it, then the user should specify
<code>match.id = c(1,1,1,2,2,2,2)</code> or <code>match.id = c(rep("Grp1", 3),rep("Grp2", 4)) </code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>augment.func</code></td>
<td>
<p>function which inputs the response <code>y</code>, the covariates <code>x</code>, and <code>trt</code> and outputs
predicted values (on the link scale) for the response using a model constructed with <code>x</code>. <code>augment.func()</code> can also be simply
a function of <code>x</code> and <code>y</code>. This function is used for efficiency augmentation.
When the form of the augmentation function is correct, it can provide efficient estimation of the subgroups. Some examples of possible
augmentation functions are:
</p>
<p>Example 1: <code>augment.func &lt;- function(x, y) {lmod &lt;- lm(y ~ x); return(fitted(lmod))}</code>
</p>
<p>Example 2:
</p>
<pre>
augment.func &lt;- function(x, y, trt) {
    data &lt;- data.frame(x, y, trt)
    lmod &lt;- lm(y ~ x * trt)
    ## get predictions when trt = 1
    data$trt &lt;- 1
    preds_1  &lt;- predict(lmod, data)

    ## get predictions when trt = -1
    data$trt &lt;- -1
    preds_n1 &lt;- predict(lmod, data)

    ## return predictions averaged over trt
    return(0.5 * (preds_1 + preds_n1))
}
</pre>
<p>For binary and time-to-event outcomes, make sure that predictions are returned on the scale of the predictors
</p>
<p>Example 3:
</p>
<pre>augment.func &lt;- function(x, y) {
        bmod &lt;- glm(y ~ x, family = binomial())
        return(predict(bmod, type = "link"))
    }
 </pre>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.custom.loss</code></td>
<td>
<p>A function which <em>minimizes</em> a user-specified
custom loss function M(y,v) to be used in model fitting.
If provided, <code>fit.custom.loss</code> should take the modified
design matrix (which includes an intercept term)
as an argument and the responses and optimize a
custom weighted loss function.
</p>
<p>The loss function <code class="reqn">M(y, v)</code> to be minimized <strong>MUST</strong> meet
the following two criteria:
</p>

<ol>
<li> <p><code class="reqn">D_M(y, v) = \partial M(y, v)/\partial v </code> must be increasing in v for each fixed y. <code class="reqn">D_M(y, v)</code> is the partial
derivative of the loss function M(y, v) with respect to v
</p>
</li>
<li> <p><code class="reqn">D_M(y, 0)</code> is monotone in y
</p>
</li>
</ol>
<p>An example of a valid loss function is <code class="reqn">M(y, v) = (y - v)^2</code>. In this case <code class="reqn">D_M(y, v) = -2(y - v)</code>.
See Chen et al. (2017) for more details on the
restrictions on the loss function <code class="reqn">M(y, v)</code>.
</p>
<p>The provided function <strong>MUST</strong> return a list with the following elements:
</p>

<ul>
<li>
<p><code>predict</code> a function that inputs a design matrix and a 'type' argument for the type of predictions and outputs
a vector of predictions on the scale of the linear predictor. Note that the matrix provided to 'fit.custom.loss'
has a column appended to the first column of <code>x</code> corresponding to the treatment main effect.
Thus, the prediction function should deal with this,
e.g. <code>predict(model, cbind(1, x))</code>
</p>
</li>
<li>
<p><code>model</code>  a fitted model object returned by the underlying fitting function
</p>
</li>
<li>
<p><code>coefficients</code> if the underlying fitting function yields a vector of coefficient estimates, they should be provided here
</p>
</li>
</ul>
<p>The provided function <strong>MUST</strong> be a function
with the following arguments:
</p>

<ol>
<li>
<p><code>x</code> design matrix
</p>
</li>
<li>
<p><code>y</code> vector of responses
</p>
</li>
<li>
<p><code>weights</code> vector for observations weights. The underlying loss function <strong>MUST</strong> have samples weighted according
to this vector. See below example
</p>
</li>
<li>
<p><code>...</code> additional arguments passed via '<code>...</code>'. This can be used so that users can specify more arguments to the
underlying fitting function if so desired.
</p>
</li>
</ol>
<p>The provided function can also optionally take the following arguments:
</p>

<ul>
<li>
<p><code>match.id</code> vector of case/control cluster IDs. This is useful if cross validation is used in the underlying fitting function
in which case it is advisable to sample whole clusters randomly instead of individual observations.
</p>
</li>
<li>
<p><code>offset</code> if efficiency augmentation is used, the predictions from the outcome model from <code>augment.func</code>
will be provided via the <code>offset</code> argument, which can be used as an offset in the underlying fitting function
as a means of incorporating the efficiency augmentation model's predictions
</p>
</li>
<li>
<p><code>trt</code> vector of treatment statuses
</p>
</li>
<li>
<p><code>family</code> family of outcome
</p>
</li>
<li>
<p><code>n.trts</code> numer of treatment levels. Can be useful if there are more than 2 treatment levels
</p>
</li>
</ul>
<p>Example 1: Here we minimize <code class="reqn">M(y, v) = (y - v)^2</code>
</p>
<pre>
 fit.custom.loss &lt;- function(x, y, weights, ...) {
     df &lt;- data.frame(y = y, x)

     # minimize squared error loss with NO lasso penalty
     lmf &lt;- lm(y ~ x - 1, weights = weights,
               data = df, ...)

     # save coefficients
     cfs = coef(lmf)

     # create prediction function. Notice
     # how a column of 1's is appended
     # to ensure treatment main effects are included
     # in predictions
     prd = function(x, type = "response")
     {
         dfte &lt;- cbind(1, x)
         colnames(dfte) &lt;- names(cfs)
         predict(lmf, data.frame(dfte))
     }
     # return lost of required components
     list(predict = prd, model = lmf, coefficients = cfs)
 }
 </pre>
<p>Example 2: <code class="reqn">M(y, v) = y\exp(-v)</code>
</p>
<pre>
 fit.expo.loss &lt;- function(x, y, weights, ...)
 {
     ## define loss function to be minimized
     expo.loss &lt;- function(beta, x, y, weights) {
         sum(weights * y * exp(-drop(tcrossprod(x, t(beta) )))
     }

     # use optim() to minimize loss function
     opt &lt;- optim(rep(0, NCOL(x)), fn = expo.loss, x = x, y = y, weights = weights)

     coefs &lt;- opt$par

     pred &lt;- function(x, type = "response") {
         tcrossprod(cbind(1, x), t(coefs))
     }

     # return list of required components
     list(predict = pred, model = opt, coefficients = coefs)
 }
 </pre>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutpoint</code></td>
<td>
<p>numeric value for patients with benefit scores above which
(or below which if <code>larger.outcome.better = FALSE</code>)
will be recommended to be in the treatment group. Can also set <code>cutpoint = "median"</code>, which will
use the median value of the benefit scores as the cutpoint or can set specific quantile values via <code>"quantx"</code>
where <code>"x"</code> is a number between 0 and 100 representing the quantile value; e.g. <code>cutpoint = "quant75"</code>
will use the 75th perent upper quantile of the benefit scores as the quantile.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>larger.outcome.better</code></td>
<td>
<p>boolean value of whether a larger outcome is better/preferable. Set to <code>TRUE</code>
if a larger outcome is better/preferable and set to <code>FALSE</code> if a smaller outcome is better/preferable. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference.trt</code></td>
<td>
<p>which treatment should be treated as the reference treatment. Defaults to the first level of <code>trt</code>
if <code>trt</code> is a factor or the first alphabetical or numerically first treatment level. Not used for multiple treatment fitting with OWL-type losses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retcall</code></td>
<td>
<p>boolean value. if <code>TRUE</code> then the passed arguments will be saved. Do not set to <code>FALSE</code>
if the <code>validate.subgroup()</code> function will later be used for your fitted subgroup model. Only set to <code>FALSE</code>
if memory is limited as setting to <code>TRUE</code> saves the design matrix to the fitted object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>options to be passed to underlying fitting function. For all <code>loss</code> options with 'lasso',
this will be passed to <code>cv.glmnet</code>. For all <code>loss</code> options with 'gam', this will
be passed to <code>gam</code> from the <span class="pkg">mgcv</span> package
Note that for all <code>loss</code> options that use <code>gam()</code>
from the <span class="pkg">mgcv</span> package,
the user cannot supply the <code>gam</code> argument <code>method</code> because it is also an argument of <code>fit.subgroup</code>, so
instead, to change the <code>gam method</code> argument, supply <code>method.gam</code>, ie <code>method.gam = "REML"</code>.
</p>
<p>For all <code>loss</code> options with 'hinge', this will be passed to both <code>weighted.ksvm</code> and
<code>ipop</code> from the <span class="pkg">kernlab</span> package</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>"subgroup_fitted"</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>predict</code></td>
<td>
<p>A function that returns predictions of the covariate-conditional treatment effects </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>An object returned by the underlying fitting function used. For example, if the lasso use used to fit
the underlying subgroup identification model, this will be an object returned by <code>cv.glmnet</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p> If the underlying subgroup identification model is parametric, <code>coefficients</code> will contain
the estimated coefficients of the model. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call that produced the returned object. If <code>retcall = TRUE</code>, this will contain all objects
supplied to <code>fit.subgroup()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>The family corresponding to the outcome provided</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>The loss function used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The method used (either weighting or A-learning)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propensity.func</code></td>
<td>
<p>The propensity score function used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>larger.outcome.better</code></td>
<td>
<p>If larger outcomes are preferred for this model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutpoint</code></td>
<td>
<p>Benefit score cutoff value used for determining subgroups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.names</code></td>
<td>
<p>The names of all variables used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.trts</code></td>
<td>
<p>The number of treatment levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comparison.trts</code></td>
<td>
<p>All treatment levels other than the reference level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference.trt</code></td>
<td>
<p>The reference level for the treatment. This should usually be the control group/level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trts</code></td>
<td>
<p>All treatment levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trt.received</code></td>
<td>
<p>The vector of treatment assignments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi.x</code></td>
<td>
<p>A vector of propensity scores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A vector of outcomes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>benefit.scores</code></td>
<td>
<p>A vector of conditional treatment effects, i.e. benefit scores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recommended.trts</code></td>
<td>
<p>A vector of treatment recommendations (i.e. for each patient,
which treatment results in the best expected potential outcomes)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subgroup.trt.effects</code></td>
<td>
<p>(Biased) estimates of the conditional treatment effects
and conditional outcomes. These are essentially just empirical averages within
different combinations of treatment assignments and treatment recommendations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>individual.trt.effects</code></td>
<td>
<p>estimates of the individual treatment effects as returned by
<code>treat.effects</code></p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Huling. J.D. and Yu, M. (2021), Subgroup Identification Using the personalized Package.
Journal of Statistical Software 98(5), 1-60. doi:10.18637/jss.v098.i05
</p>
<p>Chen, S., Tian, L., Cai, T. and Yu, M. (2017), A general statistical framework for subgroup identification
and comparative treatment scoring. Biometrics. doi:10.1111/biom.12676 <a href="https://doi.org/10.1111/biom.12676">doi:10.1111/biom.12676</a>
</p>
<p>Xu, Y., Yu, M., Zhao, Y. Q., Li, Q., Wang, S., &amp; Shao, J. (2015),
Regularized outcome weighted subgroup identification for differential treatment effects. Biometrics, 71(3), 645-653.
doi: 10.1111/biom.12322 <a href="https://doi.org/10.1111/biom.12322">doi:10.1111/biom.12322</a>
</p>
<p>Zhao, Y., Zeng, D., Rush, A. J., &amp; Kosorok, M. R. (2012),
Estimating individualized treatment rules using outcome weighted learning.
Journal of the American Statistical Association, 107(499), 1106-1118. doi: 10.1080/01621459.2012.695674
</p>


<h3>See Also</h3>

<p><code>validate.subgroup</code> for function which creates validation results for subgroup
identification models, <code>predict.subgroup_fitted</code> for a prediction function for fitted models
from <code>fit.subgroup</code>, <code>plot.subgroup_fitted</code> for a function which plots
results from fitted models, and <code>print.subgroup_fitted</code>
for arguments for printing options for <code>fit.subgroup()</code>.
from <code>fit.subgroup</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(personalized)

set.seed(123)
n.obs  &lt;- 500
n.vars &lt;- 15
x &lt;- matrix(rnorm(n.obs * n.vars, sd = 3), n.obs, n.vars)


# simulate non-randomized treatment
xbetat   &lt;- 0.5 + 0.5 * x[,7] - 0.5 * x[,9]
trt.prob &lt;- exp(xbetat) / (1 + exp(xbetat))
trt01    &lt;- rbinom(n.obs, 1, prob = trt.prob)

trt      &lt;- 2 * trt01 - 1

# simulate response
# delta below drives treatment effect heterogeneity
delta &lt;- 2 * (0.5 + x[,2] - x[,3] - x[,11] + x[,1] * x[,12] )
xbeta &lt;- x[,1] + x[,11] - 2 * x[,12]^2 + x[,13] + 0.5 * x[,15] ^ 2
xbeta &lt;- xbeta + delta * trt

# continuous outcomes
y &lt;- drop(xbeta) + rnorm(n.obs, sd = 2)

# binary outcomes
y.binary &lt;- 1 * (xbeta + rnorm(n.obs, sd = 2) &gt; 0 )

# count outcomes
y.count &lt;- round(abs(xbeta + rnorm(n.obs, sd = 2)))

# time-to-event outcomes
surv.time &lt;- exp(-20 - xbeta + rnorm(n.obs, sd = 1))
cens.time &lt;- exp(rnorm(n.obs, sd = 3))
y.time.to.event  &lt;- pmin(surv.time, cens.time)
status           &lt;- 1 * (surv.time &lt;= cens.time)

# create function for fitting propensity score model
prop.func &lt;- function(x, trt)
{
    # fit propensity score model
    propens.model &lt;- cv.glmnet(y = trt,
                               x = x, family = "binomial")
    pi.x &lt;- predict(propens.model, s = "lambda.min",
                    newx = x, type = "response")[,1]
    pi.x
}


####################  Continuous outcomes ################################


subgrp.model &lt;- fit.subgroup(x = x, y = y,
                           trt = trt01,
                           propensity.func = prop.func,
                           loss   = "sq_loss_lasso",
                           # option for cv.glmnet,
                           # better to use 'nfolds=10'
                           nfolds = 3)

summary(subgrp.model)

# estimates of the individual-specific
# treatment effect estimates:
subgrp.model$individual.trt.effects

# fit lasso + gam model with REML option for gam


subgrp.modelg &lt;- fit.subgroup(x = x, y = y,
                            trt = trt01,
                            propensity.func = prop.func,
                            loss   = "sq_loss_lasso_gam",
                            method.gam = "REML",     # option for gam
                            nfolds = 5)              # option for cv.glmnet

subgrp.modelg


####################  Using an augmentation function #####################
## augmentation funcions involve modeling the conditional mean E[Y|T, X]
## and returning predictions that are averaged over the treatment values
## return &lt;- 1/2 * (hat{E}[Y|T=1, X] + hat{E}[Y|T=-1, X])
##########################################################################

augment.func &lt;- function(x, y, trt) {
    data &lt;- data.frame(x, y, trt)
    xm &lt;- model.matrix(y~trt*x-1, data = data)

    lmod &lt;- cv.glmnet(y = y, x = xm)
    ## get predictions when trt = 1
    data$trt &lt;- 1
    xm &lt;- model.matrix(y~trt*x-1, data = data)
    preds_1  &lt;- predict(lmod, xm, s = "lambda.min")

    ## get predictions when trt = -1
    data$trt &lt;- -1
    xm &lt;- model.matrix(y~trt*x-1, data = data)
    preds_n1  &lt;- predict(lmod, xm, s = "lambda.min")

    ## return predictions averaged over trt
    return(0.5 * (preds_1 + preds_n1))
}


subgrp.model.aug &lt;- fit.subgroup(x = x, y = y,
                           trt = trt01,
                           propensity.func = prop.func,
                           augment.func    = augment.func,
                           loss   = "sq_loss_lasso",
                           # option for cv.glmnet,
                           # better to use 'nfolds=10'
                           nfolds = 3)              # option for cv.glmnet

summary(subgrp.model.aug)


####################  Binary outcomes ####################################

# use logistic loss for binary outcomes
subgrp.model.bin &lt;- fit.subgroup(x = x, y = y.binary,
                           trt = trt01,
                           propensity.func = prop.func,
                           loss   = "logistic_loss_lasso",
                           type.measure = "auc",    # option for cv.glmnet
                           nfolds = 3)              # option for cv.glmnet

subgrp.model.bin


####################  Count outcomes #####################################

# use poisson loss for count/poisson outcomes
subgrp.model.poisson &lt;- fit.subgroup(x = x, y = y.count,
                           trt = trt01,
                           propensity.func = prop.func,
                           loss   = "poisson_loss_lasso",
                           type.measure = "mse",    # option for cv.glmnet
                           nfolds = 3)              # option for cv.glmnet

subgrp.model.poisson


####################  Time-to-event outcomes #############################

library(survival)

subgrp.model.cox &lt;- fit.subgroup(x = x, y = Surv(y.time.to.event, status),
                           trt = trt01,
                           propensity.func = prop.func,
                           loss   = "cox_loss_lasso",
                           nfolds = 3)              # option for cv.glmnet

subgrp.model.cox



####################  Using custom loss functions ########################

## Use custom loss function for binary outcomes

fit.custom.loss.bin &lt;- function(x, y, weights, offset, ...) {
    df &lt;- data.frame(y = y, x)

    # minimize logistic loss with NO lasso penalty
    # with allowance for efficiency augmentation
    glmf &lt;- glm(y ~ x - 1, weights = weights,
                offset = offset, # offset term allows for efficiency augmentation
                family = binomial(), ...)

    # save coefficients
    cfs = coef(glmf)

    # create prediction function.
    prd = function(x, type = "response") {
         dfte &lt;- cbind(1, x)
         colnames(dfte) &lt;- names(cfs)
         ## predictions must be returned on the scale
         ## of the linear predictor
         predict(glmf, data.frame(dfte), type = "link")
    }
    # return lost of required components
    list(predict = prd, model = glmf, coefficients = cfs)
}


subgrp.model.bin.cust &lt;- fit.subgroup(x = x, y = y.binary,
                                 trt = trt01,
                                 propensity.func = prop.func,
                                 fit.custom.loss = fit.custom.loss.bin)

subgrp.model.bin.cust



## try exponential loss for
## positive outcomes

fit.expo.loss &lt;- function(x, y, weights, ...)
{
    expo.loss &lt;- function(beta, x, y, weights) {
        sum(weights * y * exp(-drop(x %*% beta)))
    }

    # use optim() to minimize loss function
    opt &lt;- optim(rep(0, NCOL(x)), fn = expo.loss, x = x, y = y, weights = weights)

    coefs &lt;- opt$par

    pred &lt;- function(x, type = "response") {
        tcrossprod(cbind(1, x), t(coefs))
    }

    # return list of required components
    list(predict = pred, model = opt, coefficients = coefs)
}


# use exponential loss for positive outcomes
subgrp.model.expo &lt;- fit.subgroup(x = x, y = y.count,
                                  trt = trt01,
                                  propensity.func = prop.func,
                                  fit.custom.loss = fit.expo.loss)

subgrp.model.expo



</code></pre>


</div>
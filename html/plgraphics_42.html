<div class="container">

<table style="width: 100%;"><tr>
<td>leverage</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get leverage values</h2>

<h3>Description</h3>

<p>Extracts the leverage component of a fit object using the
<code>na.action</code> component if available
</p>


<h3>Usage</h3>

<pre><code class="language-R">leverage(object)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>an object containing a component <code>fit$leverage</code> and possibly
a component <code>fit$na.action</code>
</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The difference to <code>hatvalues</code> is that <code>leverage</code> does not
call <code>influence</code> and therefore does not require residuals.
It is therefore simpler and more widely applicable.
</p>
<p>The function uses the <code>qr</code> decomposition of <code>object</code>.
If necessary, it generate it.
</p>
<p>The leverage is the squared Mahalanobis distance of the observation
from the center of the design X (<code>model.matrix</code>) with
"covariance" X^T X. If there are weights (<code>object$weights</code>),
the weighted center and "covariance" are used, and the distances are
multiplied by the weights.
To obtain the distances in the latter case, "de-weight" the leverages
by dividing them by the weights.
</p>


<h3>Value</h3>

<p>The vector <code>fit$leverage</code>, possibly expanded by missing values
if <code>fit$na.action</code> has class <code>na.exclude</code>
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code>hat; hatvalues; influence</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(d.blast)
r.blast &lt;-
  lm(log10(tremor)~location+log10(distance)+log10(charge), data=d.blast)
showd(leverage(r.blast))
</code></pre>


</div>
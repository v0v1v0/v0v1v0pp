<div class="container">

<table style="width: 100%;"><tr>
<td>icp_ppm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function that fits the multivariate independent product partition
change point model</h2>

<h3>Description</h3>

<p><code>icp_ppm</code> is a function that fits a Bayesian product partition change
point model. Each series is treated independently.
</p>


<h3>Usage</h3>

<pre><code class="language-R">icp_ppm(ydata,
         a0, b0,
         mltypes,
         thetas,
         nburn, nskip, nsave,
         verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ydata</code></td>
<td>
<p>An <code class="reqn">L \times n</code> data matrix, where <code class="reqn">L</code> is the number of
time series and <code class="reqn">n</code>, the number of time points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p>Vector of dimension <code class="reqn">L</code> with shape 1 Beta parameters (see
Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>Vector of dimension <code class="reqn">L</code> with shape 2 Beta parameters (see
Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mltypes</code></td>
<td>
<p>Type of marginal likelihood. Currently only available is:
</p>

<ul><li>
<p><code>mltypes = 1</code>. Observations within a block are conditionally
independent <code class="reqn">Normal(\mu, \sigma^2)</code> variates with mean <code class="reqn">\mu</code> and
variance <code class="reqn">\sigma^2</code>. The desired marginal likelihood is obtained after
integrating <code class="reqn">(\mu, \sigma^2)</code> with respect to a
<code class="reqn">Normal-Inverse-Gamma(\mu_0, \kappa_0, \alpha_0, \beta_0)</code>
prior.
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thetas</code></td>
<td>
<p>An <code class="reqn">L \times q</code> matrix containing hyperparameters associated
with the marginal likelihood. The number of rows <code class="reqn">(L)</code> corresponds to the
number of series. The number of columns <code class="reqn">(q)</code> depend on the marginal
likelihood:
</p>

<ul><li>
<p>  If <code>mltypes = 1</code>, then <code class="reqn">q = 4</code> and <code>thetas</code> equals
the hyperparameter <code class="reqn">(\mu_{0}, \kappa_{0}, \alpha_{0}, \beta_{0})</code> of
the Normal-Inverse-Gamma prior.
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nburn</code></td>
<td>
<p>The number of initial MCMC iterates to be discarded as burn-in.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nskip</code></td>
<td>
<p>The amount to thinning that should be applied to the MCMC chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsave</code></td>
<td>
<p>Then number of MCMC iterates to be stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical indicating whether to print to screen the MCMC
progression. The default value is <code>verbose = FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>As described in Barry and Hartigan (1992) and Loschi and Cruz (2002), for each
time series
<code class="reqn">\boldsymbol{y}_{i} = (y_{i,1}, \ldots , y_{i,n})'</code>:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{y}_{i} \mid \rho_{i} \sim
\prod_{j = 1}^{b_{i}}\mathcal{F}(\boldsymbol{y}_{i,j} \mid
\boldsymbol{\theta}_{i})</code>
</p>

<p style="text-align: center;"><code class="reqn">\rho_{i} \mid p_{i} \sim p_{i}^{b_{i} - 1}(1 - p_{i})^{n - b_{i}}</code>
</p>

<p style="text-align: center;"><code class="reqn">p_{i} \sim Beta(a_{i,0}, b_{i,0}).</code>
</p>

<p>Here, <code class="reqn">\rho_{i} = \{S_{i,1}, \ldots , S_{i,b_{i}}\}</code> is a partition of
the set <code class="reqn">\{1, \ldots , n\}</code> into <code class="reqn">b_{i}</code> contiguous blocks, and
<code class="reqn">\boldsymbol{y}_{i,j} = (y_{i,t} : t \in S_{i,j})'</code>. Also,
<code class="reqn">\mathcal{F}( \cdot \mid \boldsymbol{\theta}_{i})</code> is a marginal
likelihood function which depends on the nature of <code class="reqn">\boldsymbol{y}_{i}</code>,
indexed by a hyperparameter <code class="reqn">\boldsymbol{\theta}_{i}</code>. Notice that
<code class="reqn">p_{i}</code> is the probability of observing a change point in series <code class="reqn">i</code>,
at each time <code class="reqn">t \in \{2, \ldots , n\}</code>.
</p>


<h3>Value</h3>

<p>The function returns a list containing arrays filled with MCMC iterates
corresponding to model parameters. In order to provide more detail, in what
follows let <code class="reqn">M</code> be the number of MCMC iterates collected. The output list
contains the following:
</p>

<ul>
<li>
<p>C. An <code class="reqn">M \times \{L(n - 1)\}</code> matrix containing MCMC iterates
associated with each series indicators of a change point. The <code class="reqn">m</code>th
row in <code>C</code> is divided into <code class="reqn">L</code> blocks; the first <code class="reqn">(n - 1)</code>
change point indicators for time series 1, the next <code class="reqn">(n - 1)</code> change
point indicators for time series 2, and so on.
</p>
</li>
<li>
<p>P. An <code class="reqn">M \times \{L(n - 1)\}</code> matrix containing MCMC iterates
associated with each series probability of a change point. The <code class="reqn">m</code>th
row in <code>P</code> is divided into <code class="reqn">L</code> blocks; the first <code class="reqn">(n - 1)</code>
change point probabilities for time series 1, the next <code class="reqn">(n - 1)</code> change
point probabilities for time series 2, and so on.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
# Generate data that has two series, each with 100 observations
y1 &lt;- replicate(25, rnorm(4, c(-1, 0, 1, 2), c(0.1, 0.25, 0.5, 0.75)))
y2 &lt;- replicate(25, rnorm(4, c(2, 1, 0, -2), c(0.1, 0.25, 0.5, 0.75)))
y &lt;- rbind(c(t(y1)), c(t(y2)))
n &lt;- ncol(y)
# Marginal likelihood parameters
thetas &lt;- matrix(1, nrow = 2, ncol = 4)
thetas[1,] &lt;- c(0, 1, 2, 1)
thetas[2,] &lt;- c(0, 1, 2, 1)

# Fit the Bayesian ppm change point model
fit &lt;- icp_ppm(ydata = y,
               a0 = c(1, 1),
               b0 = c(1, 1),
               mltypes = c(1, 1),
               thetas = thetas,
               nburn = 1000, nskip = 1, nsave = 1000)

cpprobsL &lt;- matrix(apply(fit$C,2,mean), nrow=n-1, byrow=FALSE)



</code></pre>


</div>
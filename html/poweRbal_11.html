<div class="container">

<table style="width: 100%;"><tr>
<td>genGrowTree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generation of rooted binary trees under tree growing models (no extinction)</h2>

<h3>Description</h3>

<p><code>genGrowTree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under a specified
discrete-time tree growing model without extinction.
These tree growing models act at the leaves by varying their speciation
rates according to a parameter <code>ZETA</code> or variance <code>SIGMA</code>. They
may also depend on so-called trait values of the leaves (e.g., continuous or
discrete age, or another numeric trait that affects fitness).<br>
You may choose an already built-in model (see <code>use_built_in</code>) or
specify a (new) model by defining how the rates (and optionally traits)
change in every time step (see parameters <code>childRates</code> and
<code>otherRates</code> as well as <code>childTraits</code> and
<code>otherTraits</code>; see also Table 5 of the supplementary material of
the corresponding manuscript).
</p>


<h3>Usage</h3>

<pre><code class="language-R">genGrowTree(
  n,
  STARTING_RATE = 1,
  STARTING_TRAIT = 10,
  ZETA = 1,
  SIGMA = 0,
  childRates,
  otherRates,
  childTraits = NULL,
  otherTraits = NULL,
  use_built_in = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.<br>
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>STARTING_RATE</code></td>
<td>
<p>Positive numeric value (default = 1) which specifies the
initial rate at which the speciation events occur (has only influence on the
edge length, not on the tree topology).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>STARTING_TRAIT</code></td>
<td>
<p>Numeric value (default = 10) which specifies
the initial state of a trait.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ZETA</code></td>
<td>
<p>Constant non-negative numeric value (default = 1) which can
influence the speciation rates. Can also be a vector if used as such when
defining the functions <code>childRates</code>, <code>otherRates</code>,
<code>childTraits</code>, and <code>otherTraits</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SIGMA</code></td>
<td>
<p>Constant positive numeric value (default = 0) which can influence
the speciation rates. Can also be a vector if used as such when defining the
functions <code>childRates</code>, <code>otherRates</code>, <code>childTraits</code>, and
<code>otherTraits</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>childRates</code></td>
<td>
<p>A function that generates two speciation rates for the
children emerging from a speciation event based on various factors. <br>
Necessary if <code>use_built_in</code> is not specified.
<code>childTraits</code> works similarly but is executed before
<code>childRates</code>. <br>
All available parameters are: <br></p>

<ul>
<li>
<p> the starting rate <code>sr</code>,  <br></p>
</li>
<li>
<p> the starting trait value <code>st</code>,  <br></p>
</li>
<li>
<p> the parent's rate <code>pr</code>,  <br></p>
</li>
<li>
<p> the parent's trait value <code>pt</code>,  <br></p>
</li>
<li>
<p> the children's trait values <code>ct</code> (vector <code>ct[1]</code> and
<code>ct[2]</code>), <br></p>
</li>
<li>
<p> the parameters zeta <code>ze</code>  <br></p>
</li>
<li>
<p> and sigma <code>si</code>. <br><br>
All parameters have to appear in the function definition but not
necessarily in the body of the function. Trait values are NA, if
<code>childTraits</code> and <code>otherTraits</code> is not given.<br>
Example: <br><code>function (sr, st, pr, pt, ct, ze, si) return(c(pr*ze,
pr*(1-ze)))</code> for biased speciation.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>otherRates</code></td>
<td>
<p>A function that generates a new speciation rate for all
leaves not affected by the speciation event (all but parent and children)
based on various factors. The function is applied after the speciation event,
i.e., after <code>childRates/Traits</code>.<br>
Necessary if <code>use_built_in</code> is not specified.
<code>otherTraits</code> works similarly. <br>
All available parameters are: <br></p>

<ul>
<li>
<p> the starting rate <code>sr</code>,  <br></p>
</li>
<li>
<p> the starting trait value <code>st</code>,  <br></p>
</li>
<li>
<p> the leaf's old rate <code>or</code>,  <br></p>
</li>
<li>
<p> the leaf's old trait value <code>ot</code>, <br></p>
</li>
<li>
<p> the parameters zeta <code>ze</code>  <br></p>
</li>
<li>
<p> and sigma <code>si</code>. <br><br>
All parameters have to appear in the function definition but not
necessarily in the body of the function. Trait values are NA, if
<code>childTraits</code> and <code>otherTraits</code> is not given. <br>
Example: <br><code>function (sr, st, or, ot, ze, si) return(or*ze)</code> for
age-step-based fertility.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>childTraits</code></td>
<td>
<p>An optional function (default = NULL) that generates two
trait values for the children emerging from a speciation event based on
various factors. <br>
See <code>childRates</code> for available parameters (except <code>ct</code>) and
explanations. Not necessary; is only applied if not NULL.<br>
Example: <br><code>function (sr, st, pr, pt, ze, si)
return(c(0, 0))</code> for age.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>otherTraits</code></td>
<td>
<p>An optional function (default = NULL) that generates a new
trait value for all leaves not affected by the speciation event (all but
parent and children) based on various factors. <br>
See <code>otherRates</code> for available parameters and explanations. <br>
Not necessary; is only applied if not NULL.<br>
Example:<br><code>function (sr, st, or, ot, ze, si) return(ot+1)</code>
for discrete age (age in time steps).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_built_in</code></td>
<td>
<p>Optional (default = NULL): Character specifying which of
the already implemented models should be used. Overwrites <code>childRates</code>,
<code>otherRates</code>, <code>childTraits</code>, and <code>otherTraits</code>.<br>
Here is a list of available models with their (abbreviated) underlying
functions given in parentheses  (in order <code>childRates</code>,
<code>otherRates</code>; then <code>childTraits</code> and <code>otherTraits</code>
if necessary): <br></p>

<ul>
<li>
<p> "DCO_sym": Symmetric direct-children-only, <code>ZETA</code>&gt;0
(c(sr ze, sr ze), sr) <br></p>
</li>
<li>
<p> "DCO_asym": Asymmetric direct-children-only, <code>ZETA</code>&gt;0
(c(sz, pr), sr) <br></p>
</li>
<li>
<p> "IF_sym": Symmetric inherited fertility, <code>ZETA</code>&gt;0
(c(pr ze, pr ze), or) <br></p>
</li>
<li>
<p> "IF_asym": Asymmetric inherited fertility, <code>ZETA</code>&gt;0
(c(pr ze, pr), or) <br></p>
</li>
<li>
<p> "IF-diff": Unequal fertility inheritance, <code>ZETA</code>&gt;=1
(c(2 pr ze / (ze+1), 2 pr / (ze+1)), or)<br></p>
</li>
<li>
<p> "biased": Biased speciation, <code>ZETA</code> &gt;=0 and &lt;=1
(c(pr ze, pr (1-ze)), or)<br></p>
</li>
<li>
<p> "ASB": Age-step-based fertility, <code>ZETA</code>&gt;0
(c(sr, sr), or ze)<br></p>
</li>
<li>
<p> "simpleBrown_sym": Symmetric simple Brownian, <code>SIGMA</code>&gt; =0
(c(max{pr+ rnorm(1, mean=0, sd=si),1e-100},
max{pr+ rnorm(1, mean=0, sd=si),1e-100}), or) <br></p>
</li>
<li>
<p> "simpleBrown_asym": Asymmetric simple Brownian, <code>SIGMA</code>&gt;=0
(c(max{pr+ rnorm(1, mean=0, sd=si),1e-100}, pr), or) <br></p>
</li>
<li>
<p> "lin-Brown_sym": Sym. punctuated(-intermittent) linear-Brownian,
<code>SIGMA</code> vector with two values &gt;=0 <br>
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])),
10^(log(ct[2])+ rnorm(1, mean=0, sd=si[1]))), or; <br>
c(max{pt + rnorm(1, mean=0, sd=si[2]),1e-100},
max{pt + rnorm(1, mean=0, sd=si[2]),1e-100}), ot) <br></p>
</li>
<li>
<p> "lin-Brown_asym": Asym. punctuated(-intermittent) linear-Brownian,
<code>SIGMA</code> vector with two values &gt;=0 <br>
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])), pr), or; <br>
c(max{pt + rnorm(1, mean=0, sd=si[2]),1e-100}, pt, ot) <br></p>
</li>
<li>
<p> "lin-Brown-bounded_sym": Bounded sym. punctuated(-intermittent)
linear-Brownian,  <code>SIGMA</code> vector with two values &gt;=0,
<code>STARTING_TRAIT</code> is automatically set to 10 <br>
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])),
10^(log(ct[2])+ rnorm(1, mean=0, sd=si[1]))), or; <br>
c(min{max{pt + rnorm(1, mean=0, sd=si[2]),1e-100},20},
min{max{pt + rnorm(1, mean=0, sd=si[2]),1e-100},20}), ot) <br></p>
</li>
<li>
<p> "lin-Brown-bounded_asym": Bounded asym. punctuated(-intermittent)
linear-Brownian, <code>SIGMA</code> vector with two values &gt;=0 <br>
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])), pr), or; <br>
c(min{max{pt + rnorm(1, mean=0, sd=si[2]),1e-100},20}, pt), ot) <br></p>
</li>
<li>
<p> "log-Brown_sym": Sym. punctuated(-intermittent) log-Brownian,
<code>SIGMA</code> vector with two values &gt;=0 <br>
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])),
10^(log(ct[2])+ rnorm(1, mean=0, sd=si[1]))), or; <br>
c(10^(log(pt)+ rnorm(1, mean=0, sd=si[2])),
10^(log(pt)+ rnorm(1, mean=0, sd=si[2]))), ot) <br></p>
</li>
<li>
<p> "log-Brown_asym": Asym. punctuated(-intermittent) log-Brownian,
<code>SIGMA</code> vector with two values &gt;=0 <br>
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])), pr), or; <br>
10^(c(log(pt)+ rnorm(1, mean=0, sd=si[2])), pt), ot)
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>genGrowTree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>References</h3>


<ul>
<li>
<p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic models.
arXiv:2406.05185, 2024.
</p>
</li>
<li>
<p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic
models: Supplementary material. https://tinyurl.com/278cwdh8, 2024.
</p>
</li>
<li>
<p> M. G. B. Blum and O. Francois. On statistical tests of phylogenetic tree
imbalance: the Sackin and other indices revisited. Mathematical Biosciences,
195(2):141–153, 2005.
</p>
</li>
<li>
<p> S. B. Heard. Patterns in phylogenetic tree balance with variable and
evolving speciation rates. Evolution, 50(6):2141–2148, 1996.
</p>
</li>
<li>
<p> S. J. Kersting. Genetic programming as a means for generating improved
tree balance indices (Master’s thesis, University of Greifswald), 2020.
</p>
</li>
<li>
<p> M. Kirkpatrick and M. Slatkin. Searching for evolutionary patterns in the
shape of a phylogenetic tree. Evolution, 47(4):1171–1181, 1993.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">genGrowTree(n = 5, use_built_in = "IF_sym", ZETA = 2)
</code></pre>


</div>
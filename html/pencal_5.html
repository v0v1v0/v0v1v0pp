<div class="container">

<table style="width: 100%;"><tr>
<td>fit_mlpmms</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Step 1 of PRC-MLPMM (estimation of the linear mixed models)</h2>

<h3>Description</h3>

<p>This function performs the first step for the estimation
of the PRC-MLPMM model proposed in Signorelli et al. (2021)
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit_mlpmms(y.names, fixefs, ranef.time, randint.items = TRUE, long.data,
  surv.data, t.from.base, n.boots = 0, n.cores = 1, verbose = TRUE,
  seed = 123, maxiter = 100, conv = rep(0.001, 3),
  lcmm.warnings = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y.names</code></td>
<td>
<p>a list with the names of the
response variables which the MLPMMs have to be fitted to.
Each element in the list contains all the items used to 
reconstruct a latent biological process of interest</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixefs</code></td>
<td>
<p>a fixed effects formula for the model, where the
time variable (specified also in <code>ranef.time</code>) is
included as first element and within the function 
<code>contrast()</code>. Examples: <code>~ contrast(age)</code>, 
<code>~ contrast(age) + group + treatment</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranef.time</code></td>
<td>
<p>a character with the name of the time variable 
for which to include a shared random slope</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randint.items</code></td>
<td>
<p>logical: should item-specific random intercepts
be included in the MLCMMs? Default is <code>TRUE</code>. It can also be a
vector, with different values for different elements of <code>y.names</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>long.data</code></td>
<td>
<p>a data frame with the longitudinal predictors,
comprehensive of a variable called <code>id</code> with the subject 
ids</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>surv.data</code></td>
<td>
<p>a data frame with the survival data and (if 
relevant) additional baseline covariates. <code>surv.data</code> should at least
contain a subject id (called <code>id</code>), the time to event outcome  
(<code>time</code>), and binary event variable (<code>event</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.from.base</code></td>
<td>
<p>name of the variable containing time from 
baseline in <code>long.data</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.boots</code></td>
<td>
<p>number of bootstrap samples to be used in the
cluster bootstrap optimism correction procedure (CBOCP). If 0, no
bootstrapping is performed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>number of cores to use to parallelize part of
the computations. If <code>ncores = 1</code> (default), 
no parallelization is done. Pro tip: you can use 
<code>parallel::detectCores()</code> to check how many 
cores are available on your computer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code> (default and recommended value), information
on the ongoing computations is printed in the console</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>random seed used for the bootstrap sampling. Default 
is <code>seed = 123</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>maximum number of iterations to use when calling
the function <code>multlcmm</code>. Default is 100</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p>a vector containing the three convergence criteria
(<code>convB</code>, <code>convL</code> and <code>convG</code>) to use when calling
the function <code>multlcmm</code>. Default is c(1e-3, 1e-3, 1e-3)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lcmm.warnings</code></td>
<td>
<p>logical. If TRUE, a warning is printed every 
time the (strict) convergence criteria of the <code>multlcmm</code> function
are not met. Default is <code>FALSE</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is essentially a wrapper of the 
<code>multlcmm</code> function that has the goal of simplifying
the estimation of several MLPMMs. In general, ensuring 
convergence of the algorithm implemented in <code>multlcmm</code>
is sometimes difficult, and it is hard to write a function that
can automatically solve these convergence problems. <code>fit_mplmms</code>
returns a warning when estimation did not converge for one or 
more MLPMMs. If this happens, try to change the convergence 
criteria in <code>conv</code> or the relevant <code>randint.items</code> value.
If doing this doesn't solve the problem, it is recommended to
re-estimate the specific MLPMMs for which estimation didn't converge
directly with <code>multlcmm</code>, trying to manually solve
the convergence issues
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>call.info</code>: a list containing the following function
call information: <code>call</code>, <code>y.names</code>, <code>fixefs</code>,
<code>ranef.time</code>, <code>randint.items</code>;
</p>
</li>
<li> <p><code>mlpmm.fits.orig</code>: a list with the MLPMMs fitted on the
original dataset (it should comprise as many MLPMMs as the elements
of <code>y.names</code> are);
</p>
</li>
<li> <p><code>df.sanitized</code>: a sanitized version of the supplied 
<code>long.data</code> dataframe, without the
longitudinal measurements that are taken after the event
or after censoring;
</p>
</li>
<li> <p><code>n.boots</code>: number of bootstrap samples;
</p>
</li>
<li> <p><code>boot.ids</code>: a list with the ids of bootstrapped subjects 
(when <code>n.boots &gt; 0</code>);
</p>
</li>
<li> <p><code>mlpmm.fits.boot</code>: a list of lists, which contains the MLPMMs 
fitted on each bootstrapped datasets (when <code>n.boots &gt; 0</code>).
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2024). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors. 
To appear in: The R Journal. Preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code>simulate_prcmlpmm_data</code>,
<code>summarize_mlpmms</code> (step 2),
<code>fit_prcmlpmm</code> (step 3),
<code>performance_prc</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# generate example data
set.seed(123)
n.items = c(4,2,2,3,4,2)
simdata = simulate_prcmlpmm_data(n = 100, p = length(n.items),  
             p.relev = 3, n.items = n.items, 
             type = 'u+b', seed = 1)
 
# specify options for cluster bootstrap optimism correction
# procedure and for parallel computing 
do.bootstrap = FALSE
# IMPORTANT: set do.bootstrap = TRUE to compute the optimism correction!
n.boots = ifelse(do.bootstrap, 100, 0)
more.cores = FALSE
# IMPORTANT: set more.cores = TRUE to speed computations up!
if (!more.cores) n.cores = 2
if (more.cores) {
   # identify number of available cores on your machine
   n.cores = parallel::detectCores()
   if (is.na(n.cores)) n.cores = 2
}

# step 1 of PRC-MLPMM: estimate the MLPMMs
y.names = vector('list', length(n.items))
for (i in 1:length(n.items)) {
  y.names[[i]] = paste('marker', i, '_', 1:n.items[i], sep = '')
}

step1 = fit_mlpmms(y.names, fixefs = ~ contrast(age),  
                 ranef.time = age, randint.items = TRUE, 
                 long.data = simdata$long.data, 
                 surv.data = simdata$surv.data,
                 t.from.base = t.from.base,
                 n.boots = n.boots, n.cores = n.cores)

# print MLPMM summary for marker 5 (all items involved in that MLPMM):
summary(step1, 'marker5_2')

</code></pre>


</div>
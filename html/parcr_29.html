<div class="container">

<table style="width: 100%;"><tr>
<td>zero_or_more</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Repeated application of a parser</h2>

<h3>Description</h3>

<p>Often, we want to assess whether a given structure can be successfully
parsed through repetitive application of a parser <code>p</code>. This could involve
testing the parser applied multiple times in succession or determining
its capability to be applied zero or more times.
</p>
<p>The subsequent functions are designed to address and evaluate these
scenarios.
</p>


<h3>Usage</h3>

<pre><code class="language-R">zero_or_more(p)

one_or_more(p)

exactly(n, p)

zero_or_one(p)

match_n(n, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a parser.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>a positive integer, including 0.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All these parsers with the excception of <code>match_n</code> exhibit greedy behavior
striving to apply <code>p</code> as many times as possible. If the resulting count
doesn't match the expected quantity, such as in the case of <code>exactly(n,p)</code>
where <code>p</code> successfully parses more than <code>n</code> times, then the parser fails.
In contrast, <code>match_n(n,p)</code> strictly applies <code>p</code> exactly <code>n</code> times,
preventing any further application of <code>p</code> even if <code>p</code> could potentially be
applied more often. Clearly, both functions will fail if <code>p</code> fails after
less than <code>n</code> repetitions.
</p>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
zero_or_more(p):
  (p %then% zero_or_more(p)) %or% succeed(null)

one_or_more(p):
  p %then% zero_or_more(p)

exactly(n,p):
  count = 0
  r = zero_or_more(p %using% F(x): count = count + 1; x)(x)
  if count == n then
    count = 0
    r
  else fail()(x)

zero_or_one:
  exactly(0,p) %or% exactly(1,p)

match_n(n,p):
  if n==0 then F(x): succeed(list())(x)
  else
    if n==1 then p else (p %then% match_n(n-1, p))
</pre>
<p>where <code>null</code> is the empty vector.
</p>


<h3>Examples</h3>

<pre><code class="language-R">zero_or_more(literal("A")) (c("A",LETTERS[1:5]))
zero_or_more(literal("A")) (LETTERS[2:5])

one_or_more(literal("A")) (c("A",LETTERS[1:5])) # success
one_or_more(literal("A")) (LETTERS[2:5]) # failure

exactly(2,literal("A")) (c("A", LETTERS[1:5])) # success
exactly(2,literal("A")) (c(rep("A",2), LETTERS[1:5])) # failure: too many "A"

zero_or_one(literal("A")) (LETTERS[2:5]) # success
zero_or_one(literal("A")) (LETTERS[1:5]) # success
zero_or_one(literal("A")) (c("A",LETTERS[1:5])) # failure

match_n(2,literal("A")) (c("A", LETTERS[1:5])) # success
match_n(2,literal("A")) (c(rep("A",2), LETTERS[1:5])) # success

</code></pre>


</div>
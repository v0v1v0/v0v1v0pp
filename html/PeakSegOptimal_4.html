<div class="container">

<table style="width: 100%;"><tr>
<td>PeakSegFPOP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PeakSegFPOP</h2>

<h3>Description</h3>

<p>Find the optimal change-points using the Poisson loss and the
PeakSeg constraint. For N data points, the functional pruning
algorithm is O(N log N) time and memory. It recovers the exact
solution to the following optimization problem. Let Z be an
N-vector of count data (<code>count.vec</code>, non-negative integers), let W
be an N-vector of positive weights (<code>weight.vec</code>), and let <code>penalty</code>
be a non-negative real number. Find the N-vector M of real numbers
(segment means) and (N-1)-vector C of change-point indicators in
-1,0,1 which minimize the penalized Poisson Loss,
penalty*sum_[i=1]^[N_1] I(c_i=1) + sum_[i=1]^N
w_i*[m_i-z_i*log(m_i)], subject to constraints: (1) the first
change is up and the next change is down, etc (sum_[i=1]^t c_i in
0,1 for all t&lt;N-1), and (2) the last change is down
0=sum_[i=1]^[N-1] c_i, and (3) Every zero-valued change-point
variable has an equal segment mean after: c_i=0 implies
m_i=m_[i+1], (4) every positive-valued change-point variable may
have an up change after: c_i=1 implies m_i&lt;=m_[i+1], (5) every
negative-valued change-point variable may have a down change
after: c_i=-1 implies m_i&gt;=m_[i+1]. Note that when the equality
constraints are active for non-zero change-point variables, the
recovered model is not feasible for the strict inequality
constraints of the PeakSeg problem, and the optimum of the PeakSeg
problem is undefined.</p>


<h3>Usage</h3>

<pre><code class="language-R">PeakSegFPOP(count.vec, 
    weight.vec = rep(1, 
        length(count.vec)), 
    penalty = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>count.vec</code></td>
<td>
<p>integer vector of length &gt;= 3: non-negative count data to segment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.vec</code></td>
<td>
<p>numeric vector (same length as <code>count.vec</code>) of positive weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>non-negative numeric scalar: <code>penalty</code> parameter (smaller for more
peaks, larger for fewer peaks).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List of model parameters. <code>count.vec</code>, <code>weight.vec</code>, n.data, <code>penalty</code>
(input parameters), cost.mat (optimal Poisson loss), ends.vec
(optimal position of segment ends, 1-indexed), mean.vec (optimal
segment means), intervals.mat (number of intervals stored by the
functional pruning algorithm). To recover the solution in terms of
(M,C) variables, see the example.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Use the algo to compute the solution list.
library(PeakSegOptimal)
data("H3K4me3_XJ_immune_chunk1", envir=environment())
by.sample &lt;-
  split(H3K4me3_XJ_immune_chunk1, H3K4me3_XJ_immune_chunk1$sample.id)
n.data.vec &lt;- sapply(by.sample, nrow)
one &lt;- by.sample[[1]]
count.vec &lt;- one$coverage
weight.vec &lt;- with(one, chromEnd-chromStart)
penalty &lt;- 1000
fit &lt;- PeakSegFPOP(count.vec, weight.vec, penalty)

## Recover the solution in terms of (M,C) variables.
change.vec &lt;- with(fit, rev(ends.vec[ends.vec&gt;0]))
change.sign.vec &lt;- rep(c(1, -1), length(change.vec)/2)
end.vec &lt;- c(change.vec, fit$n.data)
start.vec &lt;- c(1, change.vec+1)
length.vec &lt;- end.vec-start.vec+1
mean.vec &lt;- rev(fit$mean.vec[1:(length(change.vec)+1)])
M.vec &lt;- rep(mean.vec, length.vec)
C.vec &lt;- rep(0, fit$n.data-1)
C.vec[change.vec] &lt;- change.sign.vec
diff.vec &lt;- diff(M.vec)
data.frame(
  change=c(C.vec, NA),
  mean=M.vec,
  equality.constraint.active=c(sign(diff.vec) != C.vec, NA))
stopifnot(cumsum(sign(C.vec)) %in% c(0, 1))

## Compute penalized Poisson loss of M.vec and compare to the value reported
## in the fit solution list.
n.peaks &lt;- sum(C.vec==1)
rbind(
  n.peaks*penalty + PoissonLoss(count.vec, M.vec, weight.vec),
  fit$cost.mat[2, fit$n.data])

## Plot the number of intervals stored by the algorithm.
FPOP.intervals &lt;- data.frame(
  label=ifelse(as.numeric(row(fit$intervals.mat))==1, "up", "down"),
  data=as.numeric(col(fit$intervals.mat)),
  intervals=as.numeric(fit$intervals.mat))
library(ggplot2)
ggplot()+
  theme_bw()+
  theme(panel.margin=grid::unit(0, "lines"))+
  facet_grid(label ~ .)+
  geom_line(aes(data, intervals), data=FPOP.intervals)+
  scale_y_continuous(
    "intervals stored by the\nconstrained optimal segmentation algorithm")

</code></pre>


</div>
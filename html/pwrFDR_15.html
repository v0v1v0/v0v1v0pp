<div class="container">

<table style="width: 100%;"><tr>
<td>dists</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
The Distribution family object
</h2>

<h3>Description</h3>

<p>The <code>pwrFDR</code> package currently incorporates 3 distribution types,
normal, t and F. The first two of these are strictly for statistics formed 
from two group comparison while the third is for statistics formed from the 
omnibus test of any difference among an arbitrary number of groups &gt;=2. The
structure is general and user expandable. One must specify the density, 
CDF and quantile function for a given distribution and its parameters under
the null and under the alternative. These parameters must be expressions
to be evaluated inside the kernel of the power program, functions of the
arguments <code>n.sample</code>, <code>groups</code> and <code>effect.size</code>. This is 
not used directly by the user at all unless she (he) wants to add a 
distribution type. 
</p>


<h3>Format</h3>

<p>A data frame with 3 observations on the following 6 variables.
</p>

<dl>
<dt><code>pars0</code></dt>
<dd>
<p>a list vector having components 'c(nd, p1, p2, ...)'
where 'nd' is the distribution number starting with 0,
and p1, p2, ..., are paramters of the distribution,
which are functions of 'n.sample', 'groups' and 
'effect.size' as mentioned above.  These must be 
expressed as a call e.g.  
as.call(expression(c, nd, p1, p2, ...))  etc.
'pars0' are the parameters under the null.</p>
</dd>
<dt><code>pars1</code></dt>
<dd>
<p>a list vector. See directly above. Parameters under the 
alternative.</p>
</dd>
<dt><code>minv</code></dt>
<dd>
<p>a list vector with components given the values -Inf or 0,
which will be used to decide if the two sided corrections
are used or not.</p>
</dd>
<dt><code>ddist</code></dt>
<dd>
<p>a list vector with components set to functions, each one 
computing the probability density function corresponding
to the particular distribution. A function of
arguments 'x' and 'par'. See details below.</p>
</dd>
<dt><code>pdist</code></dt>
<dd>
<p>a list vector with components set to the functions, each
one computing the cumulative distribution function 
corresponding to the particular distribution. A function
of arguments 'x' and 'par'. See details below.</p>
</dd>
<dt><code>qdist</code></dt>
<dd>
<p>a list vector with components set to the functions, each
one computing the quantile function (inverse cumulative 
distribution function) corresponding to the particular 
distribution. A function of arguments 'x' and 'par'. 
See details below.</p>
</dd>
</dl>
<h3>Details</h3>

<p><code>dists</code> is a data.frame with components <code>pars0</code>, <code>pars1</code>, 
<code>minv</code>, <code>ddist</code>, <code>pdist</code>, and <code>qdist</code>. For the three 
available distribution options, "normal", "t" and "f", the components
<code>pars0</code> and <code>pars1</code> take the following form:<br></p>

<table>
<tr>
<td style="text-align: left;">
1. pars0                              </td>
<td style="text-align: left;">  pars1                                    </td>
</tr>
<tr>
<td style="text-align: left;">
2. c(0,ncp=0,sd=1)                    </td>
<td style="text-align: left;">  c(0,ncp=.NCP.,sd=1)                      </td>
</tr>
<tr>
<td style="text-align: left;">
3. c(1,ncp=0,ndf=.DF.)                </td>
<td style="text-align: left;">  c(1,ncp=.NCP.,ndf=.DF.)                  </td>
</tr>
<tr>
<td style="text-align: left;">
4. c(2,ncp=0,ndf1=groups-1,ndf2=.DF.) </td>
<td style="text-align: left;">  c(2,ncp=.NCP.^2,ndf1=groups-1,ndf2=.DF.) </td>
</tr>
</table>
<p>The component <code>minv</code> gives the minumum value of the support set of the
distribution. For the above named three available distribution options,
<code>minv</code> is set to the values -Inf, -Inf and 0, respectively. The components
<code>ddist</code>, <code>pdist</code>, and <code>qdist</code> contain functions defining the
density, CDF, and quantile function, respectively. For the above named three
available distribution options, <code>ddist</code> takes the following form:<br></p>

<table>
<tr>
<td style="text-align: left;">
1. ddist                                                             </td>
</tr>
<tr>
<td style="text-align: left;">
2. function (x, par) dnorm(x, mean = par[2], sd = par[3])            </td>
</tr>
<tr>
<td style="text-align: left;">
3. function (x, par) dt(x, ncp = par[2], df = par[3])                </td>
</tr>
<tr>
<td style="text-align: left;">
4. function (x, par) df(x, ncp = par[2], df1 = par[3], df2 = par[4]) </td>
</tr>
</table>
<p>The components <code>pdist</code> and <code>qdist</code> are nearly identical to the
component <code>ddist</code>, but with pnorm, pt, pf and qnorm, qt, qf replacing
dnorm, dt and df, respectively.<br>
The variables, <code>.NCP.</code> and <code>.DF.</code> named above are defined within the
functions in which <code>ddist</code> is used based upon corresponding expressions,
<code>NCP</code> and <code>DF</code>. These expressions currently contain 3 component
expressions, one for each of the available test types, "paired", "balanced"
and "unbalanced".<br><code>NCP</code> is currently defined:<br></p>

<table>
<tr>
<td style="text-align: left;">
1. NCP                                                                  </td>
</tr>
<tr>
<td style="text-align: left;">
expression(n.sample^0.5*effect.size,(n.sample/groups)^0.5*effect.size,  </td>
</tr>
<tr>
<td style="text-align: left;">
   ((n.sample-1)/(1+sum((n.sample-1)/(nii.sample-1))))^0.5*effect.size) </td>
</tr>
</table>
<p>and <code>DF</code> is currently defined:<br></p>

<table>
<tr>
<td style="text-align: left;">
1. DF                                                                   </td>
</tr>
<tr>
<td style="text-align: left;">
expression(n.sample - 1, groups * (n.sample - 1),                       </td>
</tr>
<tr>
<td style="text-align: left;">
           groups^2*(n.sample-1)/(1+sum((n.sample-1)/(nii.sample-1))))	</td>
</tr>
</table>
<h3>Source</h3>

<p>This isn't 'data' data, its a kind of a 'family' object.
</p>
<p>Izmirlian G. (2020) Strong consistency and asymptotic normality for
quantities related to the Benjamini-Hochberg false discovery rate
procedure. Statistics and Probability Letters;
&lt;doi:10.1016/j.spl.2020.108713&gt;
</p>
<p>Izmirlian G. (2017) Average Power and <code class="reqn">\lambda</code>-power in
Multiple Testing Scenarios when the Benjamini-Hochberg False
Discovery Rate Procedure is Used. &lt;arXiv:1801.03989&gt;
</p>


</div>
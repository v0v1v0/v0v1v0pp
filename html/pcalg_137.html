<div class="container">

<table style="width: 100%;"><tr>
<td>udag2pag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Last steps of FCI algorithm: Transform Final Skeleton into FCI-PAG</h2>

<h3>Description</h3>

<p>This function performs the last steps of the FCI algorithm, as it
transforms an unoriented final skeleton into a Partial Ancestral
Graph (PAG).  The final skeleton must have been estimated with
<code>pdsep()</code> or <code>fciplus.intern()</code>.
The result is an adjacency matrix indicating also the edge marks.
</p>


<h3>Usage</h3>

<pre><code class="language-R">udag2pag(pag, sepset, rules = rep(TRUE, 10), unfVect = NULL,
  jci = c("0","1","12","123"), contextVars = NULL, verbose = FALSE, 
  orientCollider = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pag</code></td>
<td>
<p>Adjacency matrix of type amat.pag</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sepset</code></td>
<td>
<p>List of length p; each element of the list
contains another list of length p. The element
<code>sepset[[x]][[y]]</code> contains the separation set that made the edge
between <code>x</code> and <code>y</code> drop out. Each separation set is a
vector with (integer) positions of variables in the adjacency
matrix. This object is thought to be
obtained from a <code>pcAlgo</code>-object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rules</code></td>
<td>
<p>Array of length 10 containing <code>TRUE</code> or <code>FALSE</code>
for each rule. <code>TRUE</code> in position i means that rule i (Ri) will
be applied.  By default, all rules are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unfVect</code></td>
<td>
<p>Vector containing numbers that encode ambiguous unshielded
triples (as returned by <code>pc.cons.intern</code>).  This is
needed in the conservative and majority rule versions of FCI.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, detailed output is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orientCollider</code></td>
<td>
<p>if <code>TRUE</code>, colliders are oriented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jci</code></td>
<td>
<p>String specifying the JCI assumptions that are used. It can be one of:
</p>

<dl>
<dt>"0"</dt>
<dd>
<p>No JCI assumption is made (default),</p>
</dd>
<dt>"1"</dt>
<dd>
<p>JCI assumption 1 (no system variable causes any context variable),</p>
</dd>
<dt>"12"</dt>
<dd>
<p>JCI assumptions 1 and 2 (no system variable causes any context variable,
and no system variable is confounded with any context variable),</p>
</dd>
<dt>"123"</dt>
<dd>
<p>JCI assumptions 1, 2 and 3 (no system variable causes any context variable,
no system variable is confounded with any context variable, and all context variables are
confounded but are not direct causes of each other).</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contextVars</code></td>
<td>
<p>Subset of variable indices {1,...,p} that will be treated 
as context variables in the JCI extension.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The skeleton is transformed into an FCI-PAG using rules by Zhang (2008).
When using the JCI extension, additional adjacency and orientation rules
incorporate the JCI background knowledge regarding the causal relations 
of the context variables; for details, see Mooij et al. (2020).
</p>
<p>If <code>unfVect = NULL</code> (i.e., one uses standard FCI or one uses
conservative/majority rule FCI but there are no ambiguous triples),
then the orientation rules are applied to each eligible structure
until no more edges can be oriented.  On the other hand, if one uses
conservative or majority rule FCI and ambiguous triples have been
found in <code>pc.cons.intern</code>, <code>unfVect</code> contains the
numbers of all ambiguous triples in the graph.  In this case, the
orientation rules take this information into account.  For example, if
a *-&gt; b o-* c and &lt;a,b,c&gt; is an unambigous unshielded triple and not a
v-structure, then we obtain b -* c (otherwise we would create an
additional v-structure).  On the other hand, if a *-&gt; b o-* c but
&lt;a,b,c&gt; is an ambiguous unshielded triple, then the circle mark at b
is not oriented.
</p>
<p>Note that the algorithm works with columns' position of the adjacency
matrix and not with the names of the variables.
</p>
<p>Note that this function does not resolve possible order-dependence in
the application of the orientation rules, see Colombo and Maathuis (2014).
</p>


<h3>Value</h3>

<p>Adjacency matrix of type amat.pag.
</p>


<h3>Author(s)</h3>

<p>Diego Colombo and Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>);
JCI extension by Joris Mooij.</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782. 
</p>
<p>D. Colombo, M. H. Maathuis, M. Kalisch, T. S. Richardson
(2012). Learning high-dimensional directed acyclic graphs with latent
and selection variables. <em>Ann. Statist.</em> <b>40</b>, 294–321.
</p>
<p>J. M. Mooij, S. Magliacane, T. Claassen (2020).
Joint Causal Inference from Multiple Contexts.
<em>Journal of Machine Learning Research</em> <b>21</b>(99), 1–108.
</p>
<p>J. Zhang (2008). On the completeness of orientation rules for causal
discovery in the presence of latent confounders and selection bias.
<em>Artificial Intelligence</em> <b>172</b>, 1873–1896.
</p>


<h3>See Also</h3>

<p><code>fci</code>, <code>fciPlus</code>, <code>udag2apag</code>, <code>dag2pag</code>;
further, <code>udag2pdag</code> (incl. <code>udag2pdagSpecial</code> and
<code>udag2pdagRelaxed</code>).
</p>


<h3>Examples</h3>

<pre><code class="language-R">##################################################
## Example with hidden variables
## Zhang (2008), Fig. 6, p.1882
##################################################

## draw a DAG with latent variables
## this example is taken from Zhang (2008), Fig. 6, p.1882 (see references)
amat &lt;- t(matrix(c(0,1,0,0,1, 0,0,1,0,0, 0,0,0,1,0, 0,0,0,0,0, 0,0,0,1,0),5,5))
V &lt;- as.character(1:5)
colnames(amat) &lt;- rownames(amat) &lt;- V
edL &lt;- vector("list",length=5)
names(edL) &lt;- V
edL[[1]] &lt;- list(edges= c(2,4),weights=c(1,1))
edL[[2]] &lt;- list(edges= 3,     weights=c(1))
edL[[3]] &lt;- list(edges= 5,     weights=c(1))
edL[[4]] &lt;- list(edges= 5,     weights=c(1))
g &lt;- new("graphNEL", nodes=V, edgeL=edL,edgemode="directed")

if(require("Rgraphviz"))  plot(g) else print(g)

## define the latent variable
L &lt;- 1

## compute the true covariance matrix of g
cov.mat &lt;- trueCov(g)

## delete rows and columns which belong to L
true.cov &lt;- cov.mat[-L,-L]

## transform it in a correlation matrix
true.corr &lt;- cov2cor(true.cov)

if (require("MASS")) {
  ## generate 100000 samples of DAG using standard normal error distribution
  n &lt;- 100000
  alpha &lt;- 0.01
  set.seed(314)
  d.mat &lt;- mvrnorm(n, mu = rep(0,dim(true.corr)[1]), Sigma = true.cov)

  ## estimate the skeleton of given data
  suffStat &lt;- list(C = cor(d.mat), n = n)
  indepTest &lt;- gaussCItest
  resD &lt;- skeleton(suffStat, indepTest, p=dim(true.corr)[2], alpha = alpha)

  ## estimate v-structures conservatively
  tmp &lt;- pc.cons.intern(resD, suffStat, indepTest, alpha, version.unf = c(1, 1))
  ## tripleList &lt;- tmp$unfTripl
  resD &lt;- tmp$sk

  ## estimate the final skeleton of given data using Possible-D-Sep
  pdsepRes &lt;- pdsep(resD@graph, suffStat, indepTest, p=dim(true.corr)[2],
		    resD@sepset, alpha = alpha, m.max = Inf,
		    pMax = resD@pMax)

  ## extend the skeleton into a PAG using all 10 rules
  resP &lt;- udag2pag(pag = pdsepRes$G, pdsepRes$sepset, rules = rep(TRUE,10),
		   verbose = TRUE)
  colnames(resP) &lt;- rownames(resP) &lt;- as.character(2:5)
  print(resP)

} # only if "MASS" is there

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>dpldis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Discrete power-law distribution</h2>

<h3>Description</h3>

<p>Density, distribution function and random number generation
for the discrete power law distribution with parameters xmin and alpha.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dpldis(x, xmin, alpha, log = FALSE)

ppldis(q, xmin, alpha, lower.tail = TRUE)

rpldis(n, xmin, alpha, discrete_max = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, q</code></td>
<td>
<p>vector of quantiles. The discrete
power-law distribution is defined for x &gt; xmin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xmin</code></td>
<td>
<p>The lower bound of the power-law distribution.
For the continuous power-law, xmin &gt;= 0.
for the discrete distribution, xmin &gt; 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The scaling parameter: alpha &gt; 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical (default FALSE) if TRUE, log values are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>logical;
if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>,
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrete_max</code></td>
<td>
<p>The value when we switch from the discrete random
numbers to a CTN approximation.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Clauset, 2009 paper provides an algorithm for generating discrete random numbers.
However, if this algorithm is implemented in R, it gives terrible performance.
This is because the algorithm involves "growing vectors".
Another problem is when alpha is close to 1, this can result in very large random
number being generated (which means we need
to calculate the discrete CDF for very large values).
</p>
<p>The algorithm provided in this package generates true
discrete random numbers up to 10,000 then switches to
using continuous random numbers. This switching point can altered by
changing the <code>discrete_max</code> argument.
</p>
<p>In order to get a efficient power-law discrete random number generator, the
algorithm needs to be implemented in C.
</p>


<h3>Value</h3>

<p>dpldis returns the density, ppldis returns the distribution function
and rpldis return random numbers.
</p>


<h3>Note</h3>

<p>The naming of these functions mirrors standard R functions, i.e. dnorm.
When alpha is close to one, generating random number can be very slow.
</p>


<h3>References</h3>

<p>Clauset, Aaron, Cosma Rohilla Shalizi, and Mark EJ Newman.
"Power-law distributions in empirical data." SIAM review 51.4 (2009): 661-703.
</p>


<h3>Examples</h3>

<pre><code class="language-R">xmin = 1; alpha = 2
x = xmin:100

plot(x, dpldis(x, xmin, alpha), type="l")
plot(x, ppldis(x, xmin, alpha), type="l", main="Distribution function")
dpldis(1, xmin, alpha)

###############################################
## Random number generation                   #
###############################################
n = 1e5
x1 = rpldis(n, xmin, alpha)
## Compare with exact (dpldis(1, xmin, alpha))
sum(x1==1)/n
## Using only the approximation
x2 = rpldis(n, xmin, alpha, 0)
sum(x2==1)/n

</code></pre>


</div>
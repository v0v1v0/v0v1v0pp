<div class="container">

<table style="width: 100%;"><tr>
<td>details_svm_linear_LiblineaR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Linear support vector machines (SVMs) via LiblineaR</h2>

<h3>Description</h3>

<p><code>LiblineaR::LiblineaR()</code> fits a support vector machine model. For classification,
the model tries to maximize the width of the margin between classes.
For regression, the model optimizes a robust loss function that is only
affected by very large model residuals.
</p>


<h3>Details</h3>

<p>For this engine, there are multiple modes: classification and regression
</p>


<h4>Tuning Parameters</h4>

<p>This model has 2 tuning parameters:
</p>

<ul>
<li> <p><code>cost</code>: Cost (type: double, default: 1.0)
</p>
</li>
<li> <p><code>margin</code>: Insensitivity Margin (type: double, default: no default)
</p>
</li>
</ul>
<p>This engine fits models that are L2-regularized for L2-loss. In the
<code>LiblineaR::LiblineaR()</code> documentation, these
are types 1 (classification) and 11 (regression).
</p>



<h4>Translation from parsnip to the original package (regression)</h4>

<div class="sourceCode r"><pre>svm_linear(
  cost = double(1),
  margin = double(1)
) %&gt;%  
  set_engine("LiblineaR") %&gt;% 
  set_mode("regression") %&gt;% 
  translate()
</pre></div>
<div class="sourceCode"><pre>## Linear Support Vector Machine Model Specification (regression)
## 
## Main Arguments:
##   cost = double(1)
##   margin = double(1)
## 
## Computational engine: LiblineaR 
## 
## Model fit template:
## LiblineaR::LiblineaR(x = missing_arg(), y = missing_arg(), C = double(1), 
##     svr_eps = double(1), type = 11)
</pre></div>



<h4>Translation from parsnip to the original package (classification)</h4>

<div class="sourceCode r"><pre>svm_linear(
  cost = double(1)
) %&gt;% 
  set_engine("LiblineaR") %&gt;% 
  set_mode("classification") %&gt;% 
  translate()
</pre></div>
<div class="sourceCode"><pre>## Linear Support Vector Machine Model Specification (classification)
## 
## Main Arguments:
##   cost = double(1)
## 
## Computational engine: LiblineaR 
## 
## Model fit template:
## LiblineaR::LiblineaR(x = missing_arg(), y = missing_arg(), C = double(1), 
##     type = 1)
</pre></div>
<p>The <code>margin</code> parameter does not apply to classification models.
</p>
<p>Note that the <code>LiblineaR</code> engine does not produce class probabilities.
When optimizing the model using the tune package, the default metrics
require class probabilities. To use the <code style="white-space: pre;">⁠tune_*()⁠</code> functions, a metric
set must be passed as an argument that only contains metrics for hard
class predictions (e.g., accuracy).
</p>



<h4>Preprocessing requirements</h4>

<p>Factor/categorical predictors need to be converted to numeric values
(e.g., dummy or indicator variables) for this engine. When using the
formula method via <code>fit()</code>, parsnip will
convert factor columns to indicators.
</p>
<p>Predictors should have the same scale. One way to achieve this is to
center and scale each so that each predictor has mean zero and a
variance of one.
</p>



<h4>Case weights</h4>

<p>The underlying model implementation does not allow for case weights.
</p>



<h4>Examples</h4>

<p>The “Fitting and Predicting with parsnip” article contains
<a href="https://parsnip.tidymodels.org/articles/articles/Examples.html#svm-linear-LiblineaR">examples</a>
for <code>svm_linear()</code> with the <code>"LiblineaR"</code> engine.
</p>



<h4>References</h4>


<ul><li>
<p> Kuhn, M, and K Johnson. 2013. <em>Applied Predictive Modeling</em>. Springer.
</p>
</li></ul>
</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>fscale</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rescale a spectrum using a summary function</h2>

<h3>Description</h3>

<p>These methods return a spectral object of the same class as the one
supplied as argument but with the spectral data rescaled based on a summary
function <code>f</code> applied over a specific <code>range</code> of wavelengths and a
<code>target</code> value for the summary value. When the object contains
multiple spectra, the rescaling is applied separately to each spectrum.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fscale(x, ...)

## Default S3 method:
fscale(x, ...)

## S3 method for class 'source_spct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  set.scaled = target == 1,
  ...
)

## S3 method for class 'response_spct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  set.scaled = target == 1,
  ...
)

## S3 method for class 'filter_spct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  set.scaled = target == 1,
  ...
)

## S3 method for class 'reflector_spct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  qty.out = NULL,
  set.scaled = target == 1,
  ...
)

## S3 method for class 'solute_spct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  qty.out = NULL,
  set.scaled = target == 1,
  ...
)

## S3 method for class 'raw_spct'
fscale(x, range = NULL, f = "mean", target = 1, set.scaled = target == 1, ...)

## S3 method for class 'cps_spct'
fscale(x, range = NULL, f = "mean", target = 1, set.scaled = target == 1, ...)

## S3 method for class 'generic_spct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  set.scaled = target == 1,
  col.names,
  ...
)

## S3 method for class 'source_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'response_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'filter_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'reflector_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  qty.out = NULL,
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'solute_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'raw_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'cps_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'generic_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  set.scaled = target == 1,
  col.names,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An R object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional named arguments passed down to <code>f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p>numeric. An R object on which <code>range()</code> returns a numeric
vector of length 2 with the limits of a range of wavelengths in nm, with
min and max wavelengths (nm)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>character string. "mean" or "total" for scaling so that this summary
value becomes 1 for the returned object, or the name of a function taking
<code>x</code> as first argument and returning a numeric value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>numeric A constant used as target value for scaling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit.out</code></td>
<td>
<p>character. Allowed values "energy", and "photon", or its alias
"quantum".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set.scaled</code></td>
<td>
<p>logical or NULL Flag indicating if the data is to be marked
as "scaled" or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qty.out</code></td>
<td>
<p>character. Allowed values "transmittance", and "absorbance".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.names</code></td>
<td>
<p>character vector containing the names of columns or
variables to which to apply the scaling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.parallel</code></td>
<td>
<p>logical if TRUE, apply function in parallel, using parallel
backend provided by foreach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>After scaling, calling the function passed as argument to <code>f</code>
with the scaled spectrum as argument, will return the value passed as
argument to
<code>target</code>. <strong>The default for <code>set.scaled</code> depends
dynamically on the value passed to <code>target</code>.</strong> Sometimes we rescale a
spectrum to a "theoretical" value for the summary, while in other cases we
rescale the spectrum to a real-world target value of, e.g., a reference
energy irradiance. In the first case we say that the data are expressed in
relative units, while in the second case we retain actual physical units.
To indicate this, the default argument for 'set.scaled' is TRUE when
<code>target == 1</code>, assuming the first of these two situations, and false
otherwise, assuming the second situation. These defaults can be overriden
with an explicit <code>logical</code> argument passed to <code>set.scaled</code>.
Scaling overrides any previous normalization with the spectrum tagged as
not normalized.
</p>
<p>Method <code>fscale</code> is implemented for <code>solute_spct</code> objects but
as the spectral data stored in them are a description of an intensive
property of a substance, scaling is unlikely to useful. To represent
solutions of specific concentrations of solutes, <code>filter_spct</code> objects
should be used instead.
</p>


<h3>Value</h3>

<p>A copy of the object passed as argument to <code>x</code> with the original
spectral data values replaced with rescaled values, and the <code>"scaled"</code>
attribute set to a list describing the scaling applied.
</p>
<p>a new object of the same class as <code>x</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fscale(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>fscale(source_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(response_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(filter_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(reflector_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(solute_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(raw_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(cps_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(generic_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(source_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(response_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(solute_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(raw_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(generic_mspct)</code>: 
</p>
</li>
</ul>
<h3>Important changes</h3>

<p>Metadata describing the rescaling operation are
stored in an attribute only if <code>set.scaled = TRUE</code> is passed to the
call. The exact format and data stored in the attribute <code>"scaled"</code> has
changed during the development history of the package. Spectra re-scaled
with earlier versions will lack some information. To obtain the metadata in
a consistent format irrespective of this variation use accessor
<code>getScaling()</code>, which fills missing fields with <code>NA</code>.
</p>


<h3>See Also</h3>

<p>Other rescaling functions: 
<code>fshift()</code>,
<code>getNormalized()</code>,
<code>getScaled()</code>,
<code>is_normalized()</code>,
<code>is_scaled()</code>,
<code>normalize()</code>,
<code>setNormalized()</code>,
<code>setScaled()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
fscale(sun.spct)
fscale(sun.spct, f = "mean") # same as default
fscale(sun.spct, f = "mean", na.rm = TRUE)
fscale(sun.spct, range = c(400, 700)) # default is whole spectrum
fscale(sun.spct, f = "e_irrad", range = c(400, 700))
s400.spct &lt;- fscale(sun.spct,
                    f = e_irrad,
                    range = c(400, 700),
                    target = 400) # a target in W m-2
s400.spct
e_irrad(s400.spct, c(400, 700))

</code></pre>


</div>
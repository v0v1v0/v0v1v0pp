<div class="container">

<table style="width: 100%;"><tr>
<td>action_levels</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Set action levels: failure thresholds and functions to invoke</h2>

<h3>Description</h3>

<p>The <code>action_levels()</code> function works with the <code>actions</code> argument that is
present in the <code>create_agent()</code> function and in every validation step
function (which also has an <code>actions</code> argument). With it, we can provide
threshold <em>failure</em> values for any combination of <code>warn</code>, <code>stop</code>, or <code>notify</code>
failure states.
</p>
<p>We can react to any entering of a state by supplying corresponding functions
to the <code>fns</code> argument. They will undergo evaluation at the time when the
matching state is entered. If provided to <code>create_agent()</code> then the policies
will be applied to every validation step, acting as a default for the
validation as a whole.
</p>
<p>Calls of <code>action_levels()</code> could also be applied directly to any validation
step and this will act as an override if set also in <code>create_agent()</code>. Usage
of <code>action_levels()</code> is required to have any useful side effects (i.e.,
warnings, throwing errors) in the case of validation functions operating
directly on data (e.g., <code>mtcars %&gt;% col_vals_lt("mpg", 35)</code>). There are two
helper functions that are convenient when using validation functions directly
on data (the <code>agent</code>-less workflow): <code>warn_on_fail()</code> and <code>stop_on_fail()</code>.
These helpers either warn or stop (default failure threshold for each is set
to <code>1</code>), and, they do so with informative warning or error messages. The
<code>stop_on_fail()</code> helper is applied by default when using validation functions
directly on data (more information on this is provided in <em>Details</em>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">action_levels(warn_at = NULL, stop_at = NULL, notify_at = NULL, fns = NULL)

warn_on_fail(warn_at = 1)

stop_on_fail(stop_at = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>warn_at</code></td>
<td>
<p><em>Threshold value for the 'warn' failure state</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Either the threshold number or the threshold fraction of <em>failing</em> test
units that result in entering the <code>warn</code> failure state.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop_at</code></td>
<td>
<p><em>Threshold value for the 'stop' failure state</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Either the threshold number or the threshold fraction of <em>failing</em> test
units that result in entering the <code>stop</code> failure state.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notify_at</code></td>
<td>
<p><em>Threshold value for the 'notify' failure state</em>
</p>
<p><code>scalar&lt;integer|numeric&gt;(val&gt;=0)</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Either the threshold number or the threshold fraction of <em>failing</em> test
units that result in entering the <code>notify</code> failure state.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fns</code></td>
<td>
<p><em>Functions to execute when entering failure states</em>
</p>
<p><code>list</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A named list of functions that is to be paired with the appropriate failure
states. The syntax for this list involves using failure state names from
the set of <code>warn</code>, <code>stop</code>, and <code>notify</code>. The functions corresponding to the
failure states are provided as formulas (e.g.,
<code>list(warn = ~ warning("Too many failures."))</code>. A series of expressions for
each named state can be used by enclosing the set of statements with <code>{ }</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The output of the <code>action_levels()</code> call in <code>actions</code> will be interpreted
slightly differently if using an <em>agent</em> or using validation functions
directly on a data table. For convenience, when working directly on data, any
values supplied to <code>warn_at</code> or <code>stop_at</code> will be automatically given a stock
<code>warning()</code> or <code>stop()</code> function. For example using
<code>small_table %&gt;% col_is_integer("date")</code> will provide a detailed stop message
by default, indicating the reason for the failure. If you were to supply the
<code>fns</code> for <code>stop</code> or <code>warn</code> manually then the stock functions would be
overridden. Furthermore, if <code>actions</code> is NULL in this workflow (the default),
<strong>pointblank</strong> will use a <code>stop_at</code> value of <code>1</code> (providing a detailed,
context-specific error message if there are any <em>failing</em> units). We can
absolutely suppress this automatic stopping behavior by at each validation
step by setting <code>active = FALSE</code>. In this interactive data case, there is no
stock function given for <code>notify_at</code>. The <code>notify</code> failure state is less
commonly used in this workflow as it is in the <em>agent</em>-based one.
</p>
<p>When using an <em>agent</em>, we often opt to not use any functions in <code>fns</code> as the
<code>warn</code>, <code>stop</code>, and <code>notify</code> failure states will be reported on when using
<code>create_agent_report()</code> (and, usually that's sufficient). Instead, using the
<code>end_fns</code> argument is a better choice since that scheme provides useful data
on the entire interrogation, allowing for finer control on side effects and
reducing potential for duplicating any side effects.
</p>


<h3>Value</h3>

<p>An <code>action_levels</code> object.
</p>


<h3>Defining threshold values</h3>

<p>Any threshold values supplied for the <code>warn_at</code>, <code>stop_at</code>, or <code>notify_at</code>
arguments correspond to the <code>warn</code>, <code>stop</code>, and <code>notify</code> failure states,
respectively. A threshold value can either relates to an absolute number of
test units or a fraction-of-total test units that are <em>failing</em>. Exceeding
the threshold means entering one or more of the <code>warn</code>, <code>stop</code>, or <code>notify</code>
failure states.
</p>
<p>If a threshold value is a decimal value between <code>0</code> and <code>1</code> then it's a
proportional failure threshold (e.g., <code>0.15</code> indicates that if 15 percent of
the test units are found to be <em>failing</em>, then the designated failure state
is entered). Absolute values starting from <code>1</code> can be used instead, and this
constitutes an absolute failure threshold (e.g., <code>10</code> means that if 10 of the
test units are found to be <em>failing</em>, the failure state is entered).
</p>


<h3>Examples</h3>

<p>For these examples, we will use the included <code>small_table</code> dataset.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>
<p>Create an <code>action_levels</code> object with fractional values for the <code>warn</code>,
<code>stop</code>, and <code>notify</code> states.
</p>
<div class="sourceCode r"><pre>al &lt;- 
  action_levels(
    warn_at = 0.2,
    stop_at = 0.8,
    notify_at = 0.5
  )
</pre></div>
<p>A summary of settings for the <code>al</code> object is shown by printing it.
</p>
<p>Create a pointblank agent and apply the <code>al</code> object to <code>actions</code>. Add two
validation steps and interrogate the <code>small_table</code>.
</p>
<div class="sourceCode r"><pre>agent_1 &lt;-
  create_agent(
    tbl = small_table,
    actions = al
  ) %&gt;%
  col_vals_gt(
    columns = a, value = 2
  ) %&gt;%
  col_vals_lt(
    columns = d, value = 20000
  ) %&gt;%
  interrogate()
</pre></div>
<p>The report from the agent will show that the <code>warn</code> state has been entered
for the first validation step but not the second one. We can confirm this in
the console by inspecting the <code>warn</code> component in the agent's x-list.
</p>
<div class="sourceCode r"><pre>x_list &lt;- get_agent_x_list(agent = agent_1)

x_list$warn
</pre></div>
<div class="sourceCode"><pre>## [1]  TRUE FALSE
</pre></div>
<p>Applying the <code>action_levels</code> object to the agent means that all validation
steps will inherit these settings but we can override this by applying
another such object to the validation step instead (this time using the
<code>warn_on_fail()</code> shorthand).
</p>
<div class="sourceCode r"><pre>agent_2 &lt;-
  create_agent(
    tbl = small_table,
    actions = al
  ) %&gt;%
  col_vals_gt(
    columns = a, value = 2,
    actions = warn_on_fail(warn_at = 0.5)
  ) %&gt;%
  col_vals_lt(
    columns = d, value = 20000
  ) %&gt;%
  interrogate()
</pre></div>
<p>In this case, the first validation step has a less stringent failure
threshold for the <code>warn</code> state and it's high enough that the condition is not
entered. This can be confirmed in the console through inspection of the
x-list <code>warn</code> component.
</p>
<div class="sourceCode r"><pre>x_list &lt;- get_agent_x_list(agent = agent_2)

x_list$warn
</pre></div>
<div class="sourceCode"><pre>## [1] FALSE FALSE
</pre></div>
<p>In the context of using validation functions directly on data (i.e., no
involvement of an agent) we want to trigger warnings and raise errors. The
following will yield a warning if it is executed (returning the <code>small_table</code>
data).
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_vals_gt(
    columns = a, value = 2,
    actions = warn_on_fail(warn_at = 2)
  )
</pre></div>
<pre>## # A tibble: 13 × 8
##    date_time           date           a b           c      d e    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt;
##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-…     3  3423. TRUE 
##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-…     8 10000. TRUE 
##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-…     3  2343. TRUE 
##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-…    NA  3892. FALSE
##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-…     7   284. TRUE 
##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-…     4  3291. TRUE 
##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-…     3   843. TRUE 
##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-…     2  1036. FALSE
##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE
## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE
## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-…     7   834. TRUE 
## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-…     8   108. FALSE
## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-…    NA  2230. TRUE 
## # … with 1 more variable: f &lt;chr&gt;
## Warning message:
## Exceedance of failed test units where values in `a` should have been &gt;
## `2`.
## The `col_vals_gt()` validation failed beyond the absolute threshold
## level (2).
## * failure level (4) &gt;= failure threshold (2)</pre>
<p>With the same pipeline, not supplying anything for <code>actions</code> (it's <code>NULL</code> by
default) will have the same effect as using <code>stop_on_fail(stop_at = 1)</code>.
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_vals_gt(columns = a, value = 2)
</pre></div>
<div class="sourceCode"><pre>## Error: Exceedance of failed test units where values in `a` should have
## been &gt; `2`.
## The `col_vals_gt()` validation failed beyond the absolute threshold
## level (1).
## * failure level (4) &gt;= failure threshold (1)
</pre></div>
<p>Here's the equivalent set of statements:
</p>
<div class="sourceCode r"><pre>small_table %&gt;%
  col_vals_gt(
    columns = a, value = 2,
    actions = stop_on_fail(stop_at = 1)
  )
</pre></div>
<div class="sourceCode"><pre>## Error: Exceedance of failed test units where values in `a` should have
## been &gt; `2`.
## The `col_vals_gt()` validation failed beyond the absolute threshold
## level (1).
## * failure level (4) &gt;= failure threshold (1)
</pre></div>
<p>This is because the <code>stop_on_fail()</code> call is auto-injected in the default
case (when operating on data) for your convenience. Behind the scenes a
'secret agent' uses 'covert actions': all so you can type less.
</p>


<h3>Function ID</h3>

<p>1-5
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code>create_agent()</code>,
<code>create_informant()</code>,
<code>db_tbl()</code>,
<code>draft_validation()</code>,
<code>file_tbl()</code>,
<code>scan_data()</code>,
<code>tbl_get()</code>,
<code>tbl_source()</code>,
<code>tbl_store()</code>,
<code>validate_rmd()</code>
</p>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>add_locked_out_constraints</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add locked out constraints</h2>

<h3>Description</h3>

<p>Add constraints to a conservation planning problem to ensure
that specific planning units are not selected
(or allocated to a specific zone) in the solution. For example, it may be
useful to lock out planning units that have been degraded and are not
suitable for conserving species. If specific planning units should be locked
in to the solution, use <code>add_locked_in_constraints()</code>. For
problems with non-binary planning unit allocations (e.g., proportions), the
<code>add_manual_locked_constraints()</code> function can be used to lock
planning unit allocations to a specific value.
</p>


<h3>Usage</h3>

<pre><code class="language-R">add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,numeric'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,logical'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,matrix'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,character'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,Spatial'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,sf'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,Raster'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,SpatRaster'
add_locked_out_constraints(x, locked_out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>problem()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locked_out</code></td>
<td>
<p>Object that determines which planning units that should be
locked out. See the Data format section for more information.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An updated <code>problem()</code> object with the constraints added to it.
</p>


<h3>Data format</h3>

<p>The locked planning units can be specified using the following formats.
Generally, the locked data should correspond to the planning units
in the argument to <code>x.</code> To help make working with
<code>terra::rast()</code> planning unit data easier,
the locked data should correspond to cell indices in the
<code>terra::rast()</code> data. For example, <code>integer</code> arguments
should correspond to cell indices and <code>logical</code> arguments should have
a value for each cellâ€”regardless of which planning unit cells contain
<code>NA</code> values.
</p>

<dl>
<dt>
<code>data</code> as an <code>integer</code> vector</dt>
<dd>
<p>containing indices that indicate which
planning units should be locked for the solution. This argument is only
compatible with problems that contain a single zone.</p>
</dd>
<dt>
<code>data</code> as a <code>logical</code> vector</dt>
<dd>
<p>containing <code>TRUE</code> and/or
<code>FALSE</code> values that indicate which planning units should be locked
in the solution. This argument is only compatible with problems that
contain a single zone.</p>
</dd>
<dt>
<code>data</code> as a <code>matrix</code> object</dt>
<dd>
<p>containing <code>logical</code> <code>TRUE</code> and/or
<code>FALSE</code> values which indicate if certain planning units are
should be locked to a specific zone in the solution. Each row
corresponds to a planning unit, each column corresponds to a zone, and
each cell indicates if the planning unit should be locked to a given
zone. Thus each row should only contain at most a single <code>TRUE</code>
value.</p>
</dd>
<dt>
<code>data</code> as a <code>character</code> vector</dt>
<dd>
<p>containing column name(s)
that indicates if planning units should be locked for the solution.
This format is only
compatible if the planning units in the argument to <code>x</code> are a
<code>sf::sf()</code> or <code>data.frame</code> object. The columns
must have <code>logical</code> (i.e., <code>TRUE</code> or <code>FALSE</code>)
values indicating if the planning unit is to be locked for the solution.
For problems that contain a single zone, the argument to <code>data</code> must
contain a single column name. Otherwise, for problems that
contain multiple zones, the argument to <code>data</code> must
contain a column name for each zone.</p>
</dd>
<dt>
<code>data</code> as a <code>sf::sf()</code> object</dt>
<dd>
<p>containing geometries that will be used to lock planning units for
the solution. Specifically, planning units in <code>x</code> that spatially
intersect with <code>y</code> will be locked (per <code>intersecting_units()</code>).
Note that this option is only available
for problems that contain a single management zone.</p>
</dd>
<dt>
<code>data</code> as a <code>terra::rast()</code> object</dt>
<dd>
<p>containing cells used to lock planning units for the solution.
Specifically, planning units in <code>x</code>
that intersect with cells that have non-zero and non-<code>NA</code> values are
locked.
For problems that contain multiple zones, the
<code>data</code> object must contain a layer
for each zone. Note that for multi-band arguments, each pixel must
only contain a non-zero value in a single band. Additionally, if the
cost data in <code>x</code> is a <code>terra::rast()</code> object, we
recommend standardizing <code>NA</code> values in this dataset with the cost
data. In other words, the pixels in <code>x</code> that have <code>NA</code> values
should also have <code>NA</code> values in the locked data.</p>
</dd>
</dl>
<h3>See Also</h3>

<p>See constraints for an overview of all functions for adding constraints.
</p>
<p>Other constraints: 
<code>add_contiguity_constraints()</code>,
<code>add_feature_contiguity_constraints()</code>,
<code>add_linear_constraints()</code>,
<code>add_locked_in_constraints()</code>,
<code>add_mandatory_allocation_constraints()</code>,
<code>add_manual_bounded_constraints()</code>,
<code>add_manual_locked_constraints()</code>,
<code>add_neighbor_constraints()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_locked_out_raster &lt;- get_sim_locked_out_raster()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem
p1 &lt;-
  problem(sim_pu_polygons, sim_features, "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with added locked out constraints using integers
p2 &lt;- p1 %&gt;% add_locked_out_constraints(which(sim_pu_polygons$locked_out))

# create problem with added locked out constraints using a column name
p3 &lt;- p1 %&gt;% add_locked_out_constraints("locked_out")

# create problem with added locked out constraints using raster data
p4 &lt;- p1 %&gt;% add_locked_out_constraints(sim_locked_out_raster)

# create problem with added locked out constraints using spatial polygon data
locked_out &lt;- sim_pu_polygons[sim_pu_polygons$locked_out == 1, ]
p5 &lt;- p1 %&gt;% add_locked_out_constraints(locked_out)

# solve problems
s1 &lt;- solve(p1)
s2 &lt;- solve(p2)
s3 &lt;- solve(p3)
s4 &lt;- solve(p4)
s5 &lt;- solve(p5)

# create single object with all solutions
s6 &lt;- sf::st_sf(
  tibble::tibble(
    s1 = s1$solution_1,
    s2 = s2$solution_1,
    s3 = s3$solution_1,
    s4 = s4$solution_1,
    s5 = s5$solution_1
  ),
  geometry = sf::st_geometry(s1)
)

# plot solutions
plot(
  s6,
  main = c(
    "none locked out", "locked out (integer input)",
    "locked out (character input)", "locked out (raster input)",
    "locked out (polygon input)"
  )
)

# reset plot
par(mfrow = c(1, 1))

# create minimal multi-zone problem with spatial data
p7 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(matrix(rpois(15, 1), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create multi-zone problem with locked out constraints using matrix data
locked_matrix &lt;- as.matrix(sf::st_drop_geometry(
  sim_zones_pu_polygons[, c("locked_1", "locked_2", "locked_3")]
))

p8 &lt;- p7 %&gt;% add_locked_out_constraints(locked_matrix)

# solve problem
s8 &lt;- solve(p8)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s8$solution &lt;- category_vector(sf::st_drop_geometry(
  s8[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
))
s8$solution &lt;- factor(s8$solution)

# plot solution
plot(s8[, "solution"], main = "solution", axes = FALSE)

# create multi-zone problem with locked out constraints using column names
p9 &lt;-
  p7 %&gt;%
  add_locked_out_constraints(c("locked_1", "locked_2", "locked_3"))

# solve problem
s9 &lt;- solve(p9)

# create new column in s8 representing the zone id that each planning unit
# was allocated to in the solution
s9$solution &lt;- category_vector(sf::st_drop_geometry(
  s9[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
))
s9$solution[s9$solution == 1 &amp; s9$solution_1_zone_1 == 0] &lt;- 0
s9$solution &lt;- factor(s9$solution)

# plot solution
plot(s9[, "solution"], main = "solution", axes = FALSE)

# create multi-zone problem with raster planning units
p10 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(matrix(rpois(15, 1), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create multi-layer raster with locked out units
locked_out_raster &lt;- sim_zones_pu_raster[[1]]
locked_out_raster[!is.na(locked_out_raster)] &lt;- 0
locked_out_raster &lt;- locked_out_raster[[c(1, 1, 1)]]
names(locked_out_raster) &lt;- c("zones_1", "zones_2", "zones_3")
locked_out_raster[[1]][1] &lt;- 1
locked_out_raster[[2]][2] &lt;- 1
locked_out_raster[[3]][3] &lt;- 1

# plot locked out raster
plot(locked_out_raster)

# add locked out raster units to problem
p10 &lt;- p10 %&gt;% add_locked_out_constraints(locked_out_raster)

# solve problem
s10 &lt;- solve(p10)

# plot solution
plot(category_layer(s10), main = "solution", axes = FALSE)

## End(Not run)
</code></pre>


</div>
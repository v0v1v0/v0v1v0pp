<div class="container">

<table style="width: 100%;"><tr>
<td>generatedata_adjpin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation of AdjPIN model data.</h2>

<h3>Description</h3>

<p>Generates a <code>dataset</code> object or a <code>data.series</code> object (a list
of <code>dataset</code> objects) storing simulation parameters as well as aggregate
daily buys and sells simulated following the assumption of the <code>AdjPIN</code> model
of Duarte and Young (2009).
</p>


<h3>Usage</h3>

<pre><code class="language-R">generatedata_adjpin(series=1, days = 60, parameters = NULL, ranges = list(),
restricted = list(), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>series</code></td>
<td>
<p>The number of datasets to generate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>days</code></td>
<td>
<p>The number of trading days, for which aggregated
buys and sells are generated. The default value is <code>60</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>A vector of model parameters of size <code>10</code> and it has
the following form {<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\theta</code>, <code class="reqn">\theta'</code>,
<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>, <code class="reqn">\mu</code><sub>b</sub>, <code class="reqn">\mu</code><sub>s</sub>, <code class="reqn">\Delta</code><sub>b</sub>, <code class="reqn">\Delta</code><sub>s</sub>}.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranges</code></td>
<td>
<p>A list of ranges for the different simulation
parameters having named elements <code>alpha</code> <code class="reqn">(\alpha)</code>,
<code>delta</code> <code class="reqn">(\delta)</code>, <code>theta</code> <code class="reqn">(\theta)</code>, <code>thetap</code> <code class="reqn">(\theta')</code>,
<code>eps.b</code> (<code class="reqn">\epsilon</code><sub>b</sub>), <code>eps.s</code> (<code class="reqn">\epsilon</code><sub>s</sub>), <code>mu.b</code> (<code class="reqn">\mu</code><sub>b</sub>), <code>mu.s</code> (<code class="reqn">\mu</code><sub>s</sub>), <code>d.b</code> (<code class="reqn">\Delta</code><sub>b</sub>),
<code>d.s</code> (<code class="reqn">\Delta</code><sub>s</sub>).
The value of each element is a vector of two numbers: the first one is the
minimal value <code>min_v</code> and the second one is the maximal value <code>max_v</code>.
If the element corresponding to a given parameter is missing, the default
range for that parameter is used, otherwise, the simulation parameters are
uniformly drawn from the interval (<code>min_v</code>, <code>max_v</code>). The default value
is <code>list()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restricted</code></td>
<td>
<p>A binary list that allows estimating restricted
AdjPIN models by specifying which model parameters are assumed to be equal.
It contains one or multiple of the following four elements
<code style="white-space: pre;">⁠{theta, mu, eps, d}⁠</code>. For instance, If <code>theta</code> is set to <code>TRUE</code>,
then the probability of liquidity shock in no-information days, and in
information days is assumed to be the same (<code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>). If any of
the remaining rate elements <code style="white-space: pre;">⁠{mu, eps, d}⁠</code> is set to <code>TRUE</code>,
(say  <code>mu=TRUE</code>), then the rate is assumed to be the same on the buy side,
and on the sell side (<code class="reqn">\mu</code><sub>b</sub><code>=</code><code class="reqn">\mu</code><sub>s</sub>). If more than one element is set to
<code>TRUE</code>, then the restrictions are combined. For instance, if the argument
<code>restricted</code> is set to <code>list(theta=TRUE, eps=TRUE, d=TRUE)</code>, then the
restricted AdjPIN model is estimated, where <code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>, <code class="reqn">\epsilon</code><sub>b</sub><code>=</code><code class="reqn">\epsilon</code><sub>s</sub>,
and <code class="reqn">\Delta</code><sub>b</sub><code>=</code><code class="reqn">\Delta</code><sub>s</sub>. If the value of the argument <code>restricted</code> is the empty list
(<code>list()</code>), then all parameters of the model are assumed to be independent,
and the unrestricted model is estimated. The default value is the empty
list <code>list()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A binary variable that determines whether detailed
information about the progress of the data generation is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the argument <code>parameters</code> is missing, then the parameters are
generated using the ranges specified in the argument <code>ranges</code>.
If the argument <code>ranges</code> is set to <code>list()</code>, default ranges are used. Using
the default ranges, the simulation parameters are obtained using the
following procedure:
</p>

<ul>
<li> <p><code class="reqn">\alpha</code>, <code class="reqn">\delta</code>: <code>(alpha, delta)</code> uniformly
distributed on <code>(0, 1)</code>.
</p>
</li>
<li> <p><code class="reqn">\theta</code>, <code class="reqn">\theta'</code>: <code>(theta,thetap)</code> uniformly
distributed on <code>(0, 1)</code>.
</p>
</li>
<li> <p><code class="reqn">\epsilon</code><sub>b</sub>: <code>(eps.b)</code> an integer uniformly drawn from the interval
<code>(100, 10000)</code> with step <code>50</code>.
</p>
</li>
<li> <p><code class="reqn">\epsilon</code><sub>s</sub>: <code>(eps.s)</code> an integer uniformly drawn from (<code>(4/5)</code><code class="reqn">\epsilon</code><sub>b</sub>,
<code>(6/5)</code><code class="reqn">\epsilon</code><sub>b</sub>) with step <code>50</code>.
</p>
</li>
<li> <p><code class="reqn">\Delta</code><sub>b</sub>: <code>(d.b)</code> an integer uniformly drawn from (<code>(1/2)</code><code class="reqn">\epsilon</code><sub>b</sub>,
<code>2</code><code class="reqn">\epsilon</code><sub>b</sub>).
</p>
</li>
<li> <p><code class="reqn">\Delta</code><sub>s</sub>: <code>(d.s)</code> an integer uniformly drawn from (<code>(4/5)</code><code class="reqn">\Delta</code><sub>b</sub>,
<code>(6/5)</code><code class="reqn">\Delta</code><sub>b</sub>).
</p>
</li>
<li> <p><code class="reqn">\mu</code><sub>b</sub>: <code>(mu.b)</code> uniformly distributed on the interval
<code style="white-space: pre;">⁠((1/2) max⁠</code>(<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>)<code style="white-space: pre;">⁠, 5 max⁠</code>(<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>)<code style="white-space: pre;">⁠)⁠</code>.
</p>
</li>
<li> <p><code class="reqn">\mu</code><sub>s</sub>: <code>(mu.s)</code> uniformly distributed on the interval
(<code>(4/5)</code><code class="reqn">\mu</code><sub>b</sub>, <code>(6/5)</code><code class="reqn">\mu</code><sub>b</sub>)..
</p>
</li>
</ul>
<p>Based on the simulation parameters <code>parameters</code>, daily buys and sells are
generated by the assumption that buys and sells follow Poisson
distributions with mean parameters:
</p>

<ul>
<li>
<p> (<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>) in a day with no information and no liquidity shock;
</p>
</li>
<li>
<p> (<code class="reqn">\epsilon</code><sub>b</sub>+<code class="reqn">\Delta</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>+<code class="reqn">\Delta</code><sub>s</sub>) in a day with no information and with liquidity
shock;
</p>
</li>
<li>
<p> (<code class="reqn">\epsilon</code><sub>b</sub>+<code class="reqn">\mu</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>) in a day with good information and no liquidity
shock;
</p>
</li>
<li>
<p> (<code class="reqn">\epsilon</code><sub>b</sub>+<code class="reqn">\mu</code><sub>b</sub>+<code class="reqn">\Delta</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>+<code class="reqn">\Delta</code><sub>s</sub>) in a day with good information and
liquidity shock;
</p>
</li>
<li>
<p> (<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>+<code class="reqn">\mu</code><sub>s</sub>) in a day with bad information and no liquidity
shock;
</p>
</li>
<li>
<p> (<code class="reqn">\epsilon</code><sub>b</sub>+<code class="reqn">\Delta</code><sub>s</sub>, <code class="reqn">\epsilon</code><sub>s</sub>+<code class="reqn">\mu</code><sub>s</sub>+<code class="reqn">\Delta</code><sub>s</sub>) in a day with bad information and
liquidity shock;
</p>
</li>
</ul>
<h3>Value</h3>

<p>Returns an object of class <code>dataset</code> if <code>series=1</code>, and an
object of class <code>data.series</code> if <code>series&gt;1</code>.
</p>


<h3>References</h3>

<p>Duarte J, Young L (2009).
“Why is PIN priced?”
<em>Journal of Financial Economics</em>, <b>91</b>(2), 119–138.
ISSN 0304405X.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># ------------------------------------------------------------------------ #
# Generate data following the AdjPIN model using generatedata_adjpin()     #
# ------------------------------------------------------------------------ #

# With no arguments, the function generates one dataset object spanning
# 60 days, and where the parameters are chosen as described in the section
# 'Details'.

sdata &lt;- generatedata_adjpin()

# Alternatively, simulation parameters can be provided. Recall the order of
# parameters (alpha, delta, theta, theta', eps.b, eps.s, mub, mus, db, ds).

givenpoint &lt;- c(0.4, 0.1, 0.5, 0.6, 800, 1000, 2300, 4000, 500, 500)
sdata &lt;- generatedata_adjpin(parameters = givenpoint)

# Data can be generated following restricted AdjPIN models, for example, with
# restrictions 'eps.b = eps.s', and 'mu.b = mu.s'.

sdata &lt;- generatedata_adjpin(restricted = list(eps = TRUE, mu = TRUE))

# Data can be generated using provided ranges of simulation parameters as fed
# to the function using the argument 'ranges', where thetap corresponds to
# theta'.

sdata &lt;- generatedata_adjpin(ranges = list(
  alpha = c(0.1, 0.15), delta = c(0.2, 0.2),
  theta = c(0.2, 0.6), thetap = c(0.2, 0.4)
))

# The value of a given simulation parameter can be set to a specific value by
# setting the range of the desired parameter takes a unique value, instead of
# a pair of values.

sdata &lt;- generatedata_adjpin(ranges = list(
  alpha = 0.4, delta = c(0.2, 0.7),
  eps.b = c(100, 7000), mu.b = 8000
))

# Display the details of the generated simulation data

show(sdata)

# ------------------------------------------------------------------------ #
# Use generatedata_adjpin() to check the accuracy of adjpin()              #
# ------------------------------------------------------------------------ #

model &lt;- adjpin(sdata@data, verbose = FALSE)

summary &lt;- cbind(
  c(sdata@emp.pin['adjpin'], model@adjpin, abs(model@adjpin -
  sdata@emp.pin['adjpin'])),
  c(sdata@emp.pin['psos'], model@psos, abs(model@psos -
  sdata@emp.pin['psos']))
)
colnames(summary) &lt;- c('adjpin', 'psos')
rownames(summary) &lt;- c('Data', 'Model', 'Difference')

show(knitr::kable(summary, 'simple'))

</code></pre>


</div>
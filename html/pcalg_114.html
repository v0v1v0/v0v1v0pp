<div class="container">

<table style="width: 100%;"><tr>
<td>randDAG</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Random DAG Generation</h2>

<h3>Description</h3>

<p>Generating random directed acyclic graphs (DAGs) with fixed expected
number of neighbours.  Several different methods are provided, each
intentionally biased towards certain properties.  The methods are based
on the analogue <code>*.game</code> functions in the <span class="pkg">igraph</span> package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">randDAG(n, d, method ="er", par1=NULL, par2=NULL,
        DAG = TRUE, weighted = TRUE, wFUN = list(runif, min=0.1, max=1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer, at least <code>2</code>, indicating the number of nodes in
the DAG.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>a positive number, corresponding to the expected number of
neighbours per node, more precisely the expected sum of the in- and
out-degree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a string, specifying the method used for generating the
random graph.  See details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par1, par2</code></td>
<td>
<p>optional additional arguments, dependent on the
method.  See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DAG</code></td>
<td>
<p>logical, if <code>TRUE</code>, labelled graph is directed to a labelled acyclic graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted</code></td>
<td>
<p>logical indicating if edge weights are computed according to <code>wFUN</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wFUN</code></td>
<td>
<p>a <code>function</code> for computing the edge weights in
the DAG.  It takes as first argument a number of edges <code>m</code> for
which it returns a vector of length <code>m</code> containing the
weights.  Alternatively, <code>wFUN</code> can be a <code>list</code>
consisting of the function in the first entry and of further
arguments of the function in the additional entries.  The default
(only if <code>weighted</code> is true) is a uniform weight in <code class="reqn">[0.1,
      1]</code>.  See the examples for more.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A (weighted) random graph with <code>n</code> nodes and expected number of
neighbours <code>d</code> is constructed.  For <code>DAG=TRUE</code>, the graph is
oriented to a DAG.  There are eight different random graph models
provided, each selectable by the parameters <code>method</code>,
<code>par1</code> and <code>par2</code>, with <code>method</code>, a string,
taking one of the following values:
</p>

<dl>
<dt>
<code>regular</code>:</dt>
<dd>
<p>Graph where every node has exactly <code>d</code>
incident edges. <code>par1</code> and <code>par2</code> are not used.</p>
</dd>
<dt>
<code>watts</code>:</dt>
<dd>
<p>Watts-Strogatz graph that interpolates between
the regular (<code>par1-&gt;0</code>) and Erdoes-Renyi graph
(<code>par1-&gt;1</code>).  The parameter <code>par1</code> is per default
<code>0.5</code> and has to be in <code>(0,1)</code>. <code>par2</code> is not used.</p>
</dd>
<dt>
<code>er</code>:</dt>
<dd>
<p>Erdoes-Renyi graph where every edge is present
independently. <code>par1</code> and <code>par2</code> are not used.</p>
</dd>
<dt>
<code>power</code>:</dt>
<dd>
<p>A graph with power-law degree distribution with
expectation <code>d</code>.<code>par1</code> and <code>par2</code> are not used.</p>
</dd> 
<dt>
<code>bipartite</code>:</dt>
<dd>
<p>Bipartite graph with at least <code>par1*n</code>
nodes in group 1 and at most <code>(1-par1)*n</code> nodes in group 2.
The argument <code>par1</code> has to be in <code>[0,1]</code> and is per
default <code>0.5</code>. <code>par2</code> is not used.</p>
</dd>
<dt>
<code>barabasi</code>:</dt>
<dd>
<p>A graph with power-law degree distribution
and preferential attachement according to parameter <code>par1</code>.  It
must hold that <code>par1 &gt;= 1</code> and the default is
<code>par1=1</code>. <code>par2</code> is not used.</p>
</dd>
<dt>
<code>geometric</code>:</dt>
<dd>
<p>A geometric random graph in dimension
<code>par1</code>, where  <code>par1</code> can take values from
<code>{2,3,4,5}</code> and is per default <code>2</code>.  If <code>par2="geo"</code>
and <code>weighted=TRUE</code>, then the weights are computed according to
the Euclidean distance. There are currently no other option for
<code>par2</code> implemented.</p>
</dd>
<dt>
<code>interEr</code>:</dt>
<dd>
<p>A graph with <code>par1</code> islands of
Erdoes-Renyi graphs, every pair of those connected by a certain
number of edges proportional to <code>par2</code> (fraction of
inter-connectivity).  It is required that
<code class="reqn">n/s</code> be integer and <code>par2</code> in <code class="reqn">(0,1)</code>.  Defaults are
<code>par1=2</code> and <code>par2=0.25</code>, respectively.</p>
</dd>
</dl>
<h3>Value</h3>

<p>A graph object of class <code>graphNEL</code>.
</p>


<h3>Note</h3>

<p>The output is <em>not</em> topologically sorted (as opposed to the
output of <code>randomDAG</code>).
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Manuel Schuerch.</p>


<h3>References</h3>

<p>These methods are mainly based on the analogue functions in the <span class="pkg">igraph</span> package.
</p>


<h3>See Also</h3>

<p>the package <span class="pkg">igraph</span>, notably help pages such as
<code>sample_k_regular</code> or <code>sample_smallworld</code>;
</p>
<p><code>unifDAG</code> from package <span class="pkg">unifDAG</span> for generating uniform random DAGs.
</p>
<p><code>randomDAG</code> a limited and soon deprecated version of <code>randDAG</code>;
<code>rmvDAG</code> for generating multivariate data according to a DAG.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(38)
dag1 &lt;- randDAG(10, 4, "regular")
dag2 &lt;- randDAG(10, 4, "watts")
dag3 &lt;- randDAG(10, 4, "er")
dag4 &lt;- randDAG(10, 4, "power")
dag5 &lt;- randDAG(10, 4, "bipartite")
dag6 &lt;- randDAG(10, 4, "barabasi")
dag7 &lt;- randDAG(10, 4, "geometric")
dag8 &lt;- randDAG(10, 4, "interEr", par2 = 0.5)

if (require(Rgraphviz)) {
  par(mfrow=c(4,2))
  plot(dag1,main="Regular graph")
  plot(dag2,main="Watts-Strogatz graph")
  plot(dag3,main="Erdoes-Renyi graph")
  plot(dag4,main="Power-law graph")
  plot(dag5,main="Bipartite graph")
  plot(dag6,main="Barabasi graph")
  plot(dag7,main="Geometric random graph")
  plot(dag8,main="Interconnected island graph")
}

set.seed(45)
dag0 &lt;- randDAG(6,3)
dag1 &lt;- randDAG(6,3, weighted=FALSE)
dag2 &lt;- randDAG(6,3, DAG=FALSE)
if (require(Rgraphviz)) {
  par(mfrow=c(1,2))
  plot(dag1)
  plot(dag2)      ## undirected graph
}
dag0@edgeData   ## note the uniform weights between 0.1 and 1
dag1@edgeData   ## note the constant weights

wFUN &lt;- function(m,lB,uB) { runif(m,lB,uB) }
dag &lt;- randDAG(6,3,wFUN=list(wFUN,1,4))
dag@edgeData   ## note the uniform weights between 1 and 4
</code></pre>


</div>
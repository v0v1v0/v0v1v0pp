<div class="container">

<table style="width: 100%;"><tr>
<td>approxProfileExtrema</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Approximate profile extrema functions</h2>

<h3>Description</h3>

<p>Evaluate profile extrema for a set of Psi with approximations at few values
</p>


<h3>Usage</h3>

<pre><code class="language-R">approxProfileExtrema(f, fprime = NULL, d, allPsi, opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>the function to be evaluated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fprime</code></td>
<td>
<p>derivative of the function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>dimension of the input domain</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allPsi</code></td>
<td>
<p>a list containing the matrices Psi (dim <code class="reqn">pxd</code>) for which to compute the profile extrema</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opts</code></td>
<td>
<p>a list containing the options for this function and the subfunctions getProfileSup_optim, getProfileInf_optim or getProfileExtrema. The options only for approxProfileExtrema are
</p>

<ul>
<li>
<p><code>limits:</code>an optional list with the upper and lower limits of input space dimension, if NULL then <code>limits=list(upper=rep(1,d),lower=rep(0,d))</code>
</p>
</li>
<li>
<p><code>smoother:</code>Select which smoother to use:a string that selects which smoother to use: </p>

<ul>
<li>
<p><code>"1order"</code>: first order interpolation with gradient
</p>
</li>
<li>
<p><code>"splineSmooth"</code>: smoothing spline with default degrees of freedom (DEFAULT OPTION)
</p>
</li>
<li>
<p><code>"quantSpline"</code>: profile inf and profile sup approximated with quantile spline regression at levels 0.1 and 0.9 respectively
</p>
</li>
</ul>
</li>
<li>
<p><code>heavyReturn:</code>If TRUE returns also all minimizers, default is FALSE.
</p>
</li>
<li>
<p><code>initDesign:</code>A list of the same length as allPsi containing the designs of few points where the expensive sup is evaluated. If Null it is automatically initialized
</p>
</li>
<li>
<p><code>fullDesignSize:</code>The full design where the function is approximated.
</p>
</li>
<li>
<p><code>multistart:</code>number of multistarts for optim procedure.
</p>
</li>
<li>
<p><code>numMCsamples:</code>number of MC samples for the sup.
</p>
</li>
<li>
<p><code>plts:</code>If TRUE, plots the max/min functions at each coordinate, default is FALSE.
</p>
</li>
<li>
<p><code>verb:</code>If TRUE, outputs intermediate results, default is FALSE.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list of two data frames (min, max) of the evaluations of <code class="reqn">f_sup(x_i) = sup_{x_j \neq i} f(x_1,\dots,x_d) </code> and <code class="reqn">f_inf(x_i) = inf_{x_j \neq i} f(x_1,\dots,x_d) </code>
for each i at the design Design. By default Design is a 100 equally spaced points for each dimension. It can be changed by defining it in options$Design
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Compute the oblique profile extrema with approximate optimization on 2d example

# Define the function
testF &lt;- function(x,params,v1=c(1,0),v2=c(0,1)){
return(sin(crossprod(v1,x)*params[1]+params[2])+cos(crossprod(v2,x)*params[3]+params[4])-1.5)
}

testFprime &lt;- function(x,params,v1=c(1,0),v2=c(0,1)){
  return(matrix(c(params[1]*v1[1]*cos(crossprod(v1,x)*params[1]+params[2])-
                  params[3]*v2[1]*sin(crossprod(v2,x)*params[3]+params[4]),
                 params[1]*v1[2]*cos(crossprod(v1,x)*params[1]+params[2])-
                  params[3]*v2[2]*sin(crossprod(v2,x)*params[3]+params[4])),ncol=1))
}


# Define the main directions of the function
theta=pi/6
pparams&lt;-c(1,0,10,0)
vv1&lt;-c(cos(theta),sin(theta))
vv2&lt;-c(cos(theta+pi/2),sin(theta+pi/2))

# Define optimizer friendly function
f &lt;-function(x){
return(testF(x,pparams,vv1,vv2))
}
fprime &lt;- function(x){
 return(testFprime(x,pparams,vv1,vv2))
}

# Define list of directions where to evaluate the profile extrema
all_Psi &lt;- list(Psi1=vv1,Psi2=vv2)

# Evaluate profile extrema along directions of all_Psi
allOblique&lt;-approxProfileExtrema(f=f,fprime = fprime,d = 2,allPsi = all_Psi,
                                 opts = list(plts=FALSE,heavyReturn=TRUE))


# Consider threshold=0
threshold &lt;- 0

# Plot oblique profile extrema functions
plotMaxMin(allOblique,allOblique$Design,threshold = threshold)

## Since the example is two dimensional we can visualize the regions excluded by the profile extrema
# evaluate the function at a grid for plots
inDes&lt;-seq(0,1,,100)
inputs&lt;-expand.grid(inDes,inDes)
outs&lt;-apply(X = inputs,MARGIN = 1,function(x){return(testF(x,pparams,v1=vv1,v2=vv2))})

# obtain the points where the profiles take the threshold value
cccObl&lt;-getChangePoints(threshold = threshold,allRes = allOblique,Design = allOblique$Design)

# visualize the functions and the regions excluded

image(inDes,inDes,matrix(outs,ncol=100),col=grey.colors(20),main="Example and oblique profiles")
contour(inDes,inDes,matrix(outs,ncol=100),add=TRUE,nlevels = 20)
contour(inDes,inDes,matrix(outs,ncol=100),add=TRUE,levels = c(threshold),col=4,lwd=1.5)
plotOblique(cccObl$alwaysEx$`0`[[1]],all_Psi[[1]],col=3)
plotOblique(cccObl$alwaysEx$`0`[[2]],all_Psi[[2]],col=3)
plotOblique(cccObl$neverEx$`0`[[1]],all_Psi[[1]],col=2)
plotOblique(cccObl$neverEx$`0`[[2]],all_Psi[[2]],col=2)


</code></pre>


</div>
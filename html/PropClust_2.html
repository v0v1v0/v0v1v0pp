<div class="container">

<table style="width: 100%;"><tr>
<td>propensityClustering</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Propensity clustering
</h2>

<h3>Description</h3>

<p>This function performs propensity clustering that assigns objects (or nodes) in a network to clusters such
that the resulting Cluster and Propensity-based Approximation (CPBA) of the input adjacency matrix optimizes
a specific criterion. Large data sets on which standard propensity clustering may take too long are first
optionally split into smaller blocks. Propensity clustering is then applied to each block,
and the clustering is used for the final CPBA decomposition. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">propensityClustering(
  adjacency,
  decompositionType = c("CPBA", "Pure Propensity"),
  objectiveFunction = c("Poisson", "L2norm"),
  fastUpdates = TRUE,
  blocks = NULL,
  initialClusters = NULL,
  nClusters = NULL,
  maxBlockSize = if (fastUpdates) 5000 else 1000,
  clustMethod = "average",
  cutreeDynamicArgs = list(deepSplit = 2, minClusterSize = 20, 
                           verbose = 0),
  dropUnassigned = TRUE,
  unassignedLabel = 0,
  verbose = 2,
  indent = 0)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>adjacency</code></td>
<td>
<p>Adjacency matrix of the network: a square, symmetric, non-negative matrix giving the
connection strengths between pairs of nodes. Missing data are not allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decompositionType</code></td>
<td>
<p>Decomposition type. Either the full CPBA (Cluster and Propensity-Based
Approximation) or pure propensity, which is a special case of CPBA when all nodes are in a single cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objectiveFunction</code></td>
<td>
<p>Objective function. Available choices are <code>"Poisson"</code> and <code>"L2norm"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fastUpdates</code></td>
<td>
<p>Logical: should a fast, "approximate", propensity clustering method be used? This
option is recommended unless the number of nodes to be clustered is small (less than 500). The fast
updates may lead to slightly inferior results but are orders of magnitude faster for larger data sets (above
say 500 nodes).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blocks</code></td>
<td>

<p>Optional specification of blocks. If given, must be a vector with length equal the number of columns in
<code>adjacency</code>, each entry giving the block label for the corresponding node.
If not given, blocks will be determined automatically.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initialClusters</code></td>
<td>

<p>Optional specification of initial clusters. If given, must be a vector with length equal the number of
columns in 
<code>adjacency</code>, each entry giving the cluster label for the corresponding node.
If not given, initial clusters will be determined automatically. The method depends on whether
<code>nClusters</code> (see below) is specified.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nClusters</code></td>
<td>
<p>Optional specification of the number of clusters. Note that specifying <code>nClusters</code>
changes the cluster initialization method. If nodes are split into blocks, the number of clusters in each
block will equal <code>nClusters</code>, and the total number of clusters will be <code>nClusters</code> times the
number of blocks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxBlockSize</code></td>
<td>
<p>Maximum block size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustMethod</code></td>
<td>
<p>Hierarchical clustering method. Recognized options are "average", "complete", and
"single".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutreeDynamicArgs</code></td>
<td>
<p>Arguments (options) for the <code>cutreeDynamic</code>
function from package <code>dynamicTreeCut</code> used in the initial clustering step. Arguments <code>dendro</code> and 
<code>distM</code> are set automatically; the rest can be set by the user to fine-tune the process of initial
cluster identification.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropUnassigned</code></td>
<td>
<p> Logical: should unassigned nodes be excluded from the clustering? Unassigned nodes
can be present in initial clustering or blocks (if given), and internal pre-partitioning and initial
clustering can also lead to unassigned nodes. If <code>dropUnassigned</code> is <code>TRUE</code>, these nodes are
excluded from the calls to <code>propensityClustering</code>. 
Otherwise these nodes will be assigned to the nearest
cluster within each block and be clustered using <code>propensityClustering</code> in each block.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unassignedLabel</code></td>
<td>
<p> Label in input <code>blocks</code> and <code>initialClustering</code> that is reserved for
unassigned objects. For clusterings with numeric lables this is typically (but not always) 0. Note that this
must a valid value - missing value <code>NA</code> will not work. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> Level of verbosity of printed diagnostic messages. 0 means silent (except for progress
reports from the underlying propensity clustering function), higher values will lead to more detailed
progress messages. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indent</code></td>
<td>
<p> Indentation of the printed diagnostic messages. 0 means no indentation, each unit adds two
spaces. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>initialClusters</code> are not given, they are determined from the adjancency in one of the following 
two ways: if
<code>nClusters</code> is not specified, the initialization uses hierarchical
clustering followed by the Dynamic Tree Cut (see <code>cutreeDynamic</code>). Arguments and
options for the <code>cutreeDynamic</code> can be specified using the argument
<code>cutreeDynamicArgs</code>. Some nodes may be left unassigned and their handling is described below. 
If <code>nClusters</code> is specified, an internal initialization algorithm based on
connectivities is used. This second algorithm assigns all nodes to a cluster.
</p>
<p>If <code>dropUnassigned</code> is <code>TRUE</code>, nodes left unassigned by the clustering procedure are excluded from
the following calculations. If <code>dropUnassigned</code> is <code>FALSE</code>, nodes left unassigned by the
clustering procedure are assigned to their nearest cluster, using the clustering dissimilarity measure
specified in <code>clustMethod</code>. 
</p>
<p>In the next step, if the total number of nodes exceeds maximum block size, the initial clusters (either
given or those automatically determined by hierarchical clustering) are split into blocks. 
Clusters bigger than maximum block size
<code>maxBlockSize</code> are put
into separate blocks (one cluster per block). Clusters smaller than maximum block size are placed into
blocks such that the block size does not exceed <code>maxBlockSize</code> and such that clusters with high
between-cluster adjacency are placed in the same block, if possible. The between-cluster adjacency is
consistent with <code>clustMethod</code>. 
</p>
<p>Note that for the purposes of splitting data into blocks, hierarchical clustering is always used. If the
internal initialization of clusters is used, it is applied within each block and idependently of all other
blocks. 
</p>
<p>Next, propensity clustering 
is applied to each block. More precisely, propensity clustering is
applied to the subset of nodes in each block that is assigned to an initial cluster. Some nodes may not be
assigned to initial clusters and these nodes are excluded from propensity clustering. 
</p>
<p>Once propensity clustering on all blocks is finished, propensity decomposition is calculated on the entire
network (excluding unassigned nodes).
</p>


<h3>Value</h3>

<p>List with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Clustering</code></td>
<td>
<p>The final clustering. A vector of length equal to the number of nodes (columns in
<code>adjacency</code>) givig the cluster labels for each node. Clusters are labeled 1,2,3,... 
Label 0 is reserved for unassigned nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Propensity</code></td>
<td>
<p>Propensities (or conformities) of each node.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NodeWasConsidered</code></td>
<td>
<p>Logical vector with one entry per node. <code>TRUE</code> if the node was part of the
propensity clustering and decomposition (recall that unassigned nodes are excluded).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IntermodularAdjacency</code></td>
<td>
<p>Intermodular adjacencies or the conformities between clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Factorizability</code></td>
<td>
<p>Factorizability of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2Norm or Loglik</code></td>
<td>
<p>The L2 Norm or the loglikelihood depending on l2bool.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MeanValues</code></td>
<td>
<p>A distance structure representing the lower triangle of the symmetric matrix of estimated
values of the adjacency matrix using the Propensity and IntermodularAdjacency.
If the Poisson updates are used,
the returned values are the estimate means of the distribution.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TailPvalues</code></td>
<td>
<p> A distance structure representing the lower triangle of the symmetric matrix of
the tail probabilities under the Poisson distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Blocks</code></td>
<td>
<p>Blocks. A vector with one component for each node giving the block label for each node. The
blocks are labeled 1,2,3,...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>InitialClusters</code></td>
<td>
<p>The initial clusters. A copy of the input if given, otherwise the automatically
determined initial clutering. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>InitialTree</code></td>
<td>
<p>The hierarchical clustering dendrogram (tree) used to determine initial clusters. Only
present if the initial clusters were not supplied by the user.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>John Michael Ranola, Peter Langfelder, Kenneth Lange, Steve Horvath
</p>


<h3>References</h3>

<p>Ranola et. al. (2010) A Poisson Model for Random Multigraphs. Bioinformatics 26(16):2004-2001.
Ranola JM, Langfelder P, Lange K, Horvath S (2013) Cluster and propensity based approximation of a network.
MC Syst Biol. 2013 Mar 14;7:21. doi: 10.1186/1752-0509-7-21.
</p>


<h3>See Also</h3>

<p><code>CPBADecomposition</code> for propensity decomposition;
</p>
<p><code>hclust</code> for the hierarchical clustering function,
</p>
<p><code>cutreeDynamic</code> for the dynamic tree cut to identify clusters in a dendrogram
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Simulate 50 nodes in 5 clusters
nNodes=50
nClusters=5
# We would like to use L2Norm instead of Loglikelihood
objective = "L2norm"

ADJ&lt;-matrix(runif(nNodes*nNodes),ncol=nNodes)

ADJ = (ADJ + t(ADJ))/2;

diag(ADJ) = 0;

results&lt;-propensityClustering(
              adjacency = ADJ,
              objectiveFunction = objective,
              initialClusters = NULL,
              nClusters = nClusters,
              fastUpdates = FALSE)

table(results$Clustering)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>ll</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Log-likelihood Statistics.</h2>

<h3>Description</h3>

<p>Apply the log-likelihood statistic to detect cooccurrences or keywords.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ll(.Object, ...)

## S4 method for signature 'features'
ll(.Object)

## S4 method for signature 'context'
ll(.Object)

## S4 method for signature 'cooccurrences'
ll(.Object)

## S4 method for signature 'Cooccurrences'
ll(.Object, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.Object</code></td>
<td>
<p>An object of class <code>cooccurrence</code>, <code>context</code>, or
<code>features</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments (such as <code>verbose</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical, whether to output messages.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The log-likelihood test to detect cooccurrences is a standard approach to
find collocations (Dunning 1993, Evert 2005, 2009).
</p>
<p>(a) The basis for computing for the log-likelihood statistic is a contingency
table of observationes, which is prepared for every single token in the
corpus. It reports counts for a token to inspect and all other tokens in a
corpus of interest (coi) and a reference corpus (ref):
</p>

<table>
<tr>
<td style="text-align: right;">
</td>
<td style="text-align: center;"> coi   </td>
<td style="text-align: center;"> ref </td>
<td style="text-align: center;"> TOTAL </td>
</tr>
<tr>
<td style="text-align: right;">
count token </td>
<td style="text-align: center;"> <code class="reqn">o_{11}</code> </td>
<td style="text-align: center;"> <code class="reqn">o_{12}</code> </td>
<td style="text-align: center;"> <code class="reqn">r_{1}</code> </td>
</tr>
<tr>
<td style="text-align: right;">
other tokens </td>
<td style="text-align: center;"> <code class="reqn">o_{21}</code> </td>
<td style="text-align: center;"> <code class="reqn">o_{22}</code> </td>
<td style="text-align: center;"> <code class="reqn">r_{2}</code> </td>
</tr>
<tr>
<td style="text-align: right;">
TOTAL </td>
<td style="text-align: center;"> <code class="reqn">c_{1}</code> </td>
<td style="text-align: center;"> <code class="reqn">c_{2}</code> </td>
<td style="text-align: center;"> N
</td>
</tr>
</table>
<p>(b) Based on the contingency table(s) with observed counts, expected values
are calculated for each cell, as the product of the column and margin sums,
divided by the overall number of tokens (see example).
</p>
<p>(c) The standard formula for calculating the log-likelihood test is as
follows.
</p>
<p style="text-align: center;"><code class="reqn">G^{2} = 2 \sum{O_{ij} log(\frac{O_{ij}}{E_{ij}})}</code>
</p>

<p>Note: Before polmineR v0.7.11, a simplification of the formula was used
(Rayson/Garside 2000), which omits the third and fourth term of the previous
formula:
</p>
<p style="text-align: center;"><code class="reqn">ll = 2(o_{11} log (\frac{o_{11}}{E_{11}}) + o_{12} log(\frac{o_{12}}{E_{12}}))</code>
</p>

<p>There is a (small) gain of computational efficiency using this simplified
formula and the result is almost identical with the standard formula; see
however the critical discussion of Ulrike Tabbert (2015: 84ff).
</p>
<p>The implementation in the <code>ll</code>-method uses a vectorized approach of the
computation, which is substantially faster than iterating the rows of a
table, generating individual contingency tables etc. As using the standard
formula is not significantly slower than relying on the simplified formula,
polmineR has moved to the standard computation.
</p>
<p>An inherent difficulty of the log likelihood statistic is that it is not
possible to compute the statistical test value if the number of observed
counts in the reference corpus is 0, i.e. if a term only occurrs exclusively
in the neighborhood of a node word. When filtering out rare words from the
result table, respective <code>NA</code> values will usually disappear.
</p>


<h3>References</h3>

<p>Dunning, Ted (1993): Accurate Methods for the Statistics of
Surprise and Coincidence. <em>Computational Linguistics</em>, Vol. 19, No. 1,
pp. 61-74.
</p>
<p>Rayson, Paul; Garside, Roger (2000): Comparing Corpora using
Frequency Profiling. <em>The Workshop on Comparing Corpora</em>.
<a href="https://aclanthology.org/W00-0901/">https://aclanthology.org/W00-0901/</a>.
</p>
<p>Evert, Stefan (2005): <em>The Statistics of Word Cooccurrences.
Word Pairs and Collocations.</em> URN urn:nbn:de:bsz:93-opus-23714.
<a href="https://elib.uni-stuttgart.de/bitstream/11682/2573/1/Evert2005phd.pdf">https://elib.uni-stuttgart.de/bitstream/11682/2573/1/Evert2005phd.pdf</a>
</p>
<p>Evert, Stefan (2009). Corpora and Collocations. In: A. Ludeling
and M. Kyto (eds.), <em>Corpus Linguistics. An International Handbook</em>. Mouton
de Gruyter, Berlin, pp. 1212-1248 (ch. 58).
</p>
<p>Tabbert, Ulrike (2015): <em>Crime and Corpus. The Linguistic
Representation of Crime in the Press</em>. Amsterdam: Benjamins.
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code>chisquare()</code>,
<code>pmi()</code>,
<code>t_test()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># use ll-method explicitly
oil &lt;- cooccurrences("REUTERS", query = "oil", method = NULL)
oil &lt;- ll(oil)
oil_min &lt;- subset(oil, count_coi &gt;= 3)
if (interactive()) View(format(oil_min))
summary(oil)

# use ll-method on 'Cooccurrences'-object
## Not run: 
R &lt;- Cooccurrences("REUTERS", left = 5L, right = 5L, p_attribute = "word")
ll(R)
decode(R)
summary(R)

## End(Not run)

# use log likelihood test for feature extraction
x &lt;- partition(
  "GERMAPARLMINI", speaker = "Merkel",
  interjection = "speech", regex = TRUE,
  p_attribute = "word"
)
f &lt;- features(x, y = "GERMAPARLMINI", included = TRUE, method = "ll")
f &lt;- features(x, y = "GERMAPARLMINI", included = TRUE, method = NULL)
f &lt;- ll(f)
summary(f)

## Not run: 

# A sample do-it-yourself calculation for log-likelihood:
# Compute ll-value for query "oil", and "prices"

oil &lt;- context("REUTERS", query = "oil", left = 5, right = 5)

# (a) prepare matrix with observed values
o &lt;- matrix(data = rep(NA, 4), ncol = 2) 
o[1,1] &lt;- as(oil, "data.table")[word == "prices"][["count_coi"]]
o[1,2] &lt;- count("REUTERS", query = "prices")[["count"]] - o[1,1]
o[2,1] &lt;- size(oil)[["coi"]] - o[1,1]
o[2,2] &lt;- size(oil)[["ref"]] - o[1,2]


# (b) prepare matrix with expected values, calculate margin sums first
r &lt;- rowSums(o)
c &lt;- colSums(o)
N &lt;- sum(o)

e &lt;- matrix(data = rep(NA, 4), ncol = 2) # matrix with expected values
e[1,1] &lt;- r[1] * (c[1] / N)
e[1,2] &lt;- r[1] * (c[2] / N)
e[2,1] &lt;- r[2] * (c[1] / N)
e[2,2] &lt;- r[2] * (c[2] / N)


# (c) compute log-likelihood value
ll_value &lt;- 2 * (
  o[1,1] * log(o[1,1] / e[1,1]) +
  o[1,2] * log(o[1,2] / e[1,2]) +
  o[2,1] * log(o[2,1] / e[2,1]) +
  o[2,2] * log(o[2,2] / e[2,2])
)

df &lt;- as.data.frame(cooccurrences("REUTERS", query = "oil"))
subset(df, word == "prices")[["ll"]]

## End(Not run)
</code></pre>


</div>
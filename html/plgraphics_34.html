<div class="container">

<table style="width: 100%;"><tr>
<td>gensmooth</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Smooth: wrapper function
</h2>

<h3>Description</h3>

<p>Generate fits of a smoothing function for multiple y's.
Smooths can be calculated within given groups.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gensmooth(x, y, band = FALSE, power = 1, resid = "difference",
  weight = NULL, plargs=NULL, ploptions=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector of x values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>vector or matrix of y values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>band</code></td>
<td>
<p>logical: Should a band consisting of low and high smooth
be calculated? It will only be calculated for the first column of <code>y</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p><code>y</code> will be raised to <code>power</code> before smoothing.
Results will be back-transformed. (Useful for smoothing absolute
values for a 'scale plot', for which <code>power=0.5</code> is recommended.)    
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid</code></td>
<td>
<p>Which residuals be calculated?
<code>resid=1</code> or <code>="difference"</code> means usual residuals;
<code>resid=2</code> or <code>="ratio"</code> means $y_i/\hat y_i$, which is useful
to get scaled y's (regression residuals) according to a smooth fit in the
scale plot.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>weights of observations, may also be passed by a
variable <code>.smoothWeights.</code> in the data set <code>plargs$pldata</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plargs, ploptions</code></td>
<td>
<p>result of calling <code>pl.control</code>.
The component <code>plargs$pdata</code> may contain <code>smooth.weight</code>
and <code>smooth.group</code>, and <code>ploptions</code> specifies
<code>smoothPar</code> and <code>smoothIter</code>.
All of these may be used by the smoothing function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments, passed to the smoothing function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is useful for generating the smooths enhancing
residual plots.
It generates a smooth for a single x
variable and multiple y's.
It is also used to draw smooths from simulated residuals.
</p>
<p>NA's in either <code>x</code> or any column of <code>y</code> cause dropping the
observation (equivalent to <code>na.omit</code>).
</p>
<p>The smoothing function used to produce the smooth is
<code>smoothRegr</code>, which relies <code>loess</code>, by default.
This may be changed via <code>ploptions(smooth.function = func)</code> where
<code>func</code> is a smoothing function with the same arguments as
<code>smoothRegr</code>.
</p>
<p>The result of the smoothing function may carry an attribute
<code>xtrim</code>. This regulates if the fitted values corresponding to
extreme x values will be suppressed when plotting:
The number of extreme x values corresponding to
<code>ploptions("smooth.xtrim")</code> will be multiplied by
this attribute to obtain the number of extreme points suppressed at
each end. If the smoothing function is <code>smoothLm</code>, which fits a
straight line, then trimming is suppressed since this function returns
0 as the <code>xtrim</code> attribute.
</p>
<p>If <code>band</code> is <code>TRUE</code>, a vector of "low" and a vector of
"high" smooth values will be calculated for the first column of
<code>y</code> in the following way:
Residuals are calculated as the diference
between the observations and the respective smoothed values hat.$s_i$.
Then a smooth is calculated for the square roots of the positive residuals,
and the squared fitted values are added to the hat.$s_i$.
(The transformation by square roots makes the distribution of the residuals 
more symmetric.)
This defines the “high” smooth values. 
The construction of the “low” one is analogous.
The resulting values of the two are stored in the list component
<code>yband</code>, and <code>ybandindex</code> contains the information to which
group ("low" or "high") the value belongs.
</p>


<h3>Value</h3>

<p>A list with components:  
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector of x values, sorted, within levels of <code>group</code>
if grouping is actif.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>matrix with 1 or more columns of corresponding fitted values
of the smoothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>grouping factor, sorted, if actif. <code>NULL</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>vector of indices of the argument <code>x</code> used for
sorting. This is useful to relate the results to the input.
Use <code>ysmoothed[value$index,] &lt;- value$y</code> to get values
corresponding to input <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xorig</code></td>
<td>
<p>original <code>x</code> values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ysmorig</code></td>
<td>
<p>corresponding fitted values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>if required by the argument <code>resid</code>,
residuals from the smooth fit are provided in the original order,
i.e. <code>value$resid[i,j]</code> corresponds to the input
<code>value$y[i,j]</code>.</p>
</td>
</tr>
</table>
<p>If <code>band==TRUE</code>,
</p>
<table>
<tr style="vertical-align: top;">
<td><code>yband</code></td>
<td>
<p>vector of low and high smoothed values (for the first
column of <code>y</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ybandindex</code></td>
<td>
<p>Indicator if <code>yband</code> is a high value</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function is called by <code>plyx</code> and
<code>plmatrix</code> when <code>smooth=T</code> is set,
as well as by
<code>plregr</code> applied to model objects.
It is rarely needed to call it directly.<br>
A band is generated only for the first columnn of <code>y</code> since the
others are supposed to be simulated versions of the first one
and do not need a band. 
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code>smoothRegr</code>,
<code>plsmooth</code>, <code>plsmoothline</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(d.blast)
r.blast &lt;-
  lm(log10(tremor)~location+log10(distance)+log10(charge), data=d.blast,
    na.action=na.exclude)
r.smooth &lt;- gensmooth( fitted(r.blast), residuals(r.blast))
showd(r.smooth$y)
plot(fitted(r.blast), resid(r.blast), main="Tukey-Anscombe Plot")
abline(h=0)
lines(r.smooth$x,r.smooth$y, col="red")

## grouped data
t.plargs &lt;- list(pdata=data.frame(".smooth.group."=d.blast$location))

r.smx &lt;- gensmooth( d.blast$dist, residuals(r.blast), plargs=t.plargs)

plot(d.blast$dist, residuals(r.blast), main="Residuals against Regressor")
abline(h=0)
plsmoothline(r.smx, d.blast$dist, resid(r.blast), plargs=t.plargs)
## or, without using plsmoothlines:
## for (lg in 1:length(levels(r.smx$group))) {
##   li &lt;- as.numeric(r.smx$group)==lg 
##   lines(r.smx$x[li],r.smx$y[li], col=lg+1, lwd=3)
## }
</code></pre>


</div>
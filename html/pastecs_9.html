<div class="container">

<table style="width: 100%;"><tr>
<td>decaverage</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Time series decomposition using a moving average </h2>

<h3>Description</h3>

<p>Decompose a single regular time series with a moving average filtering. Return a 'tsd' object. To decompose several time series at once, use <code>tsd()</code> with the argument <code>method="average"</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">decaverage(x, type="additive", order=1, times=1, sides=2, ends="fill",
        weights=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> a regular time series ('rts' under S+ and 'ts' under R) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> the type of model, either <code>type="additive"</code> (by default), or <code>type="multiplicative"</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p> the order of the moving average (the window of the average being 2*order+1), centered around the current observation or at left of this observation depending upon the value of the <code>sides</code> argument. Weights are the same for all observations within the window. However, if the argument <code>weights</code> is provided, it supersedes <code>order</code>. One can also use <code>order="periodic"</code>. In this case, a deseasoning filter is calculated according to the value of <code>frequency</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p> The number of times to apply the method (by default, once) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sides</code></td>
<td>
<p> If 2 (by default), the window is centered around the current observation. If 1, the window is at left of the current observation (including it) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ends</code></td>
<td>
<p> either "NAs" (fill first and last values that are not calculable with NAs), or "fill" (fill them with the average of observations before applying the filter, by default), or "circular" (use last values for estimating first ones and vice versa), or "periodic" (use entire periods of contiguous cycles, deseasoning) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p> a vector indicating weight to give to all observations in the window. This argument has the priority over <code>order</code> </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is a wrapper around the <code>filter()</code> function and returns a 'tsd' object. However, it offers more methods to handle ends.
</p>


<h3>Value</h3>

<p>A 'tsd' object
</p>


<h3>Author(s)</h3>

<p> Frédéric Ibanez (<a href="mailto:ibanez@obs-vlfr.fr">ibanez@obs-vlfr.fr</a>), Philippe Grosjean (<a href="mailto:phgrosjean@sciviews.org">phgrosjean@sciviews.org</a>) </p>


<h3>References</h3>

<p>Kendall, M., 1976. <em>Time-series.</em> Charles Griffin &amp; Co Ltd. 197 pp.
</p>
<p>Laloire, J.C., 1972. <em>Méthodes du traitement des chroniques.</em> Dunod, Paris, 194 pp.
</p>
<p>Malinvaud, E., 1978. <em>Méthodes statistiques de l'économétrie.</em> Dunod, Paris. 846 pp.
</p>
<p>Philips, L. &amp; R. Blomme, 1973. <em>Analyse chronologique.</em> Université Catholique de Louvain. Vander ed. 339 pp.
</p>


<h3>See Also</h3>

 <p><code>tsd</code>, <code>tseries</code>, <code>deccensus</code>, <code>decdiff</code>, <code>decmedian</code>,  <code>decevf</code>, <code>decreg</code>, <code>decloess</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">data(marbio)
ClausoB.ts &lt;- ts(log(marbio$ClausocalanusB + 1))
ClausoB.dec &lt;- decaverage(ClausoB.ts, order=2, times=10, sides=2, ends="fill")
plot(ClausoB.dec, col=c(1, 3, 2), xlab="stations")
# A stacked graph is more representative in this case
plot(ClausoB.dec, col=c(1, 3), xlab="stations", stack=FALSE, resid=FALSE,
        lpos=c(53, 4.3))
</code></pre>


</div>
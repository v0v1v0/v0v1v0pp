<div class="container">

<table style="width: 100%;"><tr>
<td>debiased_lasso</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Doing statistical inference on l1-penalized multinomial regression via debiased Lasso (or desparisified Lasso).</h2>

<h3>Description</h3>

<p>Doing statistical inference on l1-penalized multinomial regression via debiased Lasso (or desparisified Lasso). This function implements the algorithm described in Tian et al. (2023), which is an extension of the original debiased Lasso (Van de Geer et al. (2014); Zhang and Zhang (2014)) to the multinomial case.
</p>


<h3>Usage</h3>

<pre><code class="language-R">debiased_lasso(
  x,
  y,
  ref = NULL,
  beta,
  nfolds = 5,
  ncores = 1,
  nlambda = 50,
  max_iter = 200,
  tol = 0.001,
  lambda.choice = "lambda.min",
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the design/predictor matrix, each row of which is an observation vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the response variable. Can be of one type from factor/integer/character.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ref</code></td>
<td>
<p>the reference level. Default = NULL, which sets the same reference level as used in obtaining <code>beta</code>. Even when the user inputs <code>ref</code> manually, it should be always the same reference level as used in obtaining <code>beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>the beta estimate from l1-penalized multinomial regression. Should be in the same format as <code>beta.min</code> or <code>beta.1se</code> in output of function <code>cv.pemultinom</code>. The user is recommended to directly pass <code>beta.min</code> or <code>beta.1se</code> from the output of function <code>cv.pemultinom</code> to parameter <code>beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>the number of cross-validation folds to use. Cross-validation is used to determine the best tuning parameter lambda in the nodewise regression, i.e., Algorithm 2 in Tian et al. (2023). Default = 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>the number of cores to use for parallel computing. Default = 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>the number of penalty parameter candidates in the cross-validation procedure. Cross-validation is used to determine the best tuning parameter lambda in the nodewise regression, i.e., Algorithm 2 in Tian et al. (2023). Default = 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>the maximum iteration rounds in each iteration of the coordinate descent algorithm. Default = 200.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>convergence threshold (tolerance level) for coordinate descent. Default = 1e-3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.choice</code></td>
<td>
<p>observation weights. Should be a vector of non-negative numbers of length n (the number of observations). Default = NULL, which sets equal weights for all observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>significance level used in the output confidence interval. Has to be a number between 0 and 1. Default = 0.05.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of data frames, each of which contains the inference results for each class (v.s. the reference class). In the data frame, each row represents a variable. The columns include:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>the debiased point estimate of the coefficient</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_value</code></td>
<td>
<p>p value of each variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CI_lower</code></td>
<td>
<p>lower endpoint of the confidence interval for each coefficient</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CI_upper</code></td>
<td>
<p>upper endpoint of the confidence interval for each coefficient</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std_dev</code></td>
<td>
<p>the estimated standard deviation of each component of beta estimate</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Tian, Y., Rusinek, H., Masurkar, A. V., &amp; Feng, Y. (2023). L1-penalized Multinomial Regression: Estimation, inference, and prediction, with an application to risk factor identification for different dementia subtypes. arXiv preprint arXiv:2302.02310.
</p>
<p>Van de Geer, S., BÃ¼hlmann, P., Ritov, Y. A., &amp; Dezeure, R. (2014). On asymptotically optimal confidence regions and tests for high-dimensional models. The Annals of Statistics, 42(3), 1166-1202.
</p>
<p>Zhang, C. H., &amp; Zhang, S. S. (2014). Confidence intervals for low dimensional parameters in high dimensional linear models. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 76(1), 217-242.
</p>


<h3>See Also</h3>

<p><code>cv.pemultinom</code>, <code>predict_pemultinom</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# generate data from Model 1 in Tian et al. (2023) with n = 100 and p = 50
set.seed(0, kind = "L'Ecuyer-CMRG")
n &lt;- 50
p &lt;- 50
K &lt;- 3

Sigma &lt;- outer(1:p, 1:p, function(x,y) {
  0.9^(abs(x-y))
})
R &lt;- chol(Sigma)
s &lt;- 3
beta_coef &lt;- matrix(0, nrow = p+1, ncol = K-1)
beta_coef[1+1:s, 1] &lt;- c(1.5, 1.5, 1.5)
beta_coef[1+1:s+s, 2] &lt;- c(1.5, 1.5, 1.5)

x &lt;- matrix(rnorm(n*p), ncol = p) %*% R
y &lt;- sapply(1:n, function(j){
  prob_i &lt;- c(sapply(1:(K-1), function(k){
    exp(sum(x[j, ]*beta_coef[-1, k]))
  }), 1)
  prob_i &lt;- prob_i/sum(prob_i)
  sample(1:K, size = 1, replace = TRUE, prob = prob_i)
})

# fit the l1-penalized multinomial regression model
fit &lt;- cv.pemultinom(x, y, ncores = 2)
beta &lt;- fit$beta.min

# run the debiasing approach
fit_debiased &lt;- debiased_lasso(x, y, beta = beta, ncores = 2)

</code></pre>


</div>
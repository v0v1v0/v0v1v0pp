<div class="container">

<table style="width: 100%;"><tr>
<td>hybrid_policy_tree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hybrid tree search</h2>

<h3>Description</h3>

<p>Finds a depth k tree by looking ahead l steps.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hybrid_policy_tree(
  X,
  Gamma,
  depth = 3,
  search.depth = 2,
  split.step = 1,
  min.node.size = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The covariates used. Dimension <code class="reqn">N*p</code> where <code class="reqn">p</code> is the number of features.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gamma</code></td>
<td>
<p>The rewards for each action. Dimension <code class="reqn">N*d</code> where <code class="reqn">d</code> is the number of actions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>depth</code></td>
<td>
<p>The depth of the fitted tree. Default is 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>search.depth</code></td>
<td>
<p>Depth to look ahead when splitting. Default is 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split.step</code></td>
<td>
<p>An optional approximation parameter, the number of possible splits
to consider when performing tree search. split.step = 1 (default) considers every possible split, split.step = 10
considers splitting at every 10'th sample and may yield a substantial speedup for dense features.
Manually rounding or re-encoding continuous covariates with very high cardinality in a
problem specific manner allows for finer-grained control of the accuracy/runtime tradeoff and may in some cases
be the preferred approach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.node.size</code></td>
<td>
<p>An integer indicating the smallest terminal node size permitted. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Give verbose output. Default is TRUE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Builds deeper trees by iteratively using exact tree search to look ahead l splits. For example,
with <code>depth = 3</code> and <code>search.depth = 2</code>, the root split is determined by a depth 2 exact tree,
and two new depth 2 trees are fit in the two immediate children using exact tree search,
leading to a total depth of 3 (the resulting tree may be shallower than the
specified <code>depth</code> depending on whether leaf nodes were pruned or not).
This algorithm scales with some coefficient multiple of the runtime of a <code>search.depth</code> <code>policy_tree</code>,
which means that for this approach to be feasible it needs an (n, p, d) configuration in which
a <code>search.depth</code> <code>policy_tree</code> runs in reasonable time.
</p>
<p>The algorithm: desired depth is given by <code>depth</code>. Each node is split using exact tree search
with depth  = <code>search.depth</code>. When we reach a node where the current level + <code>search.depth</code> is equal to <code>depth</code>,
we stop and attach the <code>search.depth</code> subtree to this node.
We also stop if the best <code>search.depth</code> split yielded a leaf node.
</p>


<h3>Value</h3>

<p>A policy_tree object.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Fit a depth three tree on doubly robust treatment effect estimates from a causal forest.
n &lt;- 1500
p &lt;- 5
X &lt;- round(matrix(rnorm(n * p), n, p), 2)
W &lt;- rbinom(n, 1, 1 / (1 + exp(X[, 3])))
tau &lt;- 1 / (1 + exp((X[, 1] + X[, 2]) / 2)) - 0.5
Y &lt;- X[, 3] + W * tau + rnorm(n)
c.forest &lt;- grf::causal_forest(X, Y, W)
dr.scores &lt;- double_robust_scores(c.forest)

tree &lt;- hybrid_policy_tree(X, dr.scores, depth = 3)

# Predict treatment assignment.
predicted &lt;- predict(tree, X)

</code></pre>


</div>
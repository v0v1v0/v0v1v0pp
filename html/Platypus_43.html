<div class="container">

<table style="width: 100%;"><tr>
<td>VDJ_GEX_matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>VDJ GEX processing and integration wrapper</h2>

<h3>Description</h3>

<p>This function is designed as a common input to the Platypus pipeline. Integration of datasets as well as VDJ and GEX information is done here. Please check the Platypus V3 vignette for a detailed walkthrough of the output structure. In short: output[[1]] = VDJ table, output[[2]] = GEX Seurat object and output[[3]] = statistics
[FB] Feature barcode (FB) technology is getting increasingly popular, which is why Platypus V3 fully supports their use as sample delimiters. As of V3, Platpyus does not support Cite-seq data natively, also the VDJ_GEX_matrix function is technically capable of loading a Cite-seq matrix and integrating it with VDJ. For details on how to process sequencing data with FB data and how to supply this information to the VDJ_GEX_matrix function, please consult the dedicated vignette on FB data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">VDJ_GEX_matrix(
  VDJ.out.directory.list,
  GEX.out.directory.list,
  FB.out.directory.list,
  Data.in,
  Seurat.in,
  group.id,
  GEX.read.h5,
  VDJ.combine,
  GEX.integrate,
  integrate.GEX.to.VDJ,
  integrate.VDJ.to.GEX,
  exclude.GEX.not.in.VDJ,
  filter.overlapping.barcodes.GEX,
  filter.overlapping.barcodes.VDJ,
  get.VDJ.stats,
  append.raw.reference,
  select.excess.chains.by.umi.count,
  excess.chain.confidence.count.threshold,
  trim.and.align,
  parallel.processing,
  numcores,
  gap.opening.cost,
  gap.extension.cost,
  exclude.on.cell.state.markers,
  exclude.on.barcodes,
  integration.method,
  VDJ.gene.filter,
  mito.filter,
  norm.scale.factor,
  n.feature.rna,
  n.count.rna.min,
  n.count.rna.max,
  n.variable.features,
  cluster.resolution,
  neighbor.dim,
  mds.dim,
  FB.count.threshold,
  FB.ratio.threshold,
  FB.exclude.pattern,
  subsample.barcodes,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>VDJ.out.directory.list</code></td>
<td>
<p>List containing paths to VDJ output directories from cell ranger. This pipeline assumes that the output file names have not been changed from the default 10x settings in the /outs/ folder. This is compatible with B and T cell repertoires. ! Neccessary files within this folder: filtered_contig_annotations.csv, clonotypes.csv, concat_ref.fasta, all_contig_annotations.csv (only if trim.and.align == TRUE) and metrics_summary.csv (Optional, will be appended to stats table if get.VDJ.stats == TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GEX.out.directory.list</code></td>
<td>
<p>List containing paths the outs/ directory of each sample or directly the raw or filtered_feature_bc_matrix folder. Order of list items must be the same as for VDJ. These may be paths to cellranger aggr or cellranger multi output directories. In that case, additional matrices found, will be loaded as either GEX or FB (Feature barcodes) depending on the number of features in the matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FB.out.directory.list</code></td>
<td>
<p>[FB] List of paths pointing at the outs/ directory of output from the Cellranger counts function which contain Feature barcode counts. ! Single list elements can be a path or "PLACEHOLDER", if the corresponding input in the VDJ or GEX path does not have any adjunct FB data. This is only the case when integrating two datasets of which only one has FB data. See examples for details. Any input will overwrite potential FB data loaded from the GEX input directories. This may be important, if wanting to input unfiltered FB data that will cover also cells in VDJ not present in GEX.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Data.in</code></td>
<td>
<p>Input for R objects from either the PlatypusDB_load_from_disk or the PlatypusDB_fetch function. If provided, input directories should not be specified. If you wish to integrate local and downloaded data, please load them via load_from_disk and fetch and provide as a list (e.g. Data.in = list(load_from_disk.output, fetch.output))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Seurat.in</code></td>
<td>
<p>Alternative to GEX.out.directory.list. A seurat object. VDJ.integrate has to be set to TRUE. In metadata the column of the seurat object, sample_id and group_id must be present. sample_id must contain ids in the format "s1", "s2" ... "sn" and must be matching the order of VDJ.out.directory.list. No processing (i.e. data normalisation and integration) will be performed on these objects. They will be returned as part of the VGM and with additional VDJ data if integrate.VDJ.to.GEX = T. Filtering parameters such as overlapping barcodes, exclude.GEX.not.in.VDJ and exclude.on.cell.state.markers will be applied to the Seurat.in GEX object(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.id</code></td>
<td>
<p>vector with integers specifying the group membership. c(1,1,2,2) would specify the first two elements of the input VDJ/GEX lists are in group 1 and the third/fourth input elements will be in group 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GEX.read.h5</code></td>
<td>
<p>Boolean. defaults to FALSE. Whether to read GEX data from an H5 file. If set to true, please provide the each directory containing a cellranger H5 output file or a direct path to a filtered_feature_bc_matrix.h5 as one GEX.out.directory.list element.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VDJ.combine</code></td>
<td>
<p>Boolean. Defaults to TRUE. Whether to integrate repertoires. A sample identifier will be appended to each barcode both in GEX as well as in VDJ. Recommended for all later functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GEX.integrate</code></td>
<td>
<p>Boolean. Defaults to TRUE. Whether to integrate GEX data. Default settings use the seurat scale.data option to integrate datasets. Sample identifiers will be appended to each barcode both in GEX and VDJ This is helpful when analysing different samples from the same organ or tissue, while it may be problematic when analysing different tissues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integrate.GEX.to.VDJ</code></td>
<td>
<p>Boolean. defaults to TRUE. Whether to integrate GEX metadata (not raw counts) into the VDJ output dataframe ! Only possible, if GEX.integrate and VDJ.combine are either both FALSE or both TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integrate.VDJ.to.GEX</code></td>
<td>
<p>Boolean. defaults to TRUE. Whether to integrate VDJ data into GEX seurat object as metadata. ! Only possible, if GEX.integrate and VDJ.combine are either both FALSE or both TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude.GEX.not.in.VDJ</code></td>
<td>
<p>Boolean. defaults to FALSE. Whether to delete all GEX cell entries, for which no VDJ information is available. Dependent on data quality and sequencing depth this may reduce the GEX cell count by a significant number</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.overlapping.barcodes.GEX</code></td>
<td>
<p>Boolean. defaults to TRUE. Whether to remove barcodes which are shared among samples in the GEX analysis. Shared barcodes normally appear at a very low rate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.overlapping.barcodes.VDJ</code></td>
<td>
<p>Boolean. defaults to TRUE. Whether to remove barcodes which are shared among samples in the GEX analysis. Shared barcodes normally appear at a very low rate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>get.VDJ.stats</code></td>
<td>
<p>Boolean. defaults to TRUE. Whether to generate general statistics table for VDJ repertoires. This is appended as element [[3]] of the output list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>append.raw.reference</code></td>
<td>
<p>Boolean. Defaults to TRUE. This appends the raw reference sequence for each contig even if trim.and.align is set to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select.excess.chains.by.umi.count</code></td>
<td>
<p>Boolean. Defaults to FALSE. There are several methods of dealing with cells containing reads for more than 1VDJ and 1VJ chain. While many analyses just exclude such cells, the VGM is designed to keep these for downstream evaluation (e.g. in VDJ_clonotype). This option presents an evidenced-based way of selectively keeping or filtering only one of the present VDJ  and VJ chains each. This works in conjunction with the parameter excess.chain.confidence.count.threshold (below) Idea source: Zhang W et al. Sci Adv. 2021 (10.1126/sciadv.abf5835)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>excess.chain.confidence.count.threshold</code></td>
<td>
<p>Interger. Defaults to 1000. This sets a umi count threshold for keeping excessive chains in a cell (e.g. T cells with 2 VJ and 1 VDJ chain) and only has an effect if select.excess.chains.by.umi.count is set to TRUE. For a given cell with chains and their UMI counts: VDJ1 = 3, VDJ2 = 7, VJ1 = 6. If count.threshold is kept at default (1000), the VDJ chain with the most UMIs will be kept (VDJ2), while the other is filtered out (VDJ1), leaving the cell as VDJ2, VJ1. If the count.threshold is set to 3, both chains VDJ chains of this cell are kept as their UMI counts are equal or greater to the count.threshold and therefore deemed high confidence chains. In the case of UMI counts being equal for two chains AND below the count.threshold, the first contig entry is kept, while the second is filtered. To avoid filtering excess chains, set select.excess.chains.by.umi.count to FALSE. For further notes on the implication of these please refer to the documentation of the parameter hierarchical in the function VDJ_clonotype_v3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trim.and.align</code></td>
<td>
<p>Boolean. Defaults to FALSE. Whether to trim VJ/VDJ seqs, align them to the 10x reference and trim the reference. This is useful to get full sequences for antibody expression or numbers of somatic hypermutations. !Setting this to TRUE significantly increases computational time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.processing</code></td>
<td>
<p>Character string. Can be "parlapply" for Windows system, "mclapply" for unix and Mac systems or "none" to use a simple for loop (slow!). Default is "none" for compatibility reasons. For the parlapply option the packages parallel, doParallel and the dependency foreach are required</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numcores</code></td>
<td>
<p>Number of cores used for parallel processing. Defaults to number of cores available. If you want to chek how many cores are available use the library Parallel and its command detectCores() (Not setting a limit here when running this function on a cluster may cause a crash)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gap.opening.cost</code></td>
<td>
<p>Argument passed to Biostrings::pairwiseAlignment during alignment to reference. Defaults to 10</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gap.extension.cost</code></td>
<td>
<p>Argument passed to Biostrings::pairwiseAlignment during alignment to reference. Defaults to 4</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude.on.cell.state.markers</code></td>
<td>
<p>Character vector. If no input is provided or input is "none", no cells are excluded. Input format should follow: Character vector containing the gene names for each state. ; is used to use multiple markers within a single gene state. Different vector elements correspond to different states. Example: c("CD4+;CD44-","CD4+;IL7R+;CD44+"). All cells which match any of the given states (in the example case any of the 2) are excluded. This is useful in case different and non lymphocyte cells were co-sequenced. It should give the option to e.g. exclude B cells in the analysis of T cells in a dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude.on.barcodes</code></td>
<td>
<p>Character vector. Provide a list of 10x barcodes WITHOUT the terminal id (-1 , -2 etc.) to exclude from GEX and VDJ prior to processing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integration.method</code></td>
<td>
<p>String specifying which data normalization and integration pipeline should be used. Default is "scale.data", which correspondings to the ScaleData function internal to harmony package. 'anchors' scales data individually and then finds and align cells in similar states as described here: https://satijalab.org/seurat/articles/integration_introduction.html. 'sct'specifies SCTransform from the Seurat package. "harmony" should be specificied to perform harmony integration. This method requires the harmony package from bioconductor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VDJ.gene.filter</code></td>
<td>
<p>Logical indicating if variable genes from the b cell receprot and t cell receptor should be removed from the analysis. True is highly recommended to avoid clonal families clustering together.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mito.filter</code></td>
<td>
<p>Numeric specifying which percent of genes are allowed to be composed of mitochondrial genes. This value may require visual inspection and can be specific to each sequencing experiment. Users can visualize the percentage of genes corresponding to mitochondrial genes using the function "investigate_mitochondial_genes".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm.scale.factor</code></td>
<td>
<p>Scaling factor for the standard Seurat pipeline. Default is set to 10000 as reported in Seurat documentation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.feature.rna</code></td>
<td>
<p>Numeric that specifies which cells should be filtered out due to low number of detected genes. Default is set to 0. Seurat standard pipeline uses 2000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.count.rna.min</code></td>
<td>
<p>Numeric that specifies which cells should be filtered out due to low RNA count.Default is set to 0. Seurat standard pipeline without VDJ information uses 200.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.count.rna.max</code></td>
<td>
<p>Numeric that specifies which cells should be filtered out due to high RNA count.Default is set to infinity. Seurat standard pipeline without VDJ information uses 2500.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.variable.features</code></td>
<td>
<p>Numeric specifying the number of variable features. Default set to 2000 as specified in Seurat standard pipeline.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster.resolution</code></td>
<td>
<p>Numeric specifying the resolution that will be supplied to Seurat's FindClusters function. Default is set to 0.5. Increasing this number will increase the number of distinct Seurat clusters. Suggested to examine multiple parameters to ensure gene signatures differentiating clusters remains constant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbor.dim</code></td>
<td>
<p>Numeric vector specifying which dimensions should be supplied in the FindNeighbors function from Seurat. Default input is '1:10'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mds.dim</code></td>
<td>
<p>Numeric vector specifying which dimensions should be supplied into dimensional reduction techniques in Seurat and Harmony. Default input is '1:10'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FB.count.threshold</code></td>
<td>
<p>Numeric. Defaults to 10. For description of Feature Barcode assignment see parameter FB.ratio.threshold above</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FB.ratio.threshold</code></td>
<td>
<p>Numeric. Defaults to 2 Threshold for assignment of feature barcodes by counts. A feature barcode is assigned to a cell if its counts are &gt;FB.count.threshold and if its counts are FB.ratio.threshold-times higher than the counts of the feature barcode with second most counts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FB.exclude.pattern</code></td>
<td>
<p>Character (regex compatible). If a feature barcode matches this pattern it will be excluded from the hashing sample assignments. This may be neccessary if CITE-seq barcodes and hashing barcodes are sequenced in the same run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subsample.barcodes</code></td>
<td>
<p>For development purposes only. If set to TRUE the function will run on 100 cells only to increase speeds of debugging</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if TRUE prints runtime info to console. Defaults to TRUE</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Single cell matrix including VDJ and GEX info. Format is a list with out[[1]] = a VDJ dataframe (or list of dataframes if VDJ.combine == FALSE, not recommended) containing also selected GEX information of integrate.GEX.to.VDJ = T. out[[2]] = GEX Seurat object with the metadata also containing GEX information if integrate.VDJ.to.GEX = T. out[[3]] = Dataframe with statistics on GEX and VDJ. out[[4]] = runtime parameters. out[[5]] = session info
</p>


<h3>Examples</h3>

<pre><code class="language-R">
try({
VDJ.out.directory.list &lt;- list()
VDJ.out.directory.list[[1]] &lt;- c("~/VDJ/S1/")
VDJ.out.directory.list[[2]] &lt;- c("~/VDJ/S2/")
GEX.out.directory.list &lt;- list()
GEX.out.directory.list[[1]] &lt;- c("~/GEX/S1/")
GEX.out.directory.list[[2]] &lt;- c("~/GEX/S2/")
VGM &lt;- VDJ_GEX_matrix(
VDJ.out.directory.list = VDJ.out.directory.list
,GEX.out.directory.list = GEX.out.directory.list
,GEX.integrate = T
,VDJ.combine = T
,integrate.GEX.to.VDJ = T
,integrate.VDJ.to.GEX = T
,exclude.GEX.not.in.VDJ = F
,filter.overlapping.barcodes.GEX = F
,filter.overlapping.barcodes.VDJ = F
,get.VDJ.stats = T
,parallel.processing = "none"
,subsample.barcodes = F
,trim.and.align = F
,group.id = c(1,2))
})

</code></pre>


</div>
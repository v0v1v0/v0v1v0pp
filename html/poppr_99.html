<div class="container">

<table style="width: 100%;"><tr>
<td>mlg.filter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>MLG definitions based on genetic distance</h2>

<h3>Description</h3>

<p>Multilocus genotypes are initially defined by naive string matching, but this
definition does not take into account missing data or genotyping error,
casting these as unique genotypes. Defining multilocus genotypes by genetic
distance allows you to incorporate genotypes that have missing data o
genotyping error into their parent clusters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mlg.filter(
  pop,
  threshold = 0,
  missing = "asis",
  memory = FALSE,
  algorithm = "farthest_neighbor",
  distance = "diss.dist",
  threads = 1L,
  stats = "MLGs",
  ...
)

mlg.filter(
  pop,
  missing = "asis",
  memory = FALSE,
  algorithm = "farthest_neighbor",
  distance = "diss.dist",
  threads = 1L,
  ...
) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pop</code></td>
<td>
<p>a <code>genclone</code>, <code>snpclone</code>, or
<code>genind</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>a number indicating the minimum distance two MLGs must be
separated by to be considered different. Defaults to 0, which will reflect
the original (naive) MLG definition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing</code></td>
<td>
<p>any method to be used by <code>missingno</code>: "mean", 
"zero", "loci", "genotype", or "asis" (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>memory</code></td>
<td>
<p>whether this function should remember the last distance matrix 
it generated. TRUE will attempt to reuse the last distance matrix if the 
other parameters are the same. (default) FALSE will ignore any stored 
matrices and not store any it generates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>determines the type of clustering to be done. 
</p>

<dl>
<dt>"farthest_neighbor"</dt>
<dd>
<p><em> (default) </em>merges clusters based on the 
maximum distance between points in either cluster. This is the strictest of
the three.</p>
</dd>
<dt>"nearest_neighbor"</dt>
<dd>
<p> merges clusters based on the minimum distance
between points in either cluster. This is the loosest of the three.</p>
</dd>
<dt>"average_neighbor"</dt>
<dd>
<p> merges clusters based on the average distance
between every pair of points between clusters.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>a character or function defining the distance to be applied 
to pop. Defaults to <code>diss.dist</code> for genclone objects and
<code>bitwise.dist</code> for snpclone objects. A matrix or table
containing distances between individuals (such as the output of 
<code>rogers.dist</code>) is also accepted for this parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threads</code></td>
<td>
<p>(unused) Previously, this was the maximum number of parallel 
threads to be used within this function. Default is 1 indicating that this
function will run serially. Any other number will result in a warning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stats</code></td>
<td>
<p>a character vector specifying which statistics should be
returned (details below). Choices are "MLG", "THRESHOLDS", "DISTANCES",
"SIZES", or "ALL". If choosing "ALL" or more than one, a named list will be
returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>any parameters to be passed off to the distance method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>the threshold at which genotypes should be collapsed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function will take in any distance matrix or function and
collapse multilocus genotypes below a given threshold. If you use this
function as the assignment method (mlg.filter(myData, distance = myDist) &lt;-
0.5), the distance function or matrix will be remembered by the object. This
means that if you define your own distance matrix or function, you must keep
it in memory to further utilize mlg.filter.
</p>


<h3>Value</h3>

<p>Default, a vector of collapsed multilocus genotypes. Otherwise, any
combination of the following:
</p>


<h4>MLGs</h4>

<p>a numeric vector defining the multilocus genotype cluster of each
individual in the dataset. Each genotype cluster is separated from every
other genotype cluster by at least the defined threshold value, as 
calculated by the selected algorithm.
</p>



<h4>THRESHOLDS</h4>

<p>A numeric vector representing the thresholds <strong>beyond</strong> which clusters
of multilocus genotypes were collapsed. 
</p>



<h4>DISTANCES</h4>

<p>A square matrix representing the distances between each cluster.
</p>



<h4>SIZES</h4>

<p>The sizes of the multilocus genotype clusters in order. 
</p>



<h3>Note</h3>

<p><code>mlg.vector</code> makes use of <code>mlg.vector</code> grouping prior to 
applying the given threshold. Genotype numbers returned by
<code>mlg.vector</code> represent the lowest numbered genotype (as returned by
<code>mlg.vector</code>) in in each new multilocus genotype. Therefore
<strong><code>mlg.filter</code> and <code>mlg.vector</code> return the same vector when
threshold is set to 0 or less</strong>.
</p>


<h3>See Also</h3>

<p><code>filter_stats</code>, 
<code>cutoff_predictor</code>, 
<code>mll</code>, 
<code>genclone</code>, 
<code>snpclone</code>, 
<code>diss.dist</code>, 
<code>bruvo.dist</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(partial_clone)
pc &lt;- as.genclone(partial_clone, threads = 1L) # convert to genclone object

# Basic Use ---------------------------------------------------------------


# Show MLGs at threshold 0.05
mlg.filter(pc, threshold = 0.05, distance = "nei.dist", threads = 1L)
pc # 26 mlgs

# Set MLGs at threshold 0.05
mlg.filter(pc, distance = "nei.dist", threads = 1L) &lt;- 0.05
pc # 25 mlgs

## Not run: 

# The distance definition is persistant
mlg.filter(pc) &lt;- 0.1
pc # 24 mlgs

# But you can still change the definition
mlg.filter(pc, distance = "diss.dist", percent = TRUE) &lt;- 0.1
pc

# Choosing a threshold ----------------------------------------------------


# Thresholds for collapsing multilocus genotypes should not be arbitrary. It
# is important to consider what threshold is suitable. One method of choosing
# a threshold is to find a gap in the distance distribution that represents
# clonal groups. You can look at this by analyzing the distribution of all
# possible thresholds with the function "cutoff_predictor".

# For this example, we'll use Bruvo's distance to predict the cutoff for
# P. infestans.

data(Pinf)
Pinf
# Repeat lengths are necessary for Bruvo's distance
(pinfreps &lt;- fix_replen(Pinf, c(2, 2, 6, 2, 2, 2, 2, 2, 3, 3, 2)))

# Now we can collect information of the thresholds. We can set threshold = 1
# because we know that this will capture the maximum possible distance:
(thresholds &lt;- mlg.filter(Pinf, distance = bruvo.dist, stats = "THRESHOLDS",
                          replen = pinfreps, threshold = 1))
# We can use these thresholds to find an appropriate cutoff
(pcut &lt;- cutoff_predictor(thresholds))
mlg.filter(Pinf, distance = bruvo.dist, replen = pinfreps) &lt;- pcut
Pinf

# This can also be visualized with the "filter_stats" function.

# Special case: threshold = 0 ---------------------------------------------


# It's important to remember that a threshold of 0 is equal to the original
# MLG definition. This example will show a data set that contains genotypes
# with missing data that share all alleles with other genotypes except for 
# the missing one.

data(monpop)
monpop # 264 mlg
mlg.filter(monpop) &lt;- 0
nmll(monpop) # 264 mlg

# In order to merge these genotypes with missing data, we should set the 
# threshold to be slightly higher than 0. We will use the smallest fraction 
# the computer can store.

mlg.filter(monpop) &lt;- .Machine$double.eps ^ 0.5
nmll(monpop) # 236 mlg

# Custom distance ---------------------------------------------------------

# Custom genetic distances can be used either in functions from other
# packages or user-defined functions

data(Pinf)
Pinf
mlg.filter(Pinf, distance = function(x) dist(tab(x))) &lt;- 3
Pinf
mlg.filter(Pinf) &lt;- 4
Pinf

# genlight / snpclone objects ---------------------------------------------


set.seed(999)
gc &lt;- as.snpclone(glSim(100, 0, n.snp.struc = 1e3, ploidy = 2))
gc # 100 mlgs
mlg.filter(gc) &lt;- 0.25
gc # 82 mlgs


## End(Not run)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>tsd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Decomposition of one or several regular time series using various methods </h2>

<h3>Description</h3>

<p>Use a decomposition method to split the series into two or more components.
Decomposition methods are either series filtering/smoothing (difference,
average, median, evf), deseasoning (loess) or model-based decomposition (reg,
i.e., regression).
</p>


<h3>Usage</h3>

<pre><code class="language-R">tsd(x, specs=NULL, method="loess",
    type=if (method == "census") "multiplicative" else "additive",
    lag=1, axes=1:5, order=1, times=1, sides=2, ends="fill", weights=NULL,
    s.window=NULL, s.degree=0, t.window=NULL, t.degree=2, robust=FALSE,
    trend=FALSE, xreg=NULL)
## S3 method for class 'tsd'
print(x, ...)
## S3 method for class 'tsd'
summary(object, ...)
## S3 method for class 'summary.tsd'
print(x, ...)
## S3 method for class 'tsd'
plot(x, series=1, stack=TRUE, resid=TRUE, col=par("col"),
    lty=par("lty"), labels=dimnames(X)[[2]], leg=TRUE, lpos=c(0, 0), xlab="time",
    ylab="series", main=paste("Series decomposition by", x$specs$method, "-",
    x$specs$type), ...)
## S3 method for class 'tsd'
extract(e, n, series=NULL, components=NULL, ...)
## S3 method for class 'tsd'
specs(x, ...)
## S3 method for class 'specs.tsd'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> an univariate or multivariate regular time series ('ts' object) to
be decomposed for <code>tsd()</code>, or a 'tsd' object for the methods </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>specs</code></td>
<td>
<p> specifications are collected from a 'tsd' object, using the
<code>specs</code> method. This allows for reusing parameters issued from a
previous similar analysis </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> the method to use to decompose the time series. Currently,
possible values are: <code>"diff"</code>, <code>"average"</code>, <code>"median"</code>,
<code>"evf"</code>, <code>"reg"</code>, <code>"loess"</code> (by default) or <code>"census"</code>.
The corresponding function <code>decXXXX()</code> is applied to each of the series
in <code>x</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> the type of model to use: either <code>"additive"</code> (by default)
or <code>"multiplicative"</code>. In the additive model, all components must be
added to reconstruct the initial series. In the multiplicative model, they
must be multiplied (one components has the same unit as the original series,
and the other ones are dimensionless multiplicative factors) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag</code></td>
<td>
<p> The lag between the two observations used to calculate differences.
By default, <code>lag=1</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axes</code></td>
<td>
<p> the number of axes to show in the plot </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p> (1) for the method 'difference': the order of the difference
corresponds to the number of times it is applied, by default <code>order=1</code>,
(2) for the method 'average': the order of the moving average (the window of
the average being 2*order+1), centered around the current observation or at
left of this observation depending upon the value of the <code>sides</code>
argument. Weights are the same for all observations within the window.
However, if the argument <code>weights</code> is provided, it supersedes
<code>order</code>. One can also use <code>order="periodic"</code>. In this case, a
deseasoning filter is calculated according to the value of <code>frequency</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p> The number of times to apply the method (by default, once) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sides</code></td>
<td>
<p> If 2 (by default), the window is centered around the current
observation. If 1, the window is at left of the current observation
(including it) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ends</code></td>
<td>
<p> either "NAs" (fill first and last values that are not calculable
with NAs), or "fill" (fill them with the average of observations before
applying the filter, by default), or "circular" (use last values for
estimating first ones and vice versa), or "periodic" (use entire periods of
contiguous cycles, deseasoning) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p> a vector indicating weight to give to all observations in the
window. This argument has the priority over <code>order</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.window</code></td>
<td>
<p> the width of the window used to extract the seasonal
component. Use an odd value equal or just larger than the number of annual
values (frequency of the time series). Use another value to extract other
cycles (circadian, lunar,...). Using <code>s.window="periodic"</code> ensures a
correct value for extracting a seasonal component when the time scale is in
years units </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.degree</code></td>
<td>
<p> the order of the polynome to use to extract the seasonal
component (0 or 1). By default <code>s.degree=0</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.window</code></td>
<td>
<p> the width of the window to use to extract the general trend
when <code>trend=TRUE</code> (indicate an odd value). If this parameter is not
provided, a reasonable value is first calculated, and then used by the
algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.degree</code></td>
<td>
<p> the order of the polynome to use to extract the general trend
(0, 1 or 2). By default <code>t.degree=2</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p> if <code>TRUE</code> a robust regression method is used. Otherwise
(<code>FALSE</code>), by default, a classical least-square regression is used </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trend</code></td>
<td>
<p> If <code>TRUE</code> a trend is calculated (under R only). Otherwise,
the series is decomposed into a seasonal component and residuals only </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xreg</code></td>
<td>
<p> a second regular time series or a vector of the same length as
<code>x</code> with corresponding values from the regression model </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> a 'tsd' object as returned by the function <code>tsd()</code>, or any
of the <code>decXXXX()</code> functions </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e</code></td>
<td>
<p> a 'tsd' object as returned by the function <code>tsd()</code>, or any of
the <code>decXXXX()</code> functions </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>series</code></td>
<td>
<p> (1) for <code>plot()</code>: the series to plot. By default,
<code>series=1</code>, the first (or possibly unique) series in the 'tsd' object
is plotted. (2) for <code>extract</code>: the name or the index of the series to
extract. If <code>series</code> is provided, then <code>n</code> is ignored. By default,
<code>series=NULL</code>. It is also possible to use negative indices. In this
case, all series are extracted, except those ones </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stack</code></td>
<td>
<p> graphs of each component are either stacked (<code>stack=TRUE</code>,
by default), or superposed on the same graph <code>stack=FALSE</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid</code></td>
<td>
<p> do we have to plot also the "residuals" components
(<code>resid=TRUE</code>, by default) or not? Usually, in a stacked graph, you
would like to plot the residuals, while in a superposed graph, you would not </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p> color of the plot </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p> line type for the plot </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p> the labels to use for all y-axes in a stacked graph, or in the
legend for a superposed graph. By default, the names of the components
("trend", "seasonal", "deseasoned", "filtered", "residuals", ...) are used </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leg</code></td>
<td>
<p> only used when <code>stack=FALSE</code>. Do we plot a legend
(<code>leg=TRUE</code> or not? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lpos</code></td>
<td>
<p> position of the upper-left corner of the legend box in the graph
coordinates (x,y). By default, <code>leg=c(0,0)</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p> the label of the x-axis </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p> the label of the y-axis </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p> the main title of the graph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> the number of series to extract (from series 1 to series n). By
default, n equals the number of series in the 'tsd' object. If both
<code>series</code> and <code>components</code> arguments are NULL, all series and
components are extracted and this method has exactly the same effect as
<code>tseries</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>components</code></td>
<td>
<p> the names or indices of the components to extract. If
<code>components=NULL</code> (by default), then all components of the selected
series are extracted. It is also possible to specify negative indices. In
this case, all components are extracted, except those ones </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> (1) for <code>tsd()</code>: further arguments to pass to the
corresponding <code>decXXXX()</code> function. (2) for <code>plot()</code>: further
graphical arguments, (3) unused for the other functions or methods </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To eliminate trend from a series, use "diff" or use "loess" with
<code>trend=TRUE</code>. If you know the shape of the trend (linear, exponential,
periodic, etc.), you can also use it with the "reg" (regression) method. To
eliminate or extract seasonal components, you can use "loess" if the seasonal
component is additive, or "census" if it is multiplicative. You can also use
"average" with argument <code>order="periodic"</code> and with either an additive or
a multiplicative model, although the later method is often less powerful than
"loess" or "census". If you want to extract a seasonal cycle with a given
shape (for instance, a sinusoid), use the "reg" method with a fitted
sinusoidal equation. If you want to identify levels in the series, use the
"median" method. To smooth the series, you can use preferably the "evf"
(eigenvector filtering), or the "average" methods, but you can also use
"median". To extract most important components from the series (no matter if
they are cycles -seasonal or not-, or long-term trends), you should use the
"evf" method. For more information on each of these methods, see online help
of the corresponding <code>decXXXX()</code> functions.
</p>


<h3>Value</h3>

<p>An object of type 'tsd' is returned. It has methods <code>print()</code>,
<code>summary()</code>, <code>plot()</code>, <code>extract()</code> and <code>specs()</code>.
</p>


<h3>Note</h3>

<p> If you have to decompose a single time series, you could also use the
corresponding <code>decXXXX()</code> function directly. In the case of a multivariate
regular time series, <code>tsd()</code> is more convenient because it decompose all
times series of a set at once! </p>


<h3>Author(s)</h3>

<p> Frédéric Ibanez (<a href="mailto:ibanez@obs-vlfr.fr">ibanez@obs-vlfr.fr</a>),
Philippe Grosjean (<a href="mailto:phgrosjean@sciviews.org">phgrosjean@sciviews.org</a>) </p>


<h3>References</h3>

 
<p>Kendall, M., 1976. <em>Time-series.</em> Charles Griffin &amp; Co Ltd. 197 pp.
</p>
<p>Laloire, J.C., 1972. <em>Méthodes du traitement des chroniques.</em> Dunod, Paris, 194 pp.
</p>
<p>Legendre, L. &amp; P. Legendre, 1984. <em>Ecologie numérique. Tome 2: La structure
des données écologiques.</em> Masson, Paris. 335 pp.
</p>
<p>Malinvaud, E., 1978. <em>Méthodes statistiques de l'économétrie.</em> Dunod, Paris. 846 pp.
</p>
<p>Philips, L. &amp; R. Blomme, 1973. <em>Analyse chronologique.</em> Université
Catholique de Louvain. Vander ed. 339 pp.
</p>


<h3>See Also</h3>

 <p><code>tseries</code>, <code>decdiff</code>, <code>decaverage</code>,
<code>decmedian</code>, <code>decevf</code>, <code>decreg</code>,
<code>decloess</code>, <code>deccensus</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">data(releve)
# Regulate the series and extract them as a time series object
rel.regy &lt;- regul(releve$Day, releve[3:8], xmin=6, n=87, units="daystoyears",
        frequency=24, tol=2.2, methods="linear", datemin="21/03/1989",
        dateformat="d/m/Y")
rel.ts &lt;- tseries(rel.regy)

# Decompose all series in the set with the "loess" method
rel.dec &lt;- tsd(rel.ts, method="loess", s.window=13, trend=FALSE)
rel.dec
plot(rel.dec, series=5, col=1:3)    # An plot series 5

# Extract "deseasoned" components
rel.des &lt;- extract(rel.dec, series=3:6, components="deseasoned")
rel.des[1:10,]

# Further decompose these components with a moving average
rel.des.dec &lt;- tsd(rel.des, method="average", order=2, times=10)
plot(rel.des.dec, series=3, col=c(2, 4, 6))
# In this case, a superposed graph is more appropriate:
plot(rel.des.dec, series=3, col=c(2,4), stack=FALSE, resid=FALSE,
        labels=c("without season cycle", "trend"), lpos=c(0, 55000))
# Extract residuals from the latter decomposition
rel.res2 &lt;- extract(rel.des.dec, components="residuals")
</code></pre>


</div>
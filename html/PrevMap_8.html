<div class="container">

<table style="width: 100%;"><tr>
<td>continuous.sample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatially continuous sampling</h2>

<h3>Description</h3>

<p>Draws a sample of spatial locations within a spatially continuous polygonal sampling region.
</p>


<h3>Usage</h3>

<pre><code class="language-R">continuous.sample(poly, n, delta, k = 0, rho = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>poly</code></td>
<td>
<p>boundary of a polygon.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of events.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>minimum permissible distance between any two events in preliminary sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of locations in preliminary sample to be replaced by near neighbours of other preliminary sample locations in final sample (must be between 0 and <code>n/2</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>maximum distance between close pairs of locations in final sample.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To draw a sample of size <code>n</code>  from a spatially continuous region <code class="reqn">A</code>, with the property that the distance between any two sampled locations is at least <code>delta</code>, the following algorithm is used.
</p>

<ul>
<li>
<p>Step 1. Set <code class="reqn">i  = 1</code> and generate a point <code class="reqn">x_{1}</code>  uniformly distributed on <code class="reqn">A</code>.
</p>
</li>
<li>
<p>Step 2. Increase <code class="reqn">i</code>  by 1, generate a point <code class="reqn">x_{i}</code>  uniformly distributed on <code class="reqn">A</code> and calculate the minimum, <code class="reqn">d_{\min}</code>, of the distances from <code class="reqn">x_{i}</code> to all <code class="reqn">x_{j}: j &lt; i </code>.
</p>
</li>
<li>
<p>Step 3. If <code class="reqn">d_{\min} \ge \delta</code>, increase <code class="reqn">i</code>  by 1 and return to step 2 if <code class="reqn">i \le n</code>, otherwise stop;
</p>
</li>
<li>
<p>Step 4. If <code class="reqn">d_{\min} &lt; \delta</code>, return to step 2 without increasing <code class="reqn">i</code>.
</p>
</li>
</ul>
<p><b> Sampling close pairs of points.</b>  For some purposes, it is desirable that a spatial sampling scheme include pairs of closely spaced points. In this case, the above algorithm requires the following additional steps to be taken.
Let <code>k</code>  be the required number of close pairs. Choose a value <code>rho</code>  such that a close pair  of points will be a pair of points separated by a distance of at most <code>rho</code>.
</p>

<ul>
<li>
<p>Step 5. Set <code class="reqn">j  = 1</code> and draw a random sample of size 2 from the integers <code class="reqn">1,2,\ldots,n</code>, say <code class="reqn">(i_{1}; i_{2})</code>;
</p>
</li>
<li>
<p>Step 6. Replace <code class="reqn">x_{i_{1}}</code> by <code class="reqn">x_{i_{2}} + u</code> , where <code class="reqn">u</code>  is uniformly distributed on the disc with centre <code class="reqn">x_{i_{2}}</code> and radius <code>rho</code>, increase <code class="reqn">i</code> by 1 and return to step 5 if <code class="reqn">i \le k</code>, otherwise stop.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A matrix of dimension <code>n</code> by 2 containing event locations.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


</div>
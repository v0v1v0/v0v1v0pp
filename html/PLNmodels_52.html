<div class="container">

<table style="width: 100%;"><tr>
<td>PLNPCAfit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>An R6 Class to represent a PLNfit in a PCA framework</h2>

<h3>Description</h3>

<p>The function <code>PLNPCA()</code> produces a collection of models which are instances of object with class <code>PLNPCAfit</code>.
This class comes with a set of methods, some of them being useful for the user:
See the documentation for the methods inherited by  <code>PLNfit</code> and the <code>plot()</code> methods for PCA visualization
</p>


<h3>Super class</h3>

<p><code>PLNmodels::PLNfit</code> -&gt; <code>PLNPCAfit</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>rank</code></dt>
<dd>
<p>the dimension of the current model</p>
</dd>
<dt><code>vcov_model</code></dt>
<dd>
<p>character: the model used for the residual covariance</p>
</dd>
<dt><code>nb_param</code></dt>
<dd>
<p>number of parameters in the current PLN model</p>
</dd>
<dt><code>entropy</code></dt>
<dd>
<p>entropy of the variational distribution</p>
</dd>
<dt><code>latent_pos</code></dt>
<dd>
<p>a matrix: values of the latent position vector (Z) without covariates effects or offset</p>
</dd>
<dt><code>model_par</code></dt>
<dd>
<p>a list with the matrices associated with the estimated parameters of the pPCA model: B (covariates), Sigma (covariance), Omega (precision) and C (loadings)</p>
</dd>
<dt><code>percent_var</code></dt>
<dd>
<p>the percent of variance explained by each axis</p>
</dd>
<dt><code>corr_circle</code></dt>
<dd>
<p>a matrix of correlations to plot the correlation circles</p>
</dd>
<dt><code>scores</code></dt>
<dd>
<p>a matrix of scores to plot the individual factor maps (a.k.a. principal components)</p>
</dd>
<dt><code>rotation</code></dt>
<dd>
<p>a matrix of rotation of the latent space</p>
</dd>
<dt><code>eig</code></dt>
<dd>
<p>description of the eigenvalues, similar to percent_var but for use with external methods</p>
</dd>
<dt><code>var</code></dt>
<dd>
<p>a list of data frames with PCA results for the variables: <code>coord</code> (coordinates of the variables), <code>cor</code> (correlation between variables and dimensions), <code>cos2</code> (Cosine of the variables) and <code>contrib</code> (contributions of the variable to the axes)</p>
</dd>
<dt><code>ind</code></dt>
<dd>
<p>a list of data frames with PCA results for the individuals: <code>coord</code> (coordinates of the individuals), <code>cos2</code> (Cosine of the individuals), <code>contrib</code> (contributions of individuals to an axis inertia) and <code>dist</code> (distance of individuals to the origin).</p>
</dd>
<dt><code>call</code></dt>
<dd>
<p>Hacky binding for compatibility with factoextra functions</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNPCAfit-new"><code>PLNPCAfit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-update"><code>PLNPCAfit$update()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-optimize"><code>PLNPCAfit$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-optimize_vestep"><code>PLNPCAfit$optimize_vestep()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-project"><code>PLNPCAfit$project()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-setVisualization"><code>PLNPCAfit$setVisualization()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-postTreatment"><code>PLNPCAfit$postTreatment()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-plot_individual_map"><code>PLNPCAfit$plot_individual_map()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-plot_correlation_circle"><code>PLNPCAfit$plot_correlation_circle()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-plot_PCA"><code>PLNPCAfit$plot_PCA()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-show"><code>PLNPCAfit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNPCAfit-clone"><code>PLNPCAfit$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict"><a href="../../PLNmodels/html/PLNfit.html#method-PLNfit-predict"><code>PLNmodels::PLNfit$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict_cond"><a href="../../PLNmodels/html/PLNfit.html#method-PLNfit-predict_cond"><code>PLNmodels::PLNfit$predict_cond()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="print"><a href="../../PLNmodels/html/PLNfit.html#method-PLNfit-print"><code>PLNmodels::PLNfit$print()</code></a></span></li>
</ul></details><hr>
<a id="method-PLNPCAfit-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Initialize a <code>PLNPCAfit</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$new(rank, responses, covariates, offsets, weights, formula, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rank</code></dt>
<dd>
<p>rank of the PCA (or equivalently, dimension of the latent space)</p>
</dd>
<dt><code>responses</code></dt>
<dd>
<p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in <code>PLNfamily</code></p>
</dd>
<dt><code>covariates</code></dt>
<dd>
<p>design matrix (called X in the model). Will usually be extracted from the corresponding field in <code>PLNfamily</code></p>
</dd>
<dt><code>offsets</code></dt>
<dd>
<p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in <code>PLNfamily</code></p>
</dd>
<dt><code>weights</code></dt>
<dd>
<p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>formula</code></dt>
<dd>
<p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt>
<dd>
<p>a list for controlling the optimization. See details.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-PLNPCAfit-update"></a>



<h4>Method <code>update()</code>
</h4>

<p>Update a <code>PLNPCAfit</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$update(
  B = NA,
  Sigma = NA,
  Omega = NA,
  C = NA,
  M = NA,
  S = NA,
  Z = NA,
  A = NA,
  Ji = NA,
  R2 = NA,
  monitoring = NA
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>B</code></dt>
<dd>
<p>matrix of regression matrix</p>
</dd>
<dt><code>Sigma</code></dt>
<dd>
<p>variance-covariance matrix of the latent variables</p>
</dd>
<dt><code>Omega</code></dt>
<dd>
<p>precision matrix of the latent variables. Inverse of Sigma.</p>
</dd>
<dt><code>C</code></dt>
<dd>
<p>matrix of PCA loadings (in the latent space)</p>
</dd>
<dt><code>M</code></dt>
<dd>
<p>matrix of mean vectors for the variational approximation</p>
</dd>
<dt><code>S</code></dt>
<dd>
<p>matrix of variance vectors for the variational approximation</p>
</dd>
<dt><code>Z</code></dt>
<dd>
<p>matrix of latent vectors (includes covariates and offset effects)</p>
</dd>
<dt><code>A</code></dt>
<dd>
<p>matrix of fitted values</p>
</dd>
<dt><code>Ji</code></dt>
<dd>
<p>vector of variational lower bounds of the log-likelihoods (one value per sample)</p>
</dd>
<dt><code>R2</code></dt>
<dd>
<p>approximate R^2 goodness-of-fit criterion</p>
</dd>
<dt><code>monitoring</code></dt>
<dd>
<p>a list with optimization monitoring quantities</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Update the current <code>PLNPCAfit</code> object
</p>


<hr>
<a id="method-PLNPCAfit-optimize"></a>



<h4>Method <code>optimize()</code>
</h4>

<p>Call to the C++ optimizer and update of the relevant fields
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$optimize(responses, covariates, offsets, weights, config)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt>
<dd>
<p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in <code>PLNfamily</code></p>
</dd>
<dt><code>covariates</code></dt>
<dd>
<p>design matrix (called X in the model). Will usually be extracted from the corresponding field in <code>PLNfamily</code></p>
</dd>
<dt><code>offsets</code></dt>
<dd>
<p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in <code>PLNfamily</code></p>
</dd>
<dt><code>weights</code></dt>
<dd>
<p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>config</code></dt>
<dd>
<p>part of the <code>control</code> argument which configures the optimizer</p>
</dd>
</dl>
</div>


<hr>
<a id="method-PLNPCAfit-optimize_vestep"></a>



<h4>Method <code>optimize_vestep()</code>
</h4>

<p>Result of one call to the VE step of the optimization procedure: optimal variational parameters (M, S) and corresponding log likelihood values for fixed model parameters (C, B). Intended to position new data in the latent space for further use with PCA.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$optimize_vestep(
  covariates,
  offsets,
  responses,
  weights = rep(1, self$n),
  control = PLNPCA_param(backend = "nlopt")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>covariates</code></dt>
<dd>
<p>design matrix (called X in the model). Will usually be extracted from the corresponding field in <code>PLNfamily</code></p>
</dd>
<dt><code>offsets</code></dt>
<dd>
<p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in <code>PLNfamily</code></p>
</dd>
<dt><code>responses</code></dt>
<dd>
<p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in <code>PLNfamily</code></p>
</dd>
<dt><code>weights</code></dt>
<dd>
<p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>control</code></dt>
<dd>
<p>a list for controlling the optimization. See details.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list with three components:
</p>

<ul>
<li>
<p> the matrix <code>M</code> of variational means,
</p>
</li>
<li>
<p> the matrix <code>S2</code> of variational variances
</p>
</li>
<li>
<p> the vector <code>log.lik</code> of (variational) log-likelihood of each new observation
</p>
</li>
</ul>
<hr>
<a id="method-PLNPCAfit-project"></a>



<h4>Method <code>project()</code>
</h4>

<p>Project new samples into the PCA space using one VE step
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$project(newdata, control = PLNPCA_param(), envir = parent.frame())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newdata</code></dt>
<dd>
<p>A data frame in which to look for variables, offsets and counts  with which to predict.</p>
</dd>
<dt><code>control</code></dt>
<dd>
<p>a list for controlling the optimization. See <code>PLN()</code> for details.</p>
</dd>
<dt><code>envir</code></dt>
<dd>
<p>Environment in which the projection is evaluated</p>
</dd>
</dl>
</div>



<h5>Returns</h5>


<ul><li>
<p> the named matrix of scores for the newdata, expressed in the same coordinate system as <code>self$scores</code>
</p>
</li></ul>
<hr>
<a id="method-PLNPCAfit-setVisualization"></a>



<h4>Method <code>setVisualization()</code>
</h4>

<p>Compute PCA scores in the latent space and update corresponding fields.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$setVisualization(scale.unit = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scale.unit</code></dt>
<dd>
<p>Logical. Should PCA scores be rescaled to have unit variance</p>
</dd>
</dl>
</div>


<hr>
<a id="method-PLNPCAfit-postTreatment"></a>



<h4>Method <code>postTreatment()</code>
</h4>

<p>Update R2, fisher, std_err fields and set up visualization
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$postTreatment(
  responses,
  covariates,
  offsets,
  weights,
  config_post,
  config_optim,
  nullModel
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>responses</code></dt>
<dd>
<p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in <code>PLNfamily</code></p>
</dd>
<dt><code>covariates</code></dt>
<dd>
<p>design matrix (called X in the model). Will usually be extracted from the corresponding field in <code>PLNfamily</code></p>
</dd>
<dt><code>offsets</code></dt>
<dd>
<p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in <code>PLNfamily</code></p>
</dd>
<dt><code>weights</code></dt>
<dd>
<p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>config_post</code></dt>
<dd>
<p>a list for controlling the post-treatments (optional bootstrap, jackknife, R2, etc.). See details</p>
</dd>
<dt><code>config_optim</code></dt>
<dd>
<p>a list for controlling the optimizer (either "nlopt" or "torch" backend). See details</p>
</dd>
<dt><code>nullModel</code></dt>
<dd>
<p>null model used for approximate R2 computations. Defaults to a GLM model with same design matrix but not latent variable.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The list of parameters <code>config_post</code> controls the post-treatment processing, with the following entries:
</p>

<ul>
<li>
<p> jackknife boolean indicating whether jackknife should be performed to evaluate bias and variance of the model parameters. Default is FALSE.
</p>
</li>
<li>
<p> bootstrap integer indicating the number of bootstrap resamples generated to evaluate the variance of the model parameters. Default is 0 (inactivated).
</p>
</li>
<li>
<p> variational_var boolean indicating whether variational Fisher information matrix should be computed to estimate the variance of the model parameters (highly underestimated). Default is FALSE.
</p>
</li>
<li>
<p> rsquared boolean indicating whether approximation of R2 based on deviance should be computed. Default is TRUE
</p>
</li>
<li>
<p> trace integer for verbosity. should be &gt; 1 to see output in post-treatments
</p>
</li>
</ul>
<hr>
<a id="method-PLNPCAfit-plot_individual_map"></a>



<h4>Method <code>plot_individual_map()</code>
</h4>

<p>Plot the factorial map of the PCA
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$plot_individual_map(
  axes = 1:min(2, self$rank),
  main = "Individual Factor Map",
  plot = TRUE,
  cols = "default"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>axes</code></dt>
<dd>
<p>numeric, the axes to use for the plot when map = "individual" or "variable". Default it c(1,min(rank))</p>
</dd>
<dt><code>main</code></dt>
<dd>
<p>character. A title for the single plot (individual or variable factor map). If NULL (the default), an hopefully appropriate title will be used.</p>
</dd>
<dt><code>plot</code></dt>
<dd>
<p>logical. Should the plot be displayed or sent back as ggplot object</p>
</dd>
<dt><code>cols</code></dt>
<dd>
<p>a character, factor or numeric to define the color associated with the individuals. By default, all individuals receive the default color of the current palette.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a <code>ggplot</code> graphic
</p>


<hr>
<a id="method-PLNPCAfit-plot_correlation_circle"></a>



<h4>Method <code>plot_correlation_circle()</code>
</h4>

<p>Plot the correlation circle of a specified axis for a <code>PLNLDAfit</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$plot_correlation_circle(
  axes = 1:min(2, self$rank),
  main = "Variable Factor Map",
  cols = "default",
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>axes</code></dt>
<dd>
<p>numeric, the axes to use for the plot when map = "individual" or "variable". Default it c(1,min(rank))</p>
</dd>
<dt><code>main</code></dt>
<dd>
<p>character. A title for the single plot (individual or variable factor map). If NULL (the default), an hopefully appropriate title will be used.</p>
</dd>
<dt><code>cols</code></dt>
<dd>
<p>a character, factor or numeric to define the color associated with the variables. By default, all variables receive the default color of the current palette.</p>
</dd>
<dt><code>plot</code></dt>
<dd>
<p>logical. Should the plot be displayed or sent back as ggplot object</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a <code>ggplot</code> graphic
</p>


<hr>
<a id="method-PLNPCAfit-plot_PCA"></a>



<h4>Method <code>plot_PCA()</code>
</h4>

<p>Plot a summary of the <code>PLNPCAfit</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$plot_PCA(
  nb_axes = min(3, self$rank),
  ind_cols = "ind_cols",
  var_cols = "var_cols",
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nb_axes</code></dt>
<dd>
<p>scalar: the number of axes to be considered when map = "both". The default is min(3,rank).</p>
</dd>
<dt><code>ind_cols</code></dt>
<dd>
<p>a character, factor or numeric to define the color associated with the individuals. By default, all variables receive the default color of the current palette.</p>
</dd>
<dt><code>var_cols</code></dt>
<dd>
<p>a character, factor or numeric to define the color associated with the variables. By default, all variables receive the default color of the current palette.</p>
</dd>
<dt><code>plot</code></dt>
<dd>
<p>logical. Should the plot be displayed or sent back as ggplot object</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a <code>grob</code> object
</p>


<hr>
<a id="method-PLNPCAfit-show"></a>



<h4>Method <code>show()</code>
</h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$show()</pre></div>


<hr>
<a id="method-PLNPCAfit-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNPCAfit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p>The function <code>PLNPCA</code>, the class <code>PLNPCAfamily</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPCAs &lt;- PLNPCA(Abundance ~ 1 + offset(log(Offset)), data = trichoptera, ranks = 1:5)
myPCA &lt;- getBestModel(myPCAs)
class(myPCA)
print(myPCA)
</code></pre>


</div>
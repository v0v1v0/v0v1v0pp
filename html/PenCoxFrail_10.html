<div class="container">

<table style="width: 100%;"><tr>
<td>pencoxfrail</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Regularization in Cox Frailty Models.</h2>

<h3>Description</h3>

<p>A regularization approach for Cox Frailty Models by penalization methods is provided.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pencoxfrail(fix=formula, rnd=formula, vary.coef=formula, data, xi, 
              adaptive.weights = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fix</code></td>
<td>
<p>a two-sided linear formula object describing the unpenalized
fixed (time-constant) effects part of the model, with the response on the left of a
<code>~</code> operator and the terms, separated by <code>+</code> operators, on
the right. The response must be a survival object as returned by the <code>Surv</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rnd</code></td>
<td>
<p>a two-sided linear formula object describing the
random-effects part of the model, with the grouping factor on the left of a
<code>~</code> operator and the random terms, separated by <code>+</code> operators, on
the right.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vary.coef</code></td>
<td>
<p>a one-sided linear formula object describing the
time-varying effects part of the model, with the time-varying terms, separated by <code>+</code> operators,
on the right side of a <code>~</code> operator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the data frame containing the variables named in the three preceding
<code>formula</code> arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xi</code></td>
<td>
<p>the overall penalty parameter that controls the strenght of both penalty terms in <code class="reqn">\xi\cdot J(\zeta,\alpha)</code> and, hence, controls the overall amount of smoothness (up to constant effects) and variable selection for a given proportion <code class="reqn">\zeta</code>.
The optimal penalty parameter is a tuning parameter of the procedure that has to be determined, 
e.g. by K-fold cross validation. (See details or the quick demo for an example.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive.weights</code></td>
<td>
<p>a two-column matrix of adaptive weights passed to the procedure; the first column contains the weights <code class="reqn">w_{\Delta,k}</code>, the second column the weights <code class="reqn">v_{k}</code> from <code class="reqn">\xi\cdot J(\zeta,\alpha)</code>. If no adaptive weights are specified all weights are set to one. The recommended strategy is to first fit an unpenalized model (i.e. <code class="reqn">\xi=0</code>) and then use the obtained adaptive weights (see value section) when fitting the model for all other combinations of <code class="reqn">\xi</code> and <code class="reqn">\zeta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control values for the estimation algorithm to replace the default values returned by the function <code>pencoxfrailControl</code>. Defaults to an empty list.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>pencoxfrail</code> algorithm is designed to investigate
the effect structure in the Cox frailty model, which is a
widely used model that accounts for heterogeneity in survival data.
Since in survival models one has to account for possible variation of
the effect strength over time the selection of the relevant features distinguishes between the folllowing cases:
covariates can have time-varying effects, can have time-constant effects
or be irrelevant. For this purpose, the following specific penality is applied on the vectors of B-spline coefficients <code class="reqn">\alpha_k</code>, assuming <code class="reqn">k=1,...,r</code> different, potentially time-varying effects, each expanded in <code class="reqn">M</code> B-spline basis functions:
</p>
<p style="text-align: center;"><code class="reqn">\xi \cdot J(\zeta,\alpha) = \xi\left( \zeta\sum_{k=1}^{r} \psi\, w_{\Delta,k} ||\Delta_{M}\alpha_{k}||_{2} + (1-\zeta)\sum_{k=1}^{r} \phi\, v_{k} ||\alpha_{k}||_{2}\right)</code>
</p>

<p>This penalty is able to distinguish between these
types of effects to obtain a sparse representation that includes the relevant effects in a proper form.
</p>
<p>The penalty is depending on two tuning parameters, <code class="reqn">\xi</code> and <code class="reqn">\zeta</code>, which have to be determined by a suitable technique, e.g. by 
(2-dimensional) K-fold cross validation.
</p>
<p>The first term of the penalty controls the smoothness of the time-varying covariate effects, whereby for
values of <code class="reqn">\xi</code> and <code class="reqn">\zeta</code> large enough, all differences <code class="reqn">(\alpha_{k,l} - \alpha_{k,l-1}),  l=2,... ,M</code>, are removed from the model, resulting in constant covariate effects.
As the B-splines of each variable with varying coefficients sum up to one,
a constant effect is obtained if all spline coefficients are set equal.
Hence, the first penalty term does not affect the spline's global level.
The second term penalizes all spline coefficients belonging to a single time-varying effect in the way
of a group LASSO and, hence, controls the selection of covariates.
</p>

<table>
<tr>
<td style="text-align: left;">
Package: </td>
<td style="text-align: left;"> pencoxfrail</td>
</tr>
<tr>
<td style="text-align: left;">
Type: </td>
<td style="text-align: left;"> Package</td>
</tr>
<tr>
<td style="text-align: left;">
Version: </td>
<td style="text-align: left;"> 1.1.2</td>
</tr>
<tr>
<td style="text-align: left;">
Date: </td>
<td style="text-align: left;"> 2023-08-25</td>
</tr>
<tr>
<td style="text-align: left;">
License: </td>
<td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
<td style="text-align: left;">
LazyLoad: </td>
<td style="text-align: left;"> yes</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>for loading a dataset type data(nameofdataset)
</p>


<h3>Value</h3>

<p>Generic functions such as <code>print</code>, <code>predict</code>, <code>plot</code> and <code>summary</code> have methods to show the results of the fit.
</p>
<p>The <code>predict</code> function uses also estimates of random effects for prediction, if possible (i.e. for known subjects of the grouping factor). 
Either the survival stepfunction or the baseline hazard (not cumulative!) can be calculated by specifying one of two possible methods: <code>method=c("hazard","survival")</code>. By default, for each new subject in <code>new.data</code> an individual stepfunction is calculated on a pre-specified time grid, also accounting for covariate changes over time. Alternatively, for <code>new.data</code> a single vector of a specific (time-constant) covariate combination can be specified.
</p>
<p>Usage:  <code>
predict(pencoxfrail.obj,new.data,time.grid,method=c("hazard","survival"))
</code>     
</p>
<p>The <code>plot</code> function plots all time-varying effects, including the baseline hazard. 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>a list containing an image of the <code>pencoxfrail</code> call that produced the object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>baseline</code></td>
<td>
<p>a vector containing the estimated B-spline coefficients of the baseline hazard.
If the covariates corresponding to the time-varying effects are centered (and standardized, see <code>pencoxfrailControl</code>), the coefficients are transformed back to the original scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.vary</code></td>
<td>
<p>a vector containing the estimated B-spline coefficients of all time-varying effects.
If the covariates corresponding to the time-varying effects are standardized (see <code>pencoxfrailControl</code>) 
the coefficients are transformed back to the original scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a vector containing the estimated fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranef</code></td>
<td>
<p>a vector containing the estimated random effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>a scalar or matrix containing the estimates of the random effects standard deviation or variance-covariance parameters, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Delta</code></td>
<td>
<p>a matrix containing the estimates of fixed and random effects (columns) for each iteration (rows) of the main algorithm (i.e. before the final re-estimation step is performed, see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q_long</code></td>
<td>
<p>a list containing the estimates of the random effects variance-covariance parameters for each iteration of the main algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>number of iterations until the main algorithm has converged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive.weights</code></td>
<td>
<p>If <code class="reqn">\xi=0</code>, a two-column matrix of adaptive weights is calculated; the first column contains the weights <code class="reqn">w_{\Delta,k}</code>, the second column the weights <code class="reqn">v_{k}</code> from <code class="reqn">\xi\cdot J(\zeta,\alpha)</code>. If <code class="reqn">\xi&gt;0</code>,
the adaptive weights that have been used in the function's argument are displayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>vector of knots used in the B-spline representation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi.big</code></td>
<td>
<p>large B-spline design matrix corresponding to the baseline hazard and all time-varying effects. For the time-varying effects, the B-spline functions (as a function of time) have already been multiplied with their associated covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.grid</code></td>
<td>
<p>the time grid used in when approximating the (Riemann) integral involved in the model's full likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>number of metric covariates with time-varying effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m2</code></td>
<td>
<p>number of categorical covariates with time-varying effects.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Andreas Groll  <a href="mailto:groll@math.lmu.de">groll@math.lmu.de</a>
</p>


<h3>References</h3>

<p>Groll, A., T. Hastie and G. Tutz (2017). 
Selection of Effects in Cox Frailty Models by Regularization Methods. <em>Biometrics</em> 73(3): 846-856.
</p>


<h3>See Also</h3>

<p><code>pencoxfrailControl,Surv,pbc</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(lung)

# remove NAs
lung &lt;- lung[!is.na(lung$inst),]

# transform inst into factor variable
lung$inst &lt;- as.factor(lung$inst)

# Random institutional effect
fix.form &lt;- as.formula("Surv(time, status) ~ 1")
vary.coef &lt;- as.formula("~ age")

pen.obj &lt;- pencoxfrail(fix=fix.form,vary.coef=vary.coef, rnd = list(inst=~1), 
              data=lung, xi=10,control=list(print.iter=TRUE))

# show fit
plot(pen.obj)

# predict survival curve of new subject, institution 1 and up to time 500
pred.obj &lt;- predict(pen.obj,newdata=data.frame(inst=1,time=NA,status=NA,age=26),
              time.grid=seq(0,500,by=1))

# plot predicted hazard function
plot(pred.obj$time.grid,pred.obj$haz,type="l",xlab="time",ylab="hazard")

# plot predicted survival function
plot(pred.obj$time.grid,pred.obj$survival,type="l",xlab="time",ylab="survival")

# see also demo("pencoxfrail-pbc")

## End(Not run)</code></pre>


</div>
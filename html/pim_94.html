<div class="container">

<table style="width: 100%;"><tr>
<td>pim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting a Probabilistic Index Model</h2>

<h3>Description</h3>

<p>This function fits a probabilistic index model,
also known as PIM. It can be used to fit standard PIMs, as well as
many different flavours of models that can be reformulated as a pim.
The most general models are implemented, but the flexible formula
interface allows you to specify a wide variety of different models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pim(
  formula,
  data,
  link = c("logit", "probit", "identity"),
  compare = if (model == "marginal") "all" else "unique",
  model = c("difference", "marginal", "regular", "customized"),
  na.action = getOption("na.action"),
  weights = NULL,
  keep.data = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>An object of class <code>formula</code> (or one that
can be coerced to that class): A symbolic description of the model
to be fitted. The details of model specification are given under 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list or environment that contains
the variables in the model. Objects that can be coerced by
<code>as.data.frame</code> can be used too.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>a character vector with a single value that determines the
used link function. Possible values are "logit", "probit" and "identity".
The default is "logit".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compare</code></td>
<td>
<p>a character vector with a single value that describes how the
model compares observations. It can take the values "unique" or "all".
Alternatively you can pass a matrix with two columns.
Each row represents the rownumbers in the original data frame that
should be compared to eachother. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a single character value with possible values "difference"
(the default), "marginal", "regular" or "customized". If the formula indicates
a customized model (by the use of <code>L()</code> or <code>R()</code>),
this parameter is set automatically to "customized". Currently, only the
options "difference", "marginal" and "customized" are implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>the name of a function which indicates what should happen when the data
contains NAs. The default is set by the <code>na.action</code> setting of
<code>options</code>, and is <code>na.fail</code> when unset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Currently not implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.data</code></td>
<td>
<p>a logical value indicating whether the model
matrix should be saved in the object. Defaults to <code>FALSE</code>. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>extra parameters sent to <code>pim.fit</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>PIMs are based on a set of pseudo-observations constructed from the
comparison between a range of possible combinations of 2 observations.
We call the set of pseudo observations <em>poset</em> in the context
of this package.
</p>
<p>By default, this poset takes every unique combination of 2 observations
(<code>compare = "unique"</code>). You can either use a character value, or
use a matrix or list to identify the set of observation pairs that have to be
used as pseudo-observations. Note that the matrix and list should
be either nameless, or have the (col)names 'L' and 'R'. If any other
names are used, these are ignored and the first column/element
is considered to be 'L'. See also
<code>new.pim.poset</code>.
</p>
<p>It's possible to store the model matrix and psuedo responses in the
resulting object. By default this is not done
(<code>keep.data = FALSE</code>) as this is less burden on the memory and
the <code>pim.formula</code> object contains all information to
reconstruct both the model matrix and the pseudo responses.
If either the model matrix or the pseudo responses are needed for
further calculations, setting <code>keep.data</code> to <code>TRUE</code> might
reduce calculation time for these further calculations.
</p>


<h3>Value</h3>

<p>An object of class <code>pim</code>. See <code>pim-class</code>
for more information.
</p>


<h3>The enhanced formula interface</h3>

<p>In case you want to fit a standard PIM, you can specify the model in
mostly the same way as for <code>lm</code>. There's one important
difference: a PIM has by default no intercept. To add an intercept, use
<code>+ 1</code> in the formula.
</p>
<p>Next to this, you can use the functions <code>L</code> and <code>R</code>
in a formula to indicate which part of the poset you refer to. Remember a
poset is essentially a matrix-like object with indices refering to the
pseudo-observations. Using <code>L()</code> and <code>R()</code> you can define
exactly how the pseudo-observations fit in the model. Keep in mind that
any calculation done with these functions, has to be wrapped in a call
to <code>I()</code>, just like you would do in any other formula interface.
</p>
<p>You don't have to specify the model though. If you choose the option
<code>model = 'difference'</code>, every variable in the formula will be
interpreted as <code>I(R(x) - L(x))</code>. If you use the option
<code>model = 'marginal'</code>, every variable will be interpreted as
<code>R(X)</code>.
</p>
<p>If you don't specify any special function (i.e. <code>L</code>,
<code>R</code>, <code>P</code> or <code>PO</code>),
the lefthand side of the formula is defined as <code>PO(y)</code>. The function
<code>PO</code> calculates pseudo observations; it is 1
if the value of the dependent variable for the observation
from the L-poset is smaller than, 0 if it is larger than and 0.5 if
it is equal to the value for value from the R-poset (see also <code>PO</code>)
</p>


<h3>See Also</h3>

<p><code>pim-class</code> for more information on the returned
object, <code>pim.fit</code> for more information on the fitting
itself,  <code>pim-getters</code>, <code>coef</code>, <code>confint</code>,
<code>vcov</code> etc  for how to extract information like coefficients,
variance-covariance matrix, ...,
<code>summary</code> for some tests on the coefficients.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data('FEVData')
# The most basic way to use the function
Model &lt;- pim(FEV~ Smoke*Sex , data=FEVData)

# A model with intercept
# The argument xscalm is passed to nleqslv via pim.fit and estimator.nleqslv
# By constructing the estimator functions wisely, you can control most of
# the fitting process from the pim() function.
data('EngelData')
Model2 &lt;- pim(foodexp ~ income + 1, data=EngelData,
   compare="all",
   xscalm = 'auto')

# A marginal model
# It makes sense to use the identity link in combination with the
# score estimator for the variance-covariance matrix
data('DysData')
Model3 &lt;- pim(SPC_D2 ~ out, data = DysData,
  model = 'marginal', link = 'identity',
  vcov.estim = score.vcov)

# A Model using logical comparisons, this is also possible!
# Model the chance that both observations have a different
# outcome in function of whether they had a different Chemo treatment
Model6 &lt;- pim(P(L(out) != R(out)) ~ I(L(Chemo) != R(Chemo)),
   data=DysData,
   compare="all")

# Implementation of the friedman test in the context of a pim
# warpbreaks data where we consider tension as a block
# To do so, you provide the argument compare with a custom
# set of comparisons
data(warpbreaks)
wb &lt;- aggregate(warpbreaks$breaks,
                by = list(w = warpbreaks$wool,
                          t = warpbreaks$tension),
                FUN = mean)
comp &lt;- expand.grid(1:nrow(wb), 1:nrow(wb))
comp &lt;- comp[wb$t[comp[,1]] == wb$t[comp[,2]],] # only compare within blocks
m &lt;- pim(x ~ w, data = wb, compare = comp, link = "identity",  vcov.estim = score.vcov)
summary(m)
friedman.test(x ~ w | t, data = wb)
## Not run: 
# This illustrates how a standard model is actually built in a pim contex
Model4 &lt;- pim(PO(L(Height),R(Height)) ~ I(R(Age) - L(Age)) + I(R(Sex) - L(Sex)),
data=FEVData,
estim = "estimator.BB")
# is the same as
Model5 &lt;- pim(Height ~ Age + Sex, data = FEVData, estim = "estimator.BB")
summary(Model4)
summary(Model5)

## End(Not run)
</code></pre>


</div>
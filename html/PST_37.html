<div class="container">

<table style="width: 100%;"><tr>
<td>pstree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Build a probabilistic suffix tree
</h2>

<h3>Description</h3>

<p>Build a probabilistic suffix tree that stores a variable length Markov chain (VLMC) model 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'stslist'
pstree(object, group, L, cdata=NULL, stationary=TRUE, 
	nmin = 1, ymin=NULL, weighted = TRUE, with.missing = FALSE, lik = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>a sequence object, i.e., an object of class <code>'stslist'</code> as created by TraMineR <code>seqdef</code> function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>

<p>a vector giving the group membership for each observation in x. If specified, a segmented PST is produced containing one PST for each group. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cdata</code></td>
<td>
 
<p>Not implemented yet.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stationary</code></td>
<td>
 
<p>Not implemented yet.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>

<p>Integer. Maximal depth of the PST. Default to maximum length of the sequence(s) in object minus 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmin</code></td>
<td>

<p>Integer. Minimum number of occurences of a string to add it in the tree 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ymin</code></td>
<td>

<p>Numeric. Smoothing parameter for conditional probabilities, assuring that no symbol, and hence no sequence, is predicted to have a null probability. The parameter $ymin$ sets a lower bound for a symbol's probability.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted</code></td>
<td>

<p>Logical. If TRUE, weights attached to the sequence object are used in the estimation of probabilities.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with.missing</code></td>
<td>

<p>Logical. If TRUE, the missing state is added to the alphabet
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lik</code></td>
<td>
<p>Logical. If TRUE, the log-likelihood of the model, i.e. the likelihood of the training sequences given the model, is computed and stored in the 'logLik' slot of the PST. Setting to FALSE will spare the time required to compute the likelihood.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A probabilistic suffix tree (PST) is built from a learning sample of <code class="reqn">n, \; n \geq 1</code> sequences by successively adding nodes labelled with subsequences (contexts) <code class="reqn">c</code> of length <code class="reqn">L,  \; 0 \leq L \leq L_{max}</code> found in the data. When the value <code class="reqn">L_{max}</code> is not defined by the user it is set to its theorectical maximum <code class="reqn">\ell-1</code> where <code class="reqn">\ell</code> is the maximum sequence length in the learning sample. The <code>nmin</code> argument specifies the minimum frequency of a subsequence required to add it to te tree.<br>
Each node of the tree is labelled with a context <code class="reqn">c</code> and stores the next symbol empirical probability distribution <code class="reqn">\hat{P}(\sigma|c), \; \sigma \in A</code>, where <code class="reqn">A</code> is an alphabet of finite size. The root node labelled with the empty string <code class="reqn">e</code> stores the <code class="reqn">0th</code> order probability <code class="reqn">\hat{P}(\sigma), \; \sigma \in A</code> of oberving each symbol of the alphabet in the whole learning sample.<br>
The building algorithm calls the <code>cprob</code> function which returns the empirical next symbol counts observed after each context <code class="reqn">c</code> and computes the corresponding empirical probability distribution. Each node in the tree is connected to its longest suffix, where the longest suffix of a string <code class="reqn">c=c_{1},c_{2}, \ldots, c_{k}</code> of length <code class="reqn">k</code> is <code class="reqn">suffix(c)=c_{2}, \ldots, c_{k}</code>.<br>
Once an initial PST is built it can be pruned to reduce its complexity by removing nodes that do not provide significant information (see <code>prune</code>). A model selection procedure based on information criteria is also available (see <code>tune</code>). For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>An object of class <code>"PSTf"</code>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Bejerano, G. &amp; Yona, G. (2001) Variations on probabilistic suffix trees: statistical modeling and prediction of protein families. <em>Bioinformatics</em> 17, 23-43.
</p>
<p>Gabadinho, A. &amp; Ritschard, G. (2016) Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em> <b>72</b>(3), 1-39.
</p>
<p>Maechler, M. &amp; Buehlmann, P. (2004) Variable Length Markov Chains: Methodology, Computing, and Software. <em>Journal of Computational and Graphical Statistics</em> 13, pp. 435-455.
</p>
<p>Ron, D.; Singer, Y. &amp; Tishby, N. (1996) The power of amnesia: Learning probabilistic automata with variable memory length. <em>Machine Learning</em> 25, 117-149.
</p>


<h3>See Also</h3>

<p><code>prune</code>, <code>tune</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Build a PST on one single sequence
data(s1)
s1.seq &lt;- seqdef(s1)
s1.seq
S1 &lt;- pstree(s1.seq, L = 3)
print(S1, digits = 3)
S1
</code></pre>


</div>
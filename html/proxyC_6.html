<div class="container">

<table style="width: 100%;"><tr>
<td>simil</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute similarity/distance between rows or columns of large matrices</h2>

<h3>Description</h3>

<p>Fast similarity/distance computation function for large sparse matrices. You
can floor small similarity value to to save computation time and storage
space by an arbitrary threshold (<code>min_simil</code>) or rank (<code>rank</code>). You
can specify the number of threads for parallel computing via
<code>options(proxyC.threads)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simil(
  x,
  y = NULL,
  margin = 1,
  method = c("cosine", "correlation", "jaccard", "ejaccard", "fjaccard", "dice", "edice",
    "hamann", "faith", "simple matching"),
  min_simil = NULL,
  rank = NULL,
  drop0 = FALSE,
  diag = FALSE,
  use_nan = NULL,
  digits = 14
)

dist(
  x,
  y = NULL,
  margin = 1,
  method = c("euclidean", "chisquared", "kullback", "jeffreys", "jensen", "manhattan",
    "maximum", "canberra", "minkowski", "hamming"),
  p = 2,
  smooth = 0,
  drop0 = FALSE,
  diag = FALSE,
  use_nan = NULL,
  digits = 14
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>matrix or Matrix object. Dense matrices are covered to
the CsparseMatrix-class internally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>if a matrix or Matrix object is provided, proximity
between documents or features in <code>x</code> and <code>y</code> is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margin</code></td>
<td>
<p>integer indicating margin of similarity/distance computation. 1
indicates rows or 2 indicates columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method to compute similarity or distance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_simil</code></td>
<td>
<p>the minimum similarity value to be recorded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>an integer value specifying top-n most similarity values to be
recorded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop0</code></td>
<td>
<p>if <code>TRUE</code>, zero values are removed regardless of
<code>min_simil</code> or <code>rank</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>
<p>if <code>TRUE</code>, only compute diagonal elements of the
similarity/distance matrix; useful when comparing corresponding rows or
columns of <code>x</code> and <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_nan</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NaN</code> if the standard deviation of a vector
is zero when <code>method</code> is "correlation"; if all the values are zero in a
vector when <code>method</code> is "cosine", "chisquared", "kullback", "jeffreys" or
"jensen". Note that use of <code>NaN</code> makes the similarity/distance matrix
denser and therefore larger in RAM. If <code>FALSE</code>, return zero in same use
situations as above. If <code>NULL</code>, will also return zero but also generate a
warning (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>determines rounding of small values towards zero. Use primarily
to correct rounding errors in C++. See zapsmall.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>weight for Minkowski distance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth</code></td>
<td>
<p>adds a  fixed value to all the cells to avoid division by zero.
Only used when <code>method</code> is "chisquared", "kullback", "jeffreys" or "jensen".</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Available Methods</h4>

<p>Similarity:
</p>

<ul>
<li> <p><code>cosine</code>: cosine similarity
</p>
</li>
<li> <p><code>correlation</code>: Pearson's correlation
</p>
</li>
<li> <p><code>jaccard</code>: Jaccard coefficient
</p>
</li>
<li> <p><code>ejaccard</code>: the real value version of <code>jaccard</code>
</p>
</li>
<li> <p><code>fjaccard</code>: Fuzzy Jaccard coefficient
</p>
</li>
<li> <p><code>dice</code>: Dice coefficient
</p>
</li>
<li> <p><code>edice</code>: the real value version of <code>dice</code>
</p>
</li>
<li> <p><code>hamann</code>: Hamann similarity
</p>
</li>
<li> <p><code>faith</code>: Faith similarity
</p>
</li>
<li> <p><code style="white-space: pre;">⁠simple matching⁠</code>: the percentage of common elements
</p>
</li>
</ul>
<p>Distance:
</p>

<ul>
<li> <p><code>euclidean</code>: Euclidean distance
</p>
</li>
<li> <p><code>chisquared</code>: chi-squared distance
</p>
</li>
<li> <p><code>kullback</code>: Kullback–Leibler divergence
</p>
</li>
<li> <p><code>jeffreys</code>: Jeffreys divergence
</p>
</li>
<li> <p><code>jensen</code>: Jensen–Shannon divergence
</p>
</li>
<li> <p><code>manhattan</code>: Manhattan distance
</p>
</li>
<li> <p><code>maximum</code>: the largest difference between values
</p>
</li>
<li> <p><code>canberra</code>: Canberra distance
</p>
</li>
<li> <p><code>minkowski</code>: Minkowski distance
</p>
</li>
<li> <p><code>hamming</code>: Hamming distance
</p>
</li>
</ul>
<p>See the vignette for how the similarity and distance are computed:
<code>vignette("measures", package = "proxyC")</code>
</p>



<h4>Parallel Computing</h4>

<p>It performs parallel computing using Intel oneAPI Threads Building Blocks.
The number of threads for parallel computing should be specified via
<code>options(proxyC.threads)</code> before calling the functions. If the value is -1,
all the available threads will be used. Unless the option is used, the
number of threads will be limited by the environmental variables
(<code>OMP_THREAD_LIMIT</code> or <code>RCPP_PARALLEL_NUM_THREADS</code>) to comply with CRAN
policy and offer backward compatibility.
</p>



<h3>See Also</h3>

<p>zapsmall
</p>


<h3>Examples</h3>

<pre><code class="language-R">mt &lt;- Matrix::rsparsematrix(100, 100, 0.01)
simil(mt, method = "cosine")[1:5, 1:5]
mt &lt;- Matrix::rsparsematrix(100, 100, 0.01)
dist(mt, method = "euclidean")[1:5, 1:5]
</code></pre>


</div>
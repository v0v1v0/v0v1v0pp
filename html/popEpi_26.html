<div class="container">

<table style="width: 100%;"><tr>
<td>lexpand</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Split case-level observations</h2>

<h3>Description</h3>

<p>Given subject-level data, data is split 
by calendar time (<code>per</code>), <code>age</code>, and follow-up
time (<code>fot</code>, from 0 to the end of follow-up) 
into subject-time-interval rows according to 
given <code>breaks</code> and additionally processed if requested.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lexpand(
  data,
  birth = NULL,
  entry = NULL,
  exit = NULL,
  event = NULL,
  status = status != 0,
  entry.status = NULL,
  breaks = list(fot = c(0, Inf)),
  id = NULL,
  overlapping = TRUE,
  aggre = NULL,
  aggre.type = c("unique", "cartesian"),
  drop = TRUE,
  pophaz = NULL,
  pp = TRUE,
  subset = NULL,
  merge = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>dataset of e.g. cancer cases as rows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>birth</code></td>
<td>
<p>birth time in date format 
or fractional years; string, symbol or expression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>entry</code></td>
<td>
<p>entry time in date format 
or fractional years; string, symbol or expression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exit</code></td>
<td>
<p>exit from follow-up time in date 
format or fractional years; string, symbol or expression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>event</code></td>
<td>
<p>advanced: time of possible event differing from <code>exit</code>;
typically only used in certain SIR/SMR calculations - see Details; 
string, symbol or expression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>status</code></td>
<td>
<p>variable indicating type of event at <code>exit</code> or <code>event</code>; 
e.g. <code>status = status != 0</code>; expression or quoted variable name</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>entry.status</code></td>
<td>
<p>input in the same way as <code>status</code>; 
status at <code>entry</code>; see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>a named list of vectors of time breaks; 
e.g. <code>breaks = list(fot=0:5, age=c(0,45,65,Inf))</code>; see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>optional; an id variable; e.g. <code>id = my_id</code>;
string, symbol or expression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overlapping</code></td>
<td>
<p>advanced, logical; if <code>FALSE</code> AND if <code>data</code> contains
multiple rows per subject, 
ensures that the timelines of <code>id</code>-specific rows do not overlap;
this ensures e.g. that person-years are only computed once per subject 
in a multi-state paradigm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggre</code></td>
<td>
<p>e.g. <code>aggre = list(sex, fot)</code>; 
a list of unquoted variables and/or expressions thereof,
which are interpreted as factors; data events and person-years will
be aggregated by the unique combinations of these; see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggre.type</code></td>
<td>
<p>one of <code>c("unique","cartesian")</code>;
can be abbreviated; see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>logical; if <code>TRUE</code>, drops all resulting rows 
after splitting that reside outside
the time window as defined by the given breaks (all time scales)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pophaz</code></td>
<td>
<p>a dataset of population hazards to merge
with split data; see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pp</code></td>
<td>
<p>logical; if <code>TRUE</code>, computes Pohar-Perme weights using
<code>pophaz</code>; adds variable with reserved name <code>pp</code>; 
see Details for computing method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>a logical vector or any logical condition; data is subsetted
before splitting accordingly</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merge</code></td>
<td>
<p>logical; if <code>TRUE</code>, retains all 
original variables from the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, the function is chatty and 
returns some messages along the way</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>e.g. <code>fot = 0:5</code>; instead of specifying a <code>breaks</code> list, 
correctly named breaks vectors can be given 
for <code>fot</code>, <code>age</code>, and <code>per</code>; these override any breaks in the
<code>breaks</code> list; see Examples</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Basics</strong>
</p>
<p><code>lexpand</code> splits a given data set (with e.g. cancer diagnoses 
as rows) to subintervals of time over 
calendar time, age, and follow-up time with given time breaks 
using <code>splitMulti</code>.
</p>
<p>The dataset must contain appropriate 
<code>Date</code> / <code>IDate</code> / <code>date</code> format or
other numeric variables that can be used
as the time variables.
</p>
<p>You may take a look at a simulated cohort 
<code>sire</code> as an example of the
minimum required information for processing data with <code>lexpand</code>.
</p>
<p>Many arguments can be supplied as a character string naming the appropriate
variable (e.g. <code>"sex"</code>), as a symbol (e.g. <code>sex</code>) or as an expression
(e.g. <code>factor(sex, 0:1, c("m", "f"))</code>) for flexibility.
</p>
<p><strong>Breaks</strong>
</p>
<p>You should define all breaks as left inclusive and right exclusive 
time points (e.g.<code>[a,b)</code> )
for 1-3 time dimensions so that the last member of a breaks vector
is a meaningful "final upper limit",
e.g. <code>per = c(2002,2007,2012)</code> 
to create a last subinterval of the form <code>[2007,2012)</code>. 
</p>
<p>All breaks are explicit, i.e. if <code>drop = TRUE</code>,
any data beyond the outermost breaks points are dropped. 
If one wants to have unspecified upper / lower limits on one time scale,
use <code>Inf</code>: e.g. <code>breaks = list(fot = 0:5, age = c(0,45,Inf))</code>.
Breaks for <code>per</code> can also be given in 
<code>Date</code>/<code>IDate</code>/<code>date</code> format, whereupon
they are converted to fractional years before used in splitting.
</p>
<p>The <code>age</code> time scale can additionally 
be automatically split into common age grouping schemes
by naming the scheme with an appropriate character string:
</p>

<ul>
<li> <p><code>"18of5"</code>: age groups 0-4, 5-9, 10-14, ..., 75-79, 80-84, 85+
</p>
</li>
<li> <p><code>"20of5"</code>: age groups 0-4, 5-9, 10-14, ..., 85-89, 90-94, 95+
</p>
</li>
<li> <p><code>"101of1"</code>: age groups 0, 1, 2, ..., 98, 99, 100+
</p>
</li>
</ul>
<p><strong>Time variables</strong>
</p>
<p>If any of the given time variables
(<code>birth</code>, <code>entry</code>, <code>exit</code>, <code>event</code>)
is in any kind of date format, they are first coerced to 
fractional years before splitting
using <code>get.yrs</code> (with <code>year.length = "actual"</code>).
</p>
<p>Sometimes in e.g. SIR/SMR calculation one may want the event time to differ
from the time of exit from follow-up, if the subject is still considered
to be at risk of the event. If <code>event</code> is specified, the transition to
<code>status</code> is moved to <code>event</code> from <code>exit</code> 
using <code>cutLexis</code>. See Examples.
</p>
<p><strong>The status variable</strong>
</p>
<p>The statuses in the expanded output (<code>lex.Cst</code> and <code>lex.Xst</code>)
are determined by using either only <code>status</code> or both <code>status</code>
and <code>entry.status</code>. If <code>entry.status = NULL</code>, the status at entry
is guessed according to the type of variable supplied via <code>status</code>:
For numeric variables it will be zero, for factors the first level
(<code>levels(status)[1]</code>) and otherwise the first unique value in alphabetical
order (<code>sort(unique(status))[1]</code>). 
</p>
<p>Using numeric or factor status
variables is strongly recommended. Logical expressions are also allowed
(e.g. <code>status = my_status != 0L</code>) and are converted to integer internally.
</p>
<p><strong>Merging population hazard information</strong>
</p>
<p>To enable computing relative/net survivals with <code>survtab</code>
and <code>relpois</code>, <code>lexpand</code> merges an appropriate
population hazard data (<code>pophaz</code>) to the expanded data 
before dropping rows outside the specified
time window (if <code>drop = TRUE</code>). <code>pophaz</code> must, for this reason, 
contain at a minimum the variables named
<code>agegroup</code>, <code>year</code>, and <code>haz</code>. <code>pophaz</code> may contain additional variables to specify
different population hazard levels in different strata; e.g. <code>popmort</code> includes <code>sex</code>.
All the strata-defining variables must be present in the supplied <code>data</code>. <code>lexpand</code> will
automatically detect variables with common names in the two datasets and merge using them.
</p>
<p>Currently <code>year</code> must be an integer variable specifying the appropriate year. <code>agegroup</code>
must currently also specify one-year age groups, e.g. <code>popmort</code> specifies 101 age groups
of length 1 year. In both
<code>year</code> and <code>agegroup</code> variables the values are interpreted as the lower bounds of intervals
(and passed on to a <code>cut</code> call). The mandatory variable <code>haz</code>
must specify the appropriate average rate at the person-year level;
e.g. <code>haz = -log(survProb)</code> where <code>survProb</code> is a one-year conditional
survival probability will be the correct hazard specification. 
</p>
<p>The corresponding <code>pophaz</code> population hazard value is merged by using the mid points
of the records after splitting as reference values. E.g. if <code>age=89.9</code> at the start
of a 1-year interval, then the reference age value is <code>90.4</code> for merging. 
This way we get a "typical" population hazard level for each record.
</p>
<p><strong>Computing Pohar-Perme weights</strong>
</p>
<p>If <code>pp = TRUE</code>, Pohar-Perme weights 
(the inverse of cumulative population survival) are computed. This will
create the new <code>pp</code> variable in the expanded data. <code>pp</code> is a
reserved name and <code>lexpand</code> throws exception if a variable with that name
exists in <code>data</code>.
</p>
<p>When a survival interval contains one or several rows per subject
(e.g. due to splitting by the <code>per</code> scale),
<code>pp</code> is cumulated from the beginning of the first record in a survival
interval for each subject to the mid-point of the remaining time within that
survival interval, and  that value is given for every other record 
that a given person has within the same survival interval. 
</p>
<p>E.g. with 5 rows of duration <code>1/5</code> within a survival interval 
<code>[0,1)]</code>, <code>pp</code> is determined for all records by a cumulative 
population survival from <code>0</code> to <code>0.5</code>. The existing accuracy is used,
so that the weight is cumulated first up to the end of the second row
and then over the remaining distance to the mid-point (first to 0.4, then to
0.5). This ensures that more accurately merged population hazards are fully
used.
</p>
<p><strong>Event not at end of follow-up &amp; overlapping time lines</strong>
</p>
<p><code>event</code> may be used if the event indicated by <code>status</code> should
occur at a time differing from <code>exit</code>. If <code>event</code> is defined,
<code>cutLexis</code> is used on the data set after coercing it to the <code>Lexis</code>
format and before splitting. Note that some values of <code>event</code> are allowed
to be <code>NA</code> as with <code>cutLexis</code> to accommodate observations
without an event occurring.
</p>
<p>Additionally, setting <code>overlapping = FALSE</code> ensures that (irrespective
of using <code>event</code>) the each subject defined by <code>id</code> only has one
continuous time line instead of possibly overlapping time lines if
there are multiple rows in <code>data</code> by <code>id</code>.
</p>
<p><strong>Aggregating</strong>
</p>
<p>Certain analyses such as SIR/SMR calculations require tables of events and
person-years by the unique combinations (interactions) of several variables. 
For this, <code>aggre</code> can be specified as a list of such variables 
(preferably <code>factor</code> variables but not mandatory)
and any arbitrary functions of the 
variables at one's disposal. E.g. 
</p>
<p><code>aggre = list(sex, agegr = cut(dg_age, 0:100))</code>
</p>
<p>would tabulate events and person-years by sex and an ad-hoc age group
variable. Every ad-hoc-created variable should be named.
</p>
<p><code>fot</code>, <code>per</code>, and <code>age</code> are special reserved variables which,
when present in the <code>aggre</code> list, are output as categories of the
corresponding time scale variables by using 
e.g. 
</p>
<p><code>cut(fot, breaks$fot, right=FALSE)</code>. 
</p>
<p>This only works if
the corresponding breaks are defined in <code>breaks</code> or via "<code>...</code>".
E.g. 
</p>
<p><code>aggre = list(sex, fot.int = fot)</code> with 
</p>
<p><code>breaks = list(fot=0:5)</code>.
</p>
<p>The output variable <code>fot.int</code> in the above example will have
the lower limits of the appropriate intervals as values.
</p>
<p><code>aggre</code> as a named list will output numbers of events and person-years
with the given new names as categorizing variable names, e.g. 
<code>aggre = list(follow_up = fot, gender = sex, agegroup = age)</code>.
</p>
<p>The output table has person-years (<code>pyrs</code>) and event counts
(e.g. <code>from0to1</code>) as columns. Event counts are the numbers of transitions
(<code>lex.Cst != lex.Xst</code>) or the <code>lex.Xst</code> value at a subject's 
last record (subject possibly defined by <code>id</code>).
</p>
<p>If <code>aggre.type = "unique"</code> (alias <code>"non-empty"</code>), 
the above results are computed for existing
combinations of expressions given in <code>aggre</code>, but also for non-existing
combinations if <code>aggre.type = "cartesian"</code> (alias <code>"full"</code>). E.g. if a
factor variable has levels <code>"a", "b", "c"</code> but the data is limited
to only have levels <code>"a", "b"</code> present 
(more than zero rows have these level values), the former setting only
computes results for <code>"a", "b"</code>, and the latter also for <code>"c"</code>
and any combination with other variables or expression given in <code>aggre</code>.
In essence, <code>"cartesian"</code> forces also combinations of variables used
in <code>aggre</code> that have no match in data to be shown in the result.
</p>
<p>If <code>aggre</code> is not <code>NULL</code> and <code>pophaz</code> has been supplied,
<code>lexpand</code> also aggregates the expected counts of events, which
appears in the output data by the reserved name <code>d.exp</code>. Additionally,
having <code>pp = TRUE</code> causes <code>lexpand</code> to also compute various
Pohar-Perme weighted figures necessary for computing Pohar-Perme net survivals
with <code>survtab_ag</code>. This can be slow, so consider what is really
needed. The Pohar-Perme weighted figures have the suffix <code>.pp</code>.
</p>


<h3>Value</h3>

<p>If <code>aggre = NULL</code>, returns 
a <code>data.table</code> or <code>data.frame</code> 
(depending on <code>options("popEpi.datatable")</code>; see <code>?popEpi</code>) 
object expanded to accommodate split observations with time scales as
fractional years and <code>pophaz</code> merged in if given. Population
hazard levels in new variable <code>pop.haz</code>, and Pohar-Perme
weights as new variable <code>pp</code> if requested.
</p>
<p>If <code>aggre</code> is defined, returns a long-format 
<code>data.table</code>/<code>data.frame</code> with the variable <code>pyrs</code> (person-years),
and variables for the counts of transitions in state or state at end of 
follow-up formatted <code>fromXtoY</code>, where <code>X</code> and <code>Y</code> are 
the states transitioned from and to, respectively. The data may also have
the columns <code>d.exp</code> for expected numbers of cases and various
Pohar-Perme weighted figures as identified by the suffix <code>.pp</code>; see 
Details.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p><code>Lexis</code>, <code>popmort</code>
</p>
<p>Other splitting functions: 
<code>splitLexisDT()</code>,
<code>splitMulti()</code>
</p>
<p>Other aggregation functions: 
<code>aggre()</code>,
<code>as.aggre()</code>,
<code>setaggre()</code>,
<code>summary.aggre()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## prepare data for e.g. 5-year cohort survival calculation
x &lt;- lexpand(sire, breaks=list(fot=seq(0, 5, by = 1/12)), 
             birth = bi_date, entry = dg_date, exit = ex_date,
             status =  status != 0, pophaz=popmort)

## prepare data for e.g. 5-year "period analysis" for 2008-2012
BL &lt;- list(fot = seq(0, 5, by = 1/12), per = c("2008-01-01", "2013-01-01"))
x &lt;- lexpand(sire, breaks = BL, 
             birth = bi_date, entry = dg_date, exit = ex_date,
             pophaz=popmort, status =  status != 0)

## aggregating
BL &lt;- list(fot = 0:5, per = c("2003-01-01","2008-01-01", "2013-01-01"))
ag &lt;- lexpand(sire, breaks = BL, status = status != 0, 
             birth = bi_date, entry = dg_date, exit = ex_date,
              aggre=list(sex, period = per, surv.int = fot))

## aggregating even more
ag &lt;- lexpand(sire, breaks = BL, status = status != 0, 
              birth = bi_date, entry = dg_date, exit = ex_date,
              aggre=list(sex, period = per, surv.int = fot),
              pophaz = popmort, pp = TRUE)

## using "..."
x &lt;- lexpand(sire, fot=0:5, status =  status != 0,
             birth = bi_date, entry = dg_date, exit = ex_date,
             pophaz=popmort) 

x &lt;- lexpand(sire, fot=0:5, status =  status != 0, 
             birth = bi_date, entry = dg_date, exit = ex_date,
             aggre=list(sex, surv.int = fot))
             
## using the "event" argument: it just places the transition to given "status"
## at the "event" time instead of at the end, if possible using cutLexis
x &lt;- lexpand(sire, status = status, event = dg_date,
             birth = bi_date, entry = dg_date, exit = ex_date,) 

## aggregating with custom "event" time
## (the transition to status is moved to the "event" time)
x &lt;- lexpand(sire, status = status, event = dg_date, 
             birth = bi_date, entry = dg_date, exit = ex_date,
             per = 1970:2014, age = c(0:100,Inf),
             aggre = list(sex, year = per, agegroup = age)) 



</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>papply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parallel, optionally verbose lapply. See ?parallel::mclapply for more info.</h2>

<h3>Description</h3>

<p>Parallel, optionally verbose lapply. See ?parallel::mclapply for more info.
</p>


<h3>Usage</h3>

<pre><code class="language-R">papply(..., n.cores = parallel::detectCores(), mc.preschedule = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to mclapply(), lapply(), or BiocParallel::bplapply()</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>Number of cores to use (default=parallel::detectCores())</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.preschedule</code></td>
<td>
<p>See ?parallel::mclapply (default=FALSE). If TRUE then the computation is first divided to (at most) as many jobs are there are cores and then the jobs are started, each job possibly covering more than one value. If FALSE, then one job is forked for each value of X. The former is better for short computations or large number of values in X, the latter is better for jobs that have high variance of completion time and not too many values of X compared to mc.cores.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>list, as returned by lapply
</p>


</div>
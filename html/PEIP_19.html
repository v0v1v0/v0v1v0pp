<div class="container">

<table style="width: 100%;"><tr>
<td>GSVD</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized SVD
</h2>

<h3>Description</h3>

<p>Wrapper for generalized svd from LAPACK
</p>


<h3>Usage</h3>

<pre><code class="language-R">GSVD(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Matrix, see below </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Matrix, see below </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The A and B matrices will be, A=U*C*t(X) and B=V*S*t(X), respectively.
</p>
<p>Since PEIP is based on a book, which is iteslef based on MATLAB routines,
the convention here follows the book.  The R implementation uses LAPACK
and wraps the function so the output will comply with the book.  See page
104 of the second edition of the Aster book cited below.  That said,
the purpose is to find an inversion of the form Y = t(A aB),
where a is a regularization parameter, B is
smoothing matrix and A is the design matrix for the forward problem.
The input matrices A and B are assumed to have full rank, and
p = rank(B).  The generalized singular values are then gamma = lambda/mu,
where lambda = sqrt(diag(t(C)*C) ) and mu = sqrt(diag(t(S)*S) ).
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>m by m orthogonal matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>p by p orthogonal matrix, p=rank(B)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>n by n nonsingular matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>singular values, m by n matrix with diagonal elements shifted from main diagonal</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>singular values, p by n diagonal matrix</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Requires R version of LAPACK. The code is a wrapper
for the dggsvd function in LAPACK.  The author thanks Berend Hasselman for advice
and help preparing this function.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>,
Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>See Also</h3>

<p>flipGSVD</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Example from NAG F08VAF

A &lt;- matrix(1:15, nrow=5,ncol=3)
 B &lt;- matrix(c(8,1,6,
               3,5,7,
               4,9,2), nrow=3, byrow=TRUE)

z &lt;- GSVD(A,B)
C &lt;- z$C
S &lt;- z$S
sqrt(diag(t(C) %*% C)) / sqrt(diag(t(S) %*% S))
testA = A - z$U %*% C %*% t(z$X)
testB = B - z$V %*% S %*% t(z$X)

print(testA)
print(testB)


</code></pre>


</div>
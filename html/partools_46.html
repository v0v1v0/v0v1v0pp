<div class="container">

<table style="width: 100%;"><tr>
<td>formrowchunks,addlists,matrixtolist,setclsinfo,getpte,distribsplit,distribcat,distribagg,distribrange,distribcounts,distribgetrows,docmd,doclscmd,geteltis,distribmeans,distribisdt,ipstrcat,dwhich.min,dwhich.max</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Utilities for <span class="pkg">parallel</span> cluster code.
</h2>

<h3>Description</h3>

<p>Miscellaneous code snippets for use with the <span class="pkg">parallel</span> package,
including “Snowdoop.”</p>


<h3>Usage</h3>

<pre><code class="language-R">formrowchunks(cls,m,mchunkname,scramble=FALSE) 
matrixtolist(rc,m) 
addlists(lst1,lst2,add)
setclsinfo(cls)
getpte()
exportlibpaths(cls)
distribsplit(cls,dfname,scramble=FALSE)
distribcat(cls,dfname) 
distribagg(cls,ynames,xnames,dataname,FUN,FUNdim=1,FUN1=FUN) 
distribrange(cls,vec,na.rm=FALSE) 
distribcounts(cls,xnames,dataname)
distribmeans(cls,ynames,xnames,dataname,saveni=FALSE)
dwhich.min(cls,vecname)
dwhich.max(cls,vecname)
distribgetrows(cls,cmd)
distribisdt(cls,dataname) 
docmd(toexec) 
doclscmd(cls,toexec) 
geteltis(lst,i)
ipstrcat(str1 = stop("str1 not supplied"), ..., outersep = "", innersep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cls</code></td>
<td>
<p>A cluster for the <span class="pkg">parallel</span> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scramble</code></td>
<td>
<p>If TRUE, randomize the row order in the resulting data
frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rc</code></td>
<td>
<p>Set to 1 for rows, other for columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>A matrix or data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mchunkname</code></td>
<td>
<p>Quoted name to be given to the created chunks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lst1</code></td>
<td>
<p>An R list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lst2</code></td>
<td>
<p>An R list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>“Addition” function, which could be summation,
concatenation and so on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfname</code></td>
<td>
<p>Quoted name of a data frame, either centralized or
distributed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ynames</code></td>
<td>
<p>Vector of quoted names of variables on which <code>FUN</code> 
is to be applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vecname</code></td>
<td>
<p>Quoted name of a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>One of more vectors of character strings, where the vectors
are typically of length 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xnames</code></td>
<td>
<p>Vector of quoted names of variables that define the
grouping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataname</code></td>
<td>
<p>Quoted name of a distributed data frame or data.table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveni</code></td>
<td>
<p>If TRUE, save the chunk sizes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>Quoted name of a single-argument function to be used in
aggregating within cluster nodes.  If <code>dataname</code> is the name
of a data.table, <code>FUN</code> must be a vector of function names, of
length equal to that of <code>ynames</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUNdim</code></td>
<td>
<p>Number of elements in the return value of <code>FUN</code>.
Must be 1 for data.tables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN1</code></td>
<td>
<p>Quoted name of function to be used in
aggregation between cluster nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vec</code></td>
<td>
<p>Quoted expression that evaluates to a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Remove NA values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cmd</code></td>
<td>
<p>An R command.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toexec</code></td>
<td>
<p>Quoted string containing command to be executed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lst</code></td>
<td>
<p>An R list of vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>A column index</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>str1</code></td>
<td>
<p>A character string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outersep</code></td>
<td>
<p>Separator, e.g. a comma, between strings specified in
...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>innersep</code></td>
<td>
<p>Separator, e.g. a comma, within string vectors specified in
...</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>setclsinfo</code> function does initialization needed for
use of the tools in the package.
</p>
<p>The function <code>formrowchunks</code> forms chunks of rows of
<code>m</code>, corresponding to the number of worker nodes
in the cluster <code>m</code>.  For any given worker, the code places its
chunk in <code>mchunk</code> in the global space of the worker.
</p>
<p>A call to <code>matrixtolist</code> extracts the rows or columns of a matrix
or data frame and forms an R list from them.
</p>
<p>The function <code>addlists</code> does the following:  Say we have two lists,
with numeric values.  We wish to form a new list, with all the keys
(names) from the two input lists appearing in the new list.  In the case
of a key in common to the two lists, the value in the new list will be
the sum of the two individual values for that key.  (Here “sum” means
the result of applying <code>add</code>.) For a key appearing in one list and
not the other, the value in the new list will be the value in the input
list.  
</p>
<p>The function <code>exportlibpaths</code>, invoked from the manager, exports
the manager's R search path to the workers.
</p>
<p>The function <code>distribsplit</code> splits a data frame <code>dfname</code> into
approximately  equal-sized chunks of rows, placing the chunks on the
cluster nodes, as global variables of the same name. The opposite action
is taken by <code>distribcat</code>, coalsecing variables of the given name in
the cluster nodes into one grand data frame as the calling (i.e.
manager) node.
</p>
<p>The package's <code>distribagg</code> function is a distributed (and somewhat
restricted) form of <code>aggregate</code>.  The latter is called to each
distributed chunk with the function <code>FUN</code>.  The manager collects
the results and calls <code>FUN1</code>.
</p>
<p>The special cases of aggregating counts and means is handled by the
wrappers <code>distribcounts</code> and <code>distribmeans</code>.  In each case,
cells are defined by <code>xnames</code>, and aggregation done first within
workers and then across workers. 
</p>
<p>The <code>distribrange</code> function is a distributed form of <code>range</code>.
</p>
<p>The <code>dwhich.min</code> and <code>dwhich.max</code> functions are distributed
analogs of R's <code>which.min</code> and <code>which.max</code>.
</p>
<p>The <code>distribgetrows</code> function is useful in a variety of situations.
It can be used, for instance, as a distributed form of <code>select</code>.
In the latter case, the specified rows will be selected at each cluster
node, then <code>rbind</code>-ed together at the caller.
</p>
<p>The <code>docmd</code> function executes the quoted command, useful for
building up complex command for remote execution.  The <code>doclscmd</code>
function does that directly.
</p>
<p>An R <code>formula</code> will be constructed from the arguments <code>ynames</code>
and <code>xnames</code>, with the latter put on the left side of the <code>~</code>
sign, with <code>cbind</code> for combining, and the latter put on the right
side, with <code>+</code> signs as delimiters.
</p>
<p>The <code>geteltis</code> function extracts from an R list of vectors element
<code>i</code> from each.
</p>


<h3>Value</h3>

<p>In the case of <code>addlists</code>, the return value is the new list.
</p>
<p>The <code>distribcat</code> function returns the concatenated data frame;
<code>distribgetrows</code> works similarly.
</p>
<p>The <code>distribagg</code> function returns a data frame, the same as would a
call to <code>aggregate</code>, though possibly in different row order;
<code>distribcounts</code> works similarly.
</p>
<p>The <code>dwhich.min</code> and <code>dwhich.max</code> functions each return a
two-tuple, consisting of the node number and row number which node at
which the min or max occurs.
</p>


<h3>Author(s)</h3>

<p>Norm Matloff
</p>


<h3>Examples</h3>

<pre><code class="language-R"># examples of addlists()
l1 &lt;- list(a=2, b=5, c=1)
l2 &lt;- list(a=8, c=12, d=28)
addlists(l1,l2,sum)  # list with a=10, b=5, c=13, d=28
z1 &lt;- list(x = c(5,12,13), y = c(3,4,5))
z2 &lt;- list(y = c(8,88))
addlists(z1,z2,c)  # list with x=(5,12,13), y=(3,4,5,8,88)

# need 'parallel' cluster for the remaining examples
cls &lt;- makeCluster(2)
setclsinfo(cls)

# check it
clusterEvalQ(cls,partoolsenv$myid)  # returns 1, 2
clusterEvalQ(cls,partoolsenv$ncls)  # returns 2, 2

# formrowchunks example; see up a matrix to be distributed first
m &lt;- rbind(1:2,3:4,5:6)
# apply the function
formrowchunks(cls,m,"mc")
# check results
clusterEvalQ(cls,mc)  # list of a 1x2 and a 2x2 matrix

matrixtolist(1,m)  # 3-component list, first is (1,2)

# test of of distribagg(): 
# form and distribute test data
x &lt;- sample(1:3,10,replace=TRUE)
y &lt;- sample(0:1,10,replace=TRUE)
u &lt;- runif(10)
v &lt;- runif(10)
d &lt;- data.frame(x,y,u,v)
distribsplit(cls,"d")
# check that it's there at the cluster nodes, in distributed form
clusterEvalQ(cls,d) 
d
# try the aggregation function
distribagg(cls,c("u","v"), c("x","y"),"d","max")
# check result
aggregate(cbind(u,v) ~ x+y,d,max)

# real data
mtc &lt;- mtcars
distribsplit(cls,"mtc")

distribagg(cls,c("mpg","disp","hp"),c("cyl","gear"),"mtc","max")
# check
aggregate(cbind(mpg,disp,hp) ~ cyl+gear,data=mtcars,FUN=max)

distribcounts(cls,c("cyl","gear"),"mtc")
# check
table(mtc$cyl,mtc$gear)

# find mean mpg, hp for each cyl/gear combination
distribmeans(cls,c('mpg','hp'),c('cyl','gear'),'mtc')

# extract and collect all the mtc rows in which the number of cylinders is 8
distribgetrows(cls,'mtc[mtc$cyl == 8,]')
# check
mtc[mtc$cyl == 8,]

# same for data.tables
mtc &lt;- as.data.table(mtc)
setkey(mtc,cyl)
distribsplit(cls,'mtc')
distribcounts(cls,c("cyl","gear"),"mtc")
distribmeans(cls,c('mpg','hp'),c('cyl','gear'),'mtc')

dwhich.min(cls,'mtc$mpg')  # smallest is at node 1, row 15
dwhich.max(cls,'mtc$mpg')  # largest is at node 2, row 4

stopCluster(cls)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>AUC.measures</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
AUC measures
</h2>

<h3>Description</h3>

<p>Set of functions to compute the Area Under the ROC Curve (AUC)
</p>


<h3>Usage</h3>

<pre><code class="language-R">AUC.single(pred, labels)
AUC.single.over.classes(target, predicted, g, root = "00")
AUC.n.single(pred, labels, n=50)
AUC.n.single.over.classes(target, predicted, g, n=50, root = "00")
compute.mean.AUC.single.over.classes(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>

<p>numeric vector (scores) of  the values  of the predicted labels
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>

<p>numeric vector of the true labels (0 negative, 1 positive examples)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>

<p>matrix with the target multilabels: rows correspond to examples and columns to classes.
target[i,j] = 1 if example i belongs to class j, target[i,j] = 0 otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predicted</code></td>
<td>

<p>a numeric matrix with predicted values (scores): rows correspond to examples and columns to classes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>

<p>a graph of class <em>graphNEL</em> (package <span class="pkg">graph</span>) of the classes. If g is missing no per.level results are computed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>number of negatives (def=50)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>root</code></td>
<td>

<p>the name of the root node (def. "00")
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>a list of lists. The components of the outer list is a list returned from the function <code>AUC.single.over.classes</code>
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>AUC.single</code> computes the AUC for a single class.
</p>
<p><code>AUC.single.over.classes</code> computes AUC for a set of classes, including their average values across classes and
the average values across the levels of the hierarchy (if any); level 1 classes are at distance 1 from the root,
level 2 the second level, till to last level correponding to the leaves. Note that if the argument g is missing no   per-level values are computed.
</p>
<p><code>AUC.n.single</code> computes the AUCn for a single class, i.e. the AUC by considering only the first n top ranked negatives, where n is the absolute
number of negative examples receiving the highest scores.
</p>
<p><code>AUC.n.single.over.classes</code> computes AUCn for a set of classes, including their average values across classes and
the average values across the levels of the hierarchy (if any); level 1 classes are at distance 1 from the root,
level 2 the second level, till to last level correponding to the leaves. Note that if the argument g is missing no   per-level values are computed.
</p>
<p><code>compute.mean.AUC.single.over.classes</code> compute means across folds of AUC.single.over.classes. It can be used to automatically computed average values (for each class, level, or average across classes) across folds.
</p>


<h3>Value</h3>

<p><code>AUC.single</code> returns a numeric value corresponding to the AUC.
</p>
<p><code>AUC.single.over.classes</code> returns  a list with three elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>- average </code></td>
<td>
<p>the average AUC across classes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>- per.level</code></td>
<td>
<p>a named vector with average  AUC for each level of the hierarchy; names correspond to levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>- per.class </code></td>
<td>
<p>a named vector with AUC for each class; names correspond to classes</p>
</td>
</tr>
</table>
<p><code>AUC.n.single</code> returns a numeric value corresponding to the AUCn.
</p>
<p><code>AUC.n.single.over.classes</code> returns  a list with three elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>- average </code></td>
<td>
<p>the average AUCn across classes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>- per.level</code></td>
<td>
<p>a named vector with average  AUCn for each level of the hierarchy; names correspond to levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>- per.class </code></td>
<td>
<p>a named vector with AUCn for each class; names correspond to classes</p>
</td>
</tr>
</table>
<p><code>compute.mean.AUC.single.over.classes</code> returns a list obtained by averaging the results across folds of the input y. 
The components are:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>- average </code></td>
<td>
<p>the average AUC across classes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>- per.level</code></td>
<td>
<p>a named vector with average  AUC for each level of the hierarchy; names correspond to levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>- per.class </code></td>
<td>
<p>a named vector with AUC for each class; names correspond to classes</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>F.measures</code>, <code>PXR</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># preparing pseudo.random scores and target-labels for examples: 100 examples
# and 10 classes
Scores &lt;- matrix(runif(1000),nrow=100);
Targets &lt;- matrix(integer(1000),nrow=100);
Targets[Scores&gt;0.5] &lt;- 1;
# adding noise to scores
Scores &lt;- Scores + matrix(rnorm(1000, sd=0.3),nrow=100);
colnames(Scores) &lt;-colnames(Targets) &lt;- LETTERS[1:10];
# getting scores and labels of class "A"
scores &lt;- Scores[,"A"];
labels &lt;- Targets[,"A"];
# AUC for a single class
AUC.single(scores,labels);
# AUC for the 10 classes
AUC.single.over.classes(Targets, Scores);
# AUCn for a single class considering only the first top scored negatives
AUC.n.single(scores,labels, n=20);
# AUCn for the 10 classes considering only the first top scored negatives
AUC.n.single.over.classes(Targets, Scores, n=20);
</code></pre>


</div>
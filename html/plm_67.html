<div class="container">

<table style="width: 100%;"><tr>
<td>is.pbalanced</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Check if data are balanced</h2>

<h3>Description</h3>

<p>This function checks if the data are balanced, i.e., if each individual has
the same time periods
</p>


<h3>Usage</h3>

<pre><code class="language-R">is.pbalanced(x, ...)

## Default S3 method:
is.pbalanced(x, y, ...)

## S3 method for class 'data.frame'
is.pbalanced(x, index = NULL, ...)

## S3 method for class 'pdata.frame'
is.pbalanced(x, ...)

## S3 method for class 'pseries'
is.pbalanced(x, ...)

## S3 method for class 'pggls'
is.pbalanced(x, ...)

## S3 method for class 'pcce'
is.pbalanced(x, ...)

## S3 method for class 'pmg'
is.pbalanced(x, ...)

## S3 method for class 'pgmm'
is.pbalanced(x, ...)

## S3 method for class 'panelmodel'
is.pbalanced(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>pdata.frame</code>, <code>data.frame</code>,
<code>pseries</code>, <code>panelmodel</code>, or <code>pgmm</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>(only in default method) the time index variable (2nd index
variable),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>only relevant for <code>data.frame</code> interface; if
<code>NULL</code>, the first two columns of the data.frame are
assumed to be the index variables; if not <code>NULL</code>, both
dimensions ('individual', 'time') need to be specified by
<code>index</code> as character of length 2 for data frames, for
further details see <code>pdata.frame()</code>,</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Balanced data are data for which each individual has the same time periods.
The returned values of the <code>is.pbalanced(object)</code> methods are identical
to <code>pdim(object)$balanced</code>.  <code>is.pbalanced</code> is provided as a short
cut and is faster than <code>pdim(object)$balanced</code> because it avoids those
computations performed by <code>pdim</code> which are unnecessary to determine the
balancedness of the data.
</p>


<h3>Value</h3>

<p>A logical indicating whether the data associated with
object <code>x</code> are balanced (<code>TRUE</code>) or not
(<code>FALSE</code>).
</p>


<h3>See Also</h3>

<p><code>punbalancedness()</code> for two measures of
unbalancedness, <code>make.pbalanced()</code> to make data
balanced; <code>is.pconsecutive()</code> to check if data are
consecutive; <code>make.pconsecutive()</code> to make data
consecutive (and, optionally, also balanced).<br><code>pdim()</code> to check the dimensions of a 'pdata.frame'
(and other objects), <code>pvar()</code> to check for individual
and time variation of a 'pdata.frame' (and other objects),
<code>pseries()</code>, <code>data.frame()</code>,
<code>pdata.frame()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# take balanced data and make it unbalanced
# by deletion of 2nd row (2nd time period for first individual)
data("Grunfeld", package = "plm")
Grunfeld_missing_period &lt;- Grunfeld[-2, ]
is.pbalanced(Grunfeld_missing_period)     # check if balanced: FALSE
pdim(Grunfeld_missing_period)$balanced    # same

# pdata.frame interface
pGrunfeld_missing_period &lt;- pdata.frame(Grunfeld_missing_period)
is.pbalanced(Grunfeld_missing_period)

# pseries interface
is.pbalanced(pGrunfeld_missing_period$inv)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>CompleteChannel-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class "CompleteChannel"</h2>

<h3>Description</h3>

<p>An object of the <code>CompleteChannel</code> class represents one channel (red or
green) of a two-color fluorescence microarray experiment. Alternatively,
it can also represent the entirety of a radioactive microarray experiment.
Affymetrix experiments produce data with a somewhat different structure
because they use multiple probes for each target gene.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CompleteChannel(name, type, data)
## S4 method for signature 'CompleteChannel'
print(x, ...)
## S4 method for signature 'CompleteChannel'
show(object)
## S4 method for signature 'CompleteChannel'
summary(object, ...)
## S4 method for signature 'CompleteChannel'
as.data.frame(x, row.names=NULL, optional=FALSE)
## S4 method for signature 'CompleteChannel,missing'
plot(x, main=x@name, useLog=FALSE, ...)
## S4 method for signature 'CompleteChannel'
image(x, ...)
## S4 method for signature 'CompleteChannel'
analyze(object, useLog=FALSE, ...)
## S4 method for signature 'CompleteChannel,Processor'
process(object, action, parameter)
## S4 method for signature 'CompleteChannel'
channelize(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>character string specifying the name of the object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>object of class <code>ChannelType</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data frame. For the pre-defined “extraction”
processors to work correctly, this should include columns called
<code>vol</code>, <code>bkgd</code>, <code>svol</code>, <code>SD</code>, and <code>SN</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>CompleteChannel</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>object of class <code>CompleteChannel</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>character string specifying the title for the plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useLog</code></td>
<td>
<p>logical scalar. If <code>TRUE</code>, convert to logarithmic values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>action</code></td>
<td>
<p>object of class <code>Processor</code> used to process a
<code>CompleteChannel</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter</code></td>
<td>
<p>any object that makes sense as a parameter to the
function represented by the <code>Processor</code> <code>action</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p>See <code>as.data.frame</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optional</code></td>
<td>
<p>See <code>as.data.frame</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The names come from the default column names in the ArrayVision software
package used at M.D. Anderson for quantifying glass or nylon microarrays.
Column names used by other software packages should be mapped to these.
</p>


<h3>Value</h3>

<p>The <code>analyze</code> method returns a list of three density functions.
</p>
<p>The return value of the <code>process</code> function depends on the
<code>Processor</code> performing the action, but is typically a
<code>Channel</code> object.
</p>
<p>Graphical methods invisibly return the object on which they were
invoked. 
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>name</code>:</dt>
<dd>
<p>character string containing the name of the object</p>
</dd>
<dt>
<code>type</code>:</dt>
<dd>
<p>object of class <code>ChannelType</code></p>
</dd>
<dt>
<code>data</code>:</dt>
<dd>
<p>data frame</p>
</dd>
<dt>
<code>history</code>:</dt>
<dd>
<p>list that keeps a record of the calls used
to produce this object</p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt>print(x, ...)</dt>
<dd>
<p>Print all the data on the object. Since
this includes the data frame, you rarely want to do this.</p>
</dd>
<dt>show(object)</dt>
<dd>
<p>Print all the data on the object. Since
this includes the data frame, you rarely want to do this.</p>
</dd>
<dt>summary(object, ...)</dt>
<dd>
<p>Write out a summary of the object.</p>
</dd>
<dt>as.data.frame(x,row.names=NULL, optional=FALSE)</dt>
<dd>
<p>Convert the
<code>CompleteChannel</code> object into a data frame. As you might
expect, this simply returns the data frame in the <code>data</code> slot
of the object.</p>
</dd>
<dt>plot(x, useLog=FALSE, ...)</dt>
<dd>
<p>Produces three estimated density
plots: one for the signal, one for the background, and one for
the background-corrected signal. Additional graphical parameters
are passed along. The logical flag <code>useLog</code> determines
whether the data are log-transformed before estimating and
plotting densities.</p>
</dd> 
<dt>analyze(object, useLog=FALSE, ...)</dt>
<dd>
<p>This method computes the
estimated probability density functions for the three data
components (signal, background, and background-corrected signal),
and returns them as a list. </p>
</dd>
<dt>image(object, ...)</dt>
<dd>
<p>Uses the image method for
<code>Channel</code> objects to produce geographically aligned
images of the log-transformed intensity and background estimates.</p>
</dd>
<dt>channelize(object, ...)</dt>
<dd>
<p>character string giving the name of the
class of a channel that is produced when you process a
<code>CompleteChannel</code> object.</p>
</dd>
<dt>process(object, action, parameter=NULL)</dt>
<dd>
<p>Use the
<code>Processor</code> <code>action</code> to process the
<code>CompleteChannel</code> <code>object</code>. Returns an object of the
class described by <code>channelize</code>, which defaults to
<code>Channel</code>.</p>
</dd>
</dl>
<h3>Pre-defined Processors</h3>

<p>The library comes with several <code>Processor</code> objects already
defined; each one takes a <code>CompleteChannel</code> as input, extracts a
single value per spot, and produces a <code>Channel</code> as output.
</p>

<dl>
<dt><code>PROC.BACKGROUND</code></dt>
<dd>
<p>Extract the vector of local
background measurements.</p>
</dd>
<dt><code>PROC.SIGNAL</code></dt>
<dd>
<p>Extract the vector of foreground signal
intensity measurements. </p>
</dd>
<dt><code>PROC.CORRECTED.SIGNAL</code></dt>
<dd>
<p>Extract the vector of
background-corrected signal measurements. Note that many software
packages automatically truncate these value below at zero, so this
need not be the same as SIGNAL - BACKGROUND.</p>
</dd>
<dt><code>PROC.NEG.CORRECTED.SIGNAL</code></dt>
<dd>
<p>Extract the vector of
background-corrected signal intensities by subtracting the local
background from the observed foreground, without truncation.</p>
</dd>
<dt><code>PROC.SD.SIGNAL</code></dt>
<dd>
<p>Extract the vector of pixel standard
deviations of the signal intensity.</p>
</dd>
<dt><code>PROC.SIGNAL.TO.NOISE</code></dt>
<dd>
<p>Extract the vector of
signal-to-noise ratios, defined as CORRECTED.SIGNAL divided by the
standard deviation of the background pixels.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
P. Roebuck <a href="mailto:proebuck@mdanderson.org">proebuck@mdanderson.org</a>
</p>


<h3>See Also</h3>

<p><code>process</code>,
<code>Processor</code>,
<code>Pipeline</code>,
<code>Channel</code>,
<code>as.data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">showClass("CompleteChannel")

## simulate a complete channel object
v &lt;- rexp(10000, 1/1000)
b &lt;- rnorm(10000, 60, 6)
s &lt;- sapply(v-b, function(x) {max(0, x)})
ct &lt;- ChannelType('user', 'random', 100, 100, 'fake')
x &lt;- CompleteChannel(name='fraud', type=ct,
                      data=data.frame(vol=v, bkgd=b, svol=s))
rm(v, b, s, ct)

summary(x)

opar &lt;- par(mfrow=c(2,3))
plot(x)
plot(x, main='Log Scale', useLog=TRUE)
par(opar)

opar &lt;- par(mfrow=c(2,1))
image(x)
par(opar)

b &lt;- process(x, PROC.NEG.CORRECTED.SIGNAL)
summary(b)

q &lt;- process(b, PIPELINE.STANDARD)
summary(q)

q &lt;- process(x, PIPELINE.MDACC.DEFAULT)
summary(q)

## cleanup
rm(x, b, q, opar)
</code></pre>


</div>
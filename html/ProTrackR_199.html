<div class="container">

<table style="width: 100%;"><tr>
<td>read.sample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Read an audio file and coerce to a PTSample object</h2>

<h3>Description</h3>

<p>Reads audio files from "wav" and "mp3" files, using <code>tuneR::tuneR</code>
methods. Commodore Amiga native formats "8svx" and "raw" can also be read.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'character'
read.sample(filename, what = c("wav", "mp3", "8svx", "raw"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>A <code>character</code> string representing the filename to be read.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>A <code>character</code> string indicating what type of file is to be
read. Can be one of the following: <code>"wav"</code> (default), <code>"mp3"</code>,
<code>"8svx"</code> or <code>"raw"</code>. The <code>AmigaFFH</code> package needs to be
installed in order to read 8svx files.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This method provides a wrapper for the <code>tuneR::readWave</code> and
<code>tuneR::readMP3</code> methods from <code>tuneR::tuneR</code>. It also
provides the means to import audio from file formats native to the Commodore
Amiga. Simple <a href="https://en.wikipedia.org/wiki/8SVX">8svx</a> files (also known
as "iff" files) can be read. This uses the <code>AmigaFFH::read.iff</code> method
from the <code>AmigaFFH::AmigaFFH</code> package.
It was also common practice to store audio samples as raw data on the
Commodore Amiga, where each byte simply represented a signed integer value
of the waveform.
</p>
<p>All audio will be coerced to 8 bit mono with a maximum length of
<code>2*0xffff</code> = <code>131070</code> bytes (= samples) as per ProTracker standards.
</p>


<h3>Value</h3>

<p>Returns a <code>PTSample</code> object based on the file read.
</p>


<h3>Note</h3>

<p>As per ProTracker standards, a sample should have an even length
(in bytes). If a sample file has an odd length, a <code>raw</code> <code>0x00</code> value
is added to the end.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other sample.operations: 
<code>PTSample-class</code>,
<code>PTSample-method</code>,
<code>fineTune()</code>,
<code>loopLength()</code>,
<code>loopSample()</code>,
<code>loopStart()</code>,
<code>loopState()</code>,
<code>name</code>,
<code>playSample()</code>,
<code>sampleLength()</code>,
<code>volume()</code>,
<code>waveform()</code>,
<code>write.sample()</code>
</p>
<p>Other io.operations: 
<code>read.module()</code>,
<code>write.module()</code>,
<code>write.sample()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data("mod.intro")

## create an audio file which we can then read:
write.sample(PTSample(mod.intro, 2), "snaredrum.iff", "8svx")

## read the created sample:
snare &lt;- read.sample("snaredrum.iff", "8svx")
print(snare)

## End(Not run)

</code></pre>


</div>
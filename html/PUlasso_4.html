<div class="container">

<table style="width: 100%;"><tr>
<td>grpPUlasso</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solve PU problem with lasso or group lasso penalty.</h2>

<h3>Description</h3>

<p>Fit a model using PUlasso algorithm over a regularization path. The regularization path is computed at a grid of values for the regularization parameter lambda.
</p>


<h3>Usage</h3>

<pre><code class="language-R">grpPUlasso(
  X,
  z,
  py1,
  initial_coef = NULL,
  group = 1:ncol(X),
  penalty = NULL,
  lambda = NULL,
  nlambda = 100,
  lambdaMinRatio = ifelse(N &lt; p, 0.05, 0.005),
  maxit = ifelse(method == "CD", 1000, N * 10),
  maxit_inner = 1e+05,
  weights = NULL,
  eps = 1e-04,
  inner_eps = 0.01,
  verbose = FALSE,
  stepSize = NULL,
  stepSizeAdjustment = NULL,
  batchSize = 1,
  updateFrequency = N,
  samplingProbabilities = NULL,
  method = c("CD", "GD", "SGD", "SVRG", "SAG"),
  trace = c("none", "param", "fVal", "all")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Input matrix; each row is an observation. Can be a matrix or a sparse matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>Response vector representing whether an observation is labeled or unlabeled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>py1</code></td>
<td>
<p>True prevalence Pr(Y=1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_coef</code></td>
<td>
<p>A vector representing an initial point where we start PUlasso algorithm from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>A vector representing grouping of the coefficients. For the least ambiguity, it is recommended if group is provided in the form of vector of consecutive ascending integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>penalty to be applied to the model. Default is sqrt(group size) for each of the group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied sequence of lambda values. If unspecified, the function automatically generates its own lambda sequence based on nlambda and lambdaMinRatio.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of lambda values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaMinRatio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of lambda.max which leads to the intercept only model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit_inner</code></td>
<td>
<p>Maximum number of iterations for a quadratic sub-problem for CD.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>observation weights. Default is 1 for each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Convergence threshold for the outer loop. The algorithm iterates until the maximum change in coefficients is less than eps in the outer loop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inner_eps</code></td>
<td>
<p>Convergence threshold for the inner loop. The algorithm iterates until the maximum change in coefficients is less than eps in the inner loop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical value. if TRUE, the function prints out the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepSize</code></td>
<td>
<p>A step size for gradient-based optimization. if NULL, a step size is taken to be stepSizeAdj/mean(Li) where Li is a Lipschitz constant for ith sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepSizeAdjustment</code></td>
<td>
<p>A step size adjustment. By default, adjustment is 1 for GD and SGD, 1/8 for SVRG and 1/16 for SAG.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batchSize</code></td>
<td>
<p>A batch size. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>updateFrequency</code></td>
<td>
<p>An update frequency of full gradient for method =="SVRG"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplingProbabilities</code></td>
<td>
<p>sampling probabilities for each of samples for stochastic gradient-based optimization. if NULL, each sample is chosen proportionally to Li.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Optimization method. Default is Coordinate Descent. CD for Coordinate Descent, GD for Gradient Descent, SGD for Stochastic Gradient Descent, SVRG for Stochastic Variance Reduction Gradient, SAG for Stochastic Averaging Gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>An option for saving intermediate quantities. All intermediate standardized-scale parameter estimates(trace=="param"), objective function values at each iteration(trace=="fVal"), or both(trace=="all") are saved in optResult. Since this is computationally very heavy, it should be only used for decently small-sized dataset and small maxit. A default is "none".</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>coef A p by length(lambda) matrix of coefficients
</p>
<p>std_coef A p by length(lambda) matrix of coefficients in a standardized scale
</p>
<p>lambda The actual sequence of lambda values used.
</p>
<p>nullDev Null deviance defined to be 2*(logLik_sat -logLik_null)
</p>
<p>deviance Deviance defined to be 2*(logLik_sat -logLik(model))
</p>
<p>optResult A list containing the result of the optimization. fValues, subGradients contain objective function values and subgradient vectors at each lambda value. If trace = TRUE, corresponding intermediate quantities are saved as well.
</p>
<p>iters Number of iterations(EM updates) if method = "CD". Number of steps taken otherwise.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("simulPU")
fit&lt;-grpPUlasso(X=simulPU$X,z=simulPU$z,py1=simulPU$truePY1)
</code></pre>


</div>
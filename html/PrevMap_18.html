<div class="container">

<table style="width: 100%;"><tr>
<td>discrete.sample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatially discrete sampling</h2>

<h3>Description</h3>

<p>Draws a sub-sample from a set of units spatially located irregularly over some defined geographical region by imposing a minimum distance between any two sampled units.
</p>


<h3>Usage</h3>

<pre><code class="language-R">discrete.sample(xy.all, n, delta, k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xy.all</code></td>
<td>
<p>set of locations from which the sample will be drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>size of required sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>minimum distance between any two locations in preliminary sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of locations in preliminary sample to be replaced by nearest neighbours of other preliminary sample locations in final sample (must be between 0 and <code>n/2</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To draw a sample of size <code>n</code>  from a population of spatial locations <code class="reqn">X_{i}  : i  = 1,\ldots,N</code>, with the property that the distance between any two sampled locations is at least <code>delta</code>, the function implements the following algorithm.
</p>

<ul>
<li>
<p>Step 1. Draw an initial sample of size <code>n</code>  completely at random and call this <code class="reqn">x_{i}  : i  = 1,\dots, n</code>.
</p>
</li>
<li>
<p>Step 2. Set <code class="reqn">i  = 1</code> and calculate the minimum, <code class="reqn">d_{\min}</code>, of the distances from <code class="reqn">x_{i}</code>  to all other <code class="reqn">x_{j}</code>  in the initial sample.
</p>
</li>
<li>
<p>Step 3. If <code class="reqn">d_{\min} \ge \delta</code>, increase <code class="reqn">i</code>  by 1 and return to step 2 if <code class="reqn">i \le n</code>, otherwise stop.
</p>
</li>
<li>
<p>Step 4. If <code class="reqn">d_{\min} &lt; \delta</code>, draw an integer <code class="reqn">j</code>  at random from <code class="reqn">1,  2,\ldots,N</code>, set <code class="reqn">x_{i}  = X_{j}</code>  and return to step 3.
</p>
</li>
</ul>
<p>Samples generated in this way will exhibit a more regular spatial arrangement than would a random sample of the same size. The degree of regularity achievable will be influenced by the spatial arrangement of the population <code class="reqn">X_{i}  : i  = 1,\ldots,N</code>, the specified value of <code>delta</code>  and the sample size <code>n</code>. For any given population, if <code>n</code>  and/or <code>delta</code>  are too large, a sample of the required size with the distance between any two sampled locations at least <code>delta</code> will not be achievable; the suggested solution is then to run the algorithm with a smaller value of <code>delta</code>.
</p>
<p><b>Sampling close pairs of points</b>.
For some purposes, it is desirable that a spatial sampling scheme include pairs of closely spaced points. In this case, the above algorithm requires the following additional steps to be taken.
Let <code>k</code>  be the required number of close pairs.
</p>

<ul>
<li>
<p>Step 5. Set <code class="reqn">j  = 1</code> and draw a random sample of size 2 from the integers <code class="reqn">1,  2,\ldots,n</code>, say <code class="reqn">(i_{1}, i_{2} )</code>.
</p>
</li>
<li>
<p>Step 6. Find the integer <code class="reqn">r</code>  such that the distances from <code class="reqn">x_{i_{1}}</code>  to <code class="reqn">X_{r}</code> is the minimum of all <code class="reqn">N-1</code> distances from <code class="reqn">x_{i_{1}}</code>  to the <code class="reqn">X_{j}</code>.
</p>
</li>
<li>
<p>Step 7.  Replace <code class="reqn">x_{i_{2}}</code>  by <code class="reqn">X_{r}</code>, increase <code class="reqn">i</code>  by 1 and return to step 5 if <code class="reqn">i \le k</code>, otherwise stop.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A matrix of dimension <code>n</code> by 2 containing the final sampled locations.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x&lt;-0.015+0.03*(1:33)
xall&lt;-rep(x,33)
yall&lt;-c(t(matrix(xall,33,33)))
xy&lt;-cbind(xall,yall)+matrix(-0.0075+0.015*runif(33*33*2),33*33,2)
par(pty="s",mfrow=c(1,2))
plot(xy[,1],xy[,2],pch=19,cex=0.25,xlab="Easting",ylab="Northing",
   cex.lab=1,cex.axis=1,cex.main=1)

set.seed(15892)
# Generate spatially random sample
xy.sample&lt;-xy[sample(1:dim(xy)[1],50,replace=FALSE),]
points(xy.sample[,1],xy.sample[,2],pch=19,col="red")
points(xy[,1],xy[,2],pch=19,cex=0.25)
plot(xy[,1],xy[,2],pch=19,cex=0.25,xlab="Easting",ylab="Northing",
   cex.lab=1,cex.axis=1,cex.main=1)

set.seed(15892)
# Generate spatially regular sample
xy.sample&lt;-discrete.sample(xy,50,0.08)
points(xy.sample[,1],xy.sample[,2],pch=19,col="red")
points(xy[,1],xy[,2],pch=19,cex=0.25)

</code></pre>


</div>
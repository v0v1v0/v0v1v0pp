<div class="container">

<table style="width: 100%;"><tr>
<td>nodeDates2branchLengths</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Obtaining Edge Lengths for Undated Phylogenies Using Known Branching Node and Tip Ages</h2>

<h3>Description</h3>

<p>This function takes some undated phylogenetic topology, a set of ages in
absolute time, for the internal nodes and (by default) the terminal tips
of that phylogeny,  and returns a dated phylogeny consistent with those input ages.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nodeDates2branchLengths(nodeDates, tree, allTipsModern = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>nodeDates</code></td>
<td>
<p>Under default <code>allTipsModern = FALSE</code> conditions,
<code>nodeDates</code> should be a vector of length <code>Ntip(tree) + Nnode(tree)</code>
which contains the dates for all terminal tip nodes and internal nodes for
the tree, in that order, as numbered in the <code>tree$edge</code> matrix. Such
a vector is produced as output by <code>dateNodes</code>. If <code>allTipsModern = TRUE</code>,
then the vector should only be as long as the number of nodes,
and contain the dates only for those same internal nodes in <code>tree</code>. 
These dates should always on a descending scale (i.e. time before present), with respect to an
absolute time-scale. It is possible for the time 0 date to represent
a date far in the future from the latest tip.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>
<p>An undated phylogeny object, of class <code>phylo</code>, lacking edge lengths.
If the tree appears to be dated (i.e. has edge lengths), the function will issue a warning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allTipsModern</code></td>
<td>
<p>A logical, default is <code>FALSE</code>. If <code>FALSE</code>,
then the function expects <code>nodeDates</code> to contain ages for all
'nodes' - both internal branching nodes and terminal tips. If <code>TRUE</code>, then
the function will expect <code>nodeDates</code> to contain ages only for internal
branching nodes, and all tips will be assumed to be at time 0. (Thus, if your
tree is ultrametric but tips aren't all at the modern, do <em>not</em>
use <code>allTipsModern = TRUE</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>compute.brtime</code> in package <code>ape</code> does
a very similar functionality, but is limited in its application for
only ultrametric trees, as it does not allow for tips to have
incongruent ages. It also only accepts node ages as on the relative
scale where the latest tips are at zero, as assumed in general
elsewhere in package <code>ape</code>.
</p>


<h3>Value</h3>

<p>A dated tree as a list of class <code>phylo</code>, with a <code>$root.time</code>
element for referencing the tree against absolute time.
</p>


<h3>Author(s)</h3>

<p>David W. Bapst
</p>


<h3>See Also</h3>

<p>This function will likely often be used in conjunction with
<code>dateNodes</code>, such as for summarizing node and tip age
estimates from a sample of trees, to produce a single dated tree
to act as a point estimate. Beware however that point estimates of
tree samples may have little resemblance to any individual tree in that sample.
</p>
<p>This function should perform identically for ultrametric trees as package 
<code>ape</code>'s function <code>compute.brtime</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(444)

# we'll do a number of tests, let's check at the end that all are TRUE
tests &lt;- logical()

# with a non-ultrametric tree
chrono &lt;- rtree(10)
# make an undated tree
notChrono &lt;- chrono
notChrono$edge.length &lt;- NULL

# now lets try with dateNodes in paleotree
nodeTimes &lt;- dateNodes(chrono)
# need to use allTipsModern = FALSE because tip ages are included
chronoRedux &lt;-  nodeDates2branchLengths(tree = notChrono,
    nodeDates = nodeTimes, allTipsModern = FALSE)
# test that its the same
(tests &lt;- c(tests,all.equal.numeric(chrono$edge.length,chronoRedux$edge.length)))

######################################
# modern ultrametric tree
chrono &lt;- rcoal(10)
# make an undated tree
notChrono &lt;- chrono
notChrono$edge.length &lt;- NULL

# with ultrametric trees, you could just use ape's compute.brtime 

# getting branching times with ape
branchingTimes &lt;- branching.times(chrono)	
# setting those branching times with ape
chronoRedux &lt;-  compute.brtime(notChrono, branchingTimes)
# test that its the same
(tests &lt;- c(tests,all.equal.numeric(chrono$edge.length,chronoRedux$edge.length)))

# lets do the same thing but with nodeDates2branchLengths

# can use branching.times from ape 
	# (but only for ultrametric trees!)
chronoRedux &lt;-  nodeDates2branchLengths(tree = notChrono,
    nodeDates = branchingTimes, allTipsModern = TRUE)
# test that its the same
(tests &lt;- c(tests,all.equal.numeric(chrono$edge.length,chronoRedux$edge.length)))

# now lets try with dateNodes in paleotree
nodeTimes &lt;- dateNodes(chrono)
# need to use allTipsModern = FALSE because tip ages are included
chronoRedux &lt;-  nodeDates2branchLengths(tree = notChrono,
    nodeDates = nodeTimes, allTipsModern = FALSE)
# test that its the same
(tests &lt;- c(tests,all.equal.numeric(chrono$edge.length,chronoRedux$edge.length)))

# get just the node times (remove tip dates)
nodeOnlyTimes &lt;- nodeTimes[-(1:Ntip(chrono))]
# let's use the allTipsModern = TRUE setting
chronoRedux &lt;-  nodeDates2branchLengths(tree = notChrono,
    nodeDates = nodeOnlyTimes, allTipsModern = TRUE)
# test that its the same
(tests &lt;- c(tests,all.equal.numeric(chrono$edge.length,chronoRedux$edge.length)))

# did all tests come out as TRUE?
if(!all(tests)){stop("nodeDates2branchLengths isn't functioning correctly")}

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>stouffer</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Stouffer's Method</h2>

<h3>Description</h3>

<p>Function to carry out Stouffer's method.<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></p>


<h3>Usage</h3>

<pre><code class="language-R">stouffer(p, adjust = "none", R, m,
         size = 10000, threshold, side = 2, batchsize, nearpd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>vector of length \(k\) with the (one- or two-sided) p-values to be combined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust</code></td>
<td>
<p>character string to specify an adjustment method to account for dependence. The default is <code>"none"</code>, in which case no adjustment is applied. Methods <code>"nyholt"</code>, <code>"liji"</code>, <code>"gao"</code>, or <code>"galwey"</code> are adjustments based on an estimate of the effective number of tests (see <code>meff</code>). Adjustment method <code>"empirical"</code> uses an empirically-derived null distribution using pseudo replicates. Finally, method <code>"generalized"</code> uses a generalization of Stouffer's method based on multivariate theory. See ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>a \(k \times k\) symmetric matrix that reflects the dependence structure among the tests. Must be specified if <code>adjust</code> is set to something other than <code>"none"</code>. See ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>optional scalar (between 1 and \(k\)) to manually specify the effective number of tests (instead of estimating it via one of the methods described above).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>size of the empirically-derived null distribution. Can also be a numeric vector of sizes, in which case a stepwise algorithm is used. This (and the following arguments) are only relevant when <code>adjust = "empirical"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>numeric vector to specify the significance thresholds for the stepwise algorithm (only relevant when <code>size</code> is a vector).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>side</code></td>
<td>
<p>scalar to specify the sidedness of the \(p\)-values that are used to simulate the null distribution (2, by default, for two-sided tests; 1 for one-sided tests).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batchsize</code></td>
<td>
<p>optional scalar to specify the batch size for generating the null distribution. When unspecified (the default), this is done in a single batch.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nearpd</code></td>
<td>
<p>logical indicating if a negative definite <code>R</code> matrix should be turned into the nearest positive definite matrix (only relevant when <code>adjust = "empirical"</code> or <code>adjust = "generalized"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><b>Stouffer's Method</b>
</p>
<p>By default (i.e., when <code>adjust = "none"</code>), the function applies Stouffer's method to the \(p\)-values (Stouffer et al., 1949). Letting \(p_1, p_2, \ldots, p_k\) denote the individual (one- or two-sided) \(p\)-values of the \(k\) hypothesis tests to be combined, the test statistic is then computed with \[z = \sum_{i = 1}^k z_i / \sqrt{k}\] where \(z_i = \Phi^{-1}(1 - p_i)\) and \(\Phi^{-1}(\cdot)\) denotes the inverse of the cumulative distribution function of a standard normal distribution. Under the joint null hypothesis, the test statistic follows a standard normal distibution which is used to compute the combined \(p\)-value.
</p>
<p>Stouffer's method assumes that the \(p\)-values to be combined are independent. If this is not the case, the method can either be conservative (not reject often enough) or liberal (reject too often), depending on the dependence structure among the tests. In this case, one can adjust the method to account for such dependence (to bring the Type I error rate closer to some desired nominal significance level).
</p>
<p><b>Adjustment Based on the Effective Number of Tests</b>
</p>
<p>When <code>adjust</code> is set to <code>"nyholt"</code>, <code>"liji"</code>, <code>"gao"</code> or <code>"galwey"</code>, Stouffer's method is adjusted based on an estimate of the effective number of tests (see <code>meff</code> for details on these methods for estimating the effective number of tests). In this case, argument <code>R</code> needs to be set to a matrix that reflects the dependence structure among the tests.
</p>
<p>There is no general solution for constructing such a matrix, as this depends on the type of test that generated the \(p\)-values and the sidedness of these tests. If the \(p\)-values are obtained from tests whose test statistics can be assumed to follow a multivariate normal distribution and a matrix is available that reflects the correlations among the test statistics, then the <code>mvnconv</code> function can be used to convert this correlation matrix into the correlations among the (one- or two-sided) \(p\)-values, which can then be passed to the <code>R</code> argument. See ‘Examples’.
</p>
<p>Once the effective number of tests, \(m\), is estimated based on <code>R</code> using one of the four methods described above, the test statistic of Stouffer's method can be modified with \[\tilde{z} = \sqrt{\frac{m}{k}} \times z\] which is then assumed to follow a standard normal distibution.
</p>
<p>Alternatively, one can also directly specify the effective number of tests via the <code>m</code> argument (e.g., if some other method not implemented in the <span class="pkg">poolr</span> package is used to estimate the effective number of tests). Argument <code>R</code> is then irrelevant and doesn't need to be specified.
</p>
<p><b>Adjustment Based on an Empirically-Derived Null Distribution</b>
</p>
<p>When <code>adjust = "empirical"</code>, the combined \(p\)-value is computed based on an empirically-derived null distribution using pseudo replicates (using the <code>empirical</code> function). This is appropriate if the test statistics that generated the \(p\)-values to be combined can be assumed to follow a multivariate normal distribution and a matrix is available that reflects the correlations among the test statistics (which is specified via the <code>R</code> argument). In this case, test statistics are repeatedly simulated from a multivariate normal distribution under the joint null hypothesis, converted into one- or two-sided \(p\)-values (depending on the <code>side</code> argument), and Stouffer's method is applied. Repeating this process <code>size</code> times yields a null distribution based on which the combined \(p\)-value can be computed, or more precisely, estimated, since repeated applications of this method will yield (slightly) different results. To obtain a stable estimate of the combined \(p\)-value, <code>size</code> should be set to a large value (the default is <code>10000</code>, but this can be increased for a more precise estimate). If we consider the combined \(p\)-value an estimate of the ‘true’ combined \(p\)-value that would be obtained for a null distribution of infinite size, we can also construct a 95% (pseudo) confidence interval based on a binomial distribution.
</p>
<p>If <code>batchsize</code> is unspecified, the null distribution is simulated in a single batch, which requires temporarily storing a matrix with dimensions <code>[size,k]</code>. When <code>size*k</code> is large, allocating the memory for this matrix might not be possible. Instead, one can specify a <code>batchsize</code> value, in which case a matrix with dimensions <code>[batchsize,k]</code> is repeatedly simulated until the desired size of the null distribution has been obtained.
</p>
<p>One can also specify a vector for the <code>size</code> argument, in which case one must also specify a corresponding vector for the <code>threshold</code> argument. In that case, a stepwise algorithm is used that proceeds as follows. For <code>j = 1, ..., length(size)</code>,
</p>

<ol>
<li>
<p> estimate the combined \(p\)-value based on <code>size[j]</code>
</p>
</li>
<li>
<p> if the combined \(p\)-value is \(\ge\) than <code>threshold[j]</code>, stop (and report the combined \(p\)-value), otherwise go back to 1.
</p>
</li>
</ol>
<p>By setting <code>size</code> to increasing values (e.g., <code>size = c(1000, 10000, 100000)</code>) and <code>threshold</code> to decreasing values (e.g., <code>threshold = c(.10, .01, 0)</code>), one can quickly obtain a fairly accurate estimate of the combined \(p\)-value if it is far from significant (e.g., \(\ge\) .10), but hone in on a more accurate estimate for a combined \(p\)-value that is closer to 0. Note that the last value of <code>threshold</code> should be 0 (and is forced to be inside of the function), so that the algorithm is guaranteed to terminate (hence, one can also leave out the last value of <code>threshold</code>, so <code>threshold = c(.10, .01)</code> would also work in the example above). One can also specify a single <code>threshold</code> (which is replicated as often as necessary depending on the length of <code>size</code>).
</p>
<p><b>Adjustment Based on Multivariate Theory</b>
</p>
<p>When <code>adjust = "generalized"</code>, Stouffer's method is computed based on a multivariate normal distribution that accounts for the dependence among the tests, assuming that the test statistics that generated the \(p\)-values follow a multivariate normal distribution. In that case, <code>R</code> needs to be set equal to a matrix that contains the covariances among the \(z_i\) values. If a matrix is available that reflects the correlations among the test statistics, this can be converted into the required covariance matrix using the <code>mvnconv</code> function. See ‘Examples’.
</p>
<p>This generalization of Stouffer's method is sometimes called Strube's method, based on Strube (1986), although the paper only describes the method for combining one-sided \(p\)-values. Both one- and two-sided versions of Strube's method are implemented in <span class="pkg">poolr</span>, but caution must be exercised when applying it to two-sided \(p\)-values (even if the test statistics follow a multivariate normal distribution, \([z_1, z_2, \ldots, z_k]\) is then not multivariate normal, but this is implicitly assumed by the method).
</p>


<h3>Value</h3>

<p>An object of class <code>"poolr"</code>. The object is a list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>combined \(p\)-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>confidence interval for the combined \(p\)-value (only when <code>adjust = "empirical"</code>; otherwise <code>NULL</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of \(p\)-values that were combined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>estimate of the effective number of tests (only when <code>adjust</code> is one of <code>"nyholt"</code>, <code>"liji"</code>, <code>"gao"</code> or <code>"galwey"</code>; otherwise <code>NULL</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust</code></td>
<td>
<p>chosen adjustment method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>value of the (adjusted) test statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>name of calling function.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The methods underlying <code>adjust = "empirical"</code> and <code>adjust = "generalized"</code> assume that the test statistics that generated the \(p\)-values to be combined follow a multivariate normal distribution. Hence, the matrix specified via <code>R</code> must be positive definite. If it is not and <code>nearpd = TRUE</code>, it will be turned into one (based on Higham, 2002, and a slightly simplified version of <code>nearPD</code> from the <span class="pkg">Matrix</span> package).
</p>


<h3>Author(s)</h3>

<p>Ozan Cinar <a href="mailto:ozancinar86@gmail.com">ozancinar86@gmail.com</a> <br>
Wolfgang Viechtbauer <a href="mailto:wvb@wvbauer.com">wvb@wvbauer.com</a> <br></p>


<h3>References</h3>

<p>Cinar, O. &amp; Viechtbauer, W. (2022). The poolr package for combining independent and dependent p values. <em>Journal of Statistical Software</em>, <b>101</b>(1), 1–42. <code style="white-space: pre;">⁠https://doi.org/10.18637/jss.v101.i01⁠</code>
</p>
<p>Higham, N. J. (2002). Computing the nearest correlation matrix: A problem from finance. <em>IMA Journal of Numerical Analysis, 22</em>(3), 329–343.
</p>
<p>Stouffer, S. A., Suchman, E. A., DeVinney, L. C., Star, S. A., &amp; Williams, R. M., Jr. (1949). <em>The American Soldier: Adjustment During Army Life (Vol. 1)</em>. Princeton, NJ: Princeton University Press.
</p>
<p>Strube, M. J. (1985). Combining and comparing significance levels from nonindependent hypothesis tests. <em>Psychological Bulletin, 97</em>(2), 334–341.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># copy p-values and LD correlation matrix into p and r
# (see help(grid2ip) for details on these data)
p &lt;- grid2ip.p
r &lt;- grid2ip.ld

# apply Stouffer's method
stouffer(p)

# use mvnconv() to convert the LD correlation matrix into a matrix with the
# correlations among the (two-sided) p-values assuming that the test
# statistics follow a multivariate normal distribution with correlation
# matrix r (note: 'side = 2' by default in mvnconv())
mvnconv(r, target = "p", cov2cor = TRUE)[1:5,1:5] # show only rows/columns 1-5

# adjustment based on estimates of the effective number of tests
stouffer(p, adjust = "nyholt", R = mvnconv(r, target = "p", cov2cor = TRUE))
stouffer(p, adjust = "liji",   R = mvnconv(r, target = "p", cov2cor = TRUE))
stouffer(p, adjust = "gao",    R = mvnconv(r, target = "p", cov2cor = TRUE))
stouffer(p, adjust = "galwey", R = mvnconv(r, target = "p", cov2cor = TRUE))

# setting argument 'm' manually
stouffer(p, m = 12)

# adjustment based on an empirically-derived null distribution (setting the
# seed for reproducibility)
set.seed(1234)
stouffer(p, adjust = "empirical", R = r)

# generate the empirical distribution in batches of size 100
stouffer(p, adjust = "empirical", R = r, batchsize = 100)

# using the stepwise algorithm
stouffer(p, adjust = "empirical", R = r, size = c(1000, 10000, 100000), threshold = c(.10, .01))

# use mvnconv() to convert the LD correlation matrix into a matrix with the
# covariances among the (two-sided) 'z_i' values assuming that the
# test statistics follow a multivariate normal distribution with correlation
# matrix r (note: 'side = 2' by default in mvnconv())
mvnconv(r, target = "z")[1:5,1:5] # show only rows/columns 1-5

# adjustment based on generalized method
stouffer(p, adjust = "generalized", R = mvnconv(r, target = "z"))

# when using mvnconv() inside stouffer() with adjust = "generalized", the
# 'target' argument is automatically set and doesn't need to be specified
stouffer(p, adjust = "generalized", R = mvnconv(r))
</code></pre>


</div>
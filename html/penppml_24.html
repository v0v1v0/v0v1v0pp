<div class="container">

<table style="width: 100%;"><tr>
<td>penhdfeppml</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>One-Shot Penalized PPML Estimation with HDFE</h2>

<h3>Description</h3>

<p><code>penhdfeppml</code> fits a penalized PPML regression for a given type of penalty and a given
value of the penalty parameter.  The penalty can be either lasso or ridge, and the plugin method
can be enabled via the <code>method</code> argument.
</p>


<h3>Usage</h3>

<pre><code class="language-R">penhdfeppml(
  data,
  dep = 1,
  indep = NULL,
  fixed = NULL,
  cluster = NULL,
  selectobs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame containing all relevant variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dep</code></td>
<td>
<p>A string with the name of the independent variable or a column number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indep</code></td>
<td>
<p>A vector with the names or column numbers of the regressors. If left unspecified,
all remaining variables (excluding fixed effects) are included in the regressor matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>A vector with the names or column numbers of factor variables identifying the fixed effects,
or a list with the desired interactions between variables in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Optional. A string with the name of the clustering variable or a column number.
It's also possible to input a vector with several variables, in which case the interaction of
all of them is taken as the clustering variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selectobs</code></td>
<td>
<p>Optional. A vector indicating which observations to use (either a logical vector
or a numeric vector with row numbers, as usual when subsetting in R).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further options, including:
</p>

<ul>
<li> <p><code>penalty</code>: A string indicating the penalty type. Currently supported: "lasso" and "ridge".
</p>
</li>
<li> <p><code>method</code>: The user can set this equal to "plugin" to perform the plugin algorithm with
coefficient-specific penalty weights (see details). Otherwise, a single global penalty is used.
</p>
</li>
</ul>
<p>For a full list of options, see penhdfeppml_int.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is a thin wrapper around penhdfeppml_int, providing a more convenient interface
for data frames. Whereas the internal function requires some preliminary handling of data sets (<code>y</code>
must be a vector, <code>x</code> must be a matrix and <code>fes</code> must be provided in a list), the wrapper
takes a full data frame in the <code>data</code> argument, and users can simply specify which variables
correspond to y, x and the fixed effects, using either variable names or column numbers.
</p>
<p>More formally, <code>penhdfeppml_int</code> performs iteratively re-weighted least squares (IRLS) on a
transformed model, as described in Breinlich, Corradi, Rocha, Ruta, Santos Silva and Zylkin (2021).
In each iteration, the function calculates the transformed dependent variable, partials out the fixed
effects (calling <code>lfe::fhdwithin</code>) and then and then calls <code>glmnet::glmnet</code> if the selected
penalty is lasso (the default). If the user has selected ridge, the analytical solution is instead
computed directly using fast C++ implementation.
</p>
<p>For information on how the plugin lasso method works, see penhdfeppml_cluster.
</p>


<h3>Value</h3>

<p>If <code>method == "lasso"</code> (the default), an object of class <code>elnet</code> with the elements
described in glmnet, as well as:
</p>

<ul>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>phi</code>: coefficient-specific penalty weights (only if <code>method == "plugin"</code>.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li>
</ul>
<p>If <code>method == "ridge"</code>, a list with the following elements:
</p>

<ul>
<li> <p><code>beta</code>: a 1 x <code>ncol(x)</code> matrix with coefficient (beta) estimates.
</p>
</li>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li>
</ul>
<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
"Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements",
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). "Fast Poisson estimation with high dimensional
fixed effects", <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). "OLS with multiple high dimensional category variables",
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). "Regularization paths for generalized linear
models via coordinate descent", <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). "Inference in high dimensional panel
models with an application to gun control", <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# To reduce run time, we keep only countries in the Americas:
americas &lt;- countries$iso[countries$region == "Americas"]
test &lt;- penhdfeppml(data = trade[, -(5:6)],
                      dep = "export",
                      fixed = list(c("exp", "time"),
                                   c("imp", "time"),
                                   c("exp", "imp")),
                      lambda = 0.05,
                      selectobs = (trade$imp %in% americas) &amp; (trade$exp %in% americas))

## End(Not run)

</code></pre>


</div>
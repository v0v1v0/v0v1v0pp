<div class="container">

<table style="width: 100%;"><tr>
<td>popkin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate kinship from a genotype matrix and subpopulation assignments</h2>

<h3>Description</h3>

<p>Given the biallelic genotypes of <code>n</code> individuals, this function returns the <code>n</code>-by-<code>n</code> kinship matrix such that the kinship estimate between the most distant subpopulations is zero on average (this sets the ancestral population to the most recent common ancestor population).
</p>


<h3>Usage</h3>

<pre><code class="language-R">popkin(
  X,
  subpops = NULL,
  n = NA,
  loci_on_cols = FALSE,
  mean_of_ratios = FALSE,
  mem_factor = 0.7,
  mem_lim = NA,
  want_M = FALSE,
  m_chunk_max = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Genotype matrix, <code>BEDMatrix</code> object, or a function <code>X(m)</code> that returns the genotypes of all individuals at <code>m</code> successive locus blocks each time it is called, and <code>NULL</code> when no loci are left.
If a regular matrix, <code>X</code> must have values only in <code>c(0, 1, 2, NA)</code>, encoded to count the number of reference alleles at the locus, or <code>NA</code> for missing data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subpops</code></td>
<td>
<p>The length-<code>n</code> vector of subpopulation assignments for each individual.
If <code>NULL</code>, every individual is effectively treated as a different population.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of individuals (required only when <code>X</code> is a function, ignored otherwise).
If <code>n</code> is missing but <code>subpops</code> is not, <code>n</code> is taken to be the length of <code>subpops</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loci_on_cols</code></td>
<td>
<p>If <code>TRUE</code>, <code>X</code> has loci on columns and individuals on rows; if <code>FALSE</code> (default), loci are on rows and individuals on columns.
Has no effect if <code>X</code> is a function.
If <code>X</code> is a <code>BEDMatrix</code> object, <code>loci_on_cols</code> is ignored (set automatically to <code>TRUE</code> internally).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_of_ratios</code></td>
<td>
<p>Chose how to weigh loci.
If <code>FALSE</code> (default) loci have equal weights (in terms of variance, rare variants contribute less than common variants; also called the "ratio-of-means" version, this has known asymptotic behavior).
If <code>TRUE</code>, rare variant loci are upweighed (in terms of variance, contributions are approximately the same across variant frequencies; also called the "mean-of-ratios" version, its asymptotic behavior is less well understood but performs better for association testing).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mem_factor</code></td>
<td>
<p>Proportion of available memory to use loading and processing data.
Ignored if <code>mem_lim</code> is not <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mem_lim</code></td>
<td>
<p>Memory limit in GB, used to break up data into chunks for very large datasets.
Note memory usage is somewhat underestimated and is not controlled strictly.
Default in Linux is <code>mem_factor</code> times the free system memory, otherwise it is 1GB (Windows, OSX and other systems).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>want_M</code></td>
<td>
<p>If <code>TRUE</code>, includes the matrix <code>M</code> of non-missing pair counts in the return value, which are sample sizes that can be useful in modeling the variance of estimates.
Default <code>FALSE</code> is to return the relatedness matrix only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m_chunk_max</code></td>
<td>
<p>Sets the maximum number of loci to process at the time.
Actual number of loci loaded may be lower if memory is limiting.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The subpopulation assignments are only used to estimate the baseline kinship (the zero value).
If the user wants to re-estimate the kinship matrix using different subpopulation labels,
it suffices to rescale it using <code>rescale_popkin()</code>
(as opposed to starting from the genotypes again, which gives the same answer but more slowly).
</p>


<h3>Value</h3>

<p>If <code>want_M = FALSE</code>, returns the estimated <code>n</code>-by-<code>n</code> kinship matrix only.
If <code>X</code> has names for the individuals, they will be copied to the rows and columns of this kinship matrix.
If <code>want_M = TRUE</code>, a named list is returned, containing:
</p>

<ul>
<li> <p><code>kinship</code>: the estimated <code>n</code>-by-<code>n</code> kinship matrix
</p>
</li>
<li> <p><code>M</code>: the <code>n</code>-by-<code>n</code> matrix of non-missing pair counts (see <code>want_M</code> option).
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>popkin_af()</code> for coancestry estimation from allele frequency matrices.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Construct toy data
X &lt;- matrix(
    c(0, 1, 2,
      1, 0, 1,
      1, 0, 2),
    nrow = 3,
    byrow = TRUE
) # genotype matrix
subpops &lt;- c(1,1,2) # subpopulation assignments for individuals

# NOTE: for BED-formatted input, use BEDMatrix!
# "file" is path to BED file (excluding .bed extension)
## library(BEDMatrix)
## X &lt;- BEDMatrix(file) # load genotype matrix object

kinship &lt;- popkin(X, subpops) # calculate kinship from genotypes and subpopulation labels

</code></pre>


</div>
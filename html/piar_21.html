<div class="container">

<table style="width: 100%;"><tr>
<td>impute_prices</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Impute missing prices</h2>

<h3>Description</h3>

<p>Impute missing prices using the carry forward or shadow price method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">shadow_price(x, ...)

## Default S3 method:
shadow_price(
  x,
  ...,
  period,
  product,
  ea,
  pias = NULL,
  weights = NULL,
  r1 = 0,
  r2 = 1
)

## S3 method for class 'data.frame'
shadow_price(x, formula, ..., weights = NULL)

carry_forward(x, ...)

## Default S3 method:
carry_forward(x, ..., period, product)

## S3 method for class 'data.frame'
carry_forward(x, formula, ...)

carry_backward(x, ...)

## Default S3 method:
carry_backward(x, ..., period, product)

## S3 method for class 'data.frame'
carry_backward(x, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Either a numeric vector (or something that can be coerced into one)
or data frame of prices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or used by methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving
the time period associated with each price in <code>x</code>. The ordering of time
periods follows of the levels of <code>period</code>, to agree with
<code>cut()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>product</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving
the product associated with each price in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ea</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving the
elemental aggregate associated with each price in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pias</code></td>
<td>
<p>A price index aggregation structure, or something that can be
coerced into one, as made with <code>aggregation_structure()</code>. The default
imputes from elemental indexes only (i.e., not recursively).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>A numeric vector of weights for the prices in <code>x</code> (i.e.,
product weights), or something that can be coerced into one. The default is
to give each price equal weight. This is evaluated in <code>x</code> for the data frame
method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r1</code></td>
<td>
<p>Order of the generalized-mean price index used to calculate the
elemental price indexes: 0 for a geometric index (the default), 1 for an
arithmetic index, or -1 for a harmonic index. Other values are possible; see
<code>gpindex::generalized_mean()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r2</code></td>
<td>
<p>Order of the generalized-mean price index used to aggregate the
elemental price indexes: 0 for a geometric index, 1 for an arithmetic index
(the default), or -1 for a harmonic index. Other values are possible; see
<code>gpindex::generalized_mean()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A two-sided formula with prices on the left-hand
side. For <code>carry_forward()</code> and <code>carry_backward()</code>, the right-hand side
should have time periods and products (in that order); for
<code>shadow_price()</code>, the right-hand side should have time period, products, and
elemental aggregates (in that order).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The carry forward method replaces a missing price for a product by the price
for the same product in the previous period. It tends to push an index value
towards 1, and is usually avoided; see paragraph 6.61 in the CPI manual
(2020). The carry backwards method does the opposite, but this is rarely
used in practice.
</p>
<p>The shadow price method recursively imputes a missing price by the value of
the price for the same product in the previous period multiplied by the
value of the period-over-period elemental index for the elemental aggregate
to which that product belongs. This requires computing and aggregating an
index (according to <code>pias</code>, unless <code>pias</code> is not supplied) for
each <code>period</code>, and so these imputations can take a while. The index
values used to do the imputations are not returned because the index needs
to be recalculated to get correct percent-change contributions.
</p>
<p>Shadow price imputation is referred to as self-correcting overall mean
imputation in chapter 6 of the CPI manual (2020). It is identical to simply
excluding missing price relatives in the index calculation, except in the
period that a missing product returns. For this reason care is needed when
using this method. It is sensitive to the assumption that a product does not
change over time, and in some cases it is safer to simply omit the missing
price relatives instead of imputing the missing prices.
</p>


<h3>Value</h3>

<p>A numeric vector of prices with missing values replaced (where possible).
</p>


<h3>References</h3>

<p>IMF, ILO, OECD, Eurostat, UNECE, and World Bank. (2020).
<em>Consumer Price Index Manual: Concepts and Methods</em>.
International Monetary Fund.
</p>


<h3>See Also</h3>

<p><code>price_relative()</code> for making price relatives for the
same products over time.
</p>


<h3>Examples</h3>

<pre><code class="language-R">prices &lt;- data.frame(
  price = c(1:7, NA),
  period = rep(1:2, each = 4),
  product = 1:4,
  ea = rep(letters[1:2], 4)
)

carry_forward(prices, price ~ period + product)

shadow_price(prices, price ~ period + product + ea)

</code></pre>


</div>
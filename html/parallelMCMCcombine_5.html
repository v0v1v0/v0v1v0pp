<div class="container">

<table style="width: 100%;"><tr>
<td>semiparamDPE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Semiparametric Density Product Estimator Method</h2>

<h3>Description</h3>

<p>The function uses the Semiparametric Density Product Estimator method introduced by Neiswanger et al. (see References) to combine the independent subset posterior samples subchains into the set of samples that estimate the posterior density given the full data set. The semiparametric density product estimator method uses kernel smoothing techniques to estimate each subset posterior density; the subposterior densities are then multiplied together to approximate the posterior density based on the full data set.</p>


<h3>Usage</h3>

<pre><code class="language-R">semiparamDPE(subchain, bandw = rep(1.0, dim(subchain)[1]), anneal = TRUE, shuff = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>subchain</code></td>
<td>

<p>array of subset posterior samples of the dimension <span class="option">c(d,sampT,M).</span> Here <span class="option">d</span> is the dimension of the parameter space, <span class="option">sampT</span> is the number of samples, and <span class="option">M</span> is the number of subposterior datasets.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandw</code></td>
<td>
<p> bandwidth vector of the length <span class="option">d=dim(subchain)[1]</span>. It is a vector of tuning parameters used in kernel density approximation employed by the semiparametric method. When <span class="option">anneal=TRUE</span> then one of the choices for <span class="option">bandw</span> could be the vector consisting of standard deviations for each of the <span class="option">d</span> parameters. When <span class="option">anneal=FALSE</span> then one of the choices for <span class="option">bandw</span> could be the diagonal of the optimal bandwidth matrix obtained via Silverman's rule of thumb; see Examples. By default <span class="option">bandw=rep(1.0,d)</span>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>anneal</code></td>
<td>
<p> logical; if TRUE, the bandwidth <span class="option">bandw</span> (instead of being fixed) is annealed as <span class="option">bandw*i^(-1/(4+d))</span>; here <span class="option">i</span> is the index corresponding to a sample; see References. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shuff</code></td>
<td>
<p>logical; if TRUE, each of the <span class="option">M</span> subsets of <span class="option">d</span> dimensional parameters  in <span class="option">subchain</span> is shuffled.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns an array of samples of dimension dim=c(d,sampT)
representing an estimated (combined) full posterior density.</p>


<h3>References</h3>

<p>Neiswanger, W., Wang, C., Xing E. (2014) Asymptotically exact, embarrassingly parallel MCMC. arXiv:1311.4780v2.
</p>
<p>Silverman, B.W. (1986). Density Estimation for Statistics and Data Analysis. <em> Chapman &amp; Hall/CRC. pp. 7-11</em>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">d      &lt;- 2     # dimension of the parameter space
sampT  &lt;- 300   # number of subset posterior samples
M      &lt;- 3     # total number of subsets

## simulate Gaussian subposterior samples

theta &lt;- array(NA,c(d,sampT,M))

norm.mean &lt;- c(1.0, 2.0)
norm.sd   &lt;- c(0.5, 1.0)

for (i in 1:d)
  for (s in 1:M)
    theta[i,,s] &lt;- rnorm(sampT, mean=norm.mean[i]+runif(1,-0.01,0.01), sd=norm.sd[i])

## estimate (mean) standard deviations for each parameter across the subsets

norm.var.est &lt;- rep(0,d)

for(i in 1:d)
  for(s in 1:M)
    norm.var.est[i] &lt;- norm.var.est[i] + var(theta[i,,s])

norm.sd.est &lt;- sqrt(norm.var.est/M)


## Compute the diagonal of the optimal bandwidth
## matrix according to Silverman's rule

h_opt1 = (4/(d+2))^(1/(4+d)) * (sampT^(-1/(4+d))) * norm.sd.est

## Combine samples. The bandwidth matrix is fixed:

full.theta1 &lt;- semiparamDPE( subchain = theta, bandw = h_opt1 * 2, anneal = FALSE)

## Compute the diagonal of the optimal bandwidth
## matrix for the method that uses annealing

h_opt2 = (4/(d+2))^(1/(4+d)) * norm.sd.est

## Combine samples. The bandwidth matrix will be annealed:

full.theta2 &lt;- semiparamDPE(subchain = theta, bandw = h_opt2 * 2, anneal = TRUE)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>add_manual_targets</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add manual targets</h2>

<h3>Description</h3>

<p>Set targets for a conservation planning problem by manually
specifying all the required information for each target. This function
is useful because it can be used to customize all aspects of a target. For
most cases, targets can be specified using the
<code>add_absolute_targets()</code> and <code>add_relative_targets()</code>
functions. However, this function can be used to (i) mix absolute and
relative targets for different features and zones, (ii) set targets that
pertain to the allocations of planning units in multiple zones, and (iii)
set targets that require different senses (e.g., targets which specify the
solution should not exceed a certain quantity using <code>"&lt;="</code> values).
</p>


<h3>Usage</h3>

<pre><code class="language-R">add_manual_targets(x, targets)

## S4 method for signature 'ConservationProblem,data.frame'
add_manual_targets(x, targets)

## S4 method for signature 'ConservationProblem,tbl_df'
add_manual_targets(x, targets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>problem()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targets</code></td>
<td>
<p><code>data.frame</code> or <code>tibble::tibble()</code> object.
See the Targets format section for more information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Targets are used to specify the minimum amount or proportion of a
feature's distribution that needs to be protected. Most conservation
planning problems require targets with the exception of the maximum cover
(see <code>add_max_cover_objective()</code>) and maximum utility
(see <code>add_max_utility_objective()</code>) problems. Attempting to solve
problems with objectives that require targets without specifying targets
will throw an error.
</p>
<p>For problems associated with multiple management zones,
<code>add_absolute_targets()</code> can
be used to set targets that each pertain to a single feature and a single
zone. To set targets that can be met through allocating different
planning units to multiple zones, see the <code>add_manual_targets()</code>
function. An example of a target that could be met through allocations
to multiple zones might be where each management zone is expected to
result in a different amount of a feature and the target requires that
the total amount of the feature in all zones must exceed a certain
threshold. In other words, the target does not require that any single
zone secure a specific amount of the feature, but the total amount held
in all zones must secure a specific amount. Thus the target could,
potentially, be met through allocating all planning units to any specific
management zone, or through allocating the planning units to different
combinations of management zones.
</p>


<h3>Value</h3>

<p>An updated <code>problem()</code> object with the targets added to it.
</p>


<h3>Targets format</h3>

<p>The <code>targets</code> argument should be a <code>data.frame</code> with the following
columns:
</p>

<dl>
<dt>feature</dt>
<dd>
<p><code>character</code> name of features in argument
to <code>x</code>.</p>
</dd>
<dt>zone</dt>
<dd>
<p><code>character</code> name of zones in the argument
<code>x</code>. It can also be a <code>list</code> of <code>character</code> vectors if
targets should correspond to multiple zones (see Examples section below).
This column is optional for arguments to <code>x</code>
that do not contain multiple zones.</p>
</dd>
<dt>type</dt>
<dd>
<p><code>character</code> describing the type of target.
Acceptable values include <code>"absolute"</code> and <code>"relative"</code>.
These values correspond to <code>add_absolute_targets()</code>,
and <code>add_relative_targets()</code> respectively.</p>
</dd>
<dt>sense</dt>
<dd>
<p><code>character</code> sense of the target. Acceptable
values include: <code>"&gt;="</code>, <code>"&lt;="</code>, and <code>"="</code>. This
column is optional and if it is missing then target senses will
default to <code>"&gt;="</code> values.</p>
</dd>
<dt>target</dt>
<dd>
<p><code>numeric</code> target threshold.</p>
</dd>
</dl>
<h3>See Also</h3>

<p>See targets for an overview of all functions for adding targets.
</p>
<p>Other targets: 
<code>add_absolute_targets()</code>,
<code>add_loglinear_targets()</code>,
<code>add_relative_targets()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create problem with 10% relative targets
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# create equivalent problem using add_manual_targets
p2 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_manual_targets(
    data.frame(
      feature = names(sim_features),
      type = "relative", sense = "&gt;=",
      target = 0.1
    )
  ) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# plot solution
plot(s2, main = "solution", axes = FALSE)

# create problem with targets set for only a few features
p3 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_manual_targets(
    data.frame(
      feature = names(sim_features)[1:3],
      type = "relative",
      sense = "&gt;=",
      target = 0.1
    )
 ) %&gt;%
 add_binary_decisions() %&gt;%
 add_default_solver(verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# plot solution
plot(s3, main = "solution", axes = FALSE)

# create problem that aims to secure at least 10% of the habitat for one
# feature whilst ensuring that the solution does not capture more than
# 20 units habitat for different feature
# create problem with targets set for only a few features
p4 &lt;-
  problem(sim_pu_raster, sim_features[[1:2]]) %&gt;%
  add_min_set_objective() %&gt;%
  add_manual_targets(
    data.frame(
      feature = names(sim_features)[1:2],
      type = "relative",
      sense = c("&gt;=", "&lt;="),
      target = c(0.1, 0.2)
    )
  ) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s4 &lt;- solve(p4)

# plot solution
plot(s4, main = "solution", axes = FALSE)

# create a multi-zone problem that requires a specific amount of each
# feature in each zone
targets_matrix &lt;- matrix(rpois(15, 1), nrow = 5, ncol = 3)

p5 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(targets_matrix) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s5 &lt;- solve(p5)

# plot solution
plot(category_layer(s5), main = "solution", axes = FALSE)

# create equivalent problem using add_manual_targets
targets_dataframe &lt;- expand.grid(
  feature = feature_names(sim_zones_features),
  zone = zone_names(sim_zones_features),
  sense = "&gt;=",
  type = "absolute"
)
targets_dataframe$target &lt;- c(targets_matrix)

p6 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_manual_targets(targets_dataframe) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s6 &lt;- solve(p6)

# plot solution
plot(category_layer(s6), main = "solution", axes = FALSE)

# create a problem that requires a total of 20 units of habitat to be
# captured for two species. This can be achieved through representing
# habitat in two zones. The first zone represents a full restoration of the
# habitat and a second zone represents a partial restoration of the habitat
# Thus only half of the benefit that would have been gained from the full
# restoration is obtained when planning units are allocated a partial
# restoration

# create data
spp_zone1 &lt;- as.list(sim_zones_features)[[1]][[1:2]]
spp_zone2 &lt;- spp_zone1 * 0.5
costs &lt;- sim_zones_pu_raster[[1:2]]

# create targets
targets_dataframe2 &lt;- tibble::tibble(
  feature = names(spp_zone1),
  zone = list(c("z1", "z2"), c("z1", "z2")),
  sense = c("&gt;=", "&gt;="),
  type = c("absolute", "absolute"),
  target = c(20, 20)
)

# create problem
p7 &lt;-
  problem(
    costs,
    zones(
      spp_zone1, spp_zone2,
      feature_names = names(spp_zone1), zone_names = c("z1", "z2")
    )
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_manual_targets(targets_dataframe2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s7 &lt;- solve(p7)

# plot solution
plot(category_layer(s7), main = "solution", axes = FALSE)

## End(Not run)
</code></pre>


</div>
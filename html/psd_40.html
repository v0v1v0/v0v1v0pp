<div class="container">

<table style="width: 100%;"><tr>
<td>psd-utilities</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Various utility functions.</h2>

<h3>Description</h3>

<p><em>The various utility functions are:</em>
</p>
<p><code>na_locf</code> is meant as a simple replacement for zoo::na.locf
which carries the last observation forward; here we force both directions, meaning
the first observation is carried backwards as well.
</p>
<p><code>vardiff</code> returns the variance of the first (or second) 
difference of the series. <code>varddiff</code> is a convenience wrapper
to return variance for the second difference.
</p>
<p><code>create_poly</code> generates an x-y sequence compatible for use with <code>polygon</code>
</p>
<p><code>dB</code> returns an object converted to decibels.
</p>
<p><code>vector_reshape</code> reshapes a vector into another vector.
</p>
<p><code>colvec</code> returns the object as a vertically long vector; whereas
<code>rowvec</code> returns the object as a horizontally long vector.
</p>
<p><code>is.spec</code> and <code>is.amt</code> report whether an object has class <code>'spec'</code> or <code>'amt'</code>, as
would one returned by, for example, <code>spectrum</code> or <code>psdcore</code>.
</p>
<p><code>is.tapers</code> reports whether an object has class <code>'tapers'</code>, as
would one returned by, for example, <code>as.tapers</code>.
</p>
<p><code>na_mat</code> populates a matrix of specified dimensions 
with <code>NA</code> values.
</p>
<p><code>zeros</code> populate a column-wise matrix with zeros; whereas,
<code>ones</code> populates a column-wise matrix with ones.  <em>Note that 
<code>n</code> is enforced to be at least 1 for both functions.</em>
</p>
<p><code>mod</code> finds the modulo division of two values
</p>


<h3>Usage</h3>

<pre><code class="language-R">na_locf(x)

## S3 method for class 'matrix'
na_locf(x)

## Default S3 method:
na_locf(x)

vardiff(x, double.diff = FALSE)

varddiff(x)

## S3 method for class 'spec'
varddiff(x)

## Default S3 method:
varddiff(x)

create_poly(x, y, dy, from.lower = FALSE)

dB(Rat, invert = FALSE, pos.only = TRUE, is.power = FALSE)

vector_reshape(x, vec.shape = c("horizontal", "vertical"))

colvec(x)

rowvec(x)

is.spec(Obj)

is.amt(Obj)

is.tapers(Obj)

na_mat(nrow, ncol = 1)

zeros(nrow)

ones(nrow)

mod(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>objects; in <code>create_poly</code> these are the vectors used to
create a <code>polygon</code>-compatible sequence (<code>x</code> is sorted by default);
in <code>mod</code> these are the "numerator" and "denominator", respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>double.diff</code></td>
<td>
<p>logical; should the double difference be used instead?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dy</code></td>
<td>
<p>numeric; the distance from <code>y</code> to the top and bottom of
the polygonal surfaces; see <code>from.lower</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from.lower</code></td>
<td>
<p>logical; should the bottom be <code>y</code> instead of <code>y+dy</code>, so that
<code>dy</code> represents the distance from the lower surface?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rat</code></td>
<td>
<p>numeric; the values – ratios – to convert to decibels (<code>dB</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invert</code></td>
<td>
<p>logical; assumes <code>Rat</code> is already in decibels, so return ratio</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos.only</code></td>
<td>
<p>logical; if <code>invert=FALSE</code>, sets negative or zero values to NA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.power</code></td>
<td>
<p>logical; should the factor of 2 be included in the decibel calculation?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vec.shape</code></td>
<td>
<p>choice between horizontally-long or vertically-long vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Obj</code></td>
<td>
<p>An object to test for class inheritance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrow, ncol</code></td>
<td>
<p>integer; the number of rows and/or columns to create</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Decibels are defined as <code class="reqn">10 \log{}_{10} \frac{X_1}{X_2}</code>, 
unless <code>is.power=TRUE</code> in which <code class="reqn">\mathrm{db} X^2 \equiv 20 \log{}_{10} X^2</code>
</p>
<p><code>colvec, rowvec</code> are simple wrapper functions to <code>vector_reshape</code>.
</p>
<p>Modulo division has higher order-of-operations ranking than other
arithmetic operations; hence, <code>x + 1 %% y</code> is equivalent to
<code>x + (1 %% y)</code> which can produce confusing results. <code>mod</code>
is simply a series of <code>trunc</code> commands which
reduces the chance for unintentionally erroneous results.
</p>


<h3>Value</h3>

<p><code>vector_reshape</code> returns a "reshaped" vector, meaning it has
had it's dimensions changes so that it has either one row 
(if <code>vec.shape=="horizontal"</code>), or one column (<code>"vertical"</code>).
</p>
<p><code>is.spec</code>, <code>is.amt</code>, and <code>is.tapers</code> return the output of <code>inherits</code>.
</p>
<p><code>na_mat</code> returns a matrix of dimensions <code>(nrow,ncol)</code> with
<code>NA</code> values, the representation of which is set by <code>NA_real_</code>
</p>
<p><code>mod</code> returns the result of a modulo division, which is 
equivalent to <code>(x) %% (y)</code>.
</p>


<h3>Note</h3>

<p>The performance of <code>mod</code> has not been tested against the 
<code>%%</code> arithmetic method – it may or may not be slower for large
numeric vectors.
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour
</p>


<h3>References</h3>

<p>For <code>mod</code>: see Peter Dalgaard's explanation of 
the non-bug (#14771) I raised (instead I should've asked it on R-help): 
<a href="https://bugs.r-project.org/show_bug.cgi?id=14771">https://bugs.r-project.org/show_bug.cgi?id=14771</a>
</p>


<h3>See Also</h3>

<p><code>psd-package</code>, <code>as.tapers</code>, <code>modulo_floor</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: #REX
library(psd)

##
## Various utilities
##

set.seed(1234)
X &lt;- rnorm(1e2)

#
# Matrix and vector creation:
#
# NA matrix
nd &lt;- 5
na_mat(nd)
na_mat(nd,nd-1)

# zeros
zeros(nd)

# and ones
ones(nd)

#
# Check for tapers object:
#
is.tapers(X)
is.tapers(as.tapers(X))

#
# Check for spec object:
#
PSD &lt;- spectrum(X, plot=FALSE)
plot(PSD)
# return is class 'spec'
is.spec(PSD) # TRUE
# but the underlying structure is just a list
PSD &lt;- unclass(PSD)
is.spec(PSD) # FALSE

#
# decibels
#
dB(1) # signal is equal &lt;--&gt; zero dB
sig &lt;- 1e-10
all.equal(sig, dB(dB(sig), invert=TRUE))
pow &lt;- sig**2
all.equal(pow, dB(dB(sig, is.power=TRUE), invert=TRUE, is.power=TRUE))

# 
# Variance of difference series
#
vardiff(X) # first difference
varddiff(X) # second difference
all.equal(vardiff(X, TRUE), varddiff(X))

#
# modulo division
#
x &lt;- 1:10
mc1a &lt;- mod(1,2)
mc2a &lt;- mod(1+x,2)
mc1b &lt;- 1 %% 2
mc2b &lt;- 1 + x %% 2
mc2c &lt;- (1 + x) %% 2
all.equal(mc1a, mc1b) # TRUE
all.equal(mc2a, mc2b) # "Mean absolute difference: 2"
all.equal(mc2a, mc2c) # TRUE
# on a series
modulo_floor(1:10) # defaults to 2
modulo_floor(1:10, 3)


## End(Not run)#REX
</code></pre>


</div>
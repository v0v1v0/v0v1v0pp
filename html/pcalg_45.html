<div class="container">

<table style="width: 100%;"><tr>
<td>ges</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate the Markov equivalence class of a DAG using GES</h2>

<h3>Description</h3>

<p>Estimate the observational essential graph representing the Markov
equivalence class of a DAG using the greedy equivalence search (GES)
algorithm of Chickering (2002).
</p>


<h3>Usage</h3>

<pre><code class="language-R">ges(score, labels = score$getNodes(),
    fixedGaps = NULL, adaptive = c("none", "vstructures", "triples"), 
    phase = c("forward", "backward", "turning"), iterate = length(phase) &gt; 1,
    turning = NULL, maxDegree = integer(0), verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>An instance of a class derived from <code>Score</code>
which only accounts for observational data. If the
dataset is high-dimensional (p&gt;=n) <code>ges</code> might not be able to terminate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>Node labels; by default, they are determined from the scoring
object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedGaps</code></td>
<td>
<p>logical <em>symmetric</em> matrix of dimension p*p.  If entry
<code>[i, j]</code> is <code>TRUE</code>, the result is guaranteed to have no edge
between nodes <code class="reqn">i</code> and <code class="reqn">j</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>
<p>indicating whether constraints should be adapted to
newly detected v-structures or unshielded triples (cf. details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase</code></td>
<td>
<p>Character vector listing the phases that should be used; possible
values: <code>forward</code>, <code>backward</code>, and <code>turning</code> (cf. details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterate</code></td>
<td>
<p>Logical indicating whether the phases listed in the argument
<code>phase</code> should be iterated more than once (<code>iterate = TRUE</code>) or
not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>turning</code></td>
<td>
<p>Setting <code>turning = TRUE</code> is equivalent to setting
<code>phases = c("forward", "backward")</code> and <code>iterate = FALSE</code>; the
use of the argument <code>turning</code> is deprecated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxDegree</code></td>
<td>
<p>Parameter used to limit the vertex degree of the estimated
graph.  Valid arguments:
</p>

<ol>
<li>
<p> Vector of length 0 (default): vertex degree is not limited.
</p>
</li>
<li>
<p> Real number <code class="reqn">r</code>, <code class="reqn">0 &lt; r &lt; 1</code>: degree of vertex <code class="reqn">v</code> is
limited to <code class="reqn">r \cdot n_v</code>, where <code class="reqn">n_v</code> denotes the number of
data points where <code class="reqn">v</code> was not intervened.
</p>
</li>
<li>
<p> Single integer: uniform bound of vertex degree for all vertices
of the graph.
</p>
</li>
<li>
<p> Integer vector of length <code>p</code>: vector of individual bounds
for the vertex degrees.
</p>
</li>
</ol>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, detailed output is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments for debugging purposes and fine tuning.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Under the assumption that the distribution of the observed variables is
faithful to a DAG, this function estimates the Markov equivalence class of
the DAG. It does not estimate the DAG itself, because this is typically
impossible (even with an infinite amount of data): different DAGs (forming a
Markov equivalence class) can describe the same conditional independence
relationships and be statistically indistinguishable from observational data
alone.
</p>
<p>All DAGs in an equivalence class have the same skeleton (i.e., the same
adjacency information) and the same v-structures (i.e., the same induced
subgraphs of the form <code class="reqn">a \longrightarrow b \longleftarrow c</code>).
However, the direction of some edges may be undetermined, in the sense that
they point one way in one DAG in the equivalence class, while they point the
other way in another DAG in the equivalence class.
</p>
<p>An equivalence class can be uniquely represented by a partially directed graph
called (observational) essential graph or CPDAG (completed partially directed
acyclic graph).  Its edges have the following interpretation:
</p>

<ol>
<li>
<p> a directed edge <code class="reqn">a \longrightarrow b</code> stands for an arrow
that has the same orientation in all representatives of the Markov
equivalence class;
</p>
</li>
<li>
<p> an undirected edge a – b stands for an arrow that is oriented in one
way in some representatives of the equivalence class and in the other way
in other representatives of the equivalence class.
</p>
</li>
</ol>
<p>Note that when plotting the object, undirected and bidirected edges are
equivalent.
</p>
<p>GES (greedy equivalence search) is a score-based algorithm that greedily
maximizes a score function (typically the BIC, passed to the function via the
argument <code>score</code>) in the space of (observational) essential graphs in
three phases, starting from the empty graph:
</p>

<dl>
<dt>Forward phase</dt>
<dd>
<p>In the forward phase, GES moves through the space of
essential graphs in steps that correspond to the addition of a single edge
in the space of DAGs; the phase is aborted as soon as the score cannot be
augmented any more.</p>
</dd>
<dt>Backward phase</dt>
<dd>
<p>In the backward phase, the algorithm performs moves
that correspond to the removal of a single edge in the space of DAGs until
the score cannot be augmented any more.</p>
</dd>
<dt>Turning phase</dt>
<dd>
<p>In the turning phase, the algorithm performs moves
that correspond to the reversal of a single arrow in the space of DAGs
until the score cannot be augmented any more.</p>
</dd>
</dl>
<p>GES cycles through these three phases until no augmentation of the score is
possible any more if <code>iterate = TRUE</code>.  Note that the turning phase 
was not part of the original implementation of Chickering (2002), but was 
introduced by Hauser and Bühlmann (2012) and shown to improve the overall 
estimation performance.  The original algorithm of Chickering (2002) is 
reproduced with <code>phase = c("forward", "backward")</code> and 
<code>iterate = FALSE</code>.
</p>
<p>GES has the same purpose as the PC algorithm (see <code>pc</code>).  While
the PC algorithm is based on conditional independence tests (requiring the
choice of an independence test and a significance level, see
<code>pc</code>), the GES algorithm is a score-based method (requiring the
choice of a score function) and does not depend on conditional independence
tests.  Since GES always operates in the space of essential graphs, it
returns a valid essential graph (or CPDAG) in any case.
</p>
<p>Using the argument <code>fixedGaps</code>, one can make sure that certain edges
will <em>not</em> be present in the resulting essential graph: if the entry
<code>[i, j]</code> of the matrix passed to <code>fixedGaps</code> is <code>TRUE</code>, there
will be no edge between nodes <code class="reqn">i</code> and <code class="reqn">j</code>.  Using this argument 
can speed up the execution of GIES and allows the user to account for
previous knowledge or other constraints.  The argument <code>adaptive</code> can be
used to relax the constraints encoded by <code>fixedGaps</code> according to a 
modification of GES called ARGES (adaptively restricted greedy 
equivalence search) which has been presented in Nandy, Hauser and Maathuis
(2015):
</p>

<ul>
<li>
<p> When <code>adaptive = "vstructures"</code> and the algorithm introduces a 
new v-structure <code class="reqn">a \longrightarrow b \longleftarrow c</code> in the 
forward phase, then the edge <code class="reqn">a - c</code> is removed from the list of fixed 
gaps, meaning that the insertion of an edge between <code class="reqn">a</code> and <code class="reqn">c</code> 
becomes possible even if it was forbidden by the initial matrix passed to 
<code>fixedGaps</code>.
</p>
</li>
<li>
<p> When <code>adaptive = "triples"</code> and the algorithm introduces a new
unshielded triple in the forward phase (i.e., a subgraph of three nodes
<code class="reqn">a</code>, <code class="reqn">b</code> and <code class="reqn">c</code> where <code class="reqn">a</code> and <code class="reqn">b</code> as well as <code class="reqn">b</code>
and <code class="reqn">c</code> are adjacent, but <code class="reqn">a</code> and <code class="reqn">c</code> are not), then the edge
<code class="reqn">a - c</code> is removed from the list of fixed gaps.
</p>
</li>
</ul>
<p>With one of the adaptive modifications, the successive application of a 
skeleton estimation method and GES restricted to an estimated skeleton still
gives a <em>consistent</em> estimator of the DAG, which is not the case without
the adaptive modification.


</p>


<h3>Value</h3>

<p><code>ges</code> returns a list with the following two components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>essgraph</code></td>
<td>
<p>An object of class <code>EssGraph</code> containing an
estimate of the equivalence class of the underlying DAG.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repr</code></td>
<td>
<p>An object of a class derived from <code>ParDAG</code>
containing a (random) representative of the estimated equivalence class.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>References</h3>

<p>D.M. Chickering (2002).  Optimal structure identification with greedy search.
<em>Journal of Machine Learning Research</em> <b>3</b>, 507–554
</p>
<p>A. Hauser and P. Bühlmann (2012).  Characterization and greedy learning of
interventional Markov equivalence classes of directed acyclic graphs.
<em>Journal of Machine Learning Research</em> <b>13</b>, 2409–2464.
</p>
<p>P. Nandy, A. Hauser and M. Maathuis (2015).  Understanding consistency in 
hybrid causal structure learning.  <em>arXiv preprint</em> 1507.02608
</p>
<p>P. Spirtes, C.N. Glymour, and R. Scheines (2000).  <em>Causation,
Prediction, and Search</em>, MIT Press, Cambridge (MA).
</p>


<h3>See Also</h3>

<p><code>pc</code>, <code>Score</code>, <code>EssGraph</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Load predefined data
data(gmG)

## Define the score (BIC)
score &lt;- new("GaussL0penObsScore", gmG8$x)

## Estimate the essential graph
ges.fit &lt;- ges(score)

## Plot the estimated essential graph and the true DAG
if (require(Rgraphviz)) {
  par(mfrow=c(1,2))
  plot(ges.fit$essgraph, main = "Estimated CPDAG")
  plot(gmG8$g, main = "True DAG")
  str(ges.fit, max=2)
}
## alternative:
if (require(Matrix)) {
  as(as(ges.fit$essgraph,"graphNEL"),"Matrix")
}
</code></pre>


</div>
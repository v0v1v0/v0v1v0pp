<div class="container">

<table style="width: 100%;"><tr>
<td>pc.cons.intern</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Utility for conservative and majority rule in PC and FCI</h2>

<h3>Description</h3>

<p>The <code>pc.cons.intern()</code> function is used in <code>pc</code> and 
<code>fci</code>, notably when
<code>conservative = TRUE</code> (conservative orientation of v-structures) or
<code>maj.rule = TRUE</code> (majority rule orientation of v-structures). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">pc.cons.intern(sk, suffStat, indepTest, alpha, version.unf = c(NA, NA),
               maj.rule = FALSE, verbose = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sk</code></td>
<td>
<p>A skeleton object as returned from <code>skeleton()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffStat</code></td>
<td>
<p>Sufficient statistic: List containing all necessary
elements for the conditional independence decisions in the
function <code>indepTest</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indepTest</code></td>
<td>
<p>Pre-defined function for testing conditional independence. The
function is internally called as <code>indepTest(x,y,S,suffStat)</code>, and
tests conditional independence of <code>x</code> and <code>y</code> given
<code>S</code>. Here, <code>x</code> and <code>y</code> are variables, and <code>S</code> is
a (possibly empty) vector of variables (all variables are denoted
by their column numbers
in the adjacency matrix). <code>suffStat</code> is a list containing
all relevant elements for the conditional independence
decisions. The return value of <code>indepTest</code> is the p-value of
the test for conditional independence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Significance level for the individual conditional
independence tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>version.unf</code></td>
<td>
<p>Vector of length two.  If <code>version.unf</code>[2]==1,
the intitial separating set found by the PC/FCI algorithm is
added to the set of separating sets; if <code>version.unf[2]==</code>2, it
is not added.  In the latter case, if the set of separating sets is
empty, the triple is marked as unambiguous if
<code>version.unf</code>[1]==1, and as ambiguous if
<code>version.unf</code>[1]==2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maj.rule</code></td>
<td>
<p>Logical indicatin if the triples are checked for
ambiguity using the majority rule idea, which is less strict than
the standard conservative method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical asking for detailed output.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For any unshielded triple A-B-C, consider all subsets of the neighbors
of A and of the neighbors of C, and record all such sets D for which A and C
are conditionally independent given D.  We call such sets
“separating sets”. 
</p>
<p>If <code>version.unf</code>[2]==1, the initial separating set found in the
PC/FCI algorithm is added to this set of separating sets.  
If <code>version.unf</code>[2]==2, the initial separating set is not added (as in Tetrad). 
</p>
<p>In the latter case, if the set of separating sets is empty, then the
triple is marked as ‘ambiguous’ if <code>version.unf</code>[1]==2, for
example in <code>pc</code>, or as ‘unambiguous’ if
<code>version.unf</code>[1]==1, for example in <code>fci</code>.
Otherwise, there is at least one separating set.
If <code>maj.rule=FALSE</code>, the conservative PC algorithm is used
(Ramsey et al., 2006): If B is in some but not all separating sets,
the triple is marked as ambiguous.  Otherwise it is treated as in the
standard PC algorithm.  If <code>maj.rule=TRUE</code>, the majority rule is
applied (Colombo and Maathuis, 2014): The triple is marked as
‘ambiguous’ if B is in exactly 50 percent of the separating sets.  If
it is in less than 50 percent it is marked as a v-structure, and if it
is in more than 50 percent it is marked as a non v-structure.
</p>
<p>Note: This function modifies the separating sets for unambiguous
triples in the skeleton object (adding or removing B) to ensure that
the usual orientations rules later on lead to the correct
v-structures/non v-structures. 
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>unfTripl</code></td>
<td>
<p>numeric vector of triples coded as numbers (via
<code>triple2numb()</code>) that were marked as ambiguous.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vers</code></td>
<td>

<p>Vector containing the version (1 or 2) of the corresponding triple
saved in unfTripl (1=normal ambiguous triple, i.e., B is in some
sepsets but not all or none; 2=triple coming from version.unf[1]==2,
i.e., a and c are indep given the initial sepset but there does not
exist a subset of the neighbours of a or of c that d-separates
them.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sk</code></td>
<td>
<p>The updated skeleton-object (separating sets might have been updated).</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Diego Colombo.
</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782.
</p>
<p>J. Ramsey, J. Zhang and P. Spirtes (2006).
Adjacency-faithfulness and conservative causal inference. In
<em>Proceedings of the 22nd Annual Conference on Uncertainty in
Artificial Intelligence</em>, Arlington, VA. AUAI Press.
</p>


<h3>See Also</h3>

<p><code>skeleton</code>, <code>pc</code>, <code>fci</code>
</p>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>tbl_get</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Obtain a materialized table via a table store</h2>

<h3>Description</h3>

<p>The <code>tbl_get()</code> function gives us the means to materialize a table that has
an entry in a table store (i.e., has a table-prep formula with a unique
name). The table store that is used for this can be in the form of a
<code>tbl_store</code> object (created with the <code>tbl_store()</code> function) or an on-disk
YAML representation of a table store (created by using <code>yaml_write()</code> with a
<code>tbl_store</code> object).
</p>
<p>Should you want a table-prep formula from a table store to use as a value for
<code>tbl</code> (in <code>create_agent()</code>, <code>create_informant()</code>, or <code>set_tbl()</code>), then have
a look at the <code>tbl_source()</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tbl_get(tbl, store = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tbl</code></td>
<td>
<p>The table to retrieve from a table <code>store</code>. This table could be
identified by its name (e.g., <code>tbl = "large_table"</code>) or by supplying a
reference using a subset (with <code>$</code>) of the <code>tbl_store</code> object (e.g., <code>tbl = store$large_table</code>). If using the latter method then nothing needs to be
supplied to <code>store</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store</code></td>
<td>
<p>Either a table store object created by the <code>tbl_store()</code>
function or a path to a table store YAML file created by <code>yaml_write()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A table object.
</p>


<h3>Examples</h3>

<p>Define a <code>tbl_store</code> object by adding several table-prep formulas in
<code>tbl_store()</code>.
</p>
<div class="sourceCode r"><pre>store &lt;- 
  tbl_store(
    small_table_duck ~ db_tbl(
      table = small_table,
      dbname = ":memory:",
      dbtype = "duckdb"
    ),
    ~ db_tbl(
      table = "rna",
      dbname = "pfmegrnargs",
      dbtype = "postgres",
      host = "hh-pgsql-public.ebi.ac.uk",
      port = 5432,
      user = I("reader"),
      password = I("NWDMCE5xdipIjRrp")
    ),
    sml_table ~ pointblank::small_table
  )
</pre></div>
<p>Once this object is available, we can access the tables named:
<code>"small_table_duck"</code>, <code>"rna"</code>, and <code>"sml_table"</code>. Let's check that the
<code>"rna"</code> table is accessible through <code>tbl_get()</code>:
</p>
<div class="sourceCode r"><pre>tbl_get(
  tbl = "rna",
  store = store
)
</pre></div>
<pre>## # Source:   table&lt;rna&gt; [?? x 9]
## # Database: postgres [reader@hh-pgsql-public.ebi.ac.uk:5432/pfmegrnargs]
##          id upi        timestamp           userstamp crc64   len seq_short
##     &lt;int64&gt; &lt;chr&gt;      &lt;dttm&gt;              &lt;chr&gt;     &lt;chr&gt; &lt;int&gt; &lt;chr&gt;    
##  1 24583872 URS000177… 2019-12-02 13:26:08 rnacen    C380…   511 ATTGAACG…
##  2 24583873 URS000177… 2019-12-02 13:26:08 rnacen    BC42…   390 ATGGGCGA…
##  3 24583874 URS000177… 2019-12-02 13:26:08 rnacen    19A5…   422 CTACGGGA…
##  4 24583875 URS000177… 2019-12-02 13:26:08 rnacen    66E1…   534 AGGGTTCG…
##  5 24583876 URS000177… 2019-12-02 13:26:08 rnacen    CC8F…   252 TACGTAGG…
##  6 24583877 URS000177… 2019-12-02 13:26:08 rnacen    19E4…   413 ATGGGCGA…
##  7 24583878 URS000177… 2019-12-02 13:26:08 rnacen    AE91…   253 TACGAAGG…
##  8 24583879 URS000177… 2019-12-02 13:26:08 rnacen    E21A…   304 CAGCAGTA…
##  9 24583880 URS000177… 2019-12-02 13:26:08 rnacen    1AA7…   460 CCTACGGG…
## 10 24583881 URS000177… 2019-12-02 13:26:08 rnacen    2046…   440 CCTACGGG…
## # … with more rows, and 2 more variables: seq_long &lt;chr&gt;, md5 &lt;chr&gt;</pre>
<p>An alternative method for getting the same table materialized is by using <code>$</code>
to get the formula of choice from <code>tbls</code> and passing that to <code>tbl_get()</code>. The
benefit of this is that we can use autocompletion to show us what's available
in the table store (i.e., appears after typing the <code>$</code>).
</p>
<div class="sourceCode r"><pre>store$small_table_duck %&gt;% tbl_get()
</pre></div>
<pre>## # Source:   table&lt;small_table&gt; [?? x 8]
## # Database: duckdb_connection
##    date_time           date           a b             c      d e     f    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
## # … with more rows</pre>


<h3>Function ID</h3>

<p>1-10
</p>


<h3>See Also</h3>

<p>Other Planning and Prep: 
<code>action_levels()</code>,
<code>create_agent()</code>,
<code>create_informant()</code>,
<code>db_tbl()</code>,
<code>draft_validation()</code>,
<code>file_tbl()</code>,
<code>scan_data()</code>,
<code>tbl_source()</code>,
<code>tbl_store()</code>,
<code>validate_rmd()</code>
</p>


</div>
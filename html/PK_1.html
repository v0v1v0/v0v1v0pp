<div class="container">

<table style="width: 100%;"><tr>
<td>auc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation of confidence intervals for the area under the concentration versus time curve in complete and incomplete data designs</h2>

<h3>Description</h3>

<p>Calculation of confidence intervals for an area under the concentration versus time curve (AUC) or for the difference between two AUCs assessed in complete and incomplete data designs.</p>


<h3>Usage</h3>

<pre><code class="language-R">auc(conc, time, group=NULL, method=c("t", "z", "boott"), 
     alternative=c("two.sided", "less", "greater"), 
     conf.level=0.95, strata=NULL, nsample=1000, 
     design=c("ssd","batch","complete"), data)	     

auc.ssd(conc, time, group=NULL, method=c("t", "z", "boott"), 
     alternative=c("two.sided", "less", "greater"), 
     conf.level=0.95, strata=NULL, nsample=1000, data)	     

auc.batch(conc, time, group=NULL, method=c("t", "z", "boott"), 
     alternative=c("two.sided", "less", "greater"), 
     conf.level=0.95, nsample=1000, data)	     

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>conc</code></td>
<td>
<p> Levels of concentrations. For batch designs a list is required, while a vector is expected otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p> Time points of concentration assessment. For batch designs a list is required, while a vector is expected otherwise. One time point for each concentration measured needs to be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p> A grouping variable (default=<code>NULL</code>). For batch designs a list is required, while a vector is expected otherwise. If specified, a confidence interval for the difference of independent AUCs will be calculated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> A character string specifying the method for calculation of confidence intervals (default=<code>c("t", "z", "boott")</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p> A character string specifying the alternative hypothesis. Possible values are <code>"less"</code>, <code>"greater"</code> and <code>"two.sided"</code> (the default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p> Confidence level (default=<code>0.95</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strata</code></td>
<td>
<p> A vector of one strata variable (default=<code>NULL</code>). Only available for method <code>boott</code> in a serial sampling design. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsample</code></td>
<td>
<p> Number of bootstrap iterations for method <code>boott</code> (default=<code>1000</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p> A character string indicating the type of design used. Possible values are <code>"ssd"</code> for a serial sampling design, <code>"batch"</code> for a batch design and <code>"complete"</code> for a complete data design. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Optional data frame containing variables named as <code>id</code>, <code>conc</code>, <code>time</code> and <code>group</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculation of confidence intervals for an AUC (from 0 to the last time point) or for the difference between two AUCs for serial sampling, batch and complete data designs. In a serial sampling design only one measurement is available per subject, while in a batch design multiple (but not necessarily all) time points are measured for each subject. In a complete data design measurements are taken for all subjects at all time points. The AUC (from 0 to the last time point) is calculated using the linear trapezoidal rule on the arithmetic means at the different time points.<br><br></p>
<p>If group=NULL a confidence interval for an AUC is calculated. If group specifies a factor variable with exactly two levels, a confidence interval for the difference between two independent AUCs is calculated. To obtain confidence intervals for dependent AUCs simply use the difference in concentrations for <code>conc</code>. See the example below.<br><br></p>
<p>The <code>t</code> method uses the critical value from a t-distribution with Satterthwaite's approximation (Satterthwaite, 1946) to the degrees of freedom for calculation of confidence intervals as presented in Tang-Liu and Burke (1988), Nedelman et al (1995), Holder et al (1999), Jaki and Wolfsegger (2009) and Jaki and Wolfsegger (2012). The <code>z</code> method uses the critical value from a normal distribution for calculation of confidence intervals as presented in Bailer (1988) or in Jaki and Wolfsegger (2009). The <code>boott</code> method uses bootstrap-<em>t</em> confidence intervals as presented in Jaki and Wolfsegger (2009). Using <code>boott</code> an additional strata variable for bootstrapping can be specified in the case of serial sampling. <br><br></p>
<p>For serial sampling designs missing data are omitted and unequal sample sizes per time point are allowed. For batch designs missing values are not permitted and at least two subjects are required per batch.<br><br></p>
<p>If <code>data</code> is specified the variable names <code>conc</code>, <code>time</code> and <code>group</code> are required and represent the corresponding variables. If <code>design</code> is <code>batch</code> an additional variable <code>id</code> is required to identify the subject.<br><br></p>
<p>NOTE: Confidence intervals for AUCs assessed in complete data designs are found using a batch design with one batch based on the asymptotic normal distribution. Conventionally, AUCs are assumed to be log-normal distributed. See the help file auc.complete for some corresponding examples.
</p>


<h3>Value</h3>

<p>An object of the class PK  containing the following components: <br></p>
<table>
<tr style="vertical-align: top;">
<td><code>est</code></td>
<td>
<p>Point estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CIs</code></td>
<td>
<p>Point estimates, standard errors and confidence intervals. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conc</code></td>
<td>
<p>Levels of concentrations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p>Confidence level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>Sampling design used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>Grouping variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>Time points measured.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This is a wrapper function for <code>auc.complete, auc.batch</code> and <code>auc.ssd</code>. 
The function calculates point and interval estimates for AUC (from 0 to the last time point).</p>


<h3>Author(s)</h3>

<p>Thomas Jaki and Martin J. Wolfsegger</p>


<h3>References</h3>

<p>Bailer A. J. (1988). Testing for the equality of area under the curves when using destructive measurement techniques. <em>Journal of Pharmacokinetics and Biopharmaceutics</em>, 16(3):303-309. <br><br></p>
<p>Gibaldi M. and Perrier D. (1982). <em>Pharmacokinetics</em>. Marcel Dekker, New York and Basel.<br><br></p>
<p>Holder D. J., Hsuan F., Dixit R. and Soper K. (1999). A method for estimating and testing area under the curve in serial sacrifice, batch, and complete data designs. <em>Journal of Biopharmaceutical Statistics</em>, 9(3):451-464.<br><br></p>
<p>Jaki T. and Wolfsegger M. J. (2012). Non-compartmental estimation of pharmacokinetic parameters for flexible sampling designs. <em>Statistics in Medicine</em>, 31(11-12):1059-1073. <br><br></p>
<p>Jaki T. and Wolfsegger M. J. (2009). A theoretical framework for estimation of AUCs in complete and incomplete sampling designs. <em>Statistics in Biopharmaceutical Research</em>, 1(2):176-184. <br><br></p>
<p>Nedelman J. R., Gibiansky E. and Lau D. T. W. (1995). Applying Bailer's method for AUC confidence intervals to sparse sampling. <em>Pharmaceutical Research</em>, 12(1):124-128. <br><br></p>
<p>Satterthwaite F. E. (1946). An approximate distribution of estimates of variance components. <em>Biometrics Bulletin</em>, 2:110-114.  <br><br></p>
<p>Tang-Liu D. D.-S. and Burke P. J. (1988). The effect of azone on ocular levobunolol absoprtion: Calculating the area under the curve and its standard error using tissue sampling compartments. <em>Pharmaceutical Research</em>, 5(4):238-241. <br><br></p>
<p>Wolfsegger M. J. and Jaki T. (2009) Assessing systemic drug exposure in repeated dose toxicity studies in the case of complete and incomplete sampling. <em>Biometrical Journal</em>, 51(6):1017:1029.<br></p>


<h3>See Also</h3>

<p><code>auc.complete</code>, <code>nca</code>, <code>eqv</code>, <code>estimator</code>, <code>ci</code> and <code>test</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">#### serial sampling design:
## example from Bailer (1988)
time &lt;- c(rep(0,4), rep(1.5,4), rep(3,4), rep(5,4), rep(8,4))
grp1 &lt;- c(0.0658, 0.0320, 0.0338, 0.0438, 0.0059, 0.0030, 0.0084,
          0.0080, 0.0000, 0.0017, 0.0028, 0.0055, 0.0000, 0.0037,
          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000)

grp2 &lt;- c(0.2287, 0.3824, 0.2402, 0.2373, 0.1252, 0.0446, 0.0638,
          0.0511, 0.0182, 0.0000, 0.0117, 0.0126, 0.0000, 0.0440,
          0.0039, 0.0040, 0.0000, 0.0000, 0.0000, 0.0000)

grp3 &lt;- c(0.4285, 0.5180, 0.3690, 0.5428, 0.0983, 0.0928, 0.1128,
          0.1157, 0.0234, 0.0311, 0.0344, 0.0349, 0.0032, 0.0052,
          0.0049, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000)

auc(conc=grp1, time=time, method='z', design='ssd')
auc(conc=grp2, time=time, method='z', design='ssd')
auc(conc=grp3, time=time, method='z', design='ssd')

## function call with data frame using simultaneous confidence intervals based 
## on bonferroni adjustment
data &lt;- data.frame(conc=c(grp1, grp2, grp3), time=rep(time, 3),
                   group=c(rep(1, length(grp1)), rep(2, length(grp2)), 
                   rep(3, length(grp3))))

auc(subset(data, group==1 | group==2)$conc, subset(data, group==1 | group==2)$time, 
    group=subset(data, group==1 | group==2)$group, method=c('z', 't'), 
    conf.level=1-0.05/3, design='ssd')

auc(subset(data, group==1 | group==3)$conc, subset(data, group==1 | group==2)$time, 
    group=subset(data, group==1 | group==3)$group, method=c('z', 't'), 
    conf.level=1-0.05/3, design='ssd')

auc(subset(data, group==2 | group==3)$conc, subset(data, group==1 | group==2)$time, 
    group=subset(data, group==2 | group==3)$group, method=c('z', 't'), 
    conf.level=1-0.05/3, design='ssd')

## example from Nedelman et al. (1995)
data(CPI975)
data &lt;- CPI975[CPI975[,'dose']&gt;=30 ,]

auc(data=subset(data,sex=='m' &amp; dose==30), method=c('z', 't'), design='ssd')
auc(data=subset(data,sex=='f' &amp; dose==30), method=c('z', 't'), design='ssd')

auc(data=subset(data,sex=='m' &amp; dose==100), method=c('z', 't'), design='ssd')
auc(data=subset(data,sex=='f' &amp; dose==100), method=c('z', 't'), design='ssd')

## comparing dose levels
data$concadj &lt;- data$conc / data$dose
data.100 &lt;- subset(data, dose==100)
data.030 &lt;- subset(data, dose==30)
res.100 &lt;- auc(conc=data.030$concadj, time=data.030$time, method='t', design='ssd')
res.030 &lt;- auc(conc=data.100$concadj, time=data.100$time, method='t', design='ssd')
plot(res.030, ylim=c(0, 140), xlim=c(0,25), pch=19, ylab='Dose-normalized concentration', 
      main='Comparison of doses')
plot(res.100, col='red', pch=21, add=TRUE)
legend(x=25, y=140, xjust=1, lty=1, col=c('black','red'), 
       legend=c('Dose of 30', 'Dose of 100'))

res &lt;- auc(conc=data$concadj, time=data$time, group=data$dose, method=c('t','z'), 
            design='ssd')
print(res)
summary(res)

## comparing two dose level using stratified resampling per gender
## caution this might take a few minutes
set.seed(260151)
auc(conc=data$concadj, time=data$time, group=data$dose, method='boott',
    strata=data$sex, design='ssd', nsample=500)

#### batch design:
## a batch design example from Holder et al. (1999).
data(Rats)
data &lt;- subset(Rats,Rats$dose==100)

# two-sided CI: data call
auc(data=data,method=c('z','t'), design='batch')
# one-sided CI: data call
auc(data=data,method=c('z','t'), alternative="less", design='batch')

## difference of two AUCs in batch design from Jaki and Wolfsegger (2009),
## originally in Holder et al. (1999).
data &lt;- subset(Rats,Rats$dose==100 | Rats$dose==300 )
data$group &lt;- data$dose
data$conc &lt;- data$conc / data$dose

## data call
res1 &lt;- auc(data=subset(data, dose==100), method='z', design='batch')
res2 &lt;- auc(data=subset(data, dose==300), method='z', design='batch')
plot(res1, col='black', ylim=c(0,0.06), xlim=c(0,25), ylab='Dose-normalized concentration', 
      main='Comparison of doses')
plot(res2, col='red', add=TRUE)
legend(x=0, y=0.06, lty=1, col=c('black','red'), 
       legend=c('Dose of 100', 'Dose of 300'))

auc(data=data, method='z', design='batch')


## difference of two dependent AUCs in a batch design from Wolfsegger and Jaki (2009)
conc &lt;- list(batch1=c(0.46,0.2,0.1,0.1, 1.49,1.22,1.27,0.53, 0.51,0.36,0.44,0.28),
             batch2=c(1.51,1.80,2.52,1.91, 0.88,0.66,0.96,0.48),
             batch3=c(1.52,1.46,2.55,1.04, 0.54,0.61,0.55,0.27))
time &lt;- list(batch1=c(0,0,0,0,1.5,1.5,1.5,1.5,10.5,10.5,10.5,10.5),
             batch2=c(5/60,5/60,5/60,5/60,4,4,4,4),
             batch3=c(0.5,0.5,0.5,0.5,7,7,7,7))
group &lt;- list(batch1=c(1,1,2,2,1,1,2,2,1,1,2,2),batch2=c(1,1,2,2,1,1,2,2),
              batch3=c(1,1,2,2,1,1,2,2))

# find difference in concentration and the corresponding times
dconc &lt;- NULL
dtime &lt;- NULL
grps &lt;- unique(unlist(group))
B &lt;- length(conc)
for(i in 1:B){
    dconc[[i]] &lt;- conc[[i]][group[[i]]==grps[1]] - conc[[i]][group[[i]]==grps[2]]
    dtime[[i]] &lt;- time[[i]][group[[i]]==grps[1]]
}
names(dconc) &lt;- names(conc)

auc(conc=dconc, time=dtime, group=NULL, method="t", conf.level=0.90, design="batch")

## example with overlapping batches (Treatment A in Example of Jaki &amp; Wolfsegger 2012)
conc &lt;- list(batch1=c(0,0,0,0, 69.7,37.2,213,64.1,  167,306,799,406, 602,758,987,627,
                      1023,1124,1301,880, 1388,1374,1756,1120, 1481,1129,1665,1598,
                      1346,1043,1529,1481, 658,576,772,851, 336,325,461,492, 
                      84,75.9,82.6,116),
             batch2=c(0,0,0, 29.2,55.9,112.2, 145,153,169, 282,420,532, 727,1033,759, 
                      1360,1388,1425, 1939,1279,1318, 1614,1205,1542, 1238,1113,1386,
                      648,770,786, 392,438,511, 77.3,90.1,97.9))
time &lt;- list(batch1=rep(c(0,0.5,0.75,1,1.5,2,3,4,8,12,24),each=4),
             batch2=rep(c(0,0.25,0.5,0.75,1,1.5,2,3,4,8,12,24),each=3))

auc.batch(conc,time,method=c("t","z"),conf.level=0.9)

#### complete data design:
## example from Gibaldi and Perrier (1982, page 436) for an individual AUC
time &lt;- c(0, 0.165, 0.5, 1, 1.5, 3, 5, 7.5, 10)
conc &lt;- c(0, 65.03, 28.69, 10.04, 4.93, 2.29, 1.36, 0.71, 0.38)
auc(conc=conc, time=time, design="complete")

## data Indometh
require(datasets)
Indometh$id &lt;- as.character(Indometh$Subject)
Indometh &lt;- Indometh[order(Indometh$id, Indometh$time),]
Indometh &lt;- Indometh[order(Indometh$time),]
res &lt;- auc.complete(conc=Indometh$conc, time=Indometh$time, method='t')
plot(res)

## more informative plot 
split.screen(c(1,2))
screen(1)
plot(x=c(0,8), y=c(0, 3), type='n', main='Observed concentration time-profiles', 
     xlab='Time', ylab='Concentration', las=1)
for(i in unique(Indometh$Subject)){
   temp &lt;- subset(Indometh, Subject==i)
   points(x=temp$time, y=temp$conc, type='b')
}
screen(2)
plot(x=c(0,8), y=c(0.01, 9), type='n', main='Log-linear concentration time-profiles', 
     xlab='Time', ylab='Log of concentration', yaxt='n', log='y')
axis(side=2, at=c(0.01, 0.1, 1, 10), labels=c('0.01', '0.1', '1', '10'), las=1)
axis(side=2, at=seq(0.01, 0.1, 0.01), tcl=-0.2, labels=FALSE)
axis(side=2, at=seq(0.1, 1, 0.1), tcl=-0.2, labels=FALSE)
axis(side=2, at=seq(1, 10, 1), tcl=-0.2, labels=FALSE)
for(i in unique(Indometh$Subject)){
   temp &lt;- subset(Indometh, Subject==i)
   points(x=temp$time, y=temp$conc, type='b')
}
close.screen(all = TRUE)
</code></pre>


</div>
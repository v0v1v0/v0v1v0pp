<div class="container">

<table style="width: 100%;"><tr>
<td>plrm.cv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Cross-validation bandwidth selection in PLR models
</h2>

<h3>Description</h3>

<p>From a sample <code class="reqn">{(Y_i, X_{i1}, ..., X_{ip}, t_i): i=1,...,n}</code>, this routine computes, for each <code class="reqn">l_n</code> considered, an optimal pair of bandwidths for estimating the regression function of the model
</p>
<p style="text-align: center;"><code class="reqn">Y_i= X_{i1}*\beta_1 +...+ X_{ip}*\beta_p + m(t_i) + \epsilon_i,</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\beta = (\beta_1,...,\beta_p)</code>
</p>

<p>is an unknown vector parameter and
</p>
<p style="text-align: center;"><code class="reqn">m(.)</code>
</p>

<p>is a smooth but unknown function.
The random errors, <code class="reqn">\epsilon_i</code>, are allowed to be time series. The optimal pair of bandwidths, (<code>b.opt, h.opt</code>), is selected by means of the leave-(<code class="reqn">2l_n + 1</code>)-out cross-validation procedure. The bandwidth <code>b.opt</code> is used in the estimate of <code class="reqn">\beta</code>, while the pair of bandwidths <code>(b.opt, h.opt)</code> is considered in the estimate of <code class="reqn">m</code>. Kernel smoothing, combined with ordinary least squares estimation, is used.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plrm.cv(data = data, b.equal.h = TRUE, b.seq=NULL, h.seq=NULL, 
num.b = NULL, num.h = NULL, w = NULL, num.ln = 1, ln.0 = 0, 
step.ln = 2, estimator = "NW", kernel = "quadratic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p><code>data[,1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2:(p+1)]</code> contains the values of the "linear" explanatory variables,
</p>
<p><code class="reqn">X_1, ..., X_p</code>;
</p>
<p><code>data[, p+2]</code> contains the values of the "nonparametric" explanatory variable, <code class="reqn">t</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.equal.h</code></td>
<td>
<p>if TRUE (the default), the same bandwidth is used for estimating both <code class="reqn">\beta</code> and <code class="reqn">m</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.seq</code></td>
<td>
<p>sequence of considered bandwidths, <code>b</code>, in the CV function for estimating <code class="reqn">\beta</code>. If <code>NULL</code> (the default), <code>num.b</code> equidistant values between zero and a quarter of the range of <code class="reqn">{t_i}</code> are considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h.seq</code></td>
<td>
<p>sequence of considered bandwidths, <code>h</code>, in the pair of bandwidths <code>(b, h)</code> used in the CV function for estimating <code class="reqn">m</code>. If <code>NULL</code> (the default), <code>num.h</code> equidistant values between zero and a quarter of the range of <code class="reqn">t_i</code> are considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.b</code></td>
<td>
<p>number of values used to build the sequence of considered bandwidths for estimating <code class="reqn">\beta</code>. If <code>b.seq</code> is not <code>NULL</code>, <code>num.b=length(b.seq)</code>. Otherwise, if both <code>num.b</code> and <code>num.h</code> are <code>NULL</code> (the default), <code>num.b=50</code> is considered; if <code>num.b</code> is <code>NULL</code> (the default) but <code>num.h</code> is not <code>NULL</code>, then <code>num.b=num.h</code> is considered; if <code>b.equal.h=TRUE</code> (the default) and both <code>num.b</code> and <code>num.h</code> are not <code>NULL</code> and different, the maximum value of <code>num.b</code> and <code>num.h</code> is considered for both.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.h</code></td>
<td>
<p>pairs of bandwidths (<code>b, h</code>) are used for estimating <code class="reqn">m</code>, <code>num.h</code> being the number of values considered for <code>h</code>. If <code>h.seq</code> is not <code>NULL</code>, <code>num.h=length(h.seq)</code>. Otherwise, if both <code>num.b</code> and <code>num.h</code> are <code>NULL</code> (the default), <code>num.h=50</code> is considered; if <code>num.h</code> is <code>NULL</code> (the default) but <code>num.b</code> is not <code>NULL</code>, <code>num.h=num.b</code> is considered; if <code>b.equal.h=TRUE</code> (the default) and both <code>num.b</code> and <code>num.h</code> are not <code>NULL</code> and different, the maximum value of <code>num.b</code> and <code>num.h</code> is considered for both.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>support interval of the weigth function in the CV function. If <code>NULL</code> (the default), <code class="reqn">(q_{0.1}, q_{0.9})</code> is considered, where <code class="reqn">q_p</code> denotes the quantile of order <code class="reqn">p</code> of <code class="reqn">{t_i}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.ln</code></td>
<td>
<p>number of values for <code class="reqn">l_n</code>: after estimating <code class="reqn">\beta</code>, <code class="reqn">2l_{n} + 1</code> observations around each point <code class="reqn">t_i</code> are eliminated to estimate <code class="reqn">m(t_i)</code> in the CV function. The default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ln.0</code></td>
<td>
<p>minimum value for <code class="reqn">l_n</code>. The default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step.ln</code></td>
<td>
<p>distance between two consecutives values of <code class="reqn">l_n</code>. The default is 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimator</code></td>
<td>
<p>allows us the choice between “NW” (Nadaraya-Watson) or “LLP” (Local Linear Polynomial). The default is “NW”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>allows us the choice between “gaussian”, “quadratic” (Epanechnikov kernel), “triweight” or “uniform” kernel. The default is “quadratic”.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A weight function (specifically, the indicator function <b>1</b><code class="reqn">_{[w[1] , w[2]]}</code>) is introduced in the CV function to allow elimination (or at least significant reduction) of boundary effects from the estimate of <code class="reqn">m(t_i)</code>.
</p>
<p>As noted in the definition of <code>num.ln</code>, the estimate of <code class="reqn">\beta</code> in the CV function is obtained from all data while, once <code class="reqn">\beta</code> is estimated, <code class="reqn">2l_{n} + 1</code> observations around each <code class="reqn">t_i</code> are eliminated to estimate <code class="reqn">m(t_i)</code> in the CV function. Actually, the estimate of <code class="reqn">\beta</code> to be used in time <code class="reqn">i</code> in the CV function could be done eliminating such <code class="reqn">2l_{n} + 1</code> observations too; that possibility was not implemented because both their computational cost and the known fact that the estimate of <code class="reqn">\beta</code> is quite insensitive to the bandwidth selection.
</p>
<p>The implemented procedure generalizes that one in expression (8) in Aneiros-Perez and Quintela-del-Rio (2001) by including a weight function (see above) and allowing two smoothing parameters instead of only one (see Aneiros-Perez <em>et al.</em>, 2004).
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bh.opt</code></td>
<td>
<p>dataframe containing, for each <code>ln</code> considered, the selected value for <code>(b,h)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CV.opt</code></td>
<td>
<p><code>CV.opt[k]</code> is the minimum value of the CV function when de k-th value of <code>ln</code> is considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CV</code></td>
<td>
<p>an array containing the values of the CV function for each pair of bandwidths and <code>ln</code> considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.seq</code></td>
<td>
<p>sequence of considered bandwidths, <code>b</code>, in the CV function for estimating <code class="reqn">\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h.seq</code></td>
<td>
<p>sequence of considered bandwidths, <code>h</code>, in the pair of bandwidths <code>(b, h)</code> used in the CV function for estimating <code class="reqn">m</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>support interval of the weigth function in the CV function.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Aneiros-Perez, G., Gonzalez-Manteiga, W. and Vieu, P. (2004) Estimation and testing in a partial linear regression under long-memory dependence. <em>Bernoulli</em> <b>10</b>, 49-78.
</p>
<p>Aneiros-Perez, G. and Quintela-del-Rio, A. (2001) Modified cross-validation in semiparametric regression models with dependent errors. <em>Comm. Statist. Theory Methods</em> <b>30</b>, 289-307.
</p>
<p>Chu, C-K and Marron, J.S. (1991) Comparison of two bandwidth selectors with dependent errors. <em>The Annals of Statistics</em> <b>19</b>, 1906-1918.
</p>


<h3>See Also</h3>

<p>Other related functions are: <code>plrm.beta</code>, <code>plrm.est</code>, <code>plrm.gcv</code>, <code>np.est</code>, <code>np.gcv</code> and <code>np.cv</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data,1:nrow(data))

aux &lt;- plrm.cv(data, step.ln=1, num.ln=2)
aux$bh.opt
plot.ts(aux$CV[,-2,])

par(mfrow=c(2,1))
plot(aux$b.seq,aux$CV[,-2,1], xlab="h", ylab="CV", type="l", main="ln=0")
plot(aux$b.seq,aux$CV[,-2,2], xlab="h", ylab="CV", type="l", main="ln=1")



# EXAMPLE 2: SIMULATED DATA
## Example 2a: independent data

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
beta &lt;- c(0.05, 0.01)
m &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m(t)

x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- rnorm(n, 0, 0.01)
y &lt;-  sum + f + epsilon
data_ind &lt;- matrix(c(y,x,t),nrow=100)

# We apply the function
a &lt;-plrm.cv(data_ind)
a$CV.opt

CV &lt;- a$CV
h &lt;- a$h.seq
plot(h, CV,type="l")


## Example 2b: dependent data and ln.0 &gt; 0

set.seed(1234)
# We generate the data
x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y &lt;-  sum + f + epsilon
data_dep &lt;- matrix(c(y,x,t),nrow=100)

# We apply the function
a &lt;-plrm.cv(data_dep, ln.0=2)
a$CV.opt

CV &lt;- a$CV
h &lt;- a$h.seq
plot(h, CV,type="l")

</code></pre>


</div>
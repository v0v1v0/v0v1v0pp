<div class="container">

<table style="width: 100%;"><tr>
<td>searchAM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Search for certain nodes in a DAG/CPDAG/MAG/PAG</h2>

<h3>Description</h3>

<p>Searches for all ancestors, descendants, anteriors, spouses, neighbors,
parents, children or possible descendants of a (set of) node(s) 
in a DAG, CPDAG, MAG or PAG.
</p>


<h3>Usage</h3>

<pre><code class="language-R">searchAM(amat,x,
	 type = c("an", "de", "ant", "sp", "nb", "pa", "ch", "pde"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>amat</code></td>
<td>
<p>Adjacency matrix of type amat.pag.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Target node(s), given as (a vector of) column number(s) 
of the node(s) in the adjacency matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character string specifying which relation to the
target nodes in <code>x</code> is asked for. It can be one of:
</p>

<dl>
<dt>"an"</dt>
<dd>
<p>ancestors: nodes <code>y</code> s.t. <code>y--&gt;...--&gt;x</code>;</p>
</dd>
<dt>"de"</dt>
<dd>
<p>descendants: nodes <code>y</code> s.t. <code>y&lt;--...&lt;--x</code>;</p>
</dd>
<dt>"ant"</dt>
<dd>
<p>anteriors: nodes <code>y</code> s.t. <code>y---...---z--&gt;...--&gt;x</code>,
i.e. there is an undirected path from <code>y</code> to a node <code>z</code>
followed by a directed path from <code>z</code> to <code>x</code>;</p>
</dd>
<dt>"sp"</dt>
<dd>
<p>spouses: nodes <code>y</code> s.t. <code>y&lt;-&gt;x</code>;</p>
</dd>
<dt>"nb"</dt>
<dd>
<p>neighbors: nodes <code>y</code> s.t. <code>y---x</code>;</p>
</dd>
<dt>"pa"</dt>
<dd>
<p>parents: nodes <code>y</code> s.t. <code>y--&gt;x</code>;</p>
</dd>
<dt>"ch"</dt>
<dd>
<p>children: nodes <code>y</code> s.t. <code>y&lt;--x</code>;</p>
</dd>
<dt>"pde"</dt>
<dd>
<p>possible descendants: nodes <code>y</code> s.t. there is a possibly
directed path from <code>y</code> to <code>x</code>: <code>y {o,-}--{o,&gt;} ... {o,-}--{o,&gt;} x</code>.</p>
</dd>
</dl>
<p>For the precise definitions of these concepts, see the references.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs a search for nodes related to the set of target nodes <code>x</code> 
in the way specified by <code>type</code> in adjacency matrix <code>amat</code> of type amat.pag.
</p>


<h3>Value</h3>

<p>Vector of column numbers of the nodes related to <code>x</code> as specified by <code>type</code>.
</p>


<h3>Author(s)</h3>

<p>Joris Mooij.
</p>


<h3>References</h3>

<p>T.S. Richardson and P. Spirtes (2002). Ancestral graph Markov models.
<em>Annals of Statistics</em> <b>30</b> 962-1030.
</p>
<p>J. Zhang (2008). Causal Reasoning with Ancestral Graphs.
<em>Journal of Machine Learning Research</em> <b>9</b> 1437-1474.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Y-structure MAG
# Encode as adjacency matrix
p &lt;- 10 # total number of variables
V &lt;- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10") # variable labels
# amat[i,j] = 0 iff no edge btw i,j
# amat[i,j] = 1 iff i *-o j
# amat[i,j] = 2 iff i *-&gt; j
# amat[i,j] = 3 iff i *-- j
amat &lt;- rbind(c(0,3,0,0,0,0,0,0,0,0),
              c(3,0,3,0,0,0,0,0,0,0),
              c(0,3,0,2,0,0,0,0,0,0),
              c(0,0,3,0,2,0,0,0,0,0),
              c(0,0,0,3,0,2,0,2,2,1),
              c(0,0,0,0,3,0,2,0,0,0),
              c(0,0,0,0,0,3,0,0,0,0),
              c(0,0,0,0,2,0,0,0,0,0),
              c(0,0,0,0,1,0,0,0,0,0),
              c(0,0,0,0,1,0,0,0,0,0))
rownames(amat)&lt;-V
colnames(amat)&lt;-V

stopifnot(all.equal(searchAM(amat,5,type = "an"), c(3,4,5))) # ancestors of X5
stopifnot(all.equal(searchAM(amat,5,type = "de"), c(5,6,7))) # descendants of X5
stopifnot(all.equal(searchAM(amat,5,type = "ant"), c(1,2,3,4,5))) # anteriors of X5
stopifnot(all.equal(searchAM(amat,5,type = "sp"), c(8))) # spouses of X5
stopifnot(all.equal(searchAM(amat,2,type = "nb"), c(1,3))) # neighbors of X2
stopifnot(all.equal(searchAM(amat,c(4,6),type = "pa"), c(3,5))) # parents of {X4,X6}
stopifnot(all.equal(searchAM(amat,c(3,5),type = "ch"), c(4,6))) # children of {X3,X5}
stopifnot(all.equal(searchAM(amat,5,type = "pde"), c(5,6,7,9,10))) # possible descendants of X5
</code></pre>


</div>
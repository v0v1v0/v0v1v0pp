<div class="container">

<table style="width: 100%;"><tr>
<td>pdDepth</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Data depth for HPD matrices</h2>

<h3>Description</h3>

<p><code>pdDepth</code> calculates the data depth of a HPD matrix with respect
to a given data cloud (i.e., a sample or collection) of HPD matrices, or the integrated
data depth of a sequence (curve) of HPD matrices with respect to a given data cloud of
sequences (curves) of HPD matrices as detailed in (Chau et al. 2019).
</p>


<h3>Usage</h3>

<pre><code class="language-R">pdDepth(y = NULL, X, method = "gdd", metric = "Riemannian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>either a <code class="reqn">(d,d)</code>-dimensional HPD matrix, or a <code class="reqn">(d, d, n)</code>-dimensional array corresponding to a sequence
or curve of HPD matrices. Defaults to <code>NULL</code>, in which case the data depth of each individual object in <code>X</code>
with respect to the data cloud <code>X</code> itself is calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>depending on the input <code>y</code>, <code>X</code> is either a <code class="reqn">(d,d,S)</code>-dimensional array corresponding to a data cloud of
<code class="reqn">S</code> individual HPD matrices, or a <code class="reqn">(d,d,n,S)</code>-dimensional array corresponding to a data cloud of <code class="reqn">S</code>
sequences or curves of <code class="reqn">n</code> individual Hermitian PD matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the data depth measure, one of <code>'gdd'</code>, <code>'zonoid'</code> or <code>'spatial'</code> corresponding to
the geodesic distance depth, intrinsic zonoid depth, and intrinsic spatial depth respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>the metric that the space of HPD matrices is equipped with. The default choice is <code>"Riemannian"</code>,
but this can also be one of: <code>"logEuclidean"</code>, <code>"Cholesky"</code>, <code>"rootEuclidean"</code> or
<code>"Euclidean"</code>. See also the Details section below.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Available pointwise or integrated intrinsic data depth functions for samples of HPD matrices are: (i)
geodesic distance depth, (ii) intrinsic zonoid depth and (iii) intrinsic spatial depth.
The various data depth measures and their theoretical properties are described in
(Chau et al. 2019). If <code>y</code> is a <code class="reqn">(d,d)</code>-dimensional HPD matrix, <code>X</code> should be a <code class="reqn">(d,d,S)</code>-dimensional array
corresponding to a length <code>S</code> sequence of <code class="reqn">(d,d)</code>-dimensional HPD matrices and the pointwise
data depth values are computed. If <code>y</code> is a sequence of <code class="reqn">(d,d)</code>-dimensional HPD matrices of length <code>n</code>
(i.e., <code class="reqn">(d,d,n)</code>-dimensional array), <code>X</code> should be a <code class="reqn">(d,d,n,S)</code>-dimensional array of replicated sequences of HPD matrices
and the integrated data depth values according to (Chau et al. 2019) are computed. If <code>is.null(y)</code>, the data depth
of each individual object (i.e., a HPD matrix or a sequence of HPD matrices) in <code>X</code> is computed with
respect to the data cloud <code>X</code>. <br>
The function computes the intrinsic data depth values based on the metric space of HPD matrices equipped with
one of the following metrics: (i) Riemannian metric (default) as detailed in e.g., (Bhatia 2009)[Chapter 6] or
(Pennec et al. 2006), (ii) log-Euclidean metric, the Euclidean inner product between matrix logarithms,
(iii) Cholesky metric, the Euclidean inner product between Cholesky decompositions, (iv) Euclidean metric and
(v) root-Euclidean metric. The default choice (Riemannian) has several properties not shared by the
other metrics, see (Chau et al. 2019) for more details.
</p>


<h3>Value</h3>

<p>If <code>!is.null(y)</code>, <code>pdDepth</code> returns the numeric depth value of <code>y</code> with
respect to <code>X</code>. If <code>is.null(y)</code>, <code>pdDepth</code> returns a numeric vector of length <code>S</code> corresponding to
the vector of depth values for each individual object in <code>X</code> with respect to <code>X</code> itself.
</p>


<h3>Note</h3>

<p>The function does not check for positive definiteness of the input matrices, and may fail
if matrices are close to being singular.
</p>
<p>The data depth computations under the Riemannian metric are more involved than under the other
metrics, and may therefore result in (significantly) higher computation times.
</p>


<h3>References</h3>

<p>Bhatia R (2009).
<em>Positive Definite Matrices</em>.
Princeton University Press, New Jersey.<br><br> Chau J, Ombao H, von
Sachs R (2019).
“Intrinsic data depth for Hermitian positive definite matrices.”
<em>Journal of Computational and Graphical Statistics</em>, <b>28</b>(2), 427–439.
doi: <a href="https://doi.org/10.1080/10618600.2018.1537926">10.1080/10618600.2018.1537926</a>.<br><br> Pennec X, Fillard P, Ayache N (2006).
“A Riemannian framework for tensor computing.”
<em>International Journal of Computer Vision</em>, <b>66</b>(1), 41–66.
</p>


<h3>See Also</h3>

<p><code>pdDist</code>, <code>pdRankTests</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Pointwise depth
X1 &lt;- replicate(50, Expm(diag(2), H.coeff(rnorm(4), inverse = TRUE)))
pdDepth(y = diag(2), X = X1) ## depth of one point
pdDepth(X = X1) ## depth of each point in the data cloud

## Integrated depth
X2 &lt;- replicate(50, replicate(5, Expm(diag(2), H.coeff(rnorm(4), inverse = TRUE))))
pdDepth(y = replicate(5, diag(2)), X2, method = "zonoid", metric = "logEuclidean")
pdDepth(X = X2, method = "zonoid", metric = "logEuclidean")

</code></pre>


</div>
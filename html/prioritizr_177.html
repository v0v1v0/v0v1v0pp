<div class="container">

<table style="width: 100%;"><tr>
<td>constraints</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Conservation problem constraints</h2>

<h3>Description</h3>

<p>A constraint can be added to a conservation planning problem
to ensure that solutions exhibit a specific characteristic.
</p>


<h3>Details</h3>

<p>Constraints can be used to ensure that solutions exhibit
a range of different characteristics. For instance, they can be
used to lock in or lock out certain planning units from the solution, such
as protected areas or degraded land (respectively).
Additionally, similar to the penalties functions,
some of the constraint functions can be used to increase connectivity in a
solution. The key difference between a penalty and a constraint, however,
is that constraints work by invalidating solutions that do not exhibit
a specific characteristic, whereas penalty functions work by than
penalizing solutions which do not meet a specific characteristic. Thus
constraints do not affect the objective function. The following constraints
are available.
</p>
<p>The following constraints can be added to a conservation planning
<code>problem()</code>:
</p>

<dl>
<dt><code>add_locked_in_constraints()</code></dt>
<dd>
<p>Add constraints to ensure
that certain planning units are selected in the solution.</p>
</dd>
<dt><code>add_locked_out_constraints()</code></dt>
<dd>
<p>Add constraints to ensure
that certain planning units are not selected in the solution.</p>
</dd>
<dt><code>add_neighbor_constraints()</code></dt>
<dd>
<p>Add constraints to
ensure that all selected planning units have at least a certain number
of neighbors.</p>
</dd>
<dt><code>add_contiguity_constraints()</code></dt>
<dd>
<p>Add constraints to a
ensure that all selected planning units are spatially connected to each
other and form a single contiguous unit.</p>
</dd>
<dt><code>add_feature_contiguity_constraints()</code></dt>
<dd>
<p>Add constraints to
ensure that each feature is represented in a contiguous unit of
dispersible habitat. These constraints are a more advanced version of
those implemented in the <code>add_contiguity_constraints()</code>
function, because they ensure that each feature is represented in a
contiguous unit and not that the entire solution should form a
contiguous unit.</p>
</dd>
<dt><code>add_linear_constraints()</code></dt>
<dd>
<p>Add constraints to ensure that all selected planning units meet certain
criteria. For example, they can be used to add
multiple budgets, or limit the number of
planning units selected in different administrative areas within a study
region (e.g., different countries).</p>
</dd>
<dt><code>add_mandatory_allocation_constraints()</code></dt>
<dd>
<p>Add constraints to ensure that every planning unit is allocated to a
management zone in the solution. <strong>This function can only be used
with problems that contain multiple zones.</strong></p>
</dd>
</dl>
<h3>See Also</h3>

<p>Other overviews: 
<code>decisions</code>,
<code>importance</code>,
<code>objectives</code>,
<code>penalties</code>,
<code>portfolios</code>,
<code>solvers</code>,
<code>summaries</code>,
<code>targets</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_locked_in_raster &lt;- get_sim_locked_in_raster()
sim_locked_out_raster &lt;- get_sim_locked_in_raster()

# create minimal problem with only targets and no additional constraints
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with locked in constraints
p2 &lt;- p1 %&gt;% add_locked_in_constraints(sim_locked_in_raster)

# create problem with locked in constraints
p3 &lt;- p1 %&gt;% add_locked_out_constraints(sim_locked_out_raster)

# create problem with neighbor constraints
p4 &lt;- p1 %&gt;% add_neighbor_constraints(2)

# create problem with contiguity constraints
p5 &lt;- p1 %&gt;% add_contiguity_constraints()

# create problem with feature contiguity constraints
p6 &lt;- p1 %&gt;% add_feature_contiguity_constraints()

# solve problems
s &lt;- terra::rast(lapply(list(p1, p2, p3, p4, p5, p6), solve))
names(s) &lt;- c(
  "minimal problem", "locked in", "locked out",
  "neighbor", "contiguity", "feature contiguity"
)

# plot solutions
plot(s, axes = FALSE, nr = 2)

## End(Not run)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>residuals</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract Model Residuals</h2>

<h3>Description</h3>

<p>A generic function to simulate surrogate residuals for cumulative link
regression models using the latent method described in Liu and Zhang (2017).
</p>
<p>It also support the sign-based residuals (Li and Shepherd, 2010), generalized
residuals (Franses and Paap, 2001), and deviance residuals for cumulative link
regression models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'clm'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S3 method for class 'lrm'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S3 method for class 'orm'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S3 method for class 'polr'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S4 method for signature 'vglm'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S4 method for signature 'vgam'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S3 method for class 'ord'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance", "pearson", "working",
    "response", "partial"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S3 method for class 'PAsso'
residuals(object, draw_id = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>PAsso</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of residuals which should be returned. The alternatives
are: "surrogate" (default), "sign", "general", and "deviance". Can be abbreviated.
</p>

<dl>
<dt><code>surrogate</code></dt>
<dd>
<p>surrogate residuals (Liu and Zhang, 2017);</p>
</dd>
<dt><code>sign</code></dt>
<dd>
<p>sign-based residuals;</p>
</dd>
<dt><code>general</code></dt>
<dd>
<p>generalized residuals (Franses and Paap, 2001);</p>
</dd>
<dt><code>deviance</code></dt>
<dd>
<p>deviance residuals (-2*loglik).</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter</code></td>
<td>
<p>When the <code>type = "surrogate"</code>, this argument is a character string
specifying which method to use to generate the surrogate response values. Current
options are <code>"latent"</code> and <code>"uniform"</code>. Default is <code>"latent"</code>.
</p>

<dl>
<dt><code>latent</code></dt>
<dd>
<p>latent approach;</p>
</dd>
<dt><code>uniform</code></dt>
<dd>
<p>jittering uniform approach.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter.uniform.scale</code></td>
<td>
<p>When the <code>jitter = "uniform"</code>, this is a character
string specifying the scale on which to perform the jittering whenever
<code>jitter = "uniform"</code>. Current options are <code>"response"</code> and <code>"probability"</code>.
Default is <code>"response"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>An integer specifying the number of replicates to use.
Default is <code>1L</code> meaning one simulation only of residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional optional arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>draw_id</code></td>
<td>
<p>A number refers to the i-th draw of residuals.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numeric vector of class <code>c("numeric", "resids")</code> containing
the simulated surrogate residuals. Additionally, if <code>nsim</code> &gt; 1,
then the result will contain the attributes:
</p>

<dl>
<dt><code>draws</code></dt>
<dd>
<p>A matrix with <code>nsim</code> columns, one for each
is a replicate of the surrogate residuals. Note, they correspond
to the original ordering of the data;</p>
</dd>
<dt><code>draws_id</code></dt>
<dd>
<p>A matrix  with <code>nsim</code> columns. Each column
contains the observation number each surrogate residuals corresponds to in
<code>draws</code>. (This is used for plotting purposes.)</p>
</dd>
</dl>
<p>A matrix of class <code>c("matrix", "resids")</code> containing
the simulated surrogate residuals used for the partial association
analysis in <code>PAsso</code>. Additionally, if <code>rep_num</code> &gt; 1 in <code>PAsso</code>,
then the result will contain the attributes:
</p>

<dl>
<dt><code>draws</code></dt>
<dd>
<p>An array contains all draws of residuals.</p>
</dd>
</dl>
<h3>Note</h3>

<p>Surrogate response values require sampling from a continuous distribution;
consequently, the result will be different with every call to
<code>surrogate</code>. The internal functions used for sampling from truncated
distributions are based on modified versions of
<code>rtrunc</code> and <code>qtrunc</code>.
</p>
<p>For <code>"glm"</code> objects, only the <code>binomial()</code> family is supported.
</p>


<h3>References</h3>

<p>Liu, D., Li, S., Yu, Y., &amp; Moustaki, I. (2020). Assessing partial association between
ordinal variables: quantification, visualization, and hypothesis testing. <em>Journal
of the American Statistical Association</em>, 1-14. doi: <a href="https://doi.org/10.1080/01621459.2020.1796394">10.1080/01621459.2020.1796394</a>
</p>
<p>Liu, D., &amp; Zhang, H. (2018). Residuals and diagnostics for ordinal regression models:
A surrogate approach. <em>Journal of the American Statistical Association</em>, 113(522), 845-854.
doi: <a href="https://doi.org/10.1080/01621459.2017.1292915">10.1080/01621459.2017.1292915</a>
</p>
<p>Li, C., &amp; Shepherd, B. E. (2010). Test of association between two ordinal variables
while adjusting for covariates. <em>Journal of the American Statistical Association</em>,
105(490), 612-620. doi: <a href="https://doi.org/10.1198/jasa.2010.tm09386">10.1198/jasa.2010.tm09386</a>
</p>
<p>Franses, P. H., &amp; Paap, R. (2001). <em>Quantitative models in marketing research</em>.
Cambridge University Press. doi: <a href="https://doi.org/10.1017/CBO9780511753794">10.1017/CBO9780511753794</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate data from a quadratic probit model
set.seed(101)
n &lt;- 2000
x &lt;- runif(n, min = -3, max = 6)
z &lt;- 10 + 3 * x - 1 * x^2 + rnorm(n)
y &lt;- ifelse(z &lt;= 0, yes = 0, no = 1)

# Scatterplot matrix
pairs(~ x + y + z)

# Misspecified mean structure
fm1 &lt;- glm(y ~ x, family = binomial(link = "probit"))
diagnostic.plot(fm1)

# Correctly specified mean structure
fm2 &lt;- glm(y ~ x + I(x ^ 2), family = binomial(link = "probit"))
diagnostic.plot(fm2)

# Load data
data("ANES2016")
PAsso_1 &lt;- PAsso(responses = c("PreVote.num", "PID"),
                 adjustments = c("income.num", "age", "edu.year"),
                 data = ANES2016)

# Compute residuals
res1 &lt;- residuals(PAsso_1)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>bilateral.index</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bilateral price indices</h2>

<h3>Description</h3>

<p>Calculation of bilateral price indices. Currently, the following ones are implemented (see below in alphabetic order).
</p>


<h3>Usage</h3>

<pre><code class="language-R">banerjee(p, r, n, q, base=NULL, settings=list())

bmw(p, r, n, base=NULL, settings=list())

carli(p, r, n, base=NULL, settings=list())

cswd(p, r, n, base=NULL, settings=list())

davies(p, r, n, q, base=NULL, settings=list())

drobisch(p, r, n, q, w=NULL, base=NULL, settings=list())

dutot(p, r, n, base=NULL, settings=list())

fisher(p, r, n, q, w=NULL, base=NULL, settings=list())

geolaspeyres(p, r, n, q, w=NULL, base=NULL, settings=list())

geopaasche(p, r, n, q, w=NULL, base=NULL, settings=list())

geowalsh(p, r, n, q, w=NULL, base=NULL, settings=list())

harmonic(p, r, n, base=NULL, settings=list())

jevons(p, r, n, base=NULL, settings=list())

laspeyres(p, r, n, q, w=NULL, base=NULL, settings=list())

lehr(p, r, n, q, base=NULL, settings=list())

lowe(p, r, n, q, base=NULL, settings=list())

medgeworth(p, r, n, q, base=NULL, settings=list())

paasche(p, r, n, q, w=NULL, base=NULL, settings=list())

palgrave(p, r, n, q, w=NULL, base=NULL, settings=list())

svartia(p, r, n, q, w=NULL, base=NULL, settings=list())

toernqvist(p, r, n, q, w=NULL, base=NULL, settings=list())

theil(p, r, n, q, w=NULL, base=NULL, settings=list())

uvalue(p, r, n, q, base=NULL, settings=list())

walsh(p, r, n, q, w=NULL, base=NULL, settings=list())

young(p, r, n, q, base=NULL, settings=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>A numeric vector of prices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r, n</code></td>
<td>
<p>A character vector or factor of regional entities <code>r</code> and products <code>n</code>, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q, w</code></td>
<td>
<p>A numeric vector of non-negative quantities <code>q</code> or expenditure share weights <code>w</code> (see details). Either <code>q</code> or <code>w</code> must be provided for weighted indices. If both <code>q</code> and <code>w</code> are provided, <code>q</code> will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>
<p>A character specifying the base region to which all price levels are expressed. If <code>NULL</code>, base region is set internally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>settings</code></td>
<td>
<p>A list of control settings to be used. The following settings are supported:
</p>

<ul>
<li> <p><code>chatty</code> : A logical specifying if warnings and info messages should be printed or not. The default is <code>getOption("pricelevels.chatty")</code>.
</p>
</li>
<li> <p><code>connect</code> : A logical specifying if the data should be checked for connectedness or not. The default is <code>getOption("pricelevels.connect")</code>. If the data are not connected, price levels are computed within the biggest block of connected regions or the block of regions to which the <code>base</code> region belongs. See also <code>connect()</code>.
</p>
</li>
<li> <p><code>plot</code> : A logical specifying if the calculated price levels should be plotted or not. If <code>TRUE</code>, the price ratios of each region are displayed as boxplots and the price levels are added as colored points. The default is <code>getOption("pricelevels.plot")</code>.
</p>
</li>
<li> <p><code>qbase</code> : A character specifying the region <code class="reqn">b</code> whose quantities (and prices) should be used in <code>lowe()</code> and <code>young()</code>. If <code>NULL</code>, prices are averaged and quantities added up for each product, i.e. <code class="reqn">p_i^b=\sum_{r=1}^{R} p_i^r / R</code> and <code class="reqn">q_i^b=\sum_{r=1}^{R} q_i^r</code>.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Before calculations start, missing values are excluded and duplicated observations for <code>r</code> and <code>n</code> are aggregated, that is, duplicated prices <code>p</code> and weights <code>w</code> are averaged and duplicated quantities <code>q</code> added up.
</p>
<p>The weights <code>w</code> must represent expenditure shares defined as <code class="reqn">w_i^r = p_i^r q_i^r / \sum_{j=1}^{N} p_j^r q_j^r</code>. They are internally (re-)normalized such that they add up to 1 for each region <code>r</code>.
</p>


<h3>Value</h3>

<p>A named vector of price levels.</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>References</h3>

<p>ILO, IMF, OECD, UNECE, Eurostat and World Bank (2020). <em>Consumer Price Index Manual: Concepts and Methods</em>. Washington DC: International Monetary Fund.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># sample complete price data:
set.seed(123)
dt1 &lt;- rdata(R=3, B=1, N=5)

# compute jevons and toernqvist index:
dt1[, jevons(p=price, r=region, n=product, base="1")]
dt1[, toernqvist(p=price, r=region, n=product, q=quantity, base="1")]

# compute lowe index using quantities of region 2:
dt1[, lowe(p=price, r=region, n=product, q=quantity, base="1",
           settings=list(qbase="2"))]

# add price data:
dt2 &lt;- rdata(R=4, B=1, N=4)
dt2[, "region":=factor(region, labels=4:7)]
dt2[, "product":=factor(product, labels=6:9)]
dt &lt;- rbind(dt1, dt2)
dt[, is.connected(r=region, n=product)] # non-connected now

# compute jevons and toernqvist index:
dt[, jevons(p=price, r=region, n=product, base="1")]

# change base region:
dt[, jevons(p=price, r=region, n=product, base="4")]
</code></pre>


</div>
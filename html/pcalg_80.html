<div class="container">

<table style="width: 100%;"><tr>
<td>mat2targets</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Conversion between an intervention matrix and a list of intervention 
targets</h2>

<h3>Description</h3>

<p>In a data set with <code class="reqn">n</code> measurements of <code class="reqn">p</code> variables, intervened
variables can be specified in two ways:
</p>

<ul>
<li>
<p> with a <code>logical</code> intervention matrix of dimension
<code class="reqn">n \times p</code>, where the entry <code>[i, j]</code> indicates whether 
variable <code class="reqn">j</code> has been intervened in measurement <code class="reqn">i</code>; or
</p>
</li>
<li>
<p> with a list of (unique) intervention targets and a 
<code class="reqn">p</code>-dimensional vector indicating the indices of the intervention
targets of the <code class="reqn">p</code> measurements.
</p>
</li>
</ul>
<p>The function <code>mat2targets</code> converts the first representation to the
second one, the function <code>targets2mat</code> does the reverse conversion.  The
second representation can be used to create scoring objects (see 
<code>Score</code>) and to run causal inference methods based on 
interventional data such as <code>gies</code> or <code>simy</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mat2targets(A)
targets2mat(p, targets, target.index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Logical matrix with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns, where <code class="reqn">n</code>
is the sample size of a data set with jointly interventional and 
observational data, and <code class="reqn">p</code> is the number of variables.  <code>A[i, j]</code>
is <code>TRUE</code> iff variable <code>j</code> is intervened in data point <code>i</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Number of variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targets</code></td>
<td>
<p>List of unique intervention targets</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target.index</code></td>
<td>
<p>Vector of intervention target indices.  The intervention
target of data point <code>i</code> is encoded as 
<code>targets[[target.index[i]]]</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>mat2targets</code> returns a list with two components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>targets</code></td>
<td>
<p>A list of unique intervention targets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target.index</code></td>
<td>
<p>A vector of intervention target indices. The intervention
target of data point <code>i</code> is encoded as 
<code>targets[[target.index[i]]]</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>See Also</h3>

<p><code>Score</code>, <code>gies</code>, <code>simy</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Specify interventions using a matrix
p &lt;- 5
n &lt;- 10
A &lt;- matrix(FALSE, nrow = n, ncol = p)
for (i in 1:n) A[i, (i-1) %% p + 1] &lt;- TRUE

## Generate list of intervention targets and corresponding indices
target.list &lt;- mat2targets(A)

for (i in 1:length(target.list$target.index))
  sprintf("Intervention target of %d-th data point: %d", 
    i, target.list$targets[[target.list$target.index[i]]]) 

## Convert back to matrix representation
all(A == targets2mat(p, target.list$targets, target.list$target.index))
</code></pre>


</div>
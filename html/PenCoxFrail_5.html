<div class="container">

<table style="width: 100%;"><tr>
<td>coxlasso</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
A LASSO approach for Cox Frailty Models.</h2>

<h3>Description</h3>

<p>A LASSO approach for Cox Frailty Models based on the Cox full likelihood is provided.
</p>


<h3>Usage</h3>

<pre><code class="language-R">coxlasso(fix=formula, rnd=NULL, vary.coef=NULL, data, xi, 
              adaptive.weights = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fix</code></td>
<td>
<p>a two-sided linear formula object describing the LASSO-penalized
fixed (time-constant) effects part of the model, with the response on the left of a
<code>~</code> operator and the terms, separated by <code>+</code> operators, on
the right. The response must be a survival object as returned by the <code>Surv</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rnd</code></td>
<td>
<p>a two-sided linear formula object describing the
random-effects part of the model, with the grouping factor on the left of a
<code>~</code> operator and the random terms, separated by <code>+</code> operators, on
the right.Default is NULL, so no random effects are present.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vary.coef</code></td>
<td>
<p>a one-sided linear formula object describing the
time-varying effects part of the model, with the time-varying terms, separated by <code>+</code> operators,
on the right side of a <code>~</code> operator.Default is NULL, so no time-varying effects are incorporated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the data frame containing the variables named in the three preceding
<code>formula</code> arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xi</code></td>
<td>
<p>the LASSO-penalty parameter that controls the strenght of the penalty term.
The optimal penalty parameter is a tuning parameter of the procedure that has to be determined, 
e.g. by K-fold cross validation (see <code>cv.coxlasso</code> for details or the quick demo for an example).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive.weights</code></td>
<td>
<p>for the LASSO-penalized fixed effects a vector of adaptive weights can be passed to the procedure. If no adaptive weights are specified, an unpenalized model (i.e. <code class="reqn">\xi=0</code>) is fitted by the <code>coxFL</code> function and the obtained estimates are used as adaptive weights (see value section).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control values for the estimation algorithm to replace the default values returned by the function <code>coxlassoControl</code>. Defaults to an empty list.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>coxlasso</code> algorithm is designed to investigate
the effect structure in the Cox frailty model, which is a
widely used model that accounts for heterogeneity in time-to-event data.
Since in survival models one has to account for possible variation of
the effect strength over time, some features can incorporated with time-varying effects. 
</p>
<p>The penalty is depending on the LASSO tuning parameter <code class="reqn">\xi</code>, which has to be determined by a suitable technique, e.g. by K-fold cross validation.
</p>

<table>
<tr>
<td style="text-align: left;">
Package: </td>
<td style="text-align: left;"> pencoxfrail</td>
</tr>
<tr>
<td style="text-align: left;">
Type: </td>
<td style="text-align: left;"> Package</td>
</tr>
<tr>
<td style="text-align: left;">
Version: </td>
<td style="text-align: left;"> 1.1.2</td>
</tr>
<tr>
<td style="text-align: left;">
Date: </td>
<td style="text-align: left;"> 2023-08-25</td>
</tr>
<tr>
<td style="text-align: left;">
License: </td>
<td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
<td style="text-align: left;">
LazyLoad: </td>
<td style="text-align: left;"> yes</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>for loading a dataset type data(nameofdataset)
</p>


<h3>Value</h3>

<p>Generic functions such as <code>print</code>, <code>predict</code>, <code>plot</code> and <code>summary</code> have methods to show the results of the fit.
</p>
<p>The <code>predict</code> function uses also estimates of random effects for prediction, if possible (i.e. for known subjects of the grouping factor). 
Either the survival stepfunction or the baseline hazard (not cumulative!) can be calculated by specifying one of two possible methods: <code>method=c("hazard","survival")</code>. By default, for each new subject in <code>new.data</code> an individual stepfunction is calculated on a pre-specified time grid, also accounting for covariate changes over time. Alternatively, for <code>new.data</code> a single vector of a specific (time-constant) covariate combination can be specified.
</p>
<p>Usage:  <code>
predict(coxlasso.obj,new.data,time.grid,method=c("hazard","survival"))
</code>     
</p>
<p>The <code>plot</code> function plots all time-varying effects, including the baseline hazard. 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>a list containing an image of the <code>coxlasso</code> call that produced the object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>baseline</code></td>
<td>
<p>a vector containing the estimated B-spline coefficients of the baseline hazard.
If the covariates corresponding to the time-varying effects are centered (and standardized, see <code>coxlassoControl</code>), the coefficients are transformed back to the original scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.vary</code></td>
<td>
<p>a vector containing the estimated B-spline coefficients of all time-varying effects.
If the covariates corresponding to the time-varying effects are standardized (see <code>coxlassoControl</code>) 
the coefficients are transformed back to the original scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a vector containing the estimated fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranef</code></td>
<td>
<p>a vector containing the estimated random effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>a scalar or matrix containing the estimates of the random effects standard deviation or variance-covariance parameters, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Delta</code></td>
<td>
<p>a matrix containing the estimates of fixed and random effects (columns) for each iteration (rows) of the main algorithm (i.e. before the final re-estimation step is performed, see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q_long</code></td>
<td>
<p>a list containing the estimates of the random effects variance-covariance parameters for each iteration of the main algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>number of iterations until the main algorithm has converged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive.weights</code></td>
<td>
<p>if not given as an argument by the user, a two-column matrix of adaptive weights is calculated by the <code>coxFL</code> function; the first column contains the weights <code class="reqn">w_{\Delta,k}</code>, the second column the weights <code class="reqn">v_{k}</code> from <code class="reqn">\xi\cdot J(\zeta,\alpha)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>vector of knots used in the B-spline representation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi.big</code></td>
<td>
<p>large B-spline design matrix corresponding to the baseline hazard and all time-varying effects. For the time-varying effects, the B-spline functions (as a function of time) have already been multiplied with their associated covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.grid</code></td>
<td>
<p>the time grid used in when approximating the (Riemann) integral involved in the model's full likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>number of metric covariates with time-varying effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m2</code></td>
<td>
<p>number of categorical covariates with time-varying effects.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Andreas Groll <a href="mailto:groll@statistik.tu-dortmund.de">groll@statistik.tu-dortmund.de</a> <br> Maike Hohberg <a href="mailto:mhohber@uni-goettingen.de">mhohber@uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>Groll, A., T. Hastie and G. Tutz (2017). 
Selection of Effects in Cox Frailty Models by
Regularization Methods. <em>Biometrics</em> 73(3): 846-856.
</p>


<h3>See Also</h3>

<p><code>coxlassoControl,cv.coxlasso,coxFL,Surv,pbc</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(lung)

# remove NAs
lung &lt;- lung[!is.na(lung$inst),]

# transform inst into factor variable
lung$inst &lt;- as.factor(lung$inst)

# just for illustration, create factor with only three ph.ecog classes
lung$ph.ecog[is.na(lung$ph.ecog)] &lt;- 2
lung$ph.ecog[lung$ph.ecog==3] &lt;- 2
lung$ph.ecog &lt;- as.factor(lung$ph.ecog)

fix.form &lt;- as.formula("Surv(time, status) ~ 1 + age + ph.ecog + sex")

lasso.obj &lt;- coxlasso(fix=fix.form, data=lung, xi=10,
                control=list(print.iter=TRUE, exact = 1))
coef(lasso.obj)             
                

# now add random institutional effect
lasso.obj2 &lt;- coxlasso(fix=fix.form, rnd = list(inst=~1), 
              data=lung, xi=10,control=list(print.iter=TRUE, exact = 1))
coef(lasso.obj2)             
# print frailty Std.Dev.
print(lasso.obj2$Q)
# print frailties
print(lasso.obj2$ranef)


# now fit a time-varying effect for age
fix.form &lt;- as.formula("Surv(time, status) ~ 1 + ph.ecog + sex")
vary.coef &lt;- as.formula("~ age")

lasso.obj3 &lt;- coxlasso(fix=fix.form,vary.coef=vary.coef,  
              data=lung, xi=10,control=list(print.iter=TRUE))
summary(lasso.obj3)

# show fit
plot(lasso.obj3)

# predict survival curve of new subject, institution 1 and up to time 300
pred.obj &lt;- predict(lasso.obj2, newdata=data.frame(inst=1, time=NA, status=NA, age=26,
              ph.ecog=2,sex=1), time.grid=seq(0,300,by=1))

# plot predicted hazard function
plot(pred.obj$time.grid,pred.obj$haz,type="l",xlab="time",ylab="hazard")

# plot predicted survival function
plot(pred.obj$time.grid,pred.obj$survival,type="l",xlab="time",ylab="survival")

## specify a larger new data set
new.data &lt;- data.frame(inst=c(1,1,6), time=c(20,40,200), 
      status=c(NA,NA,NA), age=c(26,26,54), ph.ecog=c(0,0,2),sex=c(1,1,1))

## as here no frailties have been specified, id.var needs to be given!
pred.obj2 &lt;- predict(lasso.obj3, newdata=new.data,id.var = "inst")

# plot predicted hazard functions (for the available time intervals)
plot(pred.obj2$time.grid[!is.na(pred.obj2$haz[,1])],
      pred.obj2$haz[,1][!is.na(pred.obj2$haz[,1])],
      type="l",xlab="time",ylab="hazard",xlim=c(0,200),
      ylim=c(0,max(pred.obj2$haz,na.rm=T)))
lines(pred.obj2$time.grid[!is.na(pred.obj2$haz[,3])],
      pred.obj2$haz[,3][!is.na(pred.obj2$haz[,3])],
      col="red",lty=2,)

# plot predicted survival functions (for the available time intervals)
plot(pred.obj2$time.grid[!is.na(pred.obj2$survival[,1])],
    pred.obj2$survival[,1][!is.na(pred.obj2$survival[,1])],
    type="l",xlab="time",ylab="hazard",xlim=c(0,200),
    ylim=c(0,max(pred.obj2$survival,na.rm=T)))
lines(pred.obj2$time.grid[!is.na(pred.obj2$survival[,3])],
      pred.obj2$survival[,3][!is.na(pred.obj2$survival[,3])],
      col="red",lty=2,)


# see also demo("coxlasso-lung")

## End(Not run)</code></pre>


</div>
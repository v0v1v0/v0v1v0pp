<div class="container">

<table style="width: 100%;"><tr>
<td>reporter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Turn a parser into an error reporting parser</h2>

<h3>Description</h3>

<p>Turns a parser into an error reporting parser, and when the parser is
successful returns only the <code>L</code>-element of the parser output, the
successfully parsed part of the input (see <code>succeed()</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">reporter(p)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a parser.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The error object that this function returns is a list containing the
elements <code>linenr</code> and <code>linecontent</code>, corresponding to the line in which the
parser failed and its content. The user of this package can catch this
object to create custom error messages instead of the message generated by
this function.
</p>
<p>A warning is issued when the parser did not completely consume the input.
Complete consumption of input is only explicitly made when the parser ends
with <code>eof()</code>. Therefore, even though all elements were parsed, a zero-length
character vector will remain in the <code>R</code> element if the parser does not end
with <code>eof()</code>.
</p>


<h3>Value</h3>

<p>The <code>L</code>-part of a successful parser result or an error message about
the line where the parser failed. A warning is thrown when the parser
did not completely consume the input.
</p>


<h3>Examples</h3>

<pre><code class="language-R">at &lt;- function() literal("a") %then% literal("t")
atat &lt;- rep(c("a","t"),2)
# Yields an error message about parser failing on line 5
try(
  reporter(match_n(3,at()) %then% eof())(c(atat,"t","t"))
)
# No error, but parser result
reporter(match_n(2,at()) %then% eof())(atat)
# warning: the input is not completely consumed
try(
  reporter(match_n(2,at()))(atat)
)

</code></pre>


</div>
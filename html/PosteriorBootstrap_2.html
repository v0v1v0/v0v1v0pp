<div class="container">

<table style="width: 100%;"><tr>
<td>draw_stick_breaks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Draw stick-breaks depending on a concentration parameter</h2>

<h3>Description</h3>

<p><code>draw_stick_breaks</code> returns a vector with the breaks of a stick of
length 1.
</p>


<h3>Usage</h3>

<pre><code class="language-R">draw_stick_breaks(
  concentration = 1,
  min_stick_breaks = 100,
  threshold = 1e-08,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>concentration</code></td>
<td>
<p>The parameter <code>c</code> in the paper (page 3, formula 3),
which is an effective sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_stick_breaks</code></td>
<td>
<p>The minimal number of stick-breaks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>The threshold of stick remaining below which the function
stops looking for more stick-breaks. It corresponds to epsilon in the
paper, at the bottom of page 5 and in algorithm 2 in page 12.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>A seed to start the sampling.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function implements the stick-breaking process for non-parametric
learning described in section 2 of the supplementary material. The name
"stick-breaking" comes from a stick of unit length that we need to break into
a number of items. This code implements algorithm 2 and the stick-breaking
function calculates the parameter T in algorithm 1, which is the only
difference between the two algorithms. The code uses the Beta distribution as
that distribution is part of the definition of the stick-breaking process.
The function draws from the beta distribution, e.g. <code>b_1</code>, <code>b_2</code>,
<code>b_3</code>, ..., and computes the stick breaks as <code>b_1</code>,
<code>(1-b_1)*b_2</code>, <code>(1-b_1)*(1-b_2)*b_3</code>, ... . The length remaining in
the stick at each step is <code>1-b_1</code>, <code>(1-b_1)* (1-b_2)</code>,
<code>(1-b_1)*(1-b_2)*(1-b_3)</code>, ... so the latter converges to zero.
</p>


<h3>Value</h3>

<p>A vector of stick-breaks summing to one.
</p>


<h3>Examples</h3>

<pre><code class="language-R">draw_stick_breaks(1)
draw_stick_breaks(1, min_stick_breaks = 10)
draw_stick_breaks(1, min_stick_breaks = 10, threshold = 1e-8)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>SEMap-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class and Methods for Predictive Moran's Eigenvector Maps (pMEM)</h2>

<h3>Description</h3>

<p>Generator function, class, and methods to handle predictive Moran's
eigenvector maps (pMEM).
</p>


<h3>Usage</h3>

<pre><code class="language-R">genSEF(x, m, f, tol = .Machine$double.eps^0.5)

## S3 method for class 'SEMap'
print(x, ...)

## S3 method for class 'SEMap'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S3 method for class 'SEMap'
as.matrix(x, ...)

## S3 method for class 'SEMap'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a set of coordinates to be given to the distance metric function
(argument <code>m</code> below) to obtain the distance metric (<code>genSEF</code>) or an
<code>SEMap-class</code> object (methods).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>a distance metric function, such as one of those returned by
<code>genDistMetric</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>a distance weighting function, such as one of those returned by
<code>genDWF</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>a tolerance threshold for absolute eigenvalues, below which to
discard spatial eigenfunctions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to other functions or methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row names for
the data frame. Missing values are not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optional</code></td>
<td>
<p>logical. If <code>TRUE</code>, setting row names and converting
column names (to syntactic names: see <code>make.names</code>) is optional.
See <b>base</b> <code>as.data.frame</code> for further details on this
argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an <code>SEMap-class</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>a set of new coordinates from which to calculate pMEM
predictor scores.</p>
</td>
</tr>
</table>
<h3>Format</h3>

<p>A <code>SEMap-class</code> object contains:
</p>

<dl>
<dt> show </dt>
<dd>
<p> A printing function. </p>
</dd>
<dt> getIMoran </dt>
<dd>
<p> A function (with no argument) returning the Moran's I
coefficients associated with the spatial eigenfunctions. </p>
</dd>
<dt> getSEF </dt>
<dd>
<p> A function that return the spatial eigenvectors. It has an
argument <code>wh</code> which allows one to specify a selection of the
eigenvectors that are to be returned. </p>
</dd>
<dt> getLambda </dt>
<dd>
<p> A function that returns the eigenvalues. </p>
</dd>
<dt> getPredictor </dt>
<dd>
<p> A function that calculate the spatial eigenfunction
values for arbitrary locations about the sampling points. The coordinates
of these locations are given as a vector or matrix through argument
<code>xx</code>. It also has an argument <code>wh</code> which allows one to specify a
selection of the eigenfunctions that are to be returned. </p>
</dd>
</dl>
<h3>Details</h3>

<p>Predictive Moran's Eigenvector Maps (pMEM) allows one to model the
spatial variability of an environmental variable and use the resulting model
for making prediction at any location on and around the sampling points. They
originate from coordinates in one or more dimensions, which are used to
calculate distances. The distances are obtained from the coordinates using a
function given through argument <code>m</code> (see <code>genDistMetric</code> for
further details). The distances are then transformed to weights using a
spatial weighting function given as argument <code>f</code> (see
<code>genDWF</code> for implementations of spatial weighting function). The
resulting weights are row- and column-centred to the value 0 before being
submitted to an eigenvalue decomposition. Eigenvectors associated to
eigenvalues whose absolute value are above the threshold value set through
argument <code>tol</code> are retained as part of the resulting eigenvector map.
</p>
<p>In a standard workflow, a model is built for the locations where values of
the response variable are known using the eigenvectors (or a subset thereof).
This model may be build using any model building approach using descriptors.
The scores obtained for new coordinates from method <code>predict</code> are used
given to the model for making predictions.
</p>
<p>The function can handle real-valued as well as complex-valued distance
metrics. The latter is useful to represent asymmetric (i.e., directed)
spatial processes.
</p>


<h3>Value</h3>


<dl>
<dt> genSEF </dt>
<dd>
<p> a <code>SEMap-class</code> object. </p>
</dd>
<dt> print.SEMap </dt>
<dd> <p><code>NULL</code> (invisibly). </p>
</dd>
<dt> as.data.frame.SEMap </dt>
<dd>
<p> A <code>data.frame</code> with the spatial
eigenvectors. </p>
</dd>
<dt> as.matrix.SEMap </dt>
<dd>
<p> A matrix with the spatial eigenvectors. </p>
</dd>
<dt> predict.SEMap </dt>
<dd>
<p> A matrix with the spatial eigenfunction values </p>
</dd>
</dl>
<h3>Functions</h3>


<ul>
<li> <p><code>genSEF()</code>: Predictive Moran's Eigenvector Map (pMEM) Generation
</p>
<p>Generates a predictive spatial eigenvector map (a SEMap-class object).
</p>
</li>
<li> <p><code>print(SEMap)</code>: Print SEMap-class
</p>
<p>A print method for <code>SEMap-class</code> objects.
</p>
</li>
<li> <p><code>as.data.frame(SEMap)</code>: An <code>as.data.frame</code> Method for <code>SEMap-class</code> Objects
</p>
<p>A method to extract the spatial eigenvectors from an <code>SEMap-class</code>
object as a data frame.
</p>
</li>
<li> <p><code>as.matrix(SEMap)</code>: An <code>as.matrix</code> Method for <code>SEMap-class</code> Objects
</p>
<p>A method to extract the spatial eigenvectors from an <code>SEMap-class</code>
object as a matrix.
</p>
</li>
<li> <p><code>predict(SEMap)</code>: A <code>predict</code> Method for <code>SEMap-class</code> Objects
</p>
<p>A method to obtain predictions from an <code>SEMap-class</code> object.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;)
</p>
<p>Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Store graphical parameters:
tmp &lt;- par(no.readonly = TRUE)
par(las=1)

## Case 1: one-dimensional symmetrical

n &lt;- 11
x &lt;- (n - 1)*seq(0, 1, length.out=n)
xx &lt;- (n - 1)*seq(0, 1, 0.01)

sefSym &lt;- genSEF(x, genDistMetric(), genDWF("Gaussian",3))

plot(y = predict(sefSym, xx, wh=1), x = xx, type = "l", ylab = "PMEM_1",
     xlab = "x")
points(y = as.matrix(sefSym, wh=1), x = x)

plot(y = predict(sefSym, xx, wh=2), x = xx, type = "l", ylab = "PMEM_2",
     xlab = "x")
points(y = as.matrix(sefSym, wh=2), x = x)

plot(y = predict(sefSym, xx, wh=5), x = xx, type = "l", ylab = "PMEM_5",
     xlab = "x")
points(y = as.matrix(sefSym, wh=5), x = x)

## Case 2: one-dimensional asymmetrical (each has a real and imaginary parts)

sefAsy &lt;- genSEF(x, genDistMetric(delta = pi/8), genDWF("Gaussian",3))

plot(y = Re(predict(sefAsy, xx, wh=1)), x = xx, type = "l", ylab = "PMEM_1",
     xlab = "x", ylim=c(-0.35,0.35))
lines(y = Im(predict(sefAsy, xx, wh=1)), x = xx, col="red")
points(y = Re(as.matrix(sefAsy, wh=1)), x = x)
points(y = Im(as.matrix(sefAsy, wh=1)), x = x, col="red")

plot(y = Re(predict(sefAsy, xx, wh=2)), x = xx, type = "l", ylab = "PMEM_2",
     xlab = "x", ylim=c(-0.45,0.35))
lines(y = Im(predict(sefAsy, xx, wh=2)), x = xx, col="red")
points(y = Re(as.matrix(sefAsy, wh=2)), x = x)
points(y = Im(as.matrix(sefAsy, wh=2)), x = x, col="red")

plot(y = Re(predict(sefAsy, xx, wh=5)), x = xx, type = "l", ylab = "PMEM_5",
     xlab = "x", ylim=c(-0.45,0.35))
lines(y = Im(predict(sefAsy, xx, wh=5)), x = xx, col="red")
points(y = Re(as.matrix(sefAsy, wh=5)), x = x)
points(y = Im(as.matrix(sefAsy, wh=5)), x = x, col="red")

## A function to display combinations of the real and imaginary parts:
plotAsy &lt;- function(object, xx, wh, a, ylim) {
  pp &lt;- predict(object, xx, wh=wh)
  plot(y = cos(a)*Re(pp) + sin(a)*Im(pp), x = xx, type = "l",
       ylab = "PMEM_5", xlab = "x", ylim=ylim, col="green")
  invisible(NULL)
}

## Display combinations at an angle of 45° (pMEM_5):
plotAsy(sefAsy, xx, 5, pi/4, ylim=c(-0.45,0.45))

## Display combinations for other angles:
for(i in 0:15) {
  plotAsy(sefAsy, xx, 5, i*pi/8, ylim=c(-0.45,0.45))
  if(is.null(locator(1))) break
}

## Case 3: two-dimensional symmetrical

cbind(
  x = c(-0.5,0.5,-1,0,1,-0.5,0.5),
  y = c(rep(sqrt(3)/2,2L),rep(0,3L),rep(-sqrt(3)/2,2L))
) -&gt; x2

seq(min(x2[,1L]) - 0.3, max(x2[,1L]) + 0.3, 0.05) -&gt; xx
seq(min(x2[,2L]) - 0.3, max(x2[,2L]) + 0.3, 0.05) -&gt; yy

list(
  x = xx,
  y = yy,
  coords = cbind(
    x = rep(xx, length(yy)),
    y = rep(yy, each = length(xx))
  )
) -&gt; ss

cc &lt;- seq(0,1,0.01)
cc &lt;- c(rgb(cc,cc,1),rgb(1,1-cc,1-cc))

sefSym2D &lt;- genSEF(x2, genDistMetric(), genDWF("Gaussian",3))

scr &lt;- predict(sefSym2D, ss$coords)

par(mfrow = c(2,3), mar=0.5*c(1,1,1,1))

for(i in 1L:6) {
  image(z=matrix(scr[,i],length(ss$x),length(ss$y)), x=ss$x, y=ss$y, asp=1,
        zlim=max(abs(scr[,i]))*c(-1,1), col=cc, axes=FALSE)
  points(x = x2[,1L], y = x2[,2L])
}

## Case 4: two-dimensional asymmetrical

sefAsy2D0 &lt;- genSEF(x2, genDistMetric(delta=pi/8), genDWF("Gaussian",1))
## Note: default influence angle is 0 (with respect to the abscissa)

## A function to display combinations of the real and imaginary parts (2D):
plotAsy2 &lt;- function(object, ss, a) {
  pp &lt;- predict(object, ss$coords)
  for(i in 1:6) {
    z &lt;- cos(a)*Re(pp[,i]) + sin(a)*Im(pp[,i])
    image(z=matrix(z,length(ss$x),length(ss$y)), x=ss$x, y=ss$y, asp=1,
          zlim=max(abs(z))*c(-1,1), col=cc, axes=FALSE)
  }
  invisible(NULL)
}

## Display combinations at an angle of 22°:
plotAsy2(sefAsy2D0, ss, pi/8)

## Display combinations at other angles:
for(i in 0:23) {
  plotAsy2(sefAsy2D0, ss, i*pi/12)
  if(is.null(locator(1))) break
}

## With an influence of +45° (with respect to the abscissa)
sefAsy2D1 &lt;- genSEF(x2, genDistMetric(delta=pi/8, theta = pi/4),
                    genDWF("Gaussian",1))

for(i in 0:23) {
  plotAsy2(sefAsy2D1, ss, i*pi/12)
  if(is.null(locator(1))) break
}

## With an influence of +90° (with respect to the abscissa)
sefAsy2D2 &lt;- genSEF(x2, genDistMetric(delta=pi/8, theta = pi/2),
                    genDWF("Gaussian",1))

for(i in 0:23) {
  plotAsy2(sefAsy2D2, ss, i*pi/12)
  if(is.null(locator(1))) break
}

## With an influence of -45° (with respect to the abscissa)
sefAsy2D3 &lt;- genSEF(x2, genDistMetric(delta=pi/8, theta = -pi/4),
                    genDWF("Gaussian",1))

for(i in 0:23) {
  plotAsy2(sefAsy2D3, ss, i*pi/12)
  if(is.null(locator(1))) break
}

## Reverting to initial graphical parameters:
par(tmp)

</code></pre>


</div>
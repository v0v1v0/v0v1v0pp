<div class="container">

<table style="width: 100%;"><tr>
<td>allperms</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>All permutations with given characteristics</h2>

<h3>Description</h3>

<p>Functionality to enumerate permutations given different
characteristics.  In the following, <code>n</code> is assumed to be a
non-negative integer.  Permutations, in general, are coerced to cycle
form.
</p>

<ul>
<li>
<p><code>allperms(n)</code> returns all <code class="reqn">n!</code> permutations
of <code class="reqn">[n]</code>.
</p>
</li>
<li>
<p><code>allcycn()</code> returns all <code class="reqn">(n-1)!</code>  permutations of
<code class="reqn">[n]</code> comprising a single cycle of length <code class="reqn">n</code>.
</p>
</li>
<li>
<p><code>allcyc(s)</code> returns all single-cycle permutations of set
<code class="reqn">s</code>.  If <code class="reqn">s</code> has a repeated value, an opaque error
message is returned.
</p>
</li>
<li>
<p><code>allpermslike(o)</code> takes a length-one vector <code>o</code> of
permutations and returns a vector comprising permutations with the
same shape and cycle sets as it argument.
</p>
</li>
<li>
<p><code>some_perms_shape(part)</code> takes an integer partition
<code>part</code>, as in a set of non-negative integers, and returns a
vector comprising every permutation of size <code>sum(part)</code> with
shape <code>part</code> that has its cycles in increasing order.
</p>
</li>
<li>
<p><code>all_cyclic_shuffles(u)</code> takes a permutation <code>u</code> and
returns a vector comprising of all permutations with the same shape
and cycle sets.  It is vectorised so that argument <code>u</code> may be a
vector of permutations.
</p>
</li>
<li>
<p><code>all_perms_shape(p)</code> takes a permutation <code>p</code> and
returns a vector of all permutations of size <code>sum(p)</code> and shape
<code>p</code>.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">allperms(n)
allcycn(n)
allcyc(s)
allpermslike(o)
some_perms_shape(shape)
all_cyclic_shuffles(o)
all_perms_shape(shape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>
<p>A set of strictly positive integers, interpreted as the
shape of a partition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>A set of strictly positive integers, interpreted as a set on
which permutations are defined</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The size of the permutation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>o</code></td>
<td>
<p>A vector of permutations, coerced to cycle form.  Function
<code>allpermslike()</code> considers only the first element</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function <code>allperms()</code> is very basic (the idiom is
<code>word(t(partitions::perms(n)))</code>) but is here for completeness.
</p>


<h3>Note</h3>

<p>Function <code>allcyc()</code> is taken directly from Er's
“fine-tuned” algorithm.  It should really be implemented in
C as part of the <span class="pkg">partitions</span> package but I have not
yet got round to this.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. C. Er 1989 “Efficient
enumeration of cyclic permutations in situ”.  <em>International
Journal of Computer Mathematics</em>, volume 29:2-4, pp121-129.
</p>


<h3>See Also</h3>

<p><code>allperms</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
allperms(5)

allcycn(5)

allcyc(c(5,6,8,3))

allpermslike(as.cycle("(12)(34)(5678)"))
allpermslike(rgivenshape(c(1,1,3,4)))
some_perms_shape(c(2,2,4))
all_cyclic_shuffles(cyc_len(3:5))
all_perms_shape(c(2,2,3))
</code></pre>


</div>
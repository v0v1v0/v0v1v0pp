<div class="container">

<table style="width: 100%;"><tr>
<td>image_index</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Image indexes</h2>

<h3>Description</h3>

<p><code>image_index()</code> Builds image indexes using Red, Green, Blue, Red-Edge, and NIR bands.
</p>
<p>Generates a raster or density plot of the index values computed with
<code>image_index()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">image_index(
  img,
  index = NULL,
  r = 1,
  g = 2,
  b = 3,
  re = 4,
  nir = 5,
  return_class = c("ebimage", "terra"),
  resize = FALSE,
  has_white_bg = FALSE,
  plot = TRUE,
  nrow = NULL,
  ncol = NULL,
  max_pixels = 1e+05,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'image_index'
plot(x, type = c("raster", "density"), nrow = NULL, ncol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>img</code></td>
<td>
<p>An <code>Image</code> object. Multispectral mosaics can be converted to an
<code>Image</code> object using <code>mosaic_as_ebimage()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>A character value (or a vector of characters) specifying the
target mode for conversion to a binary image. Use <code>pliman_indexes()</code> or the
<code>details</code> section to see the available indexes. Defaults to <code>NULL</code>
(normalized Red, Green, and Blue). You can also use "RGB" for RGB only,
"NRGB" for normalized RGB,  "MULTISPECTRAL" for multispectral indices
(provided NIR and RE bands are available) or "all" for all indexes. Users
can also calculate their own index using the band names, e.g., <code>index = "R+B/G"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r, g, b, re, nir</code></td>
<td>
<p>The red, green, blue, red-edge, and near-infrared bands
of the image, respectively. Defaults to 1, 2, 3, 4, and 5, respectively. If
a multispectral image is provided (5 bands), check the order of bands,
which are frequently presented in the 'BGR' format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_class</code></td>
<td>
<p>The class of object to be returned. If <code style="white-space: pre;">⁠"terra⁠</code> returns a
SpatRaster object with the number of layers equal to the number of indexes
computed. If <code>"ebimage"</code> (default) returns a list of <code>Image</code> objects, where
each element is one index computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resize</code></td>
<td>
<p>Resize the image before processing? Defaults to <code>resize = FALSE</code>. Use <code>resize = 50</code>, which resizes the image to 50% of the original
size to speed up image processing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>has_white_bg</code></td>
<td>
<p>Logical indicating whether a white background is present.
If TRUE, pixels that have R, G, and B values equals to 1 will be considered
as NA. This may be useful to compute an image index for objects that have,
for example, a white background. In such cases, the background will not be
considered for the threshold computation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>Show image after processing?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrow, ncol</code></td>
<td>
<p>The number of rows or columns in the plot grid. Defaults to
<code>NULL</code>, i.e., a square grid is produced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_pixels</code></td>
<td>
<p>integer &gt; 0. Maximum number of cells to plot the index. If
<code>max_pixels &lt; npixels(img)</code>, downsampling is performed before plotting the
index. Using a large number of pixels may slow down the plotting time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Processes the images asynchronously (in parallel) in separate
R sessions running in the background on the same machine. It may speed up
the processing time when <code>image</code> is a list. The number of sections is set
up to 70% of available cores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the maximum
number of parallel processes that can be active at the same time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to <code>plot_index()</code> for customization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class <code>image_index</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of plot. Use <code>type = "raster"</code> (default) to produce a
raster plot showing the intensity of the pixels for each image index or
<code>type = "density"</code> to produce a density plot with the pixels' intensity.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The following indexes are available in pliman.
</p>

<ul><li>
<p> RGB color space
</p>
</li></ul>
<ul>
<li> <p><code>R</code> red
</p>
</li>
<li> <p><code>G</code> green
</p>
</li>
<li> <p><code>B</code> blue
</p>
</li>
<li> <p><code>NR</code> normalized red <code>R/(R+G+B)</code>.
</p>
</li>
<li> <p><code>NG</code> normalized green <code>G/(R+G+B)</code>
</p>
</li>
<li> <p><code>NB</code> normalized blue <code>B/(R+G+B)</code>
</p>
</li>
<li> <p><code>GB</code> green blue ratio <code>G/B</code>
</p>
</li>
<li> <p><code>RB</code> red blue ratio <code>R/B</code>
</p>
</li>
<li> <p><code>GR</code> green red ratio <code>G/R</code>
</p>
</li>
<li> <p><code>BI</code> brightness Index <code>sqrt((R^2+G^2+B^2)/3)</code>
</p>
</li>
<li> <p><code>BIM</code> brightness Index 2 <code>sqrt((R*2+G*2+B*2)/3)</code>
</p>
</li>
<li> <p><code>SCI</code> Soil Colour Index <code>(R-G)/(R+G)</code>
</p>
</li>
<li> <p><code>GLI</code> Green leaf index Vis Louhaichi et al. (2001) <code>(2*G-R-B)/(2*G+R+B)</code>
</p>
</li>
<li> <p><code>HI</code> Primary colours Hue Index    (2*R-G-B)/(G-B)
</p>
</li>
<li> <p><code>NDGRI</code> Normalized green red difference index (Tucker, 1979) <code>(G-R)/(G+R)</code>
</p>
</li>
<li> <p><code>NDGBI</code> Normalized green blue difference index <code>(G-B)/(G+B)</code>
</p>
</li>
<li> <p><code>NDRBI</code> Normalized red blue difference index <code>(R-B)/(R+B)</code>
</p>
</li>
<li> <p><code>I</code>     R+G+B
</p>
</li>
<li> <p><code>S</code>     <code>((R+G+B)-3*B)/(R+G+B)</code>
</p>
</li>
<li> <p><code>L</code>     R+G+B/3
</p>
</li>
<li> <p><code>VARI</code> A Visible Atmospherically Resistant Index <code>(G-R)/(G+R-B)</code>
</p>
</li>
<li> <p><code>HUE</code> Overall Hue Index <code>atan(2*(B-G-R)/30.5*(G-R))</code>
</p>
</li>
<li> <p><code>HUE2</code>  atan(2*(R-G-R)/30.5*(G-B))
</p>
</li>
<li> <p><code>BGI</code>   B/G
</p>
</li>
<li> <p><code>GRAY</code>	<code>0.299*R + 0.587*G + 0.114*B</code>
</p>
</li>
<li> <p><code>GRAY2</code> <code>((R^2.2+(1.5*G)^2.2+(0.6*B)^2.2)/(1+1.5^2.2+0.6^2.2))^1/2.2</code>
</p>
</li>
<li> <p><code>GLAI</code> <code>(25*(G-R)/(G+R-B)+1.25)</code>
</p>
</li>
<li> <p><code>CI</code> Coloration Index <code>(R-B)/R</code>
</p>
</li>
<li> <p><code>SAT</code> Overhall Saturation Index <code>(max(R,G,B) - min(R,G,B)) / max(R,G,B)</code>
</p>
</li>
<li> <p><code>SHP</code> Shape Index <code>2*(R-G-B)/(G-B)</code>
</p>
</li>
<li> <p><code>RI</code> Redness Index <code>R**2/(B*G**3)</code>
</p>
</li>
</ul>
<ul>
<li>
<p> HSB color space
</p>
</li>
<li> <p><code>DGCI</code> Dark Green Color Index, based on HSB color space <code style="white-space: pre;">⁠60\*((G - B) / (max(R, G, B) - min(R, G, B)))⁠</code>
</p>
</li>
<li>
<p> CIE-Lab color space
</p>
</li>
</ul>
<ul>
<li> <p><code style="white-space: pre;">⁠L*⁠</code>: relative luminance <code>(0.2126 * R + 0.7152 * G + 0.0722 * B)</code>
</p>
</li>
<li> <p><code style="white-space: pre;">⁠a*⁠</code>: <code>0.55*( (R - (0.2126 * R + 0.7152 * G + 0.0722 * B)) / (1.0 - 0.2126))</code>
</p>
</li>
</ul>
<p>When <code>type = "raster"</code> (default), the function calls <code>plot_index()</code>
to create a raster plot for each index present in <code>x</code>. If <code>type = "density"</code>,
a for loop is used to create a density plot for each index. Both types of
plots can be arranged in a grid controlled by the <code>ncol</code> and <code>nrow</code>
arguments.
</p>


<h3>Value</h3>

<p>A list containing Grayscale images. The length will depend on the
number of indexes used.
</p>
<p>A <code>NULL</code> object
</p>


<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>References</h3>

<p>Nobuyuki Otsu, "A threshold selection method from gray-level
histograms". IEEE Trans. Sys., Man., Cyber. 9 (1): 62-66. 1979.
<a href="https://doi.org/10.1109/TSMC.1979.4310076">doi:10.1109/TSMC.1979.4310076</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(pliman)
img &lt;- image_pliman("soybean_touch.jpg")
image_index(img, index = c("R, NR"))

# Example for S3 method plot()
library(pliman)
img &lt;- image_pliman("sev_leaf.jpg")
# compute the index
ind &lt;- image_index(img, index = c("R, G, B, NGRDI"), plot = FALSE)
plot(ind)

# density plot
plot(ind, type = "density")
</code></pre>


</div>
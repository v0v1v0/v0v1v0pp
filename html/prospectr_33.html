<div class="container">

<table style="width: 100%;"><tr>
<td>puchwein</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Puchwein algorithm for calibration sampling</h2>

<h3>Description</h3>

<p>Select calibration samples from multivariate data using the Puchwein
algorithm
</p>


<h3>Usage</h3>

<pre><code class="language-R">puchwein(X,
         pc = 0.95,
         k,
         min.sel,
         details = FALSE,
         .center = TRUE,
         .scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a matrix from which the calibration samples are to be selected
(optionally a data frame that can be coerced to a numerical matrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pc</code></td>
<td>
<p>the number of principal components retained in the computation of
the distance in the standardized Principal Component space (Mahalanobis
distance).
If <code>pc &lt; 1</code>, the number of principal components kept corresponds to the
number of components
explaining at least (<code>pc * 100</code>) percent of the total variance
(default = 0.95 as in the Puchwein paper).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>the initial limiting distance parameter, if not specified (default),
set to 0.2. According to Puchwein, a good starting value for the limiting
distance is <code class="reqn">d_{ini} = k(p-2)</code> where <code class="reqn">p</code> is the number of
principal components</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.sel</code></td>
<td>
<p>minimum number of samples to select for calibration
(default = 5).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>details</code></td>
<td>
<p>logical value, if <code>TRUE</code>, adds a component in the output list
with the indices of the objects kept in each loop (default to <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.center</code></td>
<td>
<p>logical value indicating whether the input matrix must be
centered before Principal Component.
Analysis. Default set to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.scale</code></td>
<td>
<p>logical value indicating whether the input matrix must be
scaled before Principal Component
Analysis. Default set to FALSE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Puchwein algorithm select samples from a data matrix by iteratively
eliminating similar samples using the Mahalanobis distance.
It starts by performing a PCA on the input matrix and extracts the score
matrix truncated to <code class="reqn">A</code>, the number of principal components. The score
matrix is then normalized to unit variance and the Euclidean distance of each
sample to the centre of the data is computed, which is identical to the
Mahalanobis distance <code class="reqn">H</code>. Additionally, the Mahalanobis distances between
samples are comptuted. The algorithm then proceeds as follows:
</p>

<ol>
<li>
<p> Choose a initial limiting distance <code class="reqn">d_{ini}</code>
</p>
</li>
<li>
<p> Select the sample with the highest <code class="reqn">H</code> distance to the centre
</p>
</li>
<li>
<p> Remove all samples within the minimum distance <code class="reqn">d_{ini}</code> from
the sample selected in step 2
</p>
</li>
<li>
<p> Go back to step 2 and proceed until there are no samples/observations
left in the dataset
</p>
</li>
<li>
<p> Go back to step 1 and increase the minimum distance by multiplying
the limiting distance by the loop number
</p>
</li>
</ol>
<p>It is not possible to obtain a pre-defined number of samples selected by the
method. To choose the adequate number of samples, a data frame is returned
by <code>puchwein</code> function (<code>leverage</code>) giving the observed and theoretical
cumulative sum of leverages of the points selected in each iteration. The
theoretical cumulative sum of leverage is computed such as each point has the
same leverage (the sum of leverages divided by the number of observations).
The loop having the largest difference between the observed and theoretical
sums is considered as producing the optimal selection of points (the subset
that best reproduces the variability of the predictor space).
</p>


<h3>Value</h3>

<p>a <code>list</code> with components:
</p>

<ul>
<li>
<p>'<code>model</code>': indices of the observations (row indices of the input
data)
selected for calibration
</p>
</li>
<li>
<p>'<code>test</code>': indices of the remaining observations (row indices of the
input data)
</p>
</li>
<li>
<p>'<code>pc</code>': a numeric matrix of the scaled pc scores
</p>
</li>
<li>
<p>'<code>loop.optimal</code>': index of the loop producing the maximum difference
between the observed and
theoretical sum of leverages of the selected samples
</p>
</li>
<li>
<p>'<code>leverage</code>': data frame giving the observed and theoretical
cumulative sums of leverage of the points selected in each loop
</p>
</li>
<li>
<p>'<code>details</code>': list with the indices of the observations kept in each
loop
</p>
</li>
</ul>
<h3>Note</h3>

<p>The Puchwein algorithm is an iterative method and can be slow for large
data matrices.
</p>


<h3>Author(s)</h3>

<p>Antoine Stevens
</p>


<h3>References</h3>

<p>Puchwein, G., 1988. Selection of calibration samples for near-infrared
spectrometry by factor analysis of spectra. Analytical Chemystry 60, 569-573.
</p>
<p>Shetty, N., Rinnan, A., and Gislum, R., 2012. Selection of representative
calibration sample sets for near-infrared reflectance spectroscopy to predict
nitrogen concentration in grasses. Chemometrics and Intelligent Laboratory
Systems 111, 59-65.
</p>


<h3>See Also</h3>

<p><code>kenStone</code>, <code>duplex</code>,
<code>shenkWest</code>, <code>honigs</code>, <code>naes</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(NIRsoil)
sel &lt;- puchwein(NIRsoil$spc, k = 0.2, pc = .99)
plot(sel$pc[, 1:2])
# points selected for calibration
points(NIRsoil$spc[sel$model, 1:2], col = 2, pch = 2)
# Leverage plot
opar &lt;- par(no.readonly = TRUE)
par(mar = c(4, 5, 2, 2))
plot(sel$leverage$loop, sel$leverage$diff,
  type = "l",
  xlab = "# loops",
  ylab = "Difference between theoretical and \n observed sum of leverages"
)
par(opar)
</code></pre>


</div>
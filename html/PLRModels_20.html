<div class="container">

<table style="width: 100%;"><tr>
<td>plrm.est</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Semiparametric estimates for the unknown components of the regression function in PLR models
</h2>

<h3>Description</h3>

<p>This routine computes estimates for <code class="reqn">\beta</code> and <code class="reqn">m(newt_j)</code> (<code class="reqn">j=1,...,J</code>) from a sample 
<code class="reqn">{(Y_i, X_{i1}, ..., X_{ip}, t_i)}</code>: 
<code class="reqn">i=1,...,n</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">\beta = (\beta_1,...,\beta_p)</code>
</p>

<p>is an unknown vector parameter,
</p>
<p style="text-align: center;"><code class="reqn">m(.)</code>
</p>

<p>is a smooth but unknown function and
</p>
<p style="text-align: center;"><code class="reqn">Y_i= X_{i1}*\beta_1 +...+ X_{ip}*\beta_p + m(t_i) + \epsilon_i.</code>
</p>

<p>The random errors, <code class="reqn">\epsilon_i</code>, are allowed to be time series. Kernel smoothing, combined with ordinary least squares estimation, is used.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plrm.est(data = data, b = NULL, h = NULL, newt = NULL, estimator = "NW", 
kernel = "quadratic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p><code>data[, 1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2:(p+1)]</code> contains the values of the "linear" explanatory variables,
</p>
<p><code class="reqn">X_1, ..., X_p</code>;
</p>
<p><code>data[, p+2]</code> contains the values of the "nonparametric" explanatory variable, <code class="reqn">t</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>bandwidth for estimating the parametric part of the model. If both <code>b</code> and <code>h</code> are <code>NULL</code> (the default), it is selected by means of the cross-validation procedure (fixing <code>b=h</code>); if <code>b</code> is <code>NULL</code> (the default) but <code>h</code> is not <code>NULL</code>, <code>b=h</code> is considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p><code>(b,h)</code> is the pair of bandwidths for estimating the nonparametric part of the model. If both <code>b</code> and <code>h</code> are <code>NULL</code> (the default), it is selected by means of the cross-validation procedure (fixing <code>b=h</code>); if <code>b</code> is <code>NULL</code> (the default) but <code>h</code> is not <code>NULL</code>, <code>b=h</code> is considered; if <code>h</code> is <code>NULL</code> (the default) but <code>b</code> is not <code>NULL</code>, <code>h=b</code> is considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newt</code></td>
<td>
<p>values of the "nonparametric" explanatory variable where the estimator of <code class="reqn">m</code> is evaluated. If NULL (the default), the considered values will be the values of <code>data[,p+2]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimator</code></td>
<td>
<p>allows us the choice between “NW” (Nadaraya-Watson) or “LLP” (Local Linear Polynomial). The default is “NW”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>allows us the choice between “gaussian”, “quadratic” (Epanechnikov kernel), “triweight” or “uniform” kernel. The default is “quadratic”.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Expressions for the estimators of <code class="reqn">\beta</code> and <code class="reqn">m</code> can be seen in page 52 in Aneiros-Perez <em>et al.</em> (2004).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>a vector containing the estimate of <code class="reqn">\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.t</code></td>
<td>
<p>a vector containing the estimator of the non-parametric part, <code class="reqn">m</code>, evaluated in the design points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.newt</code></td>
<td>
<p>a vector containing the estimator of the non-parametric part, <code class="reqn">m</code>, evaluated in <code>newt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>a vector containing the residuals: <code>Y - X*beta - m.t</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>the values obtained from the expression: <code>X*beta + m.t</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>the considered bandwidth for estimating <code class="reqn">\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p><code>(b,h)</code> is the pair of bandwidths considered for estimating <code class="reqn">m</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Aneiros-Perez, G., Gonzalez-Manteiga, W. and Vieu, P. (2004) Estimation and testing in a partial linear regression under long-memory dependence. <em>Bernoulli</em> <b>10</b>, 49-78.
</p>
<p>Hardle, W., Liang, H. and Gao, J. (2000) <em>Partially Linear Models</em>. Physica-Verlag.
</p>
<p>Speckman, P. (1988) Kernel smoothing in partial linear models. <em>J. R. Statist. Soc. B</em> <b>50</b>, 413-436.
</p>


<h3>See Also</h3>

<p>Other related functions are: <code>plrm.beta</code>, <code>plrm.gcv</code>, <code>plrm.cv</code>, <code>np.est</code>, <code>np.gcv</code> and <code>np.cv</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data,1:nrow(data))

b.h &lt;- plrm.gcv(data)$bh.opt
ajuste &lt;- plrm.est(data=data, b=b.h[1], h=b.h[2])
ajuste$beta
plot(data[,4], ajuste$m, type="l", xlab="t", ylab="m(t)")

plot(data[,1], ajuste$fitted.values, xlab="y", ylab="y.hat", main="y.hat vs y")
abline(0,1)

mean(ajuste$residuals^2)/var(data[,1])



# EXAMPLE 2: SIMULATED DATA
## Example 2a: independent data

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
beta &lt;- c(0.05, 0.01)
m &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m(t)

x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- rnorm(n, 0, 0.01)
y &lt;-  sum + f + epsilon
data_ind &lt;- matrix(c(y,x,t),nrow=100)

# We estimate the components of the PLR model
# (CV bandwidth)
a &lt;- plrm.est(data_ind)

a$beta

est &lt;- a$m.t
plot(t, est, type="l", lty=2, ylab="")
points(t, 0.25*t*(1-t), type="l")
legend(x="topleft", legend = c("m", "m hat"), col=c("black", "black"), lty=c(1,2))


## Example 2b: dependent data
# We generate the data
x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y &lt;-  sum + f + epsilon
data_dep &lt;- matrix(c(y,x,t),nrow=100)

# We estimate the components of the PLR model
# (CV bandwidth)
h &lt;- plrm.cv(data_dep, ln.0=2)$bh.opt[3,1]
a &lt;- plrm.est(data_dep, h=h)

a$beta

est &lt;- a$m.t
plot(t, est, type="l", lty=2, ylab="")
points(t, 0.25*t*(1-t), type="l")
legend(x="topleft", legend = c("m", "m hat"), col=c("black", "black"), lty=c(1,2))

</code></pre>


</div>
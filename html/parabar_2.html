<div class="container">

<table style="width: 100%;"><tr>
<td>AsyncBackend</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>AsyncBackend</h2>

<h3>Description</h3>

<p>This is a concrete implementation of the abstract class <code>Backend</code>
that implements the <code>Service</code> interface. This backend executes
tasks in parallel asynchronously (i.e., without blocking the main <code>R</code>
session) on a <code>parallel::makeCluster()</code> cluster created in a background <code>R</code>
<code>session</code>.
</p>


<h3>Super classes</h3>

<p><code>parabar::Service</code> -&gt; <code>parabar::Backend</code> -&gt; <code>AsyncBackend</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>task_state</code></dt>
<dd>
<p>A list of logical values indicating the state of
the task execution. See the <code>TaskState</code> class for more
information on how the statues are determined. The following statuses
are available:
</p>

<ul>
<li> <p><code>task_not_started</code>: Indicates whether the backend is free. <code>TRUE</code>
signifies that no task has been started and the backend is free to
deploy.
</p>
</li>
<li> <p><code>task_is_running</code>: Indicates whether a task is currently running on
the backend.
</p>
</li>
<li> <p><code>task_is_completed</code>: Indicates whether a task has finished
executing. <code>TRUE</code> signifies that the output of the task has not been
fetched. Calling the method <code>get_option()</code> will move the output from
the background <code>R</code> session to the main <code>R</code> session. Once the output
has been fetched, the backend is free to deploy another task.
</p>
</li>
</ul>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AsyncBackend-new"><code>AsyncBackend$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-finalize"><code>AsyncBackend$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-start"><code>AsyncBackend$start()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-stop"><code>AsyncBackend$stop()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-clear"><code>AsyncBackend$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-peek"><code>AsyncBackend$peek()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-export"><code>AsyncBackend$export()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-evaluate"><code>AsyncBackend$evaluate()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-sapply"><code>AsyncBackend$sapply()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-lapply"><code>AsyncBackend$lapply()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-apply"><code>AsyncBackend$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-get_output"><code>AsyncBackend$get_output()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-clone"><code>AsyncBackend$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-AsyncBackend-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>AsyncBackend</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$new()</pre></div>



<h5>Returns</h5>

<p>An object of class <code>AsyncBackend</code>.
</p>


<hr>
<a id="method-AsyncBackend-finalize"></a>



<h4>Method <code>finalize()</code>
</h4>

<p>Destroy the current <code>AsyncBackend</code> instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$finalize()</pre></div>



<h5>Returns</h5>

<p>An object of class <code>AsyncBackend</code>.
</p>


<hr>
<a id="method-AsyncBackend-start"></a>



<h4>Method <code>start()</code>
</h4>

<p>Start the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$start(specification)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification</code></dt>
<dd>
<p>An object of class <code>Specification</code>
that contains the backend configuration.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The resulting backend must be stored in the
<code>.cluster</code> private field on the <code>Backend</code> abstract class,
and accessible to any concrete backend implementations via the active
binding <code>cluster</code>.
</p>


<hr>
<a id="method-AsyncBackend-stop"></a>



<h4>Method <code>stop()</code>
</h4>

<p>Stop the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$stop()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-AsyncBackend-clear"></a>



<h4>Method <code>clear()</code>
</h4>

<p>Remove all objects from the backend. This function is equivalent to
calling <code>rm(list = ls(all.names = TRUE))</code> on each node in the
backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$clear()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-AsyncBackend-peek"></a>



<h4>Method <code>peek()</code>
</h4>

<p>Inspect the backend for variables available in the <code>.GlobalEnv</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$peek()</pre></div>



<h5>Returns</h5>

<p>This method returns a list of character vectors, where each element
corresponds to a node in the backend. The character vectors contain
the names of the variables available in the <code>.GlobalEnv</code> on each
node.
</p>


<hr>
<a id="method-AsyncBackend-export"></a>



<h4>Method <code>export()</code>
</h4>

<p>Export variables from a given environment to the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$export(variables, environment)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>variables</code></dt>
<dd>
<p>A character vector of variable names to export.</p>
</dd>
<dt><code>environment</code></dt>
<dd>
<p>An environment object from which to export the
variables.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-AsyncBackend-evaluate"></a>



<h4>Method <code>evaluate()</code>
</h4>

<p>Evaluate an arbitrary expression on the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$evaluate(expression)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expression</code></dt>
<dd>
<p>An unquoted expression to evaluate on the backend.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns the result of the expression evaluation.
</p>


<hr>
<a id="method-AsyncBackend-sapply"></a>



<h4>Method <code>sapply()</code>
</h4>

<p>Run a task on the backend akin to <code>parallel::parSapply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$sapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code>Backend</code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-AsyncBackend-lapply"></a>



<h4>Method <code>lapply()</code>
</h4>

<p>Run a task on the backend akin to <code>parallel::parLapply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$lapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code>Backend</code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-AsyncBackend-apply"></a>



<h4>Method <code>apply()</code>
</h4>

<p>Run a task on the backend akin to <code>parallel::parApply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$apply(x, margin, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>An array to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>margin</code></dt>
<dd>
<p>A numeric vector indicating the dimensions of <code>x</code> the
<code>fun</code> function should be applied over. For example, for a matrix,
<code>margin = 1</code> indicates applying <code>fun</code> rows-wise, <code>margin = 2</code>
indicates applying <code>fun</code> columns-wise, and <code>margin = c(1, 2)</code>
indicates applying <code>fun</code> element-wise. Named dimensions are also
possible depending on <code>x</code>. See <code>parallel::parApply()</code> and
<code>base::apply()</code> for more details.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to <code>x</code> according to the <code>margin</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code>Backend</code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-AsyncBackend-get_output"></a>



<h4>Method <code>get_output()</code>
</h4>

<p>Get the output of the task execution.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$get_output(wait = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>wait</code></dt>
<dd>
<p>A logical value indicating whether to wait for the task
to finish executing before fetching the results. Defaults to <code>FALSE</code>.
See the <strong>Details</strong> section for more information.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>This method fetches the output of the task execution after calling
the <code>sapply()</code> method. It returns the output and immediately removes
it from the backend. Subsequent calls to this method will throw an
error if no additional tasks have been executed in the meantime. This
method should be called after the execution of a task.
</p>
<p>If <code>wait = TRUE</code>, the method will block the main process until the
backend finishes executing the task and the results are available. If
<code>wait = FALSE</code>, the method will immediately attempt to fetch the
results from the background <code>R</code> session, and throw an error if the
task is still running.
</p>



<h5>Returns</h5>

<p>A vector, matrix, or list of the same length as <code>x</code>, containing the
results of the <code>fun</code>. The output format differs based on the specific
operation employed. Check out the documentation for the <code>apply</code>
operations of <code>parallel::parallel</code> for more information.
</p>


<hr>
<a id="method-AsyncBackend-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p><code>Service</code>, <code>Backend</code>, <code>SyncBackend</code>,
<code>ProgressTrackingContext</code>, and <code>TaskState</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Create a specification object.
specification &lt;- Specification$new()

# Set the number of cores.
specification$set_cores(cores = 2)

# Set the cluster type.
specification$set_type(type = "psock")

# Create an asynchronous backend object.
backend &lt;- AsyncBackend$new()

# Start the cluster on the backend.
backend$start(specification)

# Check if there is anything on the backend.
backend$peek()

# Create a dummy variable.
name &lt;- "parabar"

# Export the variable to the backend.
backend$export("name")

# Remove variable from current environment.
rm(name)

# Run an expression on the backend, using the exported variable `name`.
backend$evaluate({
    # Print the name.
    print(paste0("Hello, ", name, "!"))
})

# Run a task in parallel (i.e., approx. 2.5 seconds).
backend$sapply(
    x = 1:10,
    fun = function(x) {
        # Sleep a bit.
        Sys.sleep(0.5)

        # Compute something.
        output &lt;- x + 1

        # Return the result.
        return(output)
    }
)

# Right know the main process is free and the task is executing on a `psock`
# cluster started in a background `R` session.

# Trying to get the output immediately will throw an error, indicating that the
# task is still running.
try(backend$get_output())

# However, we can block the main process and wait for the task to complete
# before fetching the results.
backend$get_output(wait = TRUE)

# Clear the backend.
backend$clear()

# Check that there is nothing on the cluster.
backend$peek()

# Stop the backend.
backend$stop()

# Check that the backend is not active.
backend$active

</code></pre>


</div>
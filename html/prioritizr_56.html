<div class="container">

<table style="width: 100%;"><tr>
<td>add_linear_constraints</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add linear constraints</h2>

<h3>Description</h3>

<p>Add constraints to a conservation planning problem to ensure
that all selected planning units meet certain criteria.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'ConservationProblem,ANY,ANY,character'
add_linear_constraints(x, threshold, sense, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,numeric'
add_linear_constraints(x, threshold, sense, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,matrix'
add_linear_constraints(x, threshold, sense, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,Matrix'
add_linear_constraints(x, threshold, sense, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,Raster'
add_linear_constraints(x, threshold, sense, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,SpatRaster'
add_linear_constraints(x, threshold, sense, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,dgCMatrix'
add_linear_constraints(x, threshold, sense, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>problem()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p><code>numeric</code> value.
This threshold value is also known as a "right-hand-side" value
per integer programming terminology.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sense</code></td>
<td>
<p><code>character</code> sense for the constraint. Available
options include <code>"&gt;="</code>, <code>"&lt;="</code>, or <code>"="</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>character</code>, <code>numeric</code>,
<code>terra::rast()</code>, <code>matrix</code>, or <code>Matrix</code> object
containing the constraint values.
These constraint values are also known as constraint coefficients
per integer programming terminology.
See the Data format section for more information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function adds general purpose constraints that can be used to
ensure that solutions meet certain criteria
(see Examples section below for details).
For example, these constraints can be used to add multiple budgets.
They can also be used to ensure that the total number of planning units
allocated to a certain administrative area (e.g., country) does not exceed
a certain threshold (e.g., 30% of its total area). Furthermore,
they can also be used to ensure that features have a minimal level
of representation (e.g., 30%) when using an objective
function that aims to enhance feature representation given a budget
(e.g., <code>add_min_shortfall_objective()</code>).
</p>


<h3>Value</h3>

<p>An updated <code>problem()</code> object with the constraints added to it.
</p>


<h3>Mathematical formulation</h3>

<p>The linear constraints are implemented using the following
equation.
Let <code class="reqn">I</code> denote the set of planning units
(indexed by <code class="reqn">i</code>), <code class="reqn">Z</code> the set of management zones (indexed by
<code class="reqn">z</code>), and <code class="reqn">X_{iz}</code> the decision variable for allocating
planning unit <code class="reqn">i</code> to zone <code class="reqn">z</code> (e.g., with binary
values indicating if each planning unit is allocated or not). Also, let
<code class="reqn">D_{iz}</code> denote the constraint data associated with
planning units <code class="reqn">i \in I</code> for zones <code class="reqn">z \in Z</code>
(argument to <code>data</code>, if supplied as a <code>matrix</code> object),
<code class="reqn">\theta</code> denote the constraint sense
(argument to <code>sense</code>, e.g., <code class="reqn">&lt;=</code>), and <code class="reqn">t</code> denote the constraint
threshold (argument to <code>threshold</code>).
</p>
<p style="text-align: center;"><code class="reqn">
\sum_{i}^{I} \sum_{z}^{Z} (D_{iz} \times X_{iz}) \space \theta \space t
</code>
</p>



<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using the following formats.
</p>

<dl>
<dt>
<code>data</code> as <code>character</code> vector</dt>
<dd>
<p>containing column name(s) that
contain penalty values for planning units. This format is only
compatible if the planning units in the argument to <code>x</code> are a
<code>sf::sf()</code> or <code>data.frame</code> object. The column(s) must have <code>numeric</code>
values, and must not contain any missing (<code>NA</code>) values.
For problems that contain a single zone, the argument to <code>data</code> must
contain a single column name. Otherwise, for problems that
contain multiple zones, the argument to <code>data</code> must
contain a column name for each zone.</p>
</dd>
<dt>
<code>data</code> as a <code>numeric</code> vector</dt>
<dd>
<p>containing values for
planning units. These values must not contain any missing
(<code>NA</code>) values. Note that this format is only available
for planning units that contain a single zone.</p>
</dd>
<dt>
<code>data</code> as a <code>matrix</code>/<code>Matrix</code> object</dt>
<dd>
<p>containing <code>numeric</code> values
that specify data for each planning unit.
Each row corresponds to a planning unit, each column corresponds to a
zone, and each cell indicates the data for penalizing a planning unit
when it is allocated to a given zone.</p>
</dd>
<dt>
<code>data</code> as a <code>terra::rast()</code> object</dt>
<dd>
<p>containing values for planning
units. This format is only
compatible if the planning units in the argument to <code>x</code> are
<code>sf::sf()</code>, or <code>terra::rast()</code> objects.
If the planning unit data are a <code>sf::sf()</code> object,
then the values are calculated by overlaying the
planning units with the argument to <code>data</code> and calculating the sum of the
values associated with each planning unit.
If the planning unit data are a <code>terra::rast()</code> object, then the values
are calculated by extracting the cell
values (note that the planning unit data and the argument to <code>data</code> must
have exactly the same dimensionality, extent, and missingness).
For problems involving multiple zones, the argument to <code>data</code> must
contain a layer for each zone.</p>
</dd>
</dl>
<h3>See Also</h3>

<p>See constraints for an overview of all functions for adding constraints.
</p>
<p>Other constraints: 
<code>add_contiguity_constraints()</code>,
<code>add_feature_contiguity_constraints()</code>,
<code>add_locked_in_constraints()</code>,
<code>add_locked_out_constraints()</code>,
<code>add_mandatory_allocation_constraints()</code>,
<code>add_manual_bounded_constraints()</code>,
<code>add_manual_locked_constraints()</code>,
<code>add_neighbor_constraints()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create a baseline problem with minimum shortfall objective
p0 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_shortfall_objective(1800) %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s0 &lt;- solve(p0)

# plot solution
plot(s0, main = "solution", axes = FALSE)

# now let's create some modified versions of this baseline problem by
# adding additional criteria using linear constraints

# first, let's create a modified version of p0 that contains
# an additional budget for a secondary cost dataset

# create a secondary cost dataset by simulating values
sim_pu_raster2 &lt;- simulate_cost(sim_pu_raster)

# plot the primary cost dataset (sim_pu_raster) and
# the secondary cost dataset (sim_pu_raster2)
plot(
  c(sim_pu_raster, sim_pu_raster2),
  main = c("sim_pu_raster", "sim_pu_raster2"),
  axes = FALSE
)

# create a modified version of p0 with linear constraints that
# specify that the planning units in the solution must not have
# values in sim_pu_raster2 that sum to a total greater than 500
p1 &lt;-
  p0 %&gt;%
  add_linear_constraints(
    threshold = 500, sense = "&lt;=", data = sim_pu_raster2
  )

# solve problem
s1 &lt;- solve(p1)

# plot solutions s1 and s2 to compare them
plot(c(s0, s1), main = c("s0", "s1"), axes = FALSE)

# second, let's create a modified version of p0 that contains
# additional constraints to ensure that each feature definitely has
# at least 8% of its overall distribution represented by the solution
# (in addition to the 20% targets which specify how much we would
# ideally want to conserve for each feature) 

# to achieve this, we need to calculate the total amount of each feature
# within the planning units so we can, in turn, set the constraint thresholds
feat_abund &lt;- feature_abundances(p0)$absolute_abundance

# create a modified version of p0 with additional constraints for each
# feature to specify that the planning units in the solution must
# secure at least 8% of the total abundance for each feature
p2 &lt;- p0
for (i in seq_len(terra::nlyr(sim_features))) {
  p2 &lt;-
    p2 %&gt;%
    add_linear_constraints(
      threshold = feat_abund[i] * 0.08,
      sense = "&gt;=",
      data = sim_features[[i]]
    )
}

# overall, p2 could be described as an optimization problem
# that maximizes feature representation as much as possible
# towards securing 20% of the total amount of each feature,
# whilst ensuring that (i) the total cost of the solution does
# not exceed 1800 (per cost values in sim_pu_raster) and (ii)
# the solution secures at least 8% of the total amount of each feature
# (if 20% is not possible due to the budget)

# solve problem
s2 &lt;- solve(p2)

# plot solutions s0 and s2 to compare them
plot(c(s0, s2), main = c("s1", "s2"), axes = FALSE)

# third, let's create a modified version of p0 that contains
# additional constraints to ensure that the solution equitably
# distributes conservation effort across different administrative areas
# (e.g., countries) within the study region

# to begin with, we will simulate a dataset describing the spatial extent of
# four different administrative areas across the study region
sim_admin &lt;- sim_pu_raster
sim_admin &lt;- terra::aggregate(sim_admin, fact = 5)
sim_admin &lt;- terra::setValues(sim_admin, seq_len(terra::ncell(sim_admin)))
sim_admin &lt;- terra::resample(sim_admin, sim_pu_raster, method = "near")
sim_admin &lt;- terra::mask(sim_admin, sim_pu_raster)

# plot administrative areas layer,
# we can see that the administrative areas subdivide
# the study region into four quadrants, and the sim_admin object is a
# SpatRaster with integer values denoting ids for the administrative areas
plot(sim_admin, axes = FALSE)

# next we will convert the sim_admin SpatRaster object into a SpatRaster
# object (with a layer for each administrative area) indicating which
# planning units belong to each administrative area using binary
# (presence/absence) values
sim_admin2 &lt;- binary_stack(sim_admin)

# plot binary stack of administrative areas
plot(sim_admin2, axes = FALSE)

# we will now calculate the total amount of planning units associated
# with each administrative area, so that we can set the constraint threshold

# since we are using raster data, we won't bother explicitly
# accounting for the total area of each planning unit (because all
# planning units have the same area in raster formats) -- but if we were
# using vector data then we would need to account for the area of each unit
admin_total &lt;- Matrix::rowSums(rij_matrix(sim_pu_raster, sim_admin2))

# create a modified version of p0 with additional constraints for each
# administrative area to specify that the planning units in the solution must
# not encompass more than 10% of the total extent of the administrative
# area
p3 &lt;- p0
for (i in seq_len(terra::nlyr(sim_admin2))) {
  p3 &lt;-
    p3 %&gt;%
    add_linear_constraints(
      threshold = admin_total[i] * 0.1,
      sense = "&lt;=",
      data = sim_admin2[[i]]
    )
}

# solve problem
s3 &lt;- solve(p3)

# plot solutions s0 and s3 to compare them
plot(c(s0, s3), main = c("s0", "s3"), axes = FALSE)

## End(Not run)

</code></pre>


</div>
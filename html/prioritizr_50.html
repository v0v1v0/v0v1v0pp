<div class="container">

<table style="width: 100%;"><tr>
<td>add_gurobi_solver</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add a <em>Gurobi</em> solver</h2>

<h3>Description</h3>

<p>Specify that the <a href="https://www.gurobi.com/"><em>Gurobi</em></a> software
should be used to solve a conservation planning problem
(Gurobi Optimization LLC 2021). This function can also be used to
customize the behavior of the solver.
It requires the <span class="pkg">gurobi</span> package to be installed
(see below for installation instructions).
</p>


<h3>Usage</h3>

<pre><code class="language-R">add_gurobi_solver(
  x,
  gap = 0.1,
  time_limit = .Machine$integer.max,
  presolve = 2,
  threads = 1,
  first_feasible = FALSE,
  numeric_focus = FALSE,
  node_file_start = Inf,
  start_solution = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>problem()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gap</code></td>
<td>
<p><code>numeric</code> gap to optimality. This gap is relative
and expresses the acceptable deviance from the optimal objective.
For example, a value of 0.01 will result in the solver stopping when
it has found a solution within 1% of optimality.
Additionally, a value of 0 will result in the solver stopping
when it has found an optimal solution.
The default value is 0.1 (i.e., 10% from optimality).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_limit</code></td>
<td>
<p><code>numeric</code> time limit (seconds) for generating solutions.
The solver will return the current best solution when this time limit is
exceeded. The default value is the largest integer value
(i.e., <code>.Machine$integer.max</code>), effectively meaning that solver
will keep running until a solution within the optimality gap is found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>presolve</code></td>
<td>
<p><code>integer</code> number indicating how intensively the
solver should try to simplify the problem before solving it. Available
options are: (-1) automatically determine the intensity of
pre-solving, (0) disable pre-solving, (1) conservative
level of pre-solving, and (2) very aggressive level of pre-solving .
The default value is 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threads</code></td>
<td>
<p><code>integer</code> number of threads to use for the
optimization algorithm. The default value is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>first_feasible</code></td>
<td>
<p><code>logical</code> should the first feasible solution be
be returned? If <code>first_feasible</code> is set to <code>TRUE</code>, the solver
will return the first solution it encounters that meets all the
constraints, regardless of solution quality. Note that the first feasible
solution is not an arbitrary solution, rather it is derived from the
relaxed solution, and is therefore often reasonably close to optimality.
Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numeric_focus</code></td>
<td>
<p><code>logical</code> should extra attention be paid
to verifying the accuracy of numerical calculations? This may be
useful when dealing with problems that may suffer from numerical instability
issues. Beware that it will likely substantially increase run time
(sets the <em>Gurobi</em> <code>NumericFocus</code> parameter
to 3). Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node_file_start</code></td>
<td>
<p><code>numeric</code> threshold amount of memory (in GB).
Once the amount of memory (RAM) used to store information for solving
the optimization problem exceeds this parameter value, the solver
will begin storing this information on disk
(using the <em>Gurobi</em> <code>NodeFileStart</code> parameter).
This functionality is useful if the system has insufficient memory to
solve a given problem (e.g., solving the problem with default settings
yields the <code style="white-space: pre;">⁠OUT OF MEMORY⁠</code> error message) and a system with more memory is
not readily available.
For example, a value of 4 indicates that the solver will start using
the disk after it uses more than 4 GB of memory to store information
on solving the problem.
Defaults to <code>Inf</code> such that the solver will not attempt
to store information on disk when solving a given problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_solution</code></td>
<td>
<p><code>NULL</code> or object containing the starting solution
for the solver. This is can be useful because specifying a starting
solution can speed up the optimization process.
Defaults to <code>NULL</code> such that no starting solution is used.
To specify a starting solution, the argument to <code>start_solution</code> should
be in the same format as the planning units (i.e., a <code>NULL</code>, <code>numeric</code>,
<code>matrix</code>, <code>data.frame</code>, <code>terra::rast()</code>, or <code>sf::sf()</code> object).
See the Start solution format section for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>logical</code> should information be printed while solving
optimization problems? Defaults to <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><a href="https://www.gurobi.com/"><em>Gurobi</em></a> is a
state-of-the-art commercial optimization software with an R package
interface. It is by far the fastest of the solvers available for
generating prioritizations, however, it is not freely
available. That said, licenses are available to academics at no cost. The
<span class="pkg">gurobi</span> package is distributed with the <em>Gurobi</em> software suite.
This solver uses the <span class="pkg">gurobi</span> package to solve problems.
For information on the performance of different solvers,
please see Schuster <em>et al.</em> (2020) for benchmarks comparing the
run time and solution quality of different solvers when applied to
different sized datasets.
</p>


<h3>Value</h3>

<p>An updated <code>problem()</code> object with the solver added to it.
</p>


<h3>Installation</h3>

<p>Please see the <em>Gurobi Installation Guide</em> vignette for details on
installing the <em>Gurobi</em> software and the <span class="pkg">gurobi</span> package.
You can access this vignette
<a href="https://prioritizr.net/articles/gurobi_installation_guide.html">online</a>
or using the following code:
</p>
<div class="sourceCode"><pre>vignette("gurobi_installation_guide", package = "prioritizr")
</pre></div>


<h3>Start solution format</h3>

<p>Broadly speaking, the argument to <code>start_solution</code> must be in the same
format as the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt>
<code>x</code> has <code>numeric</code> planning units</dt>
<dd>
<p>The argument to <code>start_solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>start_solution</code>.
</p>
</dd>
<dt>
<code>x</code> has <code>matrix</code> planning units</dt>
<dd>
<p>The argument to <code>start_solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>start_solution</code>.
</p>
</dd>
<dt>
<code>x</code> has <code>terra::rast()</code> planning units</dt>
<dd>
<p>The argument to <code>start_solution</code>
be a <code>terra::rast()</code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>start_solution</code>.
</p>
</dd>
<dt>
<code>x</code> has <code>data.frame</code> planning units</dt>
<dd>
<p>The argument to <code>start_solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code>sf::sf()</code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>start_solution</code>.
</p>
</dd>
<dt>
<code>x</code> has <code>sf::sf()</code> planning units</dt>
<dd>
<p>The argument to <code>start_solution</code> must be
a <code>sf::sf()</code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code>sf::sf()</code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>start_solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>start_solution</code>.
</p>
</dd>
</dl>
<h3>References</h3>

<p>Gurobi Optimization LLC (2021) Gurobi Optimizer Reference Manual.
<a href="https://www.gurobi.com">https://www.gurobi.com</a>.
</p>
<p>Schuster R, Hanson JO, Strimas-Mackey M, and Bennett JR (2020). Exact
integer linear programming solvers outperform simulated annealing for
solving conservation planning problems. <em>PeerJ</em>, 8: e9258.
</p>


<h3>See Also</h3>

<p>See solvers for an overview of all functions for adding a solver.
</p>
<p>Other solvers: 
<code>add_cbc_solver()</code>,
<code>add_cplex_solver()</code>,
<code>add_default_solver()</code>,
<code>add_highs_solver()</code>,
<code>add_lsymphony_solver</code>,
<code>add_rsymphony_solver()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create problem
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_gurobi_solver(gap = 0, verbose = FALSE)

# generate solution
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# create a similar problem with boundary length penalties and
# specify the solution from the previous run as a starting solution
p2 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_boundary_penalties(10) %&gt;%
  add_binary_decisions() %&gt;%
  add_gurobi_solver(gap = 0, start_solution = s1, verbose = FALSE)

# generate solution
s2 &lt;- solve(p2)

# plot solution
plot(s2, main = "solution with boundary penalties", axes = FALSE)

## End(Not run)
</code></pre>


</div>
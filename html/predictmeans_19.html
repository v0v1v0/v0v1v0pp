<div class="container">

<table style="width: 100%;"><tr>
<td>semipred</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Predicted Means of a Semi Paramatric Model with Covariate Variable(s)
</h2>

<h3>Description</h3>

<p>This function produces predicted means with graph for a semi paramatric model with new set of covariate values.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  semipred(semireg, modelterm=NULL, covariate, sm_term=NULL, contr=NULL,
           covariateV=NULL, boundary=NULL, level=0.05, trans=NULL, trellis=TRUE, 
		   scales=c("fixed", "free", "free_x", "free_y"),
		   plotord=NULL, ci=TRUE, point=TRUE, jitterv=0, threeD=FALSE, prt=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>semireg</code></td>
<td>

<p>A list object returned by <code>semireg</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelterm</code></td>
<td>

<p>Name (in "quotes") for indicating which factor term's predicted mean to be calculated. 
The <code>modelterm</code> must be given exactly as it appears in <code>semireg</code> model, e.g. "A" or "A:B". In case <code>modelterm</code> is the same as <code>covariate</code> or <code>NULL</code>, them <code>semipred</code> will product predictmeans with CI based on <code>covariate</code> only with out any grouping.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate</code></td>
<td>

<p>Name (in "quotes") of one or two (for <code>Ztps</code> smooth) the covariate variables in the <code>semireg</code> shuch as "x1" or c("x1", "x2").
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sm_term</code></td>
<td>

<p>Names (in "quotes") of smooth terms (from <code>smoothZ</code> list in <code>semireg</code> model) used in the prediction such as "sm1_grp" or c("sm1_grp", "sm2_grp"). The default is using all smooth terms which is <code>sm_term=NULL</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contr</code></td>
<td>

<p>A numeric vector with length of two (e.g. c(4, 1)) which indicates to produce predicted mean with CI for difference between <code>modelterm</code> level 4 vs level 1 along <code>covariate</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariateV</code></td>
<td>

<p>A numeric vector or matrix, then semipred will produce the result for <code>covariate</code> at value of <code>covariateV</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>

<p>A matrix or data frame of two columns, used to specify boundary of longitude and latitude, it is functional when the length of covariate is two.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>

<p>A significant level for calculating confident interval. The default value is 0.05.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>

<p>A function object for calculating the back transformed means, e.g. <code>trans=exp</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trellis</code></td>
<td>

<p>A logical scalar. If set to TRUE (default), a trellis plots of predicted means with CI will be drawn.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scales</code></td>
<td>

<p>Should scales be fixed ("fixed", the default), free ("free"), or free in one dimension ("free_x", "free_y") in a trellis graph?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotord</code></td>
<td>

<p>A numeric vector specifying the order of plotting for two way interaction (e.g. 
<code>plotord = c(2, 1)</code> will put the second variable in <code>modelterm</code> on the <code>X</code> 
axis, the first variable as the grouping variable, and the third one as the panel variable). 
The defaults are <code>c(1, 2)</code> for two way interactions. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>

<p>A logical scalar to indicate whether to print confidence interval. The default value is TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>point</code></td>
<td>

<p>A logical scalar to indicate whether to print raw data points. The default value is TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitterv</code></td>
<td>

<p>A degree of jitter in x and y direction in the graph. The default is zero.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threeD</code></td>
<td>

<p>A logical scalar to indicate whether to produce a 3-D plot or not. The default value is FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prt</code></td>
<td>

<p>A logical scalar to indicate whether to produce plots on the screen or not. The default value is TRUE.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>plt</code></td>
<td>
<p>A ggplot object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred_df</code></td>
<td>
<p>A data.frame with predcted data.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>Examples</h3>

<pre><code class="language-R"># library(predictmeans)
# data(Dialyzer, package="nlme")
# help(Dialyzer)
# str(Dialyzer)
# 
# library(ggplot2)
# ggplot(Dialyzer, aes(x=rate, y=pressure, col=QB)) +
#   geom_line() +
#   facet_wrap(vars(Subject))
# 
# fm &lt;- semireg(pressure ~ rate*QB+(rate|Subject),
#               smoothZ=list(
#                 qb_grp=smZ(rate, by=QB, group=TRUE)
#               ),
#               data=Dialyzer)
# str(fm$data)
# summary(fm$semer)
# residplot(fm$semer)
# anova(fm$semer)
# ranova(fm$semer)
# 
# ap_out1 &lt;- semipred(fm, "QB", "rate")
# str(ap_out1$pred_df)
# ap_out2 &lt;- semipred(fm, "QB", "rate", contr=c(1,2))
# str(ap_out2$pred_df)
# 
# help(sleepstudy)
# str(sleepstudy)
# library(latticeExtra)
# x11()
# xyplot(Reaction ~ Days | Subject, sleepstudy, aspect = "xy",
#        layout = c(9, 2), type = c("g", "p", "r"),
#        index.cond = function(x, y) coef(lm(y ~ x))[2],
#        xlab = "Days of sleep deprivation",
#        ylab = "Average reaction time (ms)",
#        as.table = TRUE)
# 
# sleep.semi &lt;- semireg(Reaction ~ Days*Subject, 
#                     smoothZ=list(
#                       sub_grp=smZ(Days, by=Subject, group=TRUE)
#                     ), 
#                     data=sleepstudy)
# residplot(sleep.semi$semer)
# summary(sleep.semi$semer)
# anova(sleep.semi$semer)
# ranova(sleep.semi$semer)

# x11()
# predout1 &lt;- semipred(sleep.semi, "Subject", "Days")
# str(predout1$pred_df)
# x11()
# predout2 &lt;- semipred(sleep.semi, "Subject", "Days", contr = c(6,1))
# str(predout2$pred_df) 
</code></pre>


</div>
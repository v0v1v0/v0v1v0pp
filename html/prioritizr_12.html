<div class="container">

<table style="width: 100%;"><tr>
<td>add_asym_connectivity_penalties</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add asymmetric connectivity penalties</h2>

<h3>Description</h3>

<p>Add penalties to a conservation planning problem to account for
asymmetric connectivity between planning units.
Asymmetric connectivity data describe connectivity information that is
directional.
For example, asymmetric connectivity data could describe
the strength of rivers flowing between different planning units. Since
river flow is directional, the level of connectivity
from an upstream planning unit to a downstream planning unit would
be higher than that from a downstream planning unit to an upstream planning
unit.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'ConservationProblem,ANY,ANY,matrix'
add_asym_connectivity_penalties(x, penalty, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,Matrix'
add_asym_connectivity_penalties(x, penalty, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,data.frame'
add_asym_connectivity_penalties(x, penalty, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,dgCMatrix'
add_asym_connectivity_penalties(x, penalty, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,array'
add_asym_connectivity_penalties(x, penalty, zones, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>problem()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p><code>numeric</code> penalty that is used to scale the importance
of selecting planning units with strong connectivity between them compared
to the main problem objective (e.g., solution cost when the argument to
<code>x</code> has a minimum set objective set using
<code>add_min_set_objective()</code>). Higher <code>penalty</code> values
can be used to obtain solutions with a high degree of connectivity,
and smaller <code>penalty</code> values can be used to obtain solutions with a
small degree of connectivity. Note that negative <code>penalty</code> values can
be used to obtain solutions that have very little connectivity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zones</code></td>
<td>
<p><code>matrix</code> or <code>Matrix</code> object describing the
level of connectivity between different zones. Each row and column
corresponds to a different zone in the argument to <code>x</code>, and cell
values indicate the level of connectivity between each combination
of zones. Cell values along the diagonal of the matrix represent
the level of connectivity between planning units allocated to the
same zone. Cell values must lay between 1 and -1, where negative
values favor solutions with weak connectivity. The default argument to
<code>zones</code> is an identity matrix (i.e., a matrix with ones along the
matrix diagonal and zeros elsewhere), so that planning units are
only considered to be connected when they are allocated to the same zone.
This argument is required when working with multiple zones and the
argument to <code>data</code> is a <code>matrix</code> or <code>Matrix</code> object.
If the argument to <code>data</code> is an <code>array</code> or <code>data.frame</code> with data for
multiple zones (e.g., using the <code>"zone1"</code> and <code>"zone2"</code> column names),
this argument must explicitly be set to <code>NULL</code> otherwise an error will be
thrown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>matrix</code>, <code>Matrix</code>, <code>data.frame</code>, or
<code>array</code> object containing connectivity data. The connectivity values
correspond to the strength of connectivity between
different planning units. Thus connections between planning units
that are associated with higher values are more favorable in the solution.
See the Data format section for more information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function adds penalties to conservation planning problem to penalize
solutions that have low connectivity.
Specifically, it penalizes solutions that select planning units that
share high connectivity values with other planning units that are
not selected by the solution (based on Beger <em>et al.</em> 2010).
</p>


<h3>Value</h3>

<p>An updated <code>problem()</code> object with the penalties added to it.
</p>


<h3>Mathematical formulation</h3>

<p>The connectivity penalties are implemented using the following equations.
Let <code class="reqn">I</code> represent the set of planning units
(indexed by <code class="reqn">i</code> or <code class="reqn">j</code>), <code class="reqn">Z</code> represent the set
of management zones (indexed by <code class="reqn">z</code> or <code class="reqn">y</code>), and <code class="reqn">X_{iz}</code>
represent the decision variable for planning unit <code class="reqn">i</code> for in zone
<code class="reqn">z</code> (e.g., with binary
values one indicating if planning unit is allocated or not). Also, let
<code class="reqn">p</code> represent the argument to <code>penalty</code>, <code class="reqn">D</code> represent the
argument to <code>data</code>, and <code class="reqn">W</code> represent the argument
to <code>zones</code>.
</p>
<p>If the argument to <code>data</code> is supplied as a <code>matrix</code> or
<code>Matrix</code> object, then the penalties are calculated as:
</p>
<p style="text-align: center;"><code class="reqn">
\sum_{i}^{I} \sum_{j}^{I} \sum_{z}^{Z} \sum_{y}^{Z}
(p \times X_{iz} \times D_{ij} \times W_{zy}) -
\sum_{i}^{I} \sum_{j}^{I} \sum_{z}^{Z} \sum_{y}^{Z}
(p \times X_{iz} \times X_{jy} \times D_{ij} \times W_{zy})</code>
</p>

<p>Otherwise, if the argument to <code>data</code> is supplied as an
<code>array</code> object, then the penalties are
calculated as:
</p>
<p style="text-align: center;"><code class="reqn">
\sum_{i}^{I} \sum_{j}^{I} \sum_{z}^{Z} \sum_{y}^{Z}
(p \times X_{iz} \times D_{ijzy}) -
\sum_{i}^{I} \sum_{j}^{I} \sum_{z}^{Z} \sum_{y}^{Z}
(p \times X_{iz} \times X_{jy} \times D_{ijzy})</code>
</p>

<p>Note that when the problem objective is to maximize some measure of
benefit and not minimize some measure of cost, the term <code class="reqn">p</code> is
replaced with <code class="reqn">-p</code>.
</p>


<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using several different formats.
</p>

<dl>
<dt>
<code>data</code> as a <code>matrix</code>/<code>Matrix</code> object</dt>
<dd>
<p>where rows and columns represent
different planning units and the value of each cell represents the
strength of connectivity between two different planning units. Cells
that occur along the matrix diagonal are treated as weights which
indicate that planning units are more desirable in the solution.
The argument to <code>zones</code> can be used to control
the strength of connectivity between planning units in different zones.
The default argument for <code>zones</code> is to treat planning units
allocated to different zones as having zero connectivity.</p>
</dd>
<dt>
<code>data</code> as a <code>data.frame</code> object</dt>
<dd>
<p>containing columns that are named
<code>"id1"</code>, <code>"id2"</code>, and <code>"boundary"</code>. Here, each row
denotes the connectivity between a pair of planning units
(per values in the <code>"id1"</code> and <code>"id2"</code> columns) following the
<em>Marxan</em> format.
If the argument to <code>x</code> contains multiple zones, then the
<code>"zone1"</code> and <code>"zone2"</code> columns can optionally be provided to manually
specify the connectivity values between planning units when they are
allocated to specific zones. If the <code>"zone1"</code> and
<code>"zone2"</code> columns are present, then the argument to <code>zones</code> must be
<code>NULL</code>.</p>
</dd>
<dt>
<code>data</code> as an <code>array</code> object</dt>
<dd>
<p>containing four-dimensions where cell values
indicate the strength of connectivity between planning units
when they are assigned to specific management zones. The first two
dimensions (i.e., rows and columns) indicate the strength of
connectivity between different planning units and the second two
dimensions indicate the different management zones. Thus
the <code>data[1, 2, 3, 4]</code> indicates the strength of
connectivity between planning unit 1 and planning unit 2 when planning
unit 1 is assigned to zone 3 and planning unit 2 is assigned to zone 4.</p>
</dd>
</dl>
<h3>References</h3>

<p>Beger M, Linke S, Watts M, Game E, Treml E, Ball I, and Possingham, HP (2010)
Incorporating asymmetric connectivity into spatial decision making for
conservation, <em>Conservation Letters</em>, 3: 359â€“368.
</p>


<h3>See Also</h3>

<p>See penalties for an overview of all functions for adding penalties.
</p>
<p>Other penalties: 
<code>add_boundary_penalties()</code>,
<code>add_connectivity_penalties()</code>,
<code>add_feature_weights()</code>,
<code>add_linear_penalties()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# load package
library(Matrix)

# set seed for reproducibility
set.seed(600)

# load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create basic problem
p1 &lt;-
  problem(sim_pu_polygons, sim_features, "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_default_solver(verbose = FALSE)

# create an asymmetric connectivity matrix. Here, connectivity occurs between
# adjacent planning units and, due to rivers flowing southwards
# through the study area, connectivity from northern planning units to
# southern planning units is ten times stronger than the reverse.
acm1 &lt;- matrix(0, nrow(sim_pu_polygons), nrow(sim_pu_polygons))
acm1 &lt;- as(acm1, "Matrix")
centroids &lt;- sf::st_coordinates(
  suppressWarnings(sf::st_centroid(sim_pu_polygons))
)
adjacent_units &lt;- sf::st_intersects(sim_pu_polygons, sparse = FALSE)
for (i in seq_len(nrow(sim_pu_polygons))) {
  for (j in seq_len(nrow(sim_pu_polygons))) {
    # find if planning units are adjacent
    if (adjacent_units[i, j]) {
      # find if planning units lay north and south of each other
      # i.e., they have the same x-coordinate
      if (centroids[i, 1] == centroids[j, 1]) {
        if (centroids[i, 2] &gt; centroids[j, 2]) {
          # if i is north of j add 10 units of connectivity
          acm1[i, j] &lt;- acm1[i, j] + 10
        } else if (centroids[i, 2] &lt; centroids[j, 2]) {
          # if i is south of j add 1 unit of connectivity
          acm1[i, j] &lt;- acm1[i, j] + 1
        }
      }
    }
  }
}

# rescale matrix values to have a maximum value of 1
acm1 &lt;- rescale_matrix(acm1, max = 1)

# visualize asymmetric connectivity matrix
image(acm1)

# create penalties
penalties &lt;- c(1, 50)

# create problems using the different penalties
p2 &lt;- list(
  p1,
  p1 %&gt;% add_asym_connectivity_penalties(penalties[1], data = acm1),
  p1 %&gt;% add_asym_connectivity_penalties(penalties[2], data = acm1)
)

# solve problems
s2 &lt;- lapply(p2, solve)

# create object with all solutions
s2 &lt;- sf::st_sf(
  tibble::tibble(
    p2_1 = s2[[1]]$solution_1,
    p2_2 = s2[[2]]$solution_1,
    p2_3 = s2[[3]]$solution_1
 ),
 geometry = sf::st_geometry(s2[[1]])
)

names(s2)[1:3] &lt;- c("basic problem", paste0("acm1 (", penalties,")"))

# plot solutions based on different penalty values
plot(s2, cex = 1.5)

# create minimal multi-zone problem and limit solver to one minute
# to obtain solutions in a short period of time
p3 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(0.15, nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(time_limit = 60, verbose = FALSE)

# crate asymmetric connectivity data by randomly simulating values
acm2 &lt;- matrix(
  runif(ncell(sim_zones_pu_raster) ^ 2),
  nrow = ncell(sim_zones_pu_raster)
)

# create multi-zone problems using the penalties
p4 &lt;- list(
  p3,
  p3 %&gt;% add_asym_connectivity_penalties(penalties[1], data = acm2),
  p3 %&gt;% add_asym_connectivity_penalties(penalties[2], data = acm2)
)

# solve problems
s4 &lt;- lapply(p4, solve)
s4 &lt;- lapply(s4, category_layer)
s4 &lt;- terra::rast(s4)
names(s4) &lt;- c("basic problem", paste0("acm2 (", penalties,")"))

# plot solutions
plot(s4, axes = FALSE)

## End(Not run)

</code></pre>


</div>
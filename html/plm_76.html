<div class="container">

<table style="width: 100%;"><tr>
<td>is.pconsecutive</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Check if time periods are consecutive</h2>

<h3>Description</h3>

<p>This function checks for each individual if its associated time periods are
consecutive (no "gaps" in time dimension per individual)
</p>


<h3>Usage</h3>

<pre><code class="language-R">is.pconsecutive(x, ...)

## Default S3 method:
is.pconsecutive(x, id, time, na.rm.tindex = FALSE, ...)

## S3 method for class 'data.frame'
is.pconsecutive(x, index = NULL, na.rm.tindex = FALSE, ...)

## S3 method for class 'pseries'
is.pconsecutive(x, na.rm.tindex = FALSE, ...)

## S3 method for class 'pdata.frame'
is.pconsecutive(x, na.rm.tindex = FALSE, ...)

## S3 method for class 'panelmodel'
is.pconsecutive(x, na.rm.tindex = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>usually, an object of class <code>pdata.frame</code>,
<code>data.frame</code>, <code>pseries</code>, or an estimated
<code>panelmodel</code>; for the default method <code>x</code> can also be
an arbitrary vector or <code>NULL</code>, see <strong>Details</strong>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id, time</code></td>
<td>
<p>only relevant for default method: vectors specifying
the id and time dimensions, i. e., a sequence of individual and
time identifiers, each as stacked time series,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm.tindex</code></td>
<td>
<p>logical indicating whether any <code>NA</code> values
in the time index are removed before consecutiveness is
evaluated (defaults to <code>FALSE</code>),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>only relevant for <code>data.frame</code> interface; if
<code>NULL</code>, the first two columns of the data.frame are
assumed to be the index variables; if not <code>NULL</code>, both
dimensions ('individual', 'time') need to be specified by
<code>index</code> for <code>is.pconsecutive</code> on data frames, for
further details see <code>pdata.frame()</code>,</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>(p)data.frame, pseries and estimated panelmodel objects can be tested if
their time periods are consecutive per individual.  For evaluation of
consecutiveness, the time dimension is interpreted to be numeric, and the
data are tested for being a regularly spaced sequence with distance 1
between the time periods for each individual (for each individual the time
dimension can be interpreted as sequence t, t+1, t+2, ... where t is an
integer). As such, the "numerical content" of the time index variable is
considered for consecutiveness, not the "physical position" of the various
observations for an individuals in the (p)data.frame/pseries (it is not
about "neighbouring" rows). If the object to be evaluated is a pseries or a
pdata.frame, the time index is coerced from factor via as.character to
numeric, i.e., the series
<code style="white-space: pre;">⁠as.numeric(as.character(index(&lt;pseries/pdata.frame&gt;)[[2]]))]⁠</code> is
evaluated for gaps.
</p>
<p>The default method also works for argument <code>x</code> being an arbitrary
vector (see <strong>Examples</strong>), provided one can supply arguments <code>id</code>
and <code>time</code>, which need to ordered as stacked time series. As only
<code>id</code> and <code>time</code> are really necessary for the default method to
evaluate the consecutiveness, <code>x = NULL</code> is also possible. However, if
the vector <code>x</code> is also supplied, additional input checking for equality
of the lengths of <code>x</code>, <code>id</code> and <code>time</code> is performed, which is
safer.
</p>
<p>For the data.frame interface, the data is ordered in the appropriate way
(stacked time series) before the consecutiveness is evaluated. For the
pdata.frame and pseries interface, ordering is not performed because both
data types are already ordered in the appropriate way when created.
</p>
<p>Note: Only the presence of the time period itself in the object is tested,
not if there are any other variables.  <code>NA</code> values in individual index
are not examined but silently dropped - In this case, it is not clear which
individual is meant by id value <code>NA</code>, thus no statement about
consecutiveness of time periods for those "<code>NA</code>-individuals" is
possible.
</p>


<h3>Value</h3>

<p>A named <code>logical</code> vector (names are those of the
individuals). The i-th element of the returned vector
corresponds to the i-th individual. The values of the i-th
element can be: </p>
<table>
<tr style="vertical-align: top;">
<td><code>TRUE</code></td>
<td>
<p>if the i-th individual has
consecutive time periods,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FALSE</code></td>
<td>
<p>if the i-th
individual has non-consecutive time periods,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>"NA"</code></td>
<td>
<p>if there are any NA values in time index of
the i-th the individual; see also argument <code>na.rm.tindex</code>
to remove those.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Kevin Tappe
</p>


<h3>See Also</h3>

<p><code>make.pconsecutive()</code> to make data consecutive
(and, as an option, balanced at the same time) and
<code>make.pbalanced()</code> to make data balanced.<br><code>pdim()</code> to check the dimensions of a 'pdata.frame'
(and other objects), <code>pvar()</code> to check for individual
and time variation of a 'pdata.frame' (and other objects),
<code>lag()</code> for lagged (and leading) values of a
'pseries' object.<br></p>
<p><code>pseries()</code>, <code>data.frame()</code>, <code>pdata.frame()</code>,
for class 'panelmodel' see <code>plm()</code> and <code>pgmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data("Grunfeld", package = "plm")
is.pconsecutive(Grunfeld)
is.pconsecutive(Grunfeld, index=c("firm", "year"))

# delete 2nd row (2nd time period for first individual)
# -&gt; non consecutive 
Grunfeld_missing_period &lt;- Grunfeld[-2, ]
is.pconsecutive(Grunfeld_missing_period)
all(is.pconsecutive(Grunfeld_missing_period)) # FALSE

# delete rows 1 and 2 (1st and 2nd time period for first individual)
# -&gt; consecutive
Grunfeld_missing_period_other &lt;- Grunfeld[-c(1,2), ]
is.pconsecutive(Grunfeld_missing_period_other) # all TRUE

# delete year 1937 (3rd period) for _all_ individuals
Grunfeld_wo_1937 &lt;- Grunfeld[Grunfeld$year != 1937, ]
is.pconsecutive(Grunfeld_wo_1937) # all FALSE

# pdata.frame interface
pGrunfeld &lt;- pdata.frame(Grunfeld)
pGrunfeld_missing_period &lt;- pdata.frame(Grunfeld_missing_period)
is.pconsecutive(pGrunfeld) # all TRUE
is.pconsecutive(pGrunfeld_missing_period) # first FALSE, others TRUE


# panelmodel interface (first, estimate some models)
mod_pGrunfeld &lt;- plm(inv ~ value + capital, data = Grunfeld)
mod_pGrunfeld_missing_period &lt;- plm(inv ~ value + capital, data = Grunfeld_missing_period)

is.pconsecutive(mod_pGrunfeld)
is.pconsecutive(mod_pGrunfeld_missing_period)

nobs(mod_pGrunfeld) # 200
nobs(mod_pGrunfeld_missing_period) # 199


# pseries interface
pinv &lt;- pGrunfeld$inv
pinv_missing_period &lt;- pGrunfeld_missing_period$inv

is.pconsecutive(pinv)
is.pconsecutive(pinv_missing_period)

# default method for arbitrary vectors or NULL
inv &lt;- Grunfeld$inv
inv_missing_period &lt;- Grunfeld_missing_period$inv
is.pconsecutive(inv, id = Grunfeld$firm, time = Grunfeld$year)
is.pconsecutive(inv_missing_period, id = Grunfeld_missing_period$firm, 
                                    time = Grunfeld_missing_period$year)

# (not run) demonstrate mismatch lengths of x, id, time 
# is.pconsecutive(x = inv_missing_period, id = Grunfeld$firm, time = Grunfeld$year)

# only id and time are needed for evaluation
is.pconsecutive(NULL, id = Grunfeld$firm, time = Grunfeld$year)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>pedModify</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Modify the pedigree of 'linkdat' objects</h2>

<h3>Description</h3>

<p>Functions to modify the pedigree of a 'linkdat' object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">swapSex(x, ids, verbose = TRUE)

swapAff(x, ids, newval = NULL)

addOffspring(
  x,
  father,
  mother,
  noffs,
  ids = NULL,
  sex = 1,
  aff = 1,
  verbose = TRUE
)

addSon(x, parent, id = NULL, aff = 1, verbose = TRUE)

addDaughter(x, parent, id = NULL, aff = 1, verbose = TRUE)

addParents(x, id, father, mother, verbose = TRUE)

removeIndividuals(x, ids, verbose = TRUE)

branch(x, id)

trim(x, keep = c("available", "affected"), return.ids = FALSE, verbose = TRUE)

relabel(x, new, old)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>linkdat</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical: Verbose output or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newval</code></td>
<td>
<p>A numeric, indicating affection status values for the
<code>ids</code> individuals: 1=unaffected, 2=affected, 0=unknown. If NULL, the
affection statuses are swapped 1 &lt;-&gt; 2, hence the main use of the
<code>newval</code> argument is to assign 0's.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>father, mother</code></td>
<td>
<p>Integers indicating the IDs of parents. If missing, a
new founder individual is created (whose ID will be 1+the largest ID
already in the pedigree).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noffs</code></td>
<td>
<p>A single integer indicating the number of offspring to be
created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sex, aff</code></td>
<td>
<p>Integer vectors indicating the gender and affection statuses
of the offspring to be created (recycled if less than <code>noffs</code>
elements).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parent</code></td>
<td>
<p>Integer ID of any pedigree member, which will be the father or
mother (depending on its gender) of the new child.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id, ids</code></td>
<td>
<p>Individual ID label(s). In <code>addOffspring</code> the (optional)
<code>ids</code> argument is used to specify ID labels for the offspring to be
created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>A character, either 'available' (trimming the pedigree for
unavailable members) or 'affected' (trimming for unaffected members).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.ids</code></td>
<td>
<p>A logical. If FALSE, the trimmed pedigree is returned as a
new <code>linkdat</code> object. If TRUE, a vector containing the IDs of
'removable' individuals is returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new</code></td>
<td>
<p>a numeric containing new labels to replace those in <code>old</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>old</code></td>
<td>
<p>a numeric containing ID labels to be replaced by those in
<code>new</code>. If missing, <code>old</code> is set to <code>x$orig.ids</code>, i.e. all
members in their original order.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When removing an individual, all descendants are also removed as well as
founders remaining without offspring.
</p>
<p>The <code>branch()</code> function extracts the pedigree subset consisting of all
descendants of <code>id</code>, including <code>id</code> itself and all relevant
spouses.
</p>


<h3>Value</h3>

<p>The modified <code>linkdat</code> object.
</p>


<h3>See Also</h3>

<p><code>linkdat</code>, <code>nuclearPed</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x = linkdat(toyped)

# To see the effect of each command below, use plot(x) in between.
x = addParents(x, id=2, father=5, mother=6)

x = swapSex(x, c(1,5))
x = swapSex(x, c(2,6))

x = addOffspring(x, mother=6, noffs=2, id=c(7,10))
x = removeIndividuals(x, 3)
x = swapAff(x, c(4,10))

stopifnot(setequal(x$orig.ids, c(1,2,4,5,6,7,10,11)))

# Trimming a pedigree
x = linkdat(dominant)
x_affectedOnly = trim(x, keep='affected')

unavail = trim(x, keep='available', return.ids=TRUE)
nonaff = trim(x, keep='affected', return.ids=TRUE)
stopifnot(setequal(unavail, c(5, 19:23)), setequal(nonaff, c(6:7, 12:13, 19:23)))

</code></pre>


</div>
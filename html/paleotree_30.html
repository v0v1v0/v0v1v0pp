<div class="container">

<table style="width: 100%;"><tr>
<td>constrainParPaleo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constrain Parameters for a Model Function from paleotree</h2>

<h3>Description</h3>

<p>This function constrains a model to make submodels with fewer parameters,
using a structure and syntax taken from the function <code>constrain</code>
in Rich Fitzjohn's package <code>diversitree</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">constrainParPaleo(f, ..., formulae = NULL, names = parnames(f), extra = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A function to constrain. This function must be of the <code>S3</code> <code>class</code>
<code>paleotreeFunc</code> and have all necessary attributes expected of that
<code>class</code>, which include parameter names and upper and lower bounds. As
I have deliberately not exported the function which creates this <code>class</code>,
it should be impossible for non-advanced users to obtain such objects easily
without using one of the <code>make</code> functions, which automatically output
a function of the appropriate <code>class</code> and attributes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Formulae indicating how the function should be constrained.
See details and examples for lengthy discussion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formulae</code></td>
<td>
<p>Optional list of constraints, possibly in addition to
those in <code>...</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>Optional Character vector of names, the same length as
the number of parameters in <code>x</code>.  Use this only if
<code>parnames</code> does not return a vector for your function.
Generally this should not be used. DWB: This argument is kept for
purposes of keeping the function as close to the parent as possible
but, in general, should not be used because the input function must
have all attributes expected of class <code>paleotreeFunc</code>, including
parameter names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra</code></td>
<td>
<p>Optional vector of additional names that might appear on
the RHS of constraints but do not represent names in the function's
<code>argnames</code>.  This can be used to set up dummy variables
(example coming later).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is based on (but does not depend on) the function <code>constrain</code>
from the package <code>diversitree</code>. Users should refer to this parent function for
more detailed discussion of model constraint usage and detailed examples.
</p>
<p>The parent function was forked to add functionality necessary for dealing with the
high parameter count models typical to some paleontological analyses, particularly
the inverse survivorship method. This necessitated that the new function be entirely
separate from its parent. Names of functions involved (both exported and not)
have been altered to avoid overlap in the package namespaces. Going forward,
the <code>paleotree</code> package maintainer (Bapst) will try to be vigilant with
respect to changes in <code>constrain</code> in the original package, <code>diversitree</code>.
</p>
<p>Useful information from the <code>diversitree</code> manual (11/01/13):
</p>
<p>"If <code>f</code> is a function that takes a vector <code>x</code> as its first
argument, this function returns a new function that takes a
shorter vector <code>x</code> with some elements constrained in some way;
parameters can be fixed to particular values, constrained to be the
same as other parameters, or arbitrary expressions of free
parameters."
</p>
<p>In general, formulae should be of the structure:
</p>
<p><em>LHS ~ RHS</em>
</p>
<p>...where the LHS is the 'Parameter We Want to Constrain' and the
RHS is whatever we are constraining the LHS to, usually another
parameter. LHS and RHS are the 'left-hand side' and
'right-hand side' respectively (which I personally find obscure).
</p>
<p>Like the original <code>constrain</code> function this function is based on,
this function cannot remove constraints previously placed on a model
object and there may be cases in which the constrained function may not 
make sense, leading to an error. The original function will sometimes
issue nonsensical functions with an incorrect number/names of parameters
if the parameters to be constrained are given in the wrong order in
formulae.
</p>


<h4>Differences from the original <code>constrain</code> function from <code>diversitree</code>
</h4>

<p>This forked <code>paleotree</code> version of constrain has two additional features,
both introduced to aid in constraining models with a high number of 
repetitive parameters. (I did not invent these models, so don't shoot the messenger.)
</p>
<p>First, it allows nuanced control over the constraining of many
parameters simultaneously, using the <code>all</code> and <code>match</code> descriptors. This
system depends on parameters being named as such: <code>name.group1.group2.group3</code>
and so on. Each 'group' is reference to a system of groups, perhaps referring to a
time interval, region, morphology, taxonomic group or some other discrete
characterization among the data (almost all functions envisioned for
paleotree are for per-taxon diversification models). The number of group systems
is arbitrary, and may be from zero to a very large number; it depends on the
'make' function used and the arguments selected by the user. For example, the
parameter <code>x.1</code> would be for the parameter <code>x</code> in the first group of the first group
system (generally a time interval for most <code>paleotree</code> functions). For a more
complicated exampled, with the parameter <code>x.1.3.1</code>, the third group
for the second group system (perhaps this taxonomic data point has a morphological
feature not seen in some other taxa) and group 1 of the third group system (maybe
biogeographic region 1? The possibilities are endless depending on user choices!). 
</p>
<p>The <code>all</code> option work like so: if <code>x.all ~ x.1</code> is given as a formulae, then all <code>x</code>
parameters will be constrained to equal <code>x.1</code>. For example, if there is <code>x.1</code>, <code>x.2</code>,
<code>x.3</code> and <code>x.4</code> parameters for a model, <code>x.all ~ x.1</code> would be equivalent to
individually giving the formulae <code>x.2~x.1</code>, <code>x.3~x.1</code> and <code>x.4~x.1</code>. This
means that if there are many parameters of a particular type (say, 50 <code>x</code>
parameters) it is easy to constrain all with a short expression. It is not
necessary that the  The <code>all</code> term can be used anywhere in the name of the parameter
in a formulae, including to make all parameters for a given <code>group</code> the same.
Furthermore, the LHS and RHS don't need to be same parameter group, and both can
contain <code>all</code> statements, even <em>multiple</em> <code>all</code> statements. Consider these
examples, each of which are legal, acceptable uses: 
</p>
 
<dl>
<dt><code>x.all ~ y.1</code></dt>
<dd>
<p>Constrains all values of the parameter x for every group to be
equal to the single value for the parameter <code>y</code> for group 1 (note that there's only
a single set of groups).</p>
</dd>
<dt><code>all.1 ~ x.1</code></dt>
<dd>
<p>Constrains all parameters for the first group to equal each other, 
here arbitrary named <code>x.1</code>. 
For example, if there is parameters named <code>x.1</code>, <code>y.1</code> and <code>z.1</code>,
all will be constrained to be equal to a single parameter value.</p>
</dd>
<dt><code>x.all.all ~ y.2.3</code></dt>
<dd>
<p>Constrains all values for x in any and all groups to
equal the single value for <code>y</code> for group 2 (of system 1)  and group 3 (of system 2).</p>
</dd>
<dt><code>x.all ~ y.all</code></dt>
<dd>
<p>Constrains all values of x for every group and y for every
group to be equal to a <em>single</em> value, which by default will be reported as <code>y.1</code></p>
</dd>
</dl>
<p>The <code>match</code> term is similar, allowing parameter values from the same group
to be quickly matched and made equivalent. These <code>match</code> terms must have a
matching (cue laughter) term both in the corresponding LHS and RHS of the formula.
For example, consider <code>x.match ~ y.match</code> where there are six parameters: <code>x.1</code>,
<code>x.2</code>, <code>x.3</code>, <code>y.1</code>, <code>y.2</code> and <code>y.3</code>. 
This will effectively constrain <code>x.1 ~ y.1</code>, <code>x.2 ~ y.2</code>
and <code>x.3 ~ y.3</code>. This is efficient for cases where we have some parameters that
we often treat as equal. For example, in paleontology, we sometimes make a
simplifying assumption that birth and death rates are equal in multiple
time intervals. Some additional legal examples are:
</p>
 
<dl>
<dt><code>x.match.1 ~ y.match.1</code></dt>
<dd>
<p>This will constrain only parameters of <code>x</code> and <code>y</code> to
to equal each other if they both belong to the same group for the first group
system AND belong to group 1 of the first group.</p>
</dd>
<dt><code>all.match. ~ x.match</code></dt>
<dd>
<p>This will constrain all named parameters in each
group to equal each other; for example, 
if there are parameters <code>x.1</code>, <code>y.1</code>, <code>z.1</code>, <code>x.2</code>, <code>y.2</code> and <code>z.2</code>, 
this will constrain them such that <code>y.1 ~ x.1</code>, <code>z.1 ~ x.1</code>, <code>y.2 ~ x.2</code>
and <code>z.2 ~ x.2</code>, leaving <code>x.1</code> and <code>x.2</code> as the only parameters effectively.</p>
</dd>
</dl>
<p>There are two less fortunate qualities to the introduction of the above terminology.
</p>
<p>Unfortunately, this package author apologizes that his programming skills are
not good enough to allow more complex sets of constraints, as would be typical
with the parent function, when <code>all</code> or <code>match</code> terms are included. For example,
it would not be legal to attempt to constraint <code>y.all ~ x.1 / 2</code>, where the user
presumably is attempting to constrain all y values to equal the x parameter
to equal half of the <code>x</code> parameter for group 1. This will not be parsed as such
and should return an error. However, there are workarounds, but they require
using <code>constrainParPaleo</code> more than once. For the above example, a user could
first use <code>y.all ~ y.1</code> constraining all y values to be equal. Then a user
could constrain with the formula <code>y.1 ~ x.1 / 2</code> which would then constrain
<code>y.1</code> (and all the <code>y</code> values constrained to equal it) to be equal to the desired
fraction.
</p>
<p>Furthermore, this function expects that parameter names don't already have
period-separated terms that are identical to <code>all</code> or <code>match</code>. 
No function in <code>paleotree</code> should produce such natively. 
If such were to occur, perhaps by specially replacing parameter names, 
<code>constrainParPaleo</code> would confuse
these terms for the specialty terms described here.
</p>
<p>Secondly, this altered version of constrain handles the parameter bounds included as
attributes in functions output by the various '<code>make</code>' functions. This means that if
<code>x.1 ~ y.1</code> is given, <code>constrainParPaleo</code> will test if the bounds on <code>x.1</code> and <code>y.1</code> are the same.
If the bounds are not the same, <code>constrainParPaleo</code> will return an error.
This is important, as some models in paleotree may make a parameter a rate (bounded
zero to some value greater than one) or a probability (bounded zero to one),
depending on user arguments. Users may not realize these differences and, in many
cases, constraining a rate to equal a probability is nonsense (absolute poppycock!).
If a user really wishes to constrain two parameters with different bounds to be equal
(I have no idea why anyone would want to do this), they can use the parameter bound
replacement functions described in <code>modelMethods</code> to set the parameter
bounds as equal. Finally, once parameters with the same bounds are constrained, the
output has updated bounds that reflect the new set of parameters
for the new constrained function.</p>



<h3>Value</h3>

<p>Modified from the <code>diversitree</code> manual:
This function returns a constrained function that can be passed
through to the optimization functions of a user's choice, such as
<code>optim</code>, <code>find.mle</code> in <code>diversitree</code> or <code>mcmc</code>.
It will behave like any other function.  However, it has a modified
<code>class</code> attribute so that some methods will dispatch differently:
<code>parnames</code>, for example, will return the names of the
parameters of the constrained function and <code>parInit</code> will
return the initial values for those same constrained set of parameters.
All arguments in addition to <code>x</code> will be passed through to the
original function <code>f</code>.
</p>
<p>Additional useful information from the <code>diversitree</code> manual (11/01/13):
</p>
<p>For help in designing constrained models, the returned function has
an additional argument <code>pars.only</code>, when this is <code>TRUE</code> the
function will return a named vector of arguments rather than evaluate
the function (see Examples).
</p>


<h3>Author(s)</h3>

<p>This function (and even this help file!) was originally written by Rich
Fitzjohn for his library <code>diversitree</code>, and subsequently rewritten
and modified by David Bapst.
</p>


<h3>References</h3>

<p>FitzJohn, R. G. 2012. <code>diversitree</code>: comparative phylogenetic analyses of
diversification in R. <em>Methods in Ecology and Evolution</em> 3(6):1084-1092.
</p>


<h3>See Also</h3>

<p>As noted above, this function is strongly based on (but does not depend on) the
function <code>constrain</code> from the library <code>diversitree</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulation example with make_durationFreqCont, with three random groups
set.seed(444)
record &lt;- simFossilRecord(
    p = 0.1, 
    q = 0.1, 
    nruns = 1,
    nTotalTaxa = c(30,40), 
    nExtant = 0
    )
taxa &lt;- fossilRecord2fossilTaxa(record)
rangesCont &lt;- sampleRanges(taxa,r = 0.5)
# create a groupings matrix
grp1 &lt;- matrix(
    sample(1:3,nrow(taxa),replace = TRUE), , 1)   
likFun &lt;- make_durationFreqCont(rangesCont, groups = grp1)

# can constrain both extinction rates to be equal
constrainFun &lt;- constrainParPaleo(likFun, q.2 ~ q.1)

#see the change in parameter names and bounds
parnames(likFun)
parnames(constrainFun)
parbounds(likFun)
parbounds(constrainFun)

# some more ways to constrain stuff!

#constrain all extinction rates to be equal
constrainFun &lt;- constrainParPaleo(likFun, q.all ~ q.1)
parnames(constrainFun)

#constrain all rates for everything to be a single parameter
constrainFun &lt;- constrainParPaleo(likFun, r.all ~ q.all)
parnames(constrainFun)

#constrain all extinction rates to be equal &amp; all sampling to be equal
constrainFun &lt;- constrainParPaleo(likFun, q.all ~ q.1, r.all ~ r.1)
parnames(constrainFun)

#similarly, can use match.all to make all matching parameters equal each other
constrainFun &lt;- constrainParPaleo(likFun, match.all ~ match.all)
parnames(constrainFun)

#Constrain rates in same group to be equal
constrainFun &lt;- constrainParPaleo(likFun, r.match ~ q.match)
parnames(constrainFun)

</code></pre>


</div>
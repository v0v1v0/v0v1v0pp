<div class="container">

<table style="width: 100%;"><tr>
<td>plaqr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Partially Linear Additive Quantile Regression</h2>

<h3>Description</h3>

<p>Returns an object of class <code>"plaqr"</code> and <code>"rq"</code> that represents a quantile regression fit.  A nonlinear term z is transformed using <code>bs(z)</code> before fitting the model.  The formula of the model (as it appears in <code>R</code>) becomes <code>y~ x1 + x2 + bs(z1) + bs(z2)</code> where <code>bs(z1)</code> is a B-spline.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plaqr(formula, nonlinVars=NULL, tau=.5, data=NULL, subset,   
            weights, na.action, method = "br", model = TRUE, 
            contrasts = NULL, splinesettings=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>a formula object, with the response on the left of a <code>~</code> operator, 
and the linear terms, separated by <code>+</code> operators, on the right.  Any terms on the right         of the <code>~</code> operator that also appear in <code>nonlinVars</code> will be included in the model as spline terms, not linear terms.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonlinVars</code></td>
<td>

<p>a one-sided formula object, with a <code>~</code> operator to the left of the nonlinear terms seperated by <code>+</code> operators.  A term appearing in both <code>formula</code> and <code>nonlinVars</code> will be treated as a nonlinear term.  If <code>nonlinVars</code> is not <code>NULL</code>, then an intercept will automatically be included in the model (despite a <code>-1</code> or <code>0</code> term included in <code>formula</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>

<p>the quantile to be estimated, this is a number strictly between 0 and 1 (for now).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>a data.frame in which to interpret the variables 
named in the formula, or in the subset and the weights argument. 
If this is missing, then the variables in the formula should be on the 
search list.  This may also be a single number to handle some special  
cases – see below for details.   
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>vector of observation weights; if supplied, the algorithm fits
to minimize the sum of the weights multiplied into the
absolute residuals. The length of weights must be the same as
the number of observations.  The weights must be nonnegative
and it is strongly recommended that they be strictly positive,
since zero weights are ambiguous. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>

<p>a function to filter missing data. 
This is applied to the model.frame after any subset argument has been used. 
The default (with <code>na.fail</code>) is to create an error if any missing values are  
found.  A possible alternative is <code>na.omit</code>, which 
deletes observations that contain one or more missing values. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>if TRUE then the model frame is returned.  This is
essential if one wants to call summary subsequently.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>the algorithmic method used to compute the fit.  There are several
options:   The default method is the modified  version of the
Barrodale and Roberts algorithm for <code class="reqn">l_1</code>-regression,
used by <code>l1fit</code> in S, and is described in detail in 
Koenker and d'Orey(1987, 1994),  default = <code>"br"</code>. 
This is quite efficient for problems up to several thousand observations, 
and may be used to compute the full quantile regression process.  It 
also implements a scheme for computing confidence intervals for 
the estimated parameters, based on inversion of a rank test described 
in Koenker(1994).  For larger problems it is advantagous to use 
the Frisch–Newton interior point method <code>"fn"</code>. 
And very large problems one can use the Frisch–Newton approach after 
preprocessing <code>"pfn"</code>.  Both of the latter methods are
described in detail in Portnoy and Koenker(1997).   
There is a fifth option <code>"fnc"</code> that enables the user to specify
linear inequality constraints on the fitted coefficients; in this
case one needs to specify the matrix <code>R</code> and the vector <code>r</code>
representing the constraints in the form <code class="reqn">Rb \geq r</code>.  See the
examples.  Finally, there are two penalized methods:  <code>"lasso"</code>
and <code>"scad"</code> that implement the lasso penalty and Fan and Li's
smoothly clipped absolute deviation penalty, respectively.  These
methods should probably be regarded as experimental.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>

<p>a list giving contrasts for some or all of the factors 
default = <code>NULL</code> appearing in the model formula. 
The elements of the list should have the same name as the variable 
and should be either a contrast matrix (specifically, any full-rank 
matrix with as many rows as there are levels in the factor), 
or else a function to compute such a matrix given the number of levels. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splinesettings</code></td>
<td>

<p>a list of length equal to the number of nonlinear effects containing arguments to pass to the <code>bs</code> function for each term.  Each element of the list is either <code>NULL</code> or a list with named elements correpsonding to the arguments in <code>bs</code>.  If not <code>NULL</code>, the first element of splinesettings corresponds to the first nonlinear effect and so on.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments for the fitting routines 
(see the <code>rq</code> function in the ‘quantreg’ package ). 
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns the following:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>

<p>Coefficients from the fitted model
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>optionally the model matrix, if <code>x=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>optionally the response, if <code>y=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>

<p>the residuals from the fit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dual</code></td>
<td>

<p>the vector dual variables from the fit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>

<p>fitted values from the fit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>the formula that was used in the <code>rq</code> function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>

<p>the value of the objective function at the solution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>optionally the model frame, if <code>model=TRUE</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear</code></td>
<td>

<p>the linear terms used in the model fit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonlinear</code></td>
<td>

<p>the nonlinear terms used in the model fit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>

<p>the values of the nonlinear terms.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Adam Maidman</p>


<h3>References</h3>

<p>Hastie, T. J. (1992) Generalized additive models. Chapter 7 of Statistical Models in S eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>
<p>Koenker, R. W. (2005). Quantile Regression, Cambridge U. Press.
</p>
<p>Sherwood, B. and Wang, L. (2016). Partially linear additive quantile regression in ultra-high
dimension. The Annals of Statistics 44, 288-317.
</p>
<p>Maidman, A., Wang, L. (2017).  New Semiparametric Method for Predicting High-Cost Patients. Preprint.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(simData)

ss &lt;- vector("list", 2)
ss[[2]]$degree &lt;- 5
ss[[2]]$Boundary.knots &lt;- c(-1, 1)

plaqr(y~., nonlinVars=~z1+z2, data=simData) 
#same as plaqr(formula= y~x1+x2+x3, nonlinVars=~z1+z2, data=simData)

plaqr(y~0, nonlinVars=~z1+z2, data=simData, splinesettings=ss) #no linear terms in the model

plaqr(y~., data=simData) #all linear terms
</code></pre>


</div>
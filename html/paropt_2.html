<div class="container">

<table style="width: 100%;"><tr>
<td>solve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solves an ode-system</h2>

<h3>Description</h3>

<p>Solves an ode equation and calculate an error based on the difference on a user-defined state-data.frame.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  solve(
    ode,
    parameter,
    reltol,
    abstol,
    states,
    solvertype,
    own_error_fct,
    own_spline_fct,
    own_jac_fct,
    verbose
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ode</code></td>
<td>
<p>the ode-system for which the parameter should be optimized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter</code></td>
<td>
<p>a data.frame containing the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol</code></td>
<td>
<p>a number defining the relative tolerance used by the ode-solver. The default value is 1e-06</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abstol</code></td>
<td>
<p>a vector containing the absolute tolerance(s) for each state used by the ode-solver. The default value is 1e-08</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>states</code></td>
<td>
<p>a data.frame containing the predetermined course of the states. <br> The data.frame is used to extract the initial values of the states. <br>
Furthermore, the ode-solver returns <em>in silico</em> values of the states at the timepoints which has to be defined in the first column</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solvertype</code></td>
<td>
<p>a string defining the type of solver which should be used "bdf" or "adams" are the possible values. The default value is "bdf". <br>
"bdf" is an abbreviation for Backward Differentiation Formulas. "adams" is an abbreviation for the Adams-Moulton algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>own_error_fct</code></td>
<td>
<p>An optional function to calculate the error between <em>in silico</em> value and the specified value in the data.frame states. The default error calculation is specified in the section notes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>own_spline_fct</code></td>
<td>
<p>An optional function to interpolate the values for variable parameters. The default function is a CatmullRome spline interpolation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>own_jac_fct</code></td>
<td>
<p>An optional function which returns the jacobian function. Furthermore it is possible to calculate the jacobian using the R package dfdr. If this is desired "dfdr" has to be passed as argument. If nothing is passed the jacobian matrix is numerically calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical value defining whether the output during compilation should be shown or not. The default value is FALSE</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>The ode system:</strong>
<br>___________________________________________________________<br>
The ode system is an R function which accepts four arguments and returns one.
</p>

<ol>
<li>
<p> the first argument is <strong>t</strong> which defines the (time-) point of then independent variable at which the ode-system is evaluated.
</p>
</li>
<li>
<p> the second argument is a vector called <strong>y</strong> which defines the current states at timepoint <strong>t</strong>
</p>
</li>
<li>
<p> the third argument is a vector called <strong>ydot</strong> which should be filled with the derivative (left hand side) of the ode-system. It has already the correct length! <strong>This vector has to be returned.</strong>
</p>
</li>
<li>
<p> the last argument is called <strong>parameter</strong> and is a vector containing the current parameter-set which is tested by the optimization algorithm. <br><strong>If the parameters can change over time. The already interpolated value is passed to the ode-system.</strong> <br></p>
</li>
</ol>
<p><code style="white-space: pre;">⁠
    # theoretical Example: The parameter 'a' can change over time whereas 'b' is constant over time.
    parameter_set &lt;- data.frame(
      time = c(0, 10, 20, 30, 40),
      a = c(1, 2, 3, 4, 5),
      b = c(1, NA, NA, NA, NA, NA))
    t &lt;- 5
    # Interpolation would result in 1.5 for parameter 'a'
    parameter &lt;- c(1.5, 1) # 'a', 'b'
    y &lt;- 1
    ydot &lt;- vector(length(1))
    ode(t, y, ydot, parameter)
  ⁠</code>
</p>

<ul>
<li>
<p> The function returns <em>ydot</em>. It is only necessary to fill the vector <strong>ydot</strong>. Check the package <em>ast2ast</em> for more details how this works.
</p>
</li>
<li>
<p> The R function is translated to a C++ function using the package <em>ast2ast</em>, see also <a href="https://CRAN.R-project.org/package=ast2ast">ast2ast on CRAN</a> and <code>ast2ast::translate()</code>. Therefore, if you are calling 'solve' for the first time the function has to be compiled. This can require a bit of time.
</p>
</li>
</ul>
<p><strong>The parameters:</strong>
<br>___________________________________________________________<br>
The lower and upper boundaries are defined as a data.frame that contains 'time' as the first column. <br>
The subsequent columns contain the information of the parameter. <br><br><code style="white-space: pre;">⁠
    # Here some examples
    # all parameters are constant over the entire integration_time
    example1 &lt;- data.frame(
      time = 0,
      a = 0.4,
      b = 1.1,
      c = 0.1,
      d = 0.4)

    # The parameter a, b, and c are constant whereas the parameter d can change over time
    example2 &lt;- data.frame(
      time = c(0, 5, 10, 15),
      a = c(0.4, NA, NA, NA),
      b = c(1.1, NA, NA, NA),
      c = c(0.1, NA, NA, NA),
      d = c(0.4, 0.5, 0.3, 0.4))

    # The parameter a, b are constant
    # whereas parameter c and d can change over time.
    # However, d is not known for all points of c
    example3 &lt;- data.frame(
      time = c(0, 5, 10, 15, 20, 25),
      a = c(1.1, NA, NA, NA, NA, NA),
      b = c(0.1, NA, NA, NA, NA, NA),
      c = c(0.2, 0.2, 0, 0, 0, 0),
      d = c(0, 0.1, 0.2, 1, NA, NA))
  ⁠</code>
<strong>The states data.frame: </strong>
<br>___________________________________________________________<br>
The states are defined as a data.frame that contains the 'time' as the first column.
The subsequent columns are the individual states. <br><br><code style="white-space: pre;">⁠
    # Here some examples
    # Only the initial values are defined.
    example1 &lt;- data.frame(
      time = seq(0, 100, 0.5),
      prey = c(10, rep(NA, 200)),
      predator = c(10, rep(NA, 200)))

    # All values are defined at each timepoint
    example2 &lt;- data.frame(
      time =  seq(0, 100, 0.5),
      prey =  c(10, runif(200)),
      predator =  c(10, runif(200)) )

    # Only the values for prey are known and are used during optimization
    example3 &lt;- data.frame(
      time =  seq(0, 100, 0.5),
      prey =  c(10, runif(200)),
      predator =  c(10, rep(NA, 200)) )

  ⁠</code>
</p>
<p><strong>solvertype: </strong>
<br>___________________________________________________________<br>
For solving the ode system the SUNDIALS Software is used check the <a href="https://computing.llnl.gov/projects/sundials">Sundials homepage</a> for more informations.
The solver-type which is used during optimization: “bdf“, “adams“. bdf is an abbreviation for Backward Differentiation Formulas and adams means Adams-Moulton.
All solvers are used in the NORMAL-Step method in a for-loop using the time-points defined in the first column of the 'states' data.frame.
The bdf solver use the SUNLinSol_Dense as linear solver.
</p>
<p><strong>own_error_fct: </strong>
<br>___________________________________________________________<br>
The error function calculates the error at one of the possible time-points. Moreover, the function expects three numerical scalars as arguments. The first one is the number of data-points at which the error is calculated. The second argument describes the <em>in silico</em> value at one specific time-point. The third argument is the input of the user at the specific time-point which should be matched. <br>
Here is one example shown using the sum of squares as an alternative error function.
<code style="white-space: pre;">⁠
error_fct &lt;- function(num_points, insilico, measured) {
  ret = (insilico - measured)^2
  return(ret/num_points)
}
⁠</code>
</p>
<p><strong>own_spline_fct: </strong>
<br>___________________________________________________________<br>
The spline function is called, directly before the ode-system is evaluated. However, the function is only called for non-constant parameters. See example Nr.2 and Nr.3 parameter <em>d</em> as described above. The results of the spline function is then stored in the vector <strong>parameter</strong> which is passed to the ode-system. The function expects three arguments:
</p>

<ul>
<li>
<p> The time-point at which the function is evaluated
</p>
</li>
<li>
<p> a vector containing the time-points for which parameters are defined
</p>
</li>
<li>
<p> a vector containing the parameters at the respective time-points
</p>
</li>
</ul>
<p>The function has to return a scalar value.See the example above for a linear interpolation:
<code style="white-space: pre;">⁠
linear_interpolation &lt;- function(t, time_vec, par_vec) {
  left = 0
  left_time = 0
  right = 0
  right_time = 0
  for(i in 1:length(time_vec)) {

    if(t == time_vec[i]) {
      return(par_vec[i])
    }

    if(t &lt; time_vec[i]) {
      left = par_vec[i - 1]
      right = par_vec[i]
      left_time = time_vec[i - 1]
      right_time = time_vec[i]
      break
    }
  }

  timespan = right_time - left_time
  m = (right - left) / timespan
  ret = left + m*(t - left_time)
  return(ret)
}
⁠</code>
Mentionable, is that it hasn't to be a interpolation function. See the example above:
<code style="white-space: pre;">⁠
fct &lt;- function(t, time_vec, par_vec) {
  ret = 0
  for(i in par_vec) {
    ret = ret + i
  }
  return(ret)
}
⁠</code>
</p>
<p><strong>own_jac_fct: </strong>
<br>___________________________________________________________<br>
The jacobian function expects 5 arguments.
</p>

<ol>
<li>
<p> the first argument is <strong>t</strong> which defines the (time-) point of then independent variable at which the ode-system is evaluated.
</p>
</li>
<li>
<p> the second argument is a vector called <strong>y</strong> which defines the current states at timepoint <strong>t</strong>
</p>
</li>
<li>
<p> the third argument is a vector called <strong>ydot</strong> which should be filled with the derivative (left hand side) of the ode-system. It has already the correct length! Please do not return the vector.
</p>
</li>
<li>
<p> the foruth argument is a matrix called <strong>J</strong> which should be filled with the respective derivatives of <strong>ydot</strong>. The matrix has already the correct dimensions. <strong>This matrix has to be returned.</strong>
</p>
</li>
<li>
<p> the last argument is called <strong>parameter</strong> and is a vector containing the current parameter-set which is tested by the optimization algorithm. <br><strong>If the parameters can change over time. The already interpolated value is passed to the ode-system.</strong> <br></p>
</li>
</ol>
<h3>Value</h3>

<p>A list is returned which contains two elements. The first one is the error of the best particle.
The other element is a data.frame containing the <em>in silico</em> states returned from the ode-solver using the parameter-set passed by the user..
</p>


<h3>Note</h3>


<ul><li>
<p> The error between the defined states and the <em>in silico</em> states is the absolute difference normalised using the true state.
</p>
</li></ul>
<h3>See Also</h3>

<p><code>optimize()</code>,
<code>ast2ast::translate()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  
# Solve an ode-system
ode &lt;- function(t, y, ydot, parameter) {
  a_db = at(parameter, 1)
  b_db = at(parameter, 2)
  c_db = at(parameter, 3)
  d_db = at(parameter, 4)
  predator_db = at(y,1)
  prey_db = at(y, 2)
  ydot[1] = predator_db*prey_db*c_db - predator_db*d_db
  ydot[2] = prey_db*a_db - prey_db*predator_db*b_db
  return(ydot)
}
path &lt;- system.file("examples", package = "paropt")
states &lt;- read.table(paste(path,"/states_LV.txt", sep = ""), header = TRUE)
parameter &lt;- data.frame(time = 0, a = 1.1, b = 0.4, c = 0.1, d = 0.4)
res &lt;- paropt::solve(ode,
                     parameter = parameter,
                     reltol = 1e-06, abstol = c(1e-08, 1e-08),
                     states = states, verbose = FALSE)


 # solving with own error, spline and jacobian function

 jac &lt;- function(t, y, ydot, J, parameter) {
  a_db = at(parameter, 1)
  b_db = at(parameter, 2)
  c_db = at(parameter, 3)
  d_db = at(parameter, 4)
  predator_db = at(y,1)
  prey_db = at(y, 2)

  J[1, 1] = prey_db*c_db - d_db
  J[2, 1] = - prey_db*b_db
  J[1, 2] = predator_db*c_db
  J[2, 2] = a_db - predator_db*b_db

  return(J)
}

error_fct &lt;- function(c, a, b) {
  ret = (a - b)^2
  return(ret)
}

spline_fct &lt;- function(t, time_vec, par_vec) {
  ret = 0
  for(i in par_vec) {
    ret = ret + i
  }
  return(ret)
}

path &lt;- system.file("examples", package = "paropt")
states &lt;- read.table(paste(path,"/states_LV.txt", sep = ""), header = TRUE)
parameter &lt;- data.frame(time = 0, a = 1.1, b = 0.4, c = 0.1, d = 0.4)
res &lt;- paropt::solve(ode,
                     parameter = parameter,
                     reltol = 1e-06, abstol = c(1e-08, 1e-08),
                     states = states, verbose = FALSE)

res &lt;- paropt::solve(ode,
                        parameter = parameter,
                        reltol = 1e-06, abstol = c(1e-08, 1e-08),
                        states = states, verbose = FALSE,
                        own_error_fct = error_fct,
                        own_spline_fct = spline_fct,
                        own_jac_fct = jac)


  
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>Familias2ped</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert <code>Familias</code> R objects to <code>ped</code>
</h2>

<h3>Description</h3>

<p>Convert pedigrees and marker data from the <code>Familias</code> R package into the
<code>ped</code> format used by the <code>pedsuite</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Familias2ped(
  familiasped,
  datamatrix,
  loci,
  matchLoci = FALSE,
  prefixAdded = "added_"
)

readFamiliasLoci(loci)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>familiasped</code></td>
<td>
<p>A <code>FamiliasPedigree</code> object or a list of such.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>datamatrix</code></td>
<td>
<p>A data frame with two columns per marker (one for each
allele) and one row per individual.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loci</code></td>
<td>
<p>A <code>FamiliasLocus</code> object or a list of such.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matchLoci</code></td>
<td>
<p>A logical, by default FALSE. If TRUE, the column names of
<code>datamatrix</code> are matched against <code>names(loci)</code>, or, if these are missing,
against the <code>name</code> entries of <code>loci</code>. The column names of <code>datamatrix</code> are
assumed to come in pairs with suffixes ".1" and ".2", e.g. "TH01.1",
"TH01.2", etc. If FALSE, the <code>loci</code> are assumed to be in correct order, and
no matching on marker name is done.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefixAdded</code></td>
<td>
<p>A string used as prefix when adding missing parents.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The definition of a <em>pedigree</em> in Familias is more liberal than that
implemented in the <code>pedsuite</code>, which requires that each <code>ped</code> object is a
connected pedigree, and that each member has either 0 or 2 parents. The
conversion function <code>Familias2ped</code> takes care of all potential differences.
Specifically, it converts each <code>FamiliasPedigree</code> object into a list of
connected <code>ped</code> components, and adds missing parents when needed.
</p>


<h3>Value</h3>

<p>A <code>ped</code> object, or a list of such.
</p>


<h3>References</h3>

<p>Familias is freely available from <a href="https://familias.name">https://familias.name</a>.
</p>


<h3>See Also</h3>

<p><code>readFam()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
famPed = list(id = c('mother', 'daughter', 'AF'),
              findex = c(0, 3, 0),
              mindex = c(0, 1, 0),
              sex = c('female', 'female', 'male'))
class(famPed) = "FamiliasPedigree"

datamatrix = data.frame(
  M1.1 = c(NA, 8, NA),
  M1.2 = c(NA, 9.3, NA),
  row.names = famPed$id)

famLoc = list(locusname = "M1",
              alleles = c("8" = 0.2, "9" = 0.5, "9.3" = 0.3))
class(famLoc) = "FamiliasLocus"

Familias2ped(famPed, datamatrix, loci = famLoc, matchLoci = TRUE)

</code></pre>


</div>
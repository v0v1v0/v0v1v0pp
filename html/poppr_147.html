<div class="container">

<table style="width: 100%;"><tr>
<td>ia</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Index of Association</h2>

<h3>Description</h3>

<p>Calculate the Index of Association and Standardized Index of Association.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ia(
  gid,
  sample = 0,
  method = 1,
  quiet = FALSE,
  missing = "ignore",
  plot = TRUE,
  hist = TRUE,
  index = "rbarD",
  valuereturn = FALSE
)

pair.ia(
  gid,
  sample = 0L,
  quiet = FALSE,
  plot = TRUE,
  low = "blue",
  high = "red",
  limits = NULL,
  index = "rbarD",
  method = 1L
)

resample.ia(gid, n = NULL, reps = 999, quiet = FALSE, use_psex = FALSE, ...)

jack.ia(gid, n = NULL, reps = 999, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>gid</code></td>
<td>
<p>a <code>adegenet::genind()</code> or <code>genclone()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample</code></td>
<td>
<p>an integer indicating the number of permutations desired
(eg 999).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>an integer from 1 to 4 indicating the sampling method desired.
see <code>shufflepop()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>Should the function print anything to the screen while it is
performing calculations?
<code>TRUE</code> prints nothing.
<code>FALSE</code> (default) will print the population name and progress bar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing</code></td>
<td>
<p>a character string. see <code>missingno()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>When <code>TRUE</code> (default), a heatmap of the values per locus pair
will be plotted (for <code>pair.ia()</code>). When <code>sampling &gt; 0</code>, different things
happen with <code>ia()</code> and <code>pair.ia()</code>. For <code>ia()</code>, a histogram for the data
set is plotted. For <code>pair.ia()</code>, p-values are added as text on the
heatmap.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hist</code></td>
<td>
<p><code>logical</code> Deprecated. Use plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p><code>character</code> either "Ia" or "rbarD". If <code>hist = TRUE</code>,
this indicates which index you want represented in the plot (default:
"rbarD").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>valuereturn</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code>, the index values from the
reshuffled data is returned. If <code>FALSE</code> (default), the index is
returned with associated p-values in a 4 element numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>low</code></td>
<td>
<p>(for pair.ia) a color to use for low values when 'plot =
TRUE'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>high</code></td>
<td>
<p>(for pair.ia) a color to use for low values when 'plot =
TRUE'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limits</code></td>
<td>
<p>(for pair.ia) the limits to be used for the color scale. 
Defaults to 'NULL'. If you want to use a custom range, supply two
numbers between -1 and 1, (e.g. 'limits = c(-0.15, 1)')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>an integer specifying the number of samples to be drawn. Defaults to
<code>NULL</code>, which then uses the number of multilocus genotypes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reps</code></td>
<td>
<p>an integer specifying the number of replicates to perform. 
Defaults to 999.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_psex</code></td>
<td>
<p>a logical. If <code>TRUE</code>, the samples will be weighted by the value 
of psex. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed on to <code>psex</code></p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li> <p><code>ia()</code> calculates the index of association over all loci in the data set.
</p>
</li>
<li> <p><code>pair.ia()</code> calculates the index of association in a pairwise manner
among all loci.
</p>
</li>
<li> <p><code>resample.ia()</code> calculates the index of association on a reduced data set
multiple times to create a distribution, showing the variation of values
observed at a given sample size (previously <code>jack.ia()</code>).
</p>
</li>
</ul>
<p>The index of association was originally developed by A.H.D. Brown analyzing
population structure of wild barley (Brown, 1980). It has been widely used
as a tool to detect clonal reproduction within populations . Populations
whose members are undergoing sexual reproduction, whether it be selfing or
out-crossing, will produce gametes via meiosis, and thus have a chance to
shuffle alleles in the next generation. Populations whose members are
undergoing clonal reproduction, however, generally do so via mitosis. This
means that the most likely mechanism for a change in genotype is via
mutation. The rate of mutation varies from species to species, but it is
rarely sufficiently high to approximate a random shuffling of alleles. The
index of association is a calculation based on the ratio of the variance of
the raw number of differences between individuals and the sum of those
variances over each locus . You can also think of it as the observed
variance over the expected variance. If they  are the same, then the index
is zero after subtracting one (from Maynard-Smith, 1993):
</p>
<p style="text-align: center;"><code class="reqn">I_A = \frac{V_O}{V_E}-1</code>
</p>

<p>Since the distance is more or less a binary distance, any sort of marker can
be used for this analysis. In the calculation, phase is not considered, and
any difference increases the distance between two individuals. Remember that
each column represents a different allele and that each entry in the table
represents the fraction of the genotype made up by that allele at that
locus. Notice also that the sum of the rows all equal one. Poppr uses this
to calculate distances by simply taking the sum of the absolute values of
the differences between rows.
</p>
<p>The calculation for the distance between two individuals at a single locus
with <em>a</em> allelic states and a ploidy of <em>k</em> is as follows (except
for Presence/Absence data):
</p>
<p style="text-align: center;"><code class="reqn"> d = \displaystyle \frac{k}{2}\sum_{i=1}^{a} \mid A_{i} - B_{i}\mid</code>
</p>

<p>To find the total number of differences between two individuals over all
loci, you just take <em>d</em> over <em>m</em> loci, a value we'll call
<em>D</em>:
</p>
<p style="text-align: center;"><code class="reqn">D = \displaystyle \sum_{i=1}^{m} d_i </code>
</p>

<p>These values are calculated over all possible combinations of individuals
in the data set, <code class="reqn">{n \choose 2}</code> after which you end up
with <code class="reqn">{n \choose 2}\cdot{}m</code> values of <em>d</em> and
<code class="reqn">{n \choose 2}</code> values of <em>D</em>. Calculating the
observed variances is fairly straightforward (modified from Agapow and
Burt, 2001):
</p>
<p style="text-align: center;"><code class="reqn"> V_O = \frac{\displaystyle \sum_{i=1}^{n \choose 2} D_{i}^2 - 
\frac{(\displaystyle\sum_{i=1}^{n \choose 2} D_{i})^2}{{n \choose 2}}}{{n 
\choose 2}}</code>
</p>

<p>Calculating the expected variance is the sum of each of the variances of the
individual loci. The calculation at a single locus, <em>j</em> is the same as
the previous equation, substituting values of <em>D</em> for <em>d</em>:
</p>
<p style="text-align: center;"><code class="reqn"> var_j = \frac{\displaystyle \sum_{i=1}^{n \choose 2} d_{i}^2 - 
\frac{(\displaystyle\sum_{i=1}^{n \choose 2} d_i)^2}{{n \choose 2}}}{{n 
\choose 2}} </code>
</p>

<p>The expected variance is then the sum of all the variances over all <em>m</em>
loci:
</p>
<p style="text-align: center;"><code class="reqn"> V_E = \displaystyle \sum_{j=1}^{m} var_j </code>
</p>

<p>Agapow and Burt showed that <code class="reqn">I_A</code> increases steadily with the number
of loci, so they came up with an approximation that is widely used,
<code class="reqn">\bar r_d</code>. For the derivation, see the manual for
<em>multilocus</em>.
</p>
<p style="text-align: center;"><code class="reqn"> \bar r_d = \frac{V_O - V_E} {2\displaystyle 
\sum_{j=1}^{m}\displaystyle \sum_{k \neq j}^{m}\sqrt{var_j\cdot{}var_k}} 
</code>
</p>



<h3>Value</h3>



<h4>for <code>pair.ia()</code>
</h4>

<p>A matrix with two columns and choose(nLoc(gid), 2) rows representing the
values for Ia and rbarD per locus pair.
</p>



<h4>If no sampling has occurred:</h4>

<p>A named number vector of length 2 giving the Index of Association, "Ia";
and the Standardized Index of Association, "rbarD"
</p>



<h4>If there is sampling:</h4>

<p>A a named numeric vector of length 4 with the following values:
</p>

<ul>
<li>
<p> Ia - numeric. The index of association.
</p>
</li>
<li>
<p> p.Ia - A number indicating the p-value resulting from a one-sided
permutation test based on the number of samples indicated in the
original call.
</p>
</li>
<li>
<p> rbarD - numeric. The standardized index of association.
</p>
</li>
<li>
<p> p.rD - A factor indicating the p-value resulting from a
one-sided permutation test based on the number of samples indicated in
the original call.
</p>
</li>
</ul>
<h4>If there is sampling and <code>valureturn = TRUE</code>
</h4>

<p>A list with the following elements:
</p>

<ul>
<li>
<p> index The above vector
</p>
</li>
<li>
<p> samples A data frame with s by 2 column data frame where s is the
number of samples defined. The columns are for the values of Ia and
rbarD, respectively.
</p>
</li>
</ul>
<h4>resample.ia()</h4>

<p>a data frame with the index of association and standardized index of
association in columns. Number of rows represents the number of reps.</p>



<h3>Note</h3>

<p><code>jack.ia()</code> is deprecated as the name was misleading. Please use
<code>resample.ia()</code>
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>References</h3>

<p>Paul-Michael Agapow and Austin Burt. Indices of multilocus
linkage disequilibrium. <em>Molecular Ecology Notes</em>, 1(1-2):101-102,
2001
</p>
<p>A.H.D. Brown, M.W. Feldman, and E. Nevo. Multilocus structure of natural
populations of <em>Hordeum spontaneum</em>. <em>Genetics</em>, 96(2):523-536, 1980.
</p>
<p>J M Smith, N H Smith, M O'Rourke, and B G Spratt. How clonal are bacteria?
Proceedings of the National Academy of Sciences, 90(10):4384-4388, 1993.
</p>


<h3>See Also</h3>

<p><code>poppr()</code>, <code>missingno()</code>,
<code>import2genind()</code>, <code>read.genalex()</code>,
<code>clonecorrect()</code>, <code>win.ia()</code>, <code>samp.ia()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(nancycats)
ia(nancycats)

# Pairwise over all loci:
data(partial_clone)
res &lt;- pair.ia(partial_clone)
plot(res, low = "black", high = "green", index = "Ia")

# Resampling
data(Pinf)
resample.ia(Pinf, reps = 99)

## Not run: 

# Pairwise IA with p-values (this will take about a minute)
res &lt;- pair.ia(partial_clone, sample = 999)
head(res)

# Plot the results of resampling rbarD. 
library("ggplot2")
Pinf.resamp &lt;- resample.ia(Pinf, reps = 999)
ggplot(Pinf.resamp[2], aes(x = rbarD)) +
  geom_histogram() +
  geom_vline(xintercept = ia(Pinf)[2]) +
  geom_vline(xintercept = ia(clonecorrect(Pinf))[2], linetype = 2) +
  xlab(expression(bar(r)[d]))

# Get the indices back and plot the distributions.
nansamp &lt;- ia(nancycats, sample = 999, valuereturn = TRUE)

plot(nansamp, index = "Ia")
plot(nansamp, index = "rbarD")

# You can also adjust the parameters for how large to display the text
# so that it's easier to export it for publication/presentations.
library("ggplot2")
plot(nansamp, labsize = 5, linesize = 2) +
  theme_bw() +                                      # adding a theme
  theme(text = element_text(size = rel(5))) +       # changing text size
  theme(plot.title = element_text(size = rel(4))) + # changing title size
  ggtitle("Index of Association of nancycats")      # adding a new title

# Get the index for each population.
lapply(seppop(nancycats), ia)
# With sampling
lapply(seppop(nancycats), ia, sample = 999)

# Plot pairwise ia for all populations in a grid with cowplot
# Set up the library and data
library("cowplot")
data(monpop)
splitStrata(monpop) &lt;- ~Tree/Year/Symptom
setPop(monpop)      &lt;- ~Tree

# Need to set up a list in which to store the plots.
plotlist        &lt;- vector(mode = "list", length = nPop(monpop))
names(plotlist) &lt;- popNames(monpop)

# Loop throgh the populations, calculate pairwise ia, plot, and then
# capture the plot in the list
for (i in popNames(monpop)){
  x &lt;- pair.ia(monpop[pop = i], limits = c(-0.15, 1)) # subset, calculate, and plot
  plotlist[[i]] &lt;- ggplot2::last_plot() # save the last plot
}

# Use the plot_grid function to plot.
plot_grid(plotlist = plotlist, labels = paste("Tree", popNames(monpop)))


## End(Not run)
</code></pre>


</div>
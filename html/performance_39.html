<div class="container">

<table style="width: 100%;"><tr>
<td>check_singularity</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Check mixed models for boundary fits</h2>

<h3>Description</h3>

<p>Check mixed models for boundary fits.
</p>


<h3>Usage</h3>

<pre><code class="language-R">check_singularity(x, tolerance = 1e-05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A mixed model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>Indicates up to which value the convergence result is
accepted. The larger <code>tolerance</code> is, the stricter the test
will be.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If a model is "singular", this means that some dimensions of the
variance-covariance matrix have been estimated as exactly zero. This
often occurs for mixed models with complex random effects structures.
</p>
<p>"While singular models are statistically well defined (it is theoretically
sensible for the true maximum likelihood estimate to correspond to a singular
fit), there are real concerns that (1) singular fits correspond to overfitted
models that may have poor power; (2) chances of numerical problems and
mis-convergence are higher for singular models (e.g. it may be computationally
difficult to compute profile confidence intervals for such models); (3)
standard inferential procedures such as Wald statistics and likelihood ratio
tests may be inappropriate." (<em>lme4 Reference Manual</em>)
</p>
<p>There is no gold-standard about how to deal with singularity and which
random-effects specification to choose. Beside using fully Bayesian methods
(with informative priors), proposals in a frequentist framework are:
</p>

<ul>
<li>
<p> avoid fitting overly complex models, such that the variance-covariance
matrices can be estimated precisely enough (<em>Matuschek et al. 2017</em>)
</p>
</li>
<li>
<p> use some form of model selection to choose a model that balances
predictive accuracy and overfitting/type I error (<em>Bates et al. 2015</em>,
<em>Matuschek et al. 2017</em>)
</p>
</li>
<li>
<p> "keep it maximal", i.e. fit the most complex model consistent with the
experimental design, removing only terms required to allow a non-singular
fit (<em>Barr et al. 2013</em>)
</p>
</li>
<li>
<p> since version 1.1.9, the <strong>glmmTMB</strong> package allows to use priors in a
frequentist framework, too. One recommendation is to use a Gamma prior
(<em>Chung et al. 2013</em>). The mean may vary from 1 to very large values
(like <code>1e8</code>), and the shape parameter should be set to a value of 2.5. You
can then <code>update()</code> your model with the specified prior. In <strong>glmmTMB</strong>,
the code would look like this:
</p>
<div class="sourceCode"><pre># "model" is an object of class gmmmTMB
prior &lt;- data.frame(
  prior = "gamma(1, 2.5)",  # mean can be 1, but even 1e8
  class = "ranef"           # for random effects
)
model_with_priors &lt;- update(model, priors = prior)
</pre></div>
<p>Large values for the mean parameter of the Gamma prior have no large impact
on the random effects variances in terms of a "bias". Thus, if <code>1</code> doesn't
fix the singular fit, you can safely try larger values.
</p>
</li>
</ul>
<p>Note the different meaning between singularity and convergence: singularity
indicates an issue with the "true" best estimate, i.e. whether the maximum
likelihood estimation for the variance-covariance matrix of the random
effects is positive definite or only semi-definite. Convergence is a
question of whether we can assume that the numerical optimization has
worked correctly or not.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if the model fit is singular.
</p>


<h3>References</h3>


<ul>
<li>
<p> Bates D, Kliegl R, Vasishth S, Baayen H. Parsimonious Mixed Models.
arXiv:1506.04967, June 2015.
</p>
</li>
<li>
<p> Barr DJ, Levy R, Scheepers C, Tily HJ. Random effects structure for
confirmatory hypothesis testing: Keep it maximal. Journal of Memory and
Language, 68(3):255-278, April 2013.
</p>
</li>
<li>
<p> Chung Y, Rabe-Hesketh S, Dorie V, Gelman A, and Liu J. 2013. "A Nondegenerate
Penalized Likelihood Estimator for Variance Parameters in Multilevel Models."
Psychometrika 78 (4): 685â€“709. <a href="https://doi.org/10.1007/s11336-013-9328-2">doi:10.1007/s11336-013-9328-2</a>
</p>
</li>
<li>
<p> Matuschek H, Kliegl R, Vasishth S, Baayen H, Bates D. Balancing type I error
and power in linear mixed models. Journal of Memory and Language, 94:305-315, 2017.
</p>
</li>
<li>
<p> lme4 Reference Manual, <a href="https://cran.r-project.org/package=lme4">https://cran.r-project.org/package=lme4</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Other functions to check model assumptions and and assess model quality: 
<code>check_autocorrelation()</code>,
<code>check_collinearity()</code>,
<code>check_convergence()</code>,
<code>check_heteroscedasticity()</code>,
<code>check_homogeneity()</code>,
<code>check_model()</code>,
<code>check_outliers()</code>,
<code>check_overdispersion()</code>,
<code>check_predictions()</code>,
<code>check_zeroinflation()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(sleepstudy, package = "lme4")
set.seed(123)
sleepstudy$mygrp &lt;- sample(1:5, size = 180, replace = TRUE)
sleepstudy$mysubgrp &lt;- NA
for (i in 1:5) {
  filter_group &lt;- sleepstudy$mygrp == i
  sleepstudy$mysubgrp[filter_group] &lt;-
    sample(1:30, size = sum(filter_group), replace = TRUE)
}

model &lt;- lme4::lmer(
  Reaction ~ Days + (1 | mygrp / mysubgrp) + (1 | Subject),
  data = sleepstudy
)
check_singularity(model)

## Not run: 
# Fixing singularity issues using priors in glmmTMB
# Example taken from `vignette("priors", package = "glmmTMB")`
dat &lt;- readRDS(system.file(
  "vignette_data",
  "gophertortoise.rds",
  package = "glmmTMB"
))
model &lt;- glmmTMB::glmmTMB(
  shells ~ prev + offset(log(Area)) + factor(year) + (1 | Site),
  family = poisson,
  data = dat
)
# singular fit
check_singularity(model)

# impose Gamma prior on random effects parameters
prior &lt;- data.frame(
  prior = "gamma(1, 2.5)", # mean can be 1, but even 1e8
  class = "ranef" # for random effects
)
model_with_priors &lt;- update(model, priors = prior)
# no singular fit
check_singularity(model_with_priors)

## End(Not run)

</code></pre>


</div>
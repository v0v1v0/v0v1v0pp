<div class="container">

<table style="width: 100%;"><tr>
<td>model_fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model Fit Object Information</h2>

<h3>Description</h3>

<p>An object with class "model_fit" is a container for
information about a model that has been fit to the data.
</p>


<h3>Details</h3>

<p>The main elements of the object are:
</p>

<ul>
<li> <p><code>lvl</code>: A vector of factor levels when the outcome is
a factor. This is <code>NULL</code> when the outcome is not a factor
vector.
</p>
</li>
<li> <p><code>spec</code>: A <code>model_spec</code> object.
</p>
</li>
<li> <p><code>fit</code>: The object produced by the fitting function.
</p>
</li>
<li> <p><code>preproc</code>: This contains any data-specific information
required to process new a sample point for prediction. For
example, if the underlying model function requires arguments <code>x</code>
and <code>y</code> and the user passed a formula to <code>fit</code>, the <code>preproc</code>
object would contain items such as the terms object and so on.
When no information is required, this is <code>NA</code>.
</p>
</li>
</ul>
<p>As discussed in the documentation for <code>model_spec</code>, the
original arguments to the specification are saved as quosures.
These are evaluated for the <code>model_fit</code> object prior to fitting.
If the resulting model object prints its call, any user-defined
options are shown in the call preceded by a tilde (see the
example below). This is a result of the use of quosures in the
specification.
</p>
<p>This class and structure is the basis for how <span class="pkg">parsnip</span>
stores model objects after seeing the data and applying a model.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

# Keep the `x` matrix if the data are not too big.
spec_obj &lt;-
  linear_reg() %&gt;%
  set_engine("lm", x = ifelse(.obs() &lt; 500, TRUE, FALSE))
spec_obj

fit_obj &lt;- fit(spec_obj, mpg ~ ., data = mtcars)
fit_obj

nrow(fit_obj$fit$x)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>getPoly</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get polynomial terms</h2>

<h3>Description</h3>

<p>Generate polynomial terms of predictor variables for a
data frame or data matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getPoly(xdata = NULL, deg = 1, maxInteractDeg = deg,
        Xy = NULL, standardize = FALSE,
        noisy = TRUE, intercept = FALSE, returnDF = TRUE, 
        modelFormula = NULL, retainedNames = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xdata</code></td>
<td>
<p> Data matrix or data frame without response variable. Categorical variables (&gt; 2 levels) should be passed as factors, not dummy variables or integers, to ensure the polynomial matrix is constructed properly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deg</code></td>
<td>
<p> The max degree of power terms. Default 1 so just returns model matrix by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxInteractDeg</code></td>
<td>
<p>The max degree of nondummy interaction terms. x1 * x2 is degree 2. x1^3 * x2^2 is degree 5. Implicitly constrained by deg. For example, if deg = 3 and maxInteractDegree = 2, x1^1 * x2^2 (i.e., degree 3) will be included but x1^2 * x2^2 (i.e., degree 4) will not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xy</code></td>
<td>
<p> The dataframe with the response in the final column (provide xdata or Xy but not both).Categorical variables (&gt; 2 levels) should be passed as factors, not dummy variables or integers, to ensure the polynomial matrix is constructed properly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p> Standardize all continuous variables? (Default: FALSE.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noisy</code></td>
<td>
<p> Output progress updates? (Default: TRUE.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p> Include intercept? (Default: FALSE.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnDF</code></td>
<td>
<p> Return a data.frame (as opposed to model.matrix)? (Default: TRUE.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelFormula</code></td>
<td>
<p> Internal use. Formula used to generate the training model matrix. Note: anticipates that polynomial terms are generated using internal functions of library(polyreg). Also, providing modelFormula bypasses deg and maxInteractDeg.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retainedNames</code></td>
<td>
<p> Internal use. colnames of polyMatrix object$xdata. Requires modelFormula be inputted as well.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Additional arguments to be passed to model.matrix() via polyreg:::model_matrix(). Note na.action = "na.omit".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>getPoly</code> function takes in a data frame or data matrix and
generates polynomial terms of predictor variables.
</p>
<p>Note the subtleties involving dummy variables.  The square, cubic and
so on terms are the same as the original variable, and the various
duplicates must be eliminated.
</p>
<p>Similarly, after dummy variable are created from a categorical
variable having more than two levels, the resulting columns will be
orthogonal to each other.  In almost
all cases, this argument should be set to TRUE at the training stage, and
then in predictions one should use the vector of names in the
component in the return value;
<code>predict.polyFit</code> does the latter automatically.
</p>
<p>Note:  If a column that is an R factor has levels with spaces in the
names, this will interfere with the parsing, and must be avoided.
</p>





<h3>Value</h3>

<p>The return value of <code>getPoly</code> is a <code>polyMatrix</code>
object.  This is an S3 class containing a model.matrix <code>
xdata</code> of the generated polynomial terms. The predictor
variables have column names V1, V2, etc. The object also contains
<code>modelFormula</code>, the formula used to construct the model matrix, and 
<code>XtestFormula</code>, the formula which should be used out-of-sample 
(when y_test is not available).
</p>


<h3>Examples</h3>

<pre><code class="language-R">N &lt;- 125
rawdata &lt;- data.frame(x1 = rnorm(N), 
                      x2 = rnorm(N),
                      group = sample(letters[1:5], N, replace=TRUE),
                      z = sample(c("treatment", "control"), N, replace=TRUE),
                      result = sample(c("win", "lose", "tie"), N, replace=TRUE))
head(rawdata)

P &lt;- length(levels(rawdata$group)) - 1 + 
     length(levels(rawdata$z)) - 1 + 
     length(levels(rawdata$result)) - 1 + 
     sum(unlist(lapply(rawdata, is.numeric)))

# quadratic polynomial, includes interactions 
# since maxInteractDeg defaults to deg
X &lt;- getPoly(rawdata, 2)$xdata 
ncol(X) # 40

# cubic polynomial, no interactions
X &lt;- getPoly(rawdata, 3, 1)$xdata
ncol(X) # 13

# cubic polynomial, interactions
X &lt;- getPoly(rawdata, 3, 2)$xdata
ncol(X) # 58

# cubic polynomial, interactions
X &lt;- getPoly(rawdata, 3)$xdata
ncol(X) # 101

# making final column the response variable, y
# results in TRUE (fewer columns)
ncol(getPoly(Xy=rawdata, deg=2)$xdata) &lt; ncol(getPoly(rawdata, 2)$xdata)

# preparing polynomial matrices for crossvalidation
# getPoly() returns a polyMatrix() object containing XtestFormula
# which should be used to ensure factors are handled correctly out-of-sample
Xtrain &lt;- getPoly(rawdata[1:100,],2)
Xtest &lt;- getPoly(rawdata[101:125,], 2, modelFormula = Xtrain$XtestFormula)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>gamlasso</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting a gamlasso model</h2>

<h3>Description</h3>

<p>This function will fit a gamlasso model with the given penalties. For some
special cases using <code>gam</code> or <code>glmnet</code>
might be more efficient and/or flexible
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'formula'
gamlasso(
  formula,
  data,
  family = "gaussian",
  linear.penalty = "l1",
  smooth.penalty = "l2",
  num.knots = 5,
  offset = NULL,
  weights = NULL,
  interactions = F,
  seed = .Random.seed[1],
  num.iter = 100,
  tolerance = 1e-04,
  ...
)

## Default S3 method:
gamlasso(
  response,
  linear.terms,
  smooth.terms,
  data,
  family = "gaussian",
  linear.penalty = "l1",
  smooth.penalty = "l2",
  num.knots = 5,
  offset = NULL,
  weights = NULL,
  interactions = F,
  seed = .Random.seed[1],
  num.iter = 100,
  tolerance = 1e-04,
  prompts = F,
  verbose = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula describing the model to be fitted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>The name of the response variable. Could be two variables
in case of a general binomial fit (see details below)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear.terms</code></td>
<td>
<p>The names of the variables to be used as linear predictors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.terms</code></td>
<td>
<p>The names of the variables to be used as smoothers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data with which to fit the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>The family describing the error distribution and link function
to be used in the model. A character string which can only be
<code>"gaussian"</code> (default), <code>"binomial"</code>, <code>"poisson"</code> or
<code>"cox"</code>. For <code>family = "binomial"</code>, <code>response</code> can be
a vector of two and for <code>family="cox"</code>, <code>weights</code> must
be provided (see details below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear.penalty</code></td>
<td>
<p>The penalty used on the linear predictors. A character
string which can be <code>"none"</code> (default), <code>"l1"</code> or <code>"l2"</code>. If
<code>"l1"</code> is used then we use the gam and lasso loop. Otherwise only a
gam model is fitted (with penalities on parametric terms if
<code>linear.penalty = "l2"</code> ).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.penalty</code></td>
<td>
<p>The penalty used on the smoothers. A character
string which can be <code>"l1"</code> or <code>"l2"</code> (default). <code>"l2"</code> refers
to the inherent second order penalty smoothers have for controlling their
shape, so <code>"none"</code> is not an option. For <code>"l1"</code> basis is specified
by <code>bs='ts'</code>, else <code>bs='tp'</code> is used. (see <code>gam</code>
for details on basis types)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.knots</code></td>
<td>
<p>Number of knots for each smoothers. Can be a single integer
(recycled for each smoother variable) or a vector of integers the same length
as the number of smoothers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>The name of the offset variable. <code>NULL</code> (default) if not provided</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>The name of the weights variable. <code>NULL</code> (default) if not
provided. See details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interactions</code></td>
<td>
<p>logical. Should interactions be included as covariates.
If <code>TRUE</code> then the smoothers are fitted with <code>ti</code>
instead of <code>s</code> so that the added effects of the interactions
can be quantified separately.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>The random seed can be specified for reproducibility. This is used
for fitting the gam and lasso models, or fixed before each loop of gamlasso.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.iter</code></td>
<td>
<p>Number of iterations for the gamlasso loop</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>Tolerance for covergence of the gamlasso loop</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prompts</code></td>
<td>
<p>logical. Should <code>gamlassoChecks</code> provide interactive
user prompts for corrective action when needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical. Should there be "progress reports" printed to the
console while fitting the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>gamlasso</code> allows for specifying models in two ways:
1) with the the formula approach, and 2) with the term specification approach.
</p>
<p>The formula approach is appropriate for when the user wants an L1-penalty on the
linear terms of the model, in which case the user is required to specify the linear terms
in a model matrix named "X" appended to the input data frame. A typical formula specification
would be "<code>y ~ X + s(z) + ...</code>" where "<code>X</code>" corresponds to the model-matrix of
linear terms subject to an L1-penalty, while everything to the right of "<code>X</code>" is
considered part of the gam formula (i.e. all smooth terms). In light of the above formula,
gamlasso iterates (until convergence) between the following two lines of pseudo code:
</p>

<ul>
<li> <p><code>model.cv.glmnet &lt;- cv.glmnet(y=y, x=X, offset="model.gam fitted values")</code>
</p>
</li>
<li> <p><code>model.gam &lt;- gam(y ~ s(z) + ..., offset="model.cv.glmnet fitted values")</code>
</p>
</li>
</ul>
<p>The term specification approach can fit the same type of models as the formula approach
(i.e. models with L1-penalty on the linear terms). However, it is more flexible in terms
of penalty-structure and can be useful if the user has big data sets with lots of variables
making the formula specification cumbersome. In the term specification approach
the user simply specifies the names of the data columns corresponding to the
<code>response</code>, <code>linear.terms</code> and <code>smooth.terms</code> and then specifies
whether to put a <code>linear.penalty="l1"</code>, <code>"l2"</code> or <code>"none"</code>
(on <code>linear.terms</code>) and whether to put a <code>smooth.penalty="l1"</code> or
<code>"l2"</code> (on <code>smooth.terms</code>).
</p>
<p>While fitting a binomial model for binary responses (0/1) include the response
variable before "~" if using the formula approach or when using the term-
specification approach the <code>response</code> argument will be a single variable name.
In general if the responses are success/failure counts then the formula should
start with something similar to <code>cbind(success,failure) ~ ...</code> and for
using the term-specification approach the <code>response</code> argument should be a
vector of length two giving the success and failure variable names.
</p>
<p>If <code>family="cox"</code> then the <code>weights</code> argument must be provided
and should correspond to a status variable (1-censor). For other models
it should correspond to a custom weights variables to be used for the
weighted log-likelihood, for example the total counts for fitting a
binomial model. (weights for families other than "cox" currently not
implemented)
</p>
<p>Both the formula and term-specification approaches can fit interaction models as
well. There are three kinds of interactions - those between two linear predictors,
between two smooth predictors and between linear and smooth predictors. For the
formula approach the first type of interaction must be included as additional
columns in the "<code>X</code>" matrix and the other two types must be mentioned in the
smooth terms part of the formula. For the term-specification approach the argument
<code>interaction</code> must be <code>TRUE</code> in which case all the pairwise
interactions are used as predictors and variable selection is done on all of them.
</p>


<h3>Value</h3>

<p>If the arguments fail the basic checking by <code>gamlassoChecks</code>
then returns <code>NULL</code>. Else the function calls <code>gamlassoFit</code> which
returns a list of two models, <code>gam</code> and <code>cv.glmnet</code>.
Either of these could be <code>NULL</code> but if both are non-null then
<code>convergence</code>, a matrix of values determining the convergence
of the gamlasso loop is also returned.
<code>gamlassoFit</code> also returns <code>inherit</code>, a list of select
arguments used to fit the <code>gamlasso</code> model and some more values needed
for prediction.
</p>


<h3>Note</h3>

<p>The default values of <code>num.iter</code> and <code>tolerance</code> are
essentially arbitrary. Also for each step when we check for convergence
between the new and old predictions by the gam and lasso predictions,
we use the following distance metric
</p>
<p style="text-align: center;"><code class="reqn"> d(x,y) = \frac{1}{length(x)} \sum_{i=1}^{length(x)} (x_i - y_i)^2 </code>
</p>



<h3>See Also</h3>

<p><code>gam</code>, <code>glmnet</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(plsmselect)

data(simData)

## Fit gaussian gamlasso model using the formula approach:
## (L1-penalty both on model matrix (X) and smooth terms (bs="ts"))
simData$X = model.matrix(~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10, data=simData)[,-1]

gfit = gamlasso(Yg ~ X +
                   s(z1, k=5, bs="ts") +
                   s(z2, k=5, bs="ts") +
                   s(z3, k=5, bs="ts") +
                   s(z4, k=5, bs="ts"),
                   data = simData,
                   seed=1)

## Equivalently with term specification approach:
gfit = gamlasso(response="Yg",
                  linear.terms=paste0("x",1:10),
                  smooth.terms=paste0("z",1:4),
                  data=simData,
                  linear.penalty = "l1",
                  smooth.penalty = "l1",
                  num.knots = 5,
                  seed=1)

## The two main components of gfit are
## gfit$cv.glmnet (LASSO component) and gfit$gam (GAM components):

## Extract lasso estimates of linear terms:
coef(gfit$cv.glmnet, s="lambda.min")

## Plot the estimates of the smooth effects:
plot(gfit$gam, pages=1)

# See ?summary.gamlasso for an example fitting a binomial response model
# See ?predict.gamlasso for an example fitting a poisson response model
# See ?cumbasehaz for an example fitting a survival response model
</code></pre>


</div>
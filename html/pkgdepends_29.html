<div class="container">

<table style="width: 100%;"><tr>
<td>new_pkg_deps</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>R6 class for package dependency lookup</h2>

<h3>Description</h3>

<p>Look up dependencies of R packages from various sources.
</p>


<h3>Usage</h3>

<pre><code class="language-R">new_pkg_deps(refs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>refs</code></td>
<td>
<p>Package names or references. See
'Package references' for the syntax.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments, passed to
<a href="#method-new"><code>pkg_deps$new()</code></a>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>new_pkg_deps()</code> creates a new object from the <code>pkg_deps</code> class.
The advantage of <code>new_pkg_deps()</code> compared to using the pkg_deps
constructor directly is that it avoids making pkgdepends a build time
dependency.
</p>
<p>The usual steps to query package dependencies are:
</p>

<ol>
<li>
<p> Create a <code>pkg_deps</code> object with <code>new_pkg_deps()</code>.
</p>
</li>
<li>
<p> Resolve all possible dependencies with
<a href="#method-resolve"><code>pkg_deps$resolve()</code></a>.
</p>
</li>
<li>
<p> Solve the dependencies, to obtain a subset of all possible
dependencies that can be installed together, with
<a href="#method-solve"><code>pkg_deps$solve()</code></a>.
</p>
</li>
<li>
<p> Call <a href="#method-get-solution"><code>pkg_deps$get_solution()</code></a> to list the
result of the dependency solver.
</p>
</li>
</ol>
<h3>Value</h3>

<p><code>new_pkg_deps()</code> returns a new <code>pkg_deps</code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-pkg_deps-new"><code>pkg_deps$new()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-get_refs"><code>pkg_deps$get_refs()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-get_config"><code>pkg_deps$get_config()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-resolve"><code>pkg_deps$resolve()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-async_resolve"><code>pkg_deps$async_resolve()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-get_resolution"><code>pkg_deps$get_resolution()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-get_solve_policy"><code>pkg_deps$get_solve_policy()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-set_solve_policy"><code>pkg_deps$set_solve_policy()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-solve"><code>pkg_deps$solve()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-get_solution"><code>pkg_deps$get_solution()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-stop_for_solution_error"><code>pkg_deps$stop_for_solution_error()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-draw"><code>pkg_deps$draw()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-format"><code>pkg_deps$format()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-print"><code>pkg_deps$print()</code></a>
</p>
</li>
<li> <p><a href="#method-pkg_deps-clone"><code>pkg_deps$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-pkg_deps-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>pkg_deps</code> object. Consider using <code>new_pkg_deps()</code>
instead of calling the constructor directly.
</p>
<p>The returned object can be used to look up (recursive) dependencies
of R packages from various sources. To perform the actual lookup,
you'll need to call the <a href="#method-resolve"><code>resolve()</code></a> method.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$new(
  refs,
  config = list(),
  policy = c("lazy", "upgrade"),
  remote_types = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>refs</code></dt>
<dd>
<p>Package names or references. See
'Package references' for the syntax.</p>
</dd>
<dt><code>config</code></dt>
<dd>
<p>Configuration options, a named list. See
'Configuration'.</p>
</dd>
<dt><code>policy</code></dt>
<dd>
<p>Solution policy. See 'The dependency solver'.</p>
</dd>
<dt><code>remote_types</code></dt>
<dd>
<p>Custom remote ref types, this is for advanced
use, and experimental currently.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new <code>pkg_deps</code> object.
</p>


<hr>
<a id="method-pkg_deps-get_refs"></a>



<h4>Method <code>get_refs()</code>
</h4>

<p>The package refs that were used to create the <code>pkg_deps</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$get_refs()</pre></div>



<h5>Returns</h5>

<p>A character vector of package refs that were used to create the
<code>pkg_deps</code> object.
</p>


<hr>
<a id="method-pkg_deps-get_config"></a>



<h4>Method <code>get_config()</code>
</h4>

<p>Configuration options for the <code>pkg_deps</code> object. See
'Configuration' for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$get_config()</pre></div>



<h5>Returns</h5>

<p>See 'Configuration' for the configuration entries.
</p>


<hr>
<a id="method-pkg_deps-resolve"></a>



<h4>Method <code>resolve()</code>
</h4>

<p>Resolve the dependencies of the specified package references. This
usually means downloading metadata from CRAN and Bioconductor, unless
already cached, and also from GitHub if GitHub refs were included,
either directly or indirectly. See
'Dependency resolution' for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$resolve()</pre></div>



<h5>Returns</h5>

<p>The <code>pkg_deps</code> object itself, invisibly.
</p>


<hr>
<a id="method-pkg_deps-async_resolve"></a>



<h4>Method <code>async_resolve()</code>
</h4>

<p>The same as <a href="#method-resolve"><code>resolve()</code></a>, but asynchronous.
This method is for advanced use.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$async_resolve()</pre></div>



<h5>Returns</h5>

<p>A deferred value.
</p>


<hr>
<a id="method-pkg_deps-get_resolution"></a>



<h4>Method <code>get_resolution()</code>
</h4>

<p>Query the result of the dependency resolution. This method can be
called after <a href="#method-resolve"><code>resolve()</code></a> has completed.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$get_resolution()</pre></div>



<h5>Returns</h5>

<p>A pkg_resolution_result object, which is also a data frame. See
'Dependency resolution' for its columns.
</p>


<hr>
<a id="method-pkg_deps-get_solve_policy"></a>



<h4>Method <code>get_solve_policy()</code>
</h4>

<p>Returns the current policy of the dependency solver.
See 'The dependency solver' for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$get_solve_policy()</pre></div>



<h5>Returns</h5>

<p>A character vector of length one.
</p>


<hr>
<a id="method-pkg_deps-set_solve_policy"></a>



<h4>Method <code>set_solve_policy()</code>
</h4>

<p>Set the current policy of the dependency solver.
If the object already contains a solution and the new policy is
different than the old policy, then the solution is deleted.
See 'The dependency solver' for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$set_solve_policy(policy = c("lazy", "upgrade"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>policy</code></dt>
<dd>
<p>Policy to set.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-pkg_deps-solve"></a>



<h4>Method <code>solve()</code>
</h4>

<p>Solve the package dependencies. Out of the resolved dependencies, it
works out a set of packages, that can be installed together to
create a functional installation. The set includes all directly
specified packages, and all required (or suggested, depending on
the configuration) packages as well. It includes every package at
most once. See 'The dependency solver' for details.
</p>
<p><code>solve()</code> calls <a href="#method-resolve"><code>resolve()</code></a> automatically, if it
hasn't been called yet.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$solve()</pre></div>



<h5>Returns</h5>

<p>The <code>pkg_deps</code> object itself, invisibly.
</p>


<hr>
<a id="method-pkg_deps-get_solution"></a>



<h4>Method <code>get_solution()</code>
</h4>

<p>Returns the solution of the package dependencies.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$get_solution()</pre></div>



<h5>Returns</h5>

<p>A pkg_solution_result object, which is a list. See
pkg_solution_result for details.
</p>


<hr>
<a id="method-pkg_deps-stop_for_solution_error"></a>



<h4>Method <code>stop_for_solution_error()</code>
</h4>

<p>Error if the dependency solver failed to find a consistent set of
packages that can be installed together.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$stop_for_solution_error()</pre></div>


<hr>
<a id="method-pkg_deps-draw"></a>



<h4>Method <code>draw()</code>
</h4>

<p>Draw a tree of package dependencies. It returns a <code>tree</code> object, see
<code>cli::tree()</code>. Printing this object prints the dependency tree to the
screen.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$draw()</pre></div>



<h5>Returns</h5>

<p>A <code>tree</code> object from the cli package, see <code>cli::tree()</code>.
</p>


<hr>
<a id="method-pkg_deps-format"></a>



<h4>Method <code>format()</code>
</h4>

<p>Format a <code>pkg_deps</code> object, typically for printing.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Not used currently.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A character vector, each element should be a line in the printout.
</p>


<hr>
<a id="method-pkg_deps-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Prints a <code>pkg_deps</code> object to the screen. The printout includes:
</p>

<ul>
<li>
<p> The package refs.
</p>
</li>
<li>
<p> Whether the object has the resolved dependencies.
</p>
</li>
<li>
<p> Whether the resolution had errors.
</p>
</li>
<li>
<p> Whether the object has the solved dependencies.
</p>
</li>
<li>
<p> Whether the solution had errors.
</p>
</li>
<li>
<p> Advice on which methods to call next.
</p>
</li>
</ul>
<p>See the example below.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>not used currently.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The <code>pkg_deps</code> object itself, invisibly.
</p>


<hr>
<a id="method-pkg_deps-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>pkg_deps$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">
# Method initialize()
pd &lt;- pkg_deps$new("r-lib/pkgdepends")
pd


# Method get_refs()
pd &lt;- new_pkg_deps(c("pak", "jsonlite"))
pd$get_refs()


# Method get_config()
pd &lt;- new_pkg_deps("pak")
pd$get_config()


# Method resolve()
pd &lt;- new_pkg_deps("pak")
pd$resolve()
pd$get_resolution()


# Method get_resolution()
pd &lt;- new_pkg_deps("r-lib/pkgdepends")
pd$resolve()
pd$get_resolution()


# Method get_solve_policy()
pdi &lt;- new_pkg_deps("r-lib/pkgdepends")
pdi$get_solve_policy()
pdi$set_solve_policy("upgrade")
pdi$get_solve_policy()


# Method set_solve_policy()
pdi &lt;- new_pkg_deps("r-lib/pkgdepends")
pdi$get_solve_policy()
pdi$set_solve_policy("upgrade")
pdi$get_solve_policy()


# Method solve()
pd &lt;- new_pkg_deps("r-lib/pkgdepends")
pd$resolve()
pd$solve()
pd$get_solution()


# Method get_solution()
pd &lt;- new_pkg_deps("pkgload")
pd$resolve()
pd$solve()
pd$get_solution()


# Method stop_for_solution_error()
# This is an error, because the packages conflict:
pd &lt;- new_pkg_deps(
  c("r-lib/pak", "cran::pak"),
  config = list(library = tempfile())
)
pd$resolve()
pd$solve()
pd
# This fails:
# pd$stop_for_solution_error()


# Method draw()
pd &lt;- new_pkg_deps("pkgload")
pd$solve()
pd$draw()


# Method print()
pd &lt;- new_pkg_deps("r-lib/pkgdepends")
pd

pd$resolve()
pd

pd$solve()
pd

</code></pre>


</div>
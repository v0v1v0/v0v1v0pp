<div class="container">

<table style="width: 100%;"><tr>
<td>parglm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting Generalized Linear Models in Parallel</h2>

<h3>Description</h3>

<p>Function like <code>glm</code> which can make the computation
in parallel. The function supports most families listed in <code>family</code>.
See "<code>vignette("parglm", "parglm")</code>" for run time examples.
</p>


<h3>Usage</h3>

<pre><code class="language-R">parglm(formula, family = gaussian, data, weights, subset, na.action,
  start = NULL, offset, control = list(...), contrasts = NULL,
  model = TRUE, x = FALSE, y = TRUE, ...)

parglm.fit(x, y, weights = rep(1, NROW(x)), start = NULL,
  etastart = NULL, mustart = NULL, offset = rep(0, NROW(x)),
  family = gaussian(), control = list(), intercept = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class <code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a <code>family</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list or environment containing the variables
in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the fitting process. Should
be <code>NULL</code> or a numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in
the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be
included in the linear predictor during fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of parameters for controlling the fitting process.
For parglm.fit this is passed to <code>parglm.control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of
<code>model.matrix.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a logical value indicating whether model frame should be included
as a component of the returned value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>For <code>parglm</code>: logical values indicating whether the response vector
and model matrix used in the fitting process should be returned as components of the
returned value.
</p>
<p>For <code>parglm.fit</code>: <code>x</code> is a design matrix of dimension <code>n * p</code>, and
<code>y</code> is a vector of observations of length <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For <code>parglm</code>: arguments to be used to form the default <code>control</code> argument
if it is not supplied directly.
</p>
<p>For <code>parglm.fit</code>: unused.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etastart</code></td>
<td>
<p>starting values for the linear predictor. Not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mustart</code></td>
<td>
<p>starting values for the vector of means. Not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>logical. Should an intercept be included in the null model?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The current implementation uses <code>min(as.integer(n / p), nthreads)</code>
threads where <code>n</code> is the number observations, <code>p</code> is the
number of covariates, and <code>nthreads</code> is the <code>nthreads</code> element of
the list
returned by <code>parglm.control</code>. Thus, there is likely little (if
any) reduction in computation time if <code>p</code> is almost equal to <code>n</code>.
The current implementation cannot handle <code>p &gt; n</code>.
</p>


<h3>Value</h3>

<p><code>glm</code> object as returned by <code>glm</code> but differs mainly by the <code>qr</code>
element. The <code>qr</code> element in the object returned by <code>parglm</code>(<code>.fit</code>) only has the <code class="reqn">R</code>
matrix from the QR decomposition.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># small example from `help('glm')`. Fitting this model in parallel does
# not matter as the data set is small
clotting &lt;- data.frame(
  u = c(5,10,15,20,30,40,60,80,100),
  lot1 = c(118,58,42,35,27,25,21,19,18),
  lot2 = c(69,35,26,21,18,16,13,12,12))
f1 &lt;- glm   (lot1 ~ log(u), data = clotting, family = Gamma)
f2 &lt;- parglm(lot1 ~ log(u), data = clotting, family = Gamma,
             control = parglm.control(nthreads = 2L))
all.equal(coef(f1), coef(f2))

</code></pre>


</div>
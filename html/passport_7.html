<div class="container">

<table style="width: 100%;"><tr>
<td>parse_country</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parse country names to standardized form</h2>

<h3>Description</h3>

<p><code>parse_country</code> parses irregular country names to the ISO 3166-1 Alpha-2 code
or other standardized code or name format.
</p>


<h3>Usage</h3>

<pre><code class="language-R">parse_country(
  x,
  to = "iso2c",
  how = c("regex", "google"),
  language = c("en", "de"),
  factor = is.factor(x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A character or factor vector of country names to standardize</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>Format to which to convert. Defaults to <code>"iso2c"</code>; see <code>codes</code>
for more options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>how</code></td>
<td>
<p>How to parse; defaults to <code>"regex"</code>. '"google"â€œ uses the Google
Maps geocoding API. See "Details" for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>language</code></td>
<td>
<p>If <code>how = "regex"</code>, the language from which to parse country
names. Currently accepts <code>"en"</code> (default) and <code>"de"</code>. Ignored if
<code>how = "google"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor</code></td>
<td>
<p>If <code>TRUE</code>, returns factor instead of character vector. If not
supplied, defaults to <code>is.factor(x)</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>parse_country</code> tries to parse a character or factor vector of country names
to a standardized form: by default, ISO 3166-1 Alpha-2 codes.
</p>
<p>When <code>how = "regex"</code> (default), <code>parse_country</code> uses regular expressions to
match irregular forms.
</p>
<p>If regular expressions are insufficient, <code>how = "google"</code> will use the
Google Maps geocoding API instead, which permits a much broader range of
input formats and languages. The API allows 2500 calls per day, and should
thus be called judiciously. <code>parse_country</code> will make one call per unique
input. For more calls, see options that allow passing an API key like
<code>ggmap::geocode()</code> with <code>output = "all"</code> or <code>googleway::google_geocode()</code>.
</p>
<p>Note that due to their flexibility, the APIs may fail unpredictably, e.g.
<code>parse_country("foo", how = "google")</code> returns <code>"CH"</code> whereas <code>how = "regex"</code>
fails with a graceful <code>NA</code> and warning.
</p>


<h3>Value</h3>

<p>A character vector or factor of ISO 2-character country codes or
other specified codes or names. Warns of any parsing failure.
</p>


<h3>Examples</h3>

<pre><code class="language-R">parse_country(c("United States", "USA", "U.S.", "us", "United States of America"))

## Not run: 
# Unicode support for parsing accented or non-Latin scripts
parse_country(c("\u65e5\u672c", "Japon", "\u0698\u0627\u067e\u0646"), how = "google")
#&gt; [1] "JP" "JP" "JP" "JP"

# Parse distinct place names via geocoding APIs
parse_country(c("1600 Pennsylvania Ave, DC", "Eiffel Tower"), how = "google")
#&gt; [1] "US" "FR"

## End(Not run)

</code></pre>


</div>
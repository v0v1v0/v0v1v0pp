<div class="container">

<table style="width: 100%;"><tr>
<td>check_zeroinflation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Check for zero-inflation in count models</h2>

<h3>Description</h3>

<p><code>check_zeroinflation()</code> checks whether count models are
over- or underfitting zeros in the outcome.
</p>


<h3>Usage</h3>

<pre><code class="language-R">check_zeroinflation(x, ...)

## Default S3 method:
check_zeroinflation(x, tolerance = 0.05, ...)

## S3 method for class 'performance_simres'
check_zeroinflation(
  x,
  tolerance = 0.1,
  alternative = c("two.sided", "less", "greater"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Fitted model of class <code>merMod</code>, <code>glmmTMB</code>, <code>glm</code>, or <code>glm.nb</code>
(package <strong>MASS</strong>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed down to <code>simulate_residuals()</code>. This only applies
for models with zero-inflation component, or for models of class <code>glmmTMB</code>
from <code>nbinom1</code> or <code>nbinom2</code> family.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>The tolerance for the ratio of observed and predicted
zeros to considered as over- or underfitting zeros. A ratio
between 1 +/- <code>tolerance</code> is considered as OK, while a ratio
beyond or below this threshold would indicate over- or underfitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the amount of observed zeros is larger than the amount of
predicted zeros, the model is underfitting zeros, which indicates a
zero-inflation in the data. In such cases, it is recommended to use
negative binomial or zero-inflated models.
</p>
<p>In case of negative binomial models, models with zero-inflation component,
or hurdle models, the results from <code>check_zeroinflation()</code> are based on
<code>simulate_residuals()</code>, i.e. <code>check_zeroinflation(simulate_residuals(model))</code>
is internally called if necessary.
</p>


<h3>Value</h3>

<p>A list with information about the amount of predicted and observed
zeros in the outcome, as well as the ratio between these two values.
</p>


<h3>Tests based on simulated residuals</h3>

<p>For certain models, resp. model from certain families, tests are based on
simulated residuals (see <code>simulate_residuals()</code>). These are usually more
accurate for testing such models than the traditionally used Pearson residuals.
However, when simulating from more complex models, such as mixed models or
models with zero-inflation, there are several important considerations.
Arguments specified in <code>...</code> are passed to <code>simulate_residuals()</code>, which
relies on <code>DHARMa::simulateResiduals()</code> (and therefore, arguments in <code>...</code>
are passed further down to <em>DHARMa</em>). The defaults in DHARMa are set on the
most conservative option that works for all models. However, in many cases,
the help advises to use different settings in particular situations or for
particular models. It is recommended to read the 'Details' in
<code>?DHARMa::simulateResiduals</code> closely to understand the implications of the
simulation process and which arguments should be modified to get the most
accurate results.
</p>


<h3>See Also</h3>

<p>Other functions to check model assumptions and and assess model quality: 
<code>check_autocorrelation()</code>,
<code>check_collinearity()</code>,
<code>check_convergence()</code>,
<code>check_heteroscedasticity()</code>,
<code>check_homogeneity()</code>,
<code>check_model()</code>,
<code>check_outliers()</code>,
<code>check_overdispersion()</code>,
<code>check_predictions()</code>,
<code>check_singularity()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(Salamanders, package = "glmmTMB")
m &lt;- glm(count ~ spp + mined, family = poisson, data = Salamanders)
check_zeroinflation(m)

# for models with zero-inflation component, it's better to carry out
# the check for zero-inflation using simulated residuals
m &lt;- glmmTMB::glmmTMB(
  count ~ spp + mined,
  ziformula = ~ mined + spp,
  family = poisson,
  data = Salamanders
)
res &lt;- simulate_residuals(m)
check_zeroinflation(res)

</code></pre>


</div>
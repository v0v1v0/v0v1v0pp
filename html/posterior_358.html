<div class="container">

<table style="width: 100%;"><tr>
<td>rvar-slice</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Random variable slicing</h2>

<h3>Description</h3>

<p>Operations for slicing <code>rvar</code>s and replacing parts of <code>rvar</code>s.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'rvar'
x[[i, ...]]

## S3 replacement method for class 'rvar'
x[[i, ...]] &lt;- value

## S3 method for class 'rvar'
x[..., drop = FALSE]

## S3 replacement method for class 'rvar'
x[i, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an <code>rvar</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i, ...</code></td>
<td>
<p>indices; see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>(<code>rvar</code> or coercable to <code>rvar</code>) Value to insert into
<code>x</code> at the location determined by the indices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>(logical) Should singular dimensions be dropped when slicing
array <code>rvar</code>s? Unlike base array slicing operations, defaults to <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>rvar</code> slicing operators (<code>[</code> and <code>[[</code>) attempt to implement the same
semantics as the base array slicing operators. There are some
exceptions; most notably, <code>rvar</code> slicing defaults to <code>drop = FALSE</code> instead
of <code>drop = TRUE</code>.
</p>


<h3>Extracting or replacing single elements with <code>[[</code>
</h3>

<p>The <code>[[</code> operator extracts (or replaces) single elements. It always
returns (or replaces) a scalar (length-1) <code>rvar</code>.
</p>
<p>The <code>x[[i,...]]</code> operator can be used as follows:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠x[[&lt;numeric&gt;]]⁠</code> for scalar numeric <code>i</code>: gives the <code>i</code>th element of <code>x</code>. If <code>x</code> is
multidimensional (i.e. <code>length(dim(x)) &gt; 1</code>), extra dimensions are ignored
when indexing. For example, if <code>x</code> is a <code class="reqn">6 \times 2</code> <code>rvar</code> array, the
7th element, <code>x[[7]]</code>, will be the first element of the second column, <code>x[1,2]</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠x[[&lt;numeric rvar&gt;]]⁠</code> for scalar numeric <code>rvar</code> <code>i</code>: a generalization of indexing when
<code>i</code> is a scalar numeric. Within each draw of <code>x</code>, selects the element
corresponding to the value of <code>i</code> within that same draw.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠x[[&lt;character&gt;]]⁠</code> for scalar character <code>i</code>: gives the element of <code>x</code> with name
equal to <code>i</code>. <strong>Unlike with base arrays</strong>, does not work with
multidimensional <code>rvar</code>s.
</p>
</li>
<li> <p><code>x[[i_1,i_2,...,i_n]]</code> for scalar numeric or character <code>i_1</code>, <code>i_2</code>, etc.
Must provide exactly the same number of indices as dimensions in <code>x</code>. Selects
the element at the corresponding position in the <code>rvar</code> by number and/or
dimname (as a string).
</p>
</li>
</ul>
<h3>Extracting or replacing multiple elements with <code>[</code>
</h3>

<p>The <code>[</code> operator extracts (or replaces) multiple elements. It always returns
(or replaces) a possibly-multidimensional <code>rvar</code>.
</p>
<p>The <code>x[i,...]</code> operator can be used as follows:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠x[&lt;logical&gt;]⁠</code> for vector logical <code>i</code>: <code>i</code> is recycled to the same length as <code>x</code>,
ignoring multiple dimensions in <code>x</code>, then an <code>rvar</code> vector is returned
containing the elements in <code>x</code> where <code>i</code> is <code>TRUE</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠x[&lt;logical rvar&gt;]⁠</code> for scalar logical <code>rvar</code> <code>i</code>: returns an <code>rvar</code> the same shape
as <code>x</code> containing only those draws where <code>i</code> is <code>TRUE</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠x[&lt;numeric&gt;]⁠</code> for vector numeric <code>i</code>: an <code>rvar</code> vector is returned
containing the <code>i</code>th elements of <code>x</code>, ignoring dimensions.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠x[&lt;matrix&gt;]⁠</code> for numeric matrix <code>i</code>, where <code>ncol(i) == length(dim(x))</code>: each row
of <code>i</code> should give the multidimensional index for a single element in <code>x</code>. The
result is an <code>rvar</code> vector of length <code>nrow(i)</code> containing elements of <code>x</code>
selected by each row of <code>i</code>.
</p>
</li>
<li> <p><code>x[i_1,i_2,...,i_n]</code> for vector numeric, character, or logical <code>i_1</code>,
<code>i_2</code>, etc. Returns a slice of <code>x</code> containing all elements from the dimensions
specified in <code>i_1</code>, <code>i_2</code>, etc. If an argument is left empty, all elements
from that dimension are included. Unlike base arrays, trailing dimensions
can be omitted entirely and will still be selected; for example, if <code>x</code> has
three dimensions, both <code>x[1,,]</code> and <code>x[1,]</code> can be used to create a
slice that includes all elements from the last two dimensions. Unlike base
arrays, <code>[</code> defaults to <code>drop = FALSE</code>, so results retain the same number of
dimensions as <code>x</code>.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">x &lt;- rvar(array(1:24, dim = c(4,2,3)))
dimnames(x) &lt;- list(c("a","b"), c("d","e","f"))
x

## Slicing single elements
# x[[&lt;numeric&gt;]]
x[[2]]

# x[[&lt;numeric rvar&gt;]]
# notice the draws of x[1:4]...
draws_of(x[1:4])
x[[rvar(c(1,3,4,4))]]
# ... x[[rvar(c(1,3,4,4))]] creates a mixures of those draws
draws_of(x[[rvar(c(1,3,4,4))]])

# x[[i_1,i_2,...]]
x[[2,"e"]]


## Slicing multiple elements
# x[&lt;logical&gt;]
x[c(TRUE,TRUE,FALSE)]

# x[&lt;logical rvar&gt;]
# select every other draw
x[rvar(c(TRUE,FALSE,TRUE,FALSE))]

# x[&lt;numeric&gt;]
x[1:3]

# x[&lt;matrix&gt;]
x[rbind(
  c(1,2),
  c(1,3),
  c(2,2)
)]

# x[i_1,i_2,...,i_n]
x[1,]
x[1,2:3]
x[,2:3]
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>Context</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Context</h2>

<h3>Description</h3>

<p>This class represents the base context for interacting with
<code>Backend</code> implementations via the <code>Service</code> interface.
</p>


<h3>Details</h3>

<p>This class is a vanilla wrapper around a <code>Backend</code> implementation.
It registers a backend instance and forwards all <code>Service</code> methods
calls to the backend instance. Subclasses can override any of the
<code>Service</code> methods to decorate the backend instance with additional
functionality (e.g., see the <code>ProgressTrackingContext</code> class).
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>backend</code></dt>
<dd>
<p>The <code>Backend</code> object registered with the
context.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Context-set_backend"><code>Context$set_backend()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-start"><code>Context$start()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-stop"><code>Context$stop()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-clear"><code>Context$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-peek"><code>Context$peek()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-export"><code>Context$export()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-evaluate"><code>Context$evaluate()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-sapply"><code>Context$sapply()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-lapply"><code>Context$lapply()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-apply"><code>Context$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-get_output"><code>Context$get_output()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-clone"><code>Context$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-Context-set_backend"></a>



<h4>Method <code>set_backend()</code>
</h4>

<p>Set the backend instance to be used by the context.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$set_backend(backend)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>backend</code></dt>
<dd>
<p>An object of class <code>Backend</code> that
implements the <code>Service</code> interface.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Context-start"></a>



<h4>Method <code>start()</code>
</h4>

<p>Start the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$start(specification)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification</code></dt>
<dd>
<p>An object of class <code>Specification</code>
that contains the backend configuration.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The resulting backend must be stored in the
<code>.cluster</code> private field on the <code>Backend</code> abstract class,
and accessible to any concrete backend implementations via the active
binding <code>cluster</code>.
</p>


<hr>
<a id="method-Context-stop"></a>



<h4>Method <code>stop()</code>
</h4>

<p>Stop the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$stop()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-Context-clear"></a>



<h4>Method <code>clear()</code>
</h4>

<p>Remove all objects from the backend. This function is equivalent to
calling <code>rm(list = ls(all.names = TRUE))</code> on each node in the
backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$clear()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-Context-peek"></a>



<h4>Method <code>peek()</code>
</h4>

<p>Inspect the backend for variables available in the <code>.GlobalEnv</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$peek()</pre></div>



<h5>Returns</h5>

<p>This method returns a list of character vectors, where each element
corresponds to a node in the backend. The character vectors contain
the names of the variables available in the <code>.GlobalEnv</code> on each
node.
</p>


<hr>
<a id="method-Context-export"></a>



<h4>Method <code>export()</code>
</h4>

<p>Export variables from a given environment to the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$export(variables, environment)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>variables</code></dt>
<dd>
<p>A character vector of variable names to export.</p>
</dd>
<dt><code>environment</code></dt>
<dd>
<p>An environment object from which to export the
variables. Defaults to the parent frame.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-Context-evaluate"></a>



<h4>Method <code>evaluate()</code>
</h4>

<p>Evaluate an arbitrary expression on the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$evaluate(expression)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expression</code></dt>
<dd>
<p>An unquoted expression to evaluate on the backend.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns the result of the expression evaluation.
</p>


<hr>
<a id="method-Context-sapply"></a>



<h4>Method <code>sapply()</code>
</h4>

<p>Run a task on the backend akin to <code>parallel::parSapply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$sapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code>Backend</code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-Context-lapply"></a>



<h4>Method <code>lapply()</code>
</h4>

<p>Run a task on the backend akin to <code>parallel::parLapply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$lapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code>Backend</code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-Context-apply"></a>



<h4>Method <code>apply()</code>
</h4>

<p>Run a task on the backend akin to <code>parallel::parApply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$apply(x, margin, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>An array to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>margin</code></dt>
<dd>
<p>A numeric vector indicating the dimensions of <code>x</code> the
<code>fun</code> function should be applied over. For example, for a matrix,
<code>margin = 1</code> indicates applying <code>fun</code> rows-wise, <code>margin = 2</code>
indicates applying <code>fun</code> columns-wise, and <code>margin = c(1, 2)</code>
indicates applying <code>fun</code> element-wise. Named dimensions are also
possible depending on <code>x</code>. See <code>parallel::parApply()</code> and
<code>base::apply()</code> for more details.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to <code>x</code> according to the <code>margin</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code>Backend</code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-Context-get_output"></a>



<h4>Method <code>get_output()</code>
</h4>

<p>Get the output of the task execution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$get_output(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the backend registered
with the context. This is useful for backends that require additional
arguments to fetch the output (e.g., <code>AsyncBackend$get_output(wait = TRUE)</code>).</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>This method fetches the output of the task execution after calling
the <code>sapply()</code> method. It returns the output and immediately removes
it from the backend. Therefore, subsequent calls to this method are
not advised. This method should be called after the execution of a
task.
</p>



<h5>Returns</h5>

<p>A vector, matrix, or list of the same length as <code>x</code>, containing the
results of the <code>fun</code>. The output format differs based on the specific
operation employed. Check out the documentation for the <code>apply</code>
operations of <code>parallel::parallel</code> for more information.
</p>


<hr>
<a id="method-Context-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p><code>ProgressTrackingContext</code>, <code>Service</code>,
<code>Backend</code>, and <code>SyncBackend</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Define a task to run in parallel.
task &lt;- function(x, y) {
    # Sleep a bit.
    Sys.sleep(0.25)

    # Return the result of a computation.
    return(x + y)
}

# Create a specification object.
specification &lt;- Specification$new()

# Set the number of cores.
specification$set_cores(cores = 2)

# Set the cluster type.
specification$set_type(type = "psock")

# Create a backend factory.
backend_factory &lt;- BackendFactory$new()

# Get a synchronous backend instance.
backend &lt;- backend_factory$get("sync")

# Create a base context object.
context &lt;- Context$new()

# Register the backend with the context.
context$set_backend(backend)

# From now all, all backend operations are intercepted by the context.

# Start the backend.
context$start(specification)

# Run a task in parallel (i.e., approx. 1.25 seconds).
context$sapply(x = 1:10, fun = task, y = 10)

# Get the task output.
context$get_output()

# Close the backend.
context$stop()

# Get an asynchronous backend instance.
backend &lt;- backend_factory$get("async")

# Register the backend with the same context object.
context$set_backend(backend)

# Start the backend reusing the specification object.
context$start(specification)

# Run a task in parallel (i.e., approx. 1.25 seconds).
context$sapply(x = 1:10, fun = task, y = 10)

# Get the task output.
backend$get_output(wait = TRUE)

# Close the backend.
context$stop()

</code></pre>


</div>
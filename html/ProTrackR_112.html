<div class="container">

<table style="width: 100%;"><tr>
<td>patternOrder</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get the pattern order table</h2>

<h3>Description</h3>

<p>The pattern order table is a <code>vector</code> of <code>numeric</code> indices of
<code>PTPattern</code> tables, which determines in which order the patterns
need to be played. This method returns this <code>vector</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'PTModule'
patternOrder(x, full = FALSE)

## S4 replacement method for signature 'PTModule,ANY,numeric'
patternOrder(x, full = FALSE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>PTModule</code> object for which the pattern order table
needs to be returned or modified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>
<p>A <code>logical</code> value indicating whether the full (<code>TRUE</code>,
default), or only the visible (<code>FALSE</code>) part of the pattern order table
should be returned. This argument will also affect how new pattern order
tables are assigned (see <code>value</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>A <code>numeric</code> <code>vector</code> (maximum length: 128) holding
<code>PTPattern</code> indices minus 1 for the new pattern order table.
</p>
<p>When <code>full = TRUE</code>, the <code>vector</code> will be padded with zeros to a
length of 128, and the <code>patternOrderLength</code> will be set to the
length of <code>value</code>. When <code>full = FALSE</code>, <code>value</code> will only
repplace the part of the order table up to the length of <code>value</code>. The
remainder of the table is not changed. The <code>patternOrderLength</code>
is also not modified in this case.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The actual length of the <code>vector</code> containing the pattern order is 128
as per ProTracker standards. Only part of this <code>vector</code> is ‘visible’
and will be used to determine in which order pattern tables are to be played.
This method can be used to return either the visible or full (all 128) part
of the table. It can also be used to assign a new patter order table.
</p>
<p>Note that <code>PTPattern</code> indices start at 0, as per ProTracker
standards, whereas R start indices at 1. Hence, add 1 to the indices obtained
with <code>patternOrder</code>, in order to extract the correct
<code>PTPattern</code> from a <code>PTModule</code>.
</p>
<p>The maximum index plus 1 in the full pattern order table should equal
the number of pattern tables (see <code>patternLength</code>) in the
<code>PTModule</code>. Is you assign a new pattern order, with a lower
maximum, <code>PTPattern</code> objects will get lost (see also examples)!
</p>


<h3>Value</h3>

<p>For <code>patternOrder</code>, a <code>vector</code> of <code>numeric</code>
<code>PTPattern</code> indices is returned.
</p>
<p>For <code style="white-space: pre;">⁠patternOrder&lt;-⁠</code>, an updated version of object <code>x</code> is returned,
in which the pattern order table is modified based on <code>value</code>.
</p>


<h3>Note</h3>

<p>The maximum number of <code>PTPattern</code>s cannot exceed either 64 or
100 (depending on the <code>trackerFlag</code>). This means that values in
the order table should also not exceed these values minus 1.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other pattern.operations: 
<code>MODPlugToPTPattern()</code>,
<code>PTPattern-class</code>,
<code>PTPattern-method</code>,
<code>PTPatternToMODPlug()</code>,
<code>appendPattern()</code>,
<code>deletePattern()</code>,
<code>pasteBlock()</code>,
<code>patternLength()</code>,
<code>patternOrderLength()</code>
</p>
<p>Other module.operations: 
<code>PTModule-class</code>,
<code>appendPattern()</code>,
<code>clearSamples()</code>,
<code>clearSong()</code>,
<code>deletePattern()</code>,
<code>fix.PTModule()</code>,
<code>modToWave()</code>,
<code>moduleSize()</code>,
<code>patternLength()</code>,
<code>patternOrderLength()</code>,
<code>playMod()</code>,
<code>playingtable()</code>,
<code>rawToPTModule()</code>,
<code>read.module()</code>,
<code>trackerFlag()</code>,
<code>write.module()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("mod.intro")

## get the visible part of the patternOrder table:
patternOrder(mod.intro)

## get the full patternOrder table:
patternOrder(mod.intro, full = TRUE)

## add 1 to get extract the right PTPattern from
## mod.intro:
first.pattern.played &lt;-
  (PTPattern(mod.intro, patternOrder(mod.intro)[1] + 1))

## set a different playing order:
patternOrder(mod.intro) &lt;- c(0:3, 0:3, 0:3)

## The assignment above uses a value that
## longer than the patternOrderLength.
## This means that a part ends up in the
## 'invisible' part of the order table:
patternOrder(mod.intro)
patternOrder(mod.intro, full = TRUE)

## Let's do the same assignment, but update
## the visible part of the table as well:
patternOrder(mod.intro, full = TRUE) &lt;- c(0:3, 0:3, 0:3)

## note that the maximum of the order table plus 1
## equals the patternLength of mod.intro (always the case
## for a valid PTModule object):
max(patternOrder(mod.intro, full = TRUE) + 1) ==
  patternLength(mod.intro)

## Let's do something dangerous. If the replacement
## indices do not hold a maximum value that equals
## the patternLength minus 1, PTPatterns will get lost,
## in order to maintain the validity of mod.intro:
patternOrder(mod.intro) &lt;- rep(0, 12)

</code></pre>


</div>
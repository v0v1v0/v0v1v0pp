<div class="container">

<table style="width: 100%;"><tr>
<td>mv_ag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multi Value Trait Aggregation function</h2>

<h3>Description</h3>

<p>EMD can get very heavy with large datasets. For an example
lemnatech dataset filtering for images from every 5th day there are
6332^2 = 40,094,224 pairwise EMD values. In long format that's a 40 million row dataframe,
which is unwieldy. This function is to help reduce the size of datasets before
comparing histograms and moving on with matrix methods or network analysis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mv_ag(
  df,
  group,
  mvCols = "frequencies",
  n_per_group = 1,
  outRows = NULL,
  keep = NULL,
  parallel = getOption("mc.cores", 1),
  traitCol = "trait",
  labelCol = "label",
  valueCol = "value",
  id = "image"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>A dataframe with multi value traits. This can be in wide or long format,
data is assumed to be long if traitCol, valueCol, and labelCol are present.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>Vector of column names for variables which uniquely identify groups
in the data to summarize data over. Typically this would be the design variables
and a time variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mvCols</code></td>
<td>
<p>Either a vector of column names/positions representing multi value
traits or a character string that identifies the multi value trait columns as a
regex pattern. Defaults to "frequencies".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_per_group</code></td>
<td>
<p>Number of rows to return for each group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outRows</code></td>
<td>
<p>Optionally this is a different way to specify how many rows to return.
This will often not be exact so that groups have the same number of observations each.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>A vector of single value traits to also average over groups, if there are
a mix of single and multi value traits in your data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Optionally the groups can be run in parallel with this number of cores,
defaults to 1 if the "mc.cores" option is not set globally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>traitCol</code></td>
<td>
<p>Column with phenotype names, defaults to "trait".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labelCol</code></td>
<td>
<p>Column with phenotype labels (units), defaults to "label".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>valueCol</code></td>
<td>
<p>Column with phenotype values, defaults to "value".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>Column that uniquely identifies images if the data is in long format.
This is ignored when data is in wide format.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a dataframe summarized by the specified groups over the multi-value traits.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
s1 &lt;- mvSim(
 dists = list(runif = list(min = 15, max = 150)),
 n_samples = 10,
 counts = 1000,
 min_bin = 1,
 max_bin = 180,
 wide = TRUE
)
mv_ag(s1, group = "group", mvCols = "sim_", n_per_group = 2)

</code></pre>


</div>
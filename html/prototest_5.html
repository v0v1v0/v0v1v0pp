<div class="container">

<table style="width: 100%;"><tr>
<td>prototest.univariate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Perform Prototype or F Tests for Significance of Groups of Predictors in the Univariate Model
</h2>

<h3>Description</h3>

<p>Perform prototype or F tests for significance of groups of predictors in the univariate model. Choose either exact or approximate likelihood ratio prototype tests (ELR) or (ALR) or F test or marginal screening prototype test. Options for selective or non-selective tests. Further options for non-sampling or hit-and-run null reference distributions for selective tests.
</p>


<h3>Usage</h3>

<pre><code class="language-R">prototest.univariate(x, y, type = c("ALR", "ELR", "MS", "F"), 
selected.col = NULL, lambda, mu = NULL, sigma = 1, hr.iter = 50000, 
hr.burn.in = 5000, verbose = FALSE, tol = 10^-8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>input matrix of dimension <em>n</em>-by-<em>p</em>, where <em>p</em> is the number of predictors in a single predetermined group of predictors. Will be mean centered and standardised before tests are performed. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>response variable. Vector of length emphn, assumed to be quantitative.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>type of test to be performed. Can only select one at a time. Options include the exact and approximate likelihood ratio prototype tests of Reid et al (2015) (ELR, ALR), the F test and the marginal screening prototype test of Reid and Tibshirani (2015) (MS). Default is ELR.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selected.col</code></td>
<td>

<p>preselected columns specified by user. Vector of indices in the set {1, 2, ..., <em>p</em>}. If specified, a <em>non-selective</em> (classical) version of the chosen test it performed. In particular, this means the classicial <code class="reqn">\chi^2_1</code> reference distribution for the likelihood ratio tests and the F reference for the F test. Default is <code>NULL</code>, which directs the function to estimate the selected set with the lasso or the marginal screening procedure, depending on the test.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>regularisation parameter for the lasso fit. Must be supplied when <code>selected.col</code> is <code>NULL</code>. Will be supplied to <code>glmnet</code>. This is the unstandardised version, equivalent to <code>lambda</code>/<em>n</em> supplied to <code>glmnet</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>

<p>mean parameter for the response. See Details below. If supplied, it is first subtracted from the response to yield a mean-zero (at the population level) vector for which we proceed with testing. If <code>NULL</code> (the default), this parameter is treated as nuisance parameter and accounted for as such in testing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>

<p>error standard deviation for the response. See Details below. Must be supplied. If not, it is assumed to be 1. Required for the computation of some of the test statistics.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hr.iter</code></td>
<td>

<p>number of hit-and-run samples required in the reference distrbution of a selective test. Applies only if <code>selected.col</code> is <code>NULL</code>. Default is 50000. Since dependent samples are generated, large values are required to generate good reference distributions. If set to 0, the function tries to apply a non-sampling selective test (provided <code>selected.col</code> is <code>NULL</code>), if possible. If non-sampling test is not possible, the function exits with a message.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hr.burn.in</code></td>
<td>

<p>number of burn-in hit-and-run samples. These are generated first so as to make subsequent hit-and-run realisations less dependent on the observed response. Samples are then discarded and do not inform the null reference distribution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>should progress be printed?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>convergence threshold for iterative optimisation procedures.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model underpinning each of the tests is
</p>
<p style="text-align: center;"><code class="reqn">
	y = \mu + \theta\cdot\hat{y} + \epsilon
</code>
</p>

<p>where <code class="reqn">\epsilon \sim N(0, \sigma^2I)</code> and <code class="reqn">\hat{y}</code> depends on the particular test considered. 
</p>
<p>In particular, for the ELR, ALR and F tests, we have <code class="reqn">\hat{y} = P_M\left(y - \mu\right)</code>, where <code class="reqn">P_M = X_M\left(X_M^\top X_M\right)^{-1}X_M^\top</code>. <code class="reqn">X_M</code> is the input matrix reduced to the columns in the set <em>M</em>, which, in turn, is either provided by the user (via <code>selected.col</code>) or selected by the lasso (if <code>selected.col</code> is <code>NULL</code>). If the former, a non-selective test is performed; if the latter, a selective test is performed, with the restrictions <code class="reqn">Ay\leq b</code>, as set out in Lee et al (2015). 
</p>
<p>For the marginal screening prototype (MS) test, <code class="reqn">\hat{y} = x_{j^*}</code> where <code class="reqn">x_j</code> is the <code class="reqn">j^{th}</code> column of <code>x</code> and <code class="reqn">j^* = {\rm argmax}_j |x_j^\top y|</code>.
</p>
<p>All tests test the null hypothesis <code class="reqn">H_0: \theta = 0</code>. Details of each are described in Reid et al (2015).
</p>


<h3>Value</h3>

<p>A list with the following four components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>ts</code></td>
<td>
<p>The value of the test statistic on the observed data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.val</code></td>
<td>
<p>Valid p-value of the test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selected.col</code></td>
<td>
<p>Vector with columns selected. If initially <code>NULL</code>, this will now contain indices of columns selected by the automatic column selection procedures of the test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.hr</code></td>
<td>
<p>Matrix with hit-and-run replications of the response. If sampled selective test was not performed, this will be <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Stephen Reid
</p>


<h3>References</h3>

<p>Reid, S. and Tibshirani, R. (2015) <em>Sparse regression and marginal testing using cluster prototypes</em>. <a href="http://arxiv.org/pdf/1503.00334v2.pdf">http://arxiv.org/pdf/1503.00334v2.pdf</a>. <em>Biostatistics <a href="http://doi.org/10.1093/biostatistics/kxv049">doi: 10.1093/biostatistics/kxv049</a></em><br>
Reid, S., Taylor, J. and Tibshirani, R. (2015) <em>A general framework for estimation and inference from clusters of features</em>. Available online: <a href="http://arxiv.org/abs/1511.07839">http://arxiv.org/abs/1511.07839</a>.
</p>


<h3>See Also</h3>

<p><code>prototest.multivariate</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require (prototest)

### generate data
set.seed (12345)
n = 100
p = 80

X = matrix (rnorm(n*p, 0, 1), ncol=p)


beta = rep(0, p)
beta[1:3] = 0.1 # three signal variables: number 1, 2, 3
signal = apply(X, 1, function(col){sum(beta*col)})
intercept = 3

y = intercept + signal + rnorm (n, 0, 1)

### treat all columns as if in same group and test for signal

# non-selective ELR test with nuisance intercept
elr = prototest.univariate (X, y, "ELR", selected.col=1:5)
# selective F test with nuisance intercept; non-sampling
f.test = prototest.univariate (X, y, "F", lambda=0.01, hr.iter=0) 
print (elr)
print (f.test)

### assume variables occur in 4 equally sized groups
num.groups = 4
groups = rep (1:num.groups, each=p/num.groups)

# selective ALR test -- select columns 21-25 in 2nd group; test for signal in 1st; hit-and-run
alr = prototest.multivariate(X, y, groups, 1, "ALR", 21:25, lambda=0.005, hr.iter=20000)
# non-selective MS test -- specify first column in each group; test for signal in 1st
ms = prototest.multivariate(X, y, groups, 1, "MS", c(1,21,41,61)) 
print (alr)
print (ms)
</code></pre>


</div>
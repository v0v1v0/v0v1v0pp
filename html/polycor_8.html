<div class="container">

<table style="width: 100%;"><tr>
<td>polyserial</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Polyserial Correlation</h2>

<h3>Description</h3>

<p>Computes the polyserial correlation (and its standard error)
between a quantitative variable and an ordinal variable, based on the assumption
that the joint distribution of the quantitative variable and a latent continuous variable underlying the ordinal 
variable is bivariate normal. Either
the maximum-likelihood estimator or a quicker “two-step” approximation is available. For the ML
estimator the estimates of the thresholds and the covariance matrix of the estimates are also available.
</p>


<h3>Usage</h3>

<pre><code class="language-R">polyserial(x, y, ML = FALSE, control = list(), 
  std.err = FALSE, maxcor=.9999, bins=4, start, thresholds=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numerical variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>an ordered categorical variable; can be numeric, logical, a factor,
an ordered factor, or a character variables,
but if a factor, its levels should be in proper order, and the values of a
character variable are ordered alphabetically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ML</code></td>
<td>
<p>if <code>TRUE</code>, compute the maximum-likelihood estimate; if <code>FALSE</code>, the default, compute a quicker
“two-step” approximation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>optional arguments to be passed to the <code>optim</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.err</code></td>
<td>
<p>if <code>TRUE</code>, return the estimated variance of the correlation (for the two-step estimator)
or the estimated covariance matrix of the correlation and thresholds (for the ML estimator);
the default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxcor</code></td>
<td>
<p>maximum absolute correlation (to insure numerical stability).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bins</code></td>
<td>
<p>the number of bins into which to dissect <code>x</code> for a test of bivariate normality; the default is 4.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>optional start value(s): if a single number, start value for the correlation; if a list with the elements <code>rho</code> and <code>thresholds</code>, start values for these parameters; start values are supplied automatically if omitted, and are only relevant when the ML estimator or standard errors are selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholds</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>) return estimated thresholds along with the estimated correlation even if standard errors aren't computed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The ML estimator is computed by maximizing the bivariate-normal likelihood with respect to the 
thresholds for <code class="reqn">y</code> (<code class="reqn">\tau^{y}_j, i = 1,\ldots, c - 1</code>) and
the population correlation (<code class="reqn">\rho</code>). The likelihood is maximized numerically using the <code>optim</code> function,
and the covariance matrix of the estimated parameters is based on the numerical Hessian computed by <code>optim</code>.
</p>
<p>The two-step estimator is computed by first estimating the thresholds 
(<code class="reqn">\tau^{y}_j, i = 1,\ldots, c - 1</code>)
from the marginal distribution of <code class="reqn">y</code>. Then if the standard error of <code class="reqn">\hat{\rho}</code> is requested, the 
one-dimensional likelihood for <code class="reqn">\rho</code> is maximized numerically, using <code>optim</code> if standard errors are
requested; the standard error computed treats the thresholds as fixed. If the standard error isn't request,
<code class="reqn">\hat{\rho}</code> is computed directly. 
</p>


<h3>Value</h3>

<p>If <code>std.err</code> or <code>thresholds</code> is <code>TRUE</code>, 
returns an object of class <code>"polycor"</code> with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>set to <code>"polyserial"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>the polyserial correlation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cuts</code></td>
<td>
<p>estimated thresholds for the ordinal variable (<code>y</code>), for the ML estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>the estimated variance of the correlation, or, for the ML estimator, 
the estimated covariance matrix of the correlation and thresholds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of observations on which the correlation is based.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chisq</code></td>
<td>
<p>chi-square test for bivariate normality.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>degrees of freedom for the test of bivariate normality.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ML</code></td>
<td>
<p><code>TRUE</code> for the ML estimate, <code>FALSE</code> for the two-step estimate.</p>
</td>
</tr>
</table>
<p>Othewise, returns the polyserial correlation.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Drasgow, F. (1986) 
Polychoric and polyserial correlations. 
Pp. 68–74 in S. Kotz and N. Johnson, eds.,
<em>The Encyclopedia of Statistics, Volume 7.</em> Wiley.
</p>


<h3>See Also</h3>

<p><code>hetcor</code>, <code>polychor</code>, <code>print.polycor</code>,
<code>optim</code></p>


<h3>Examples</h3>

<pre><code class="language-R">if(require(mvtnorm)){
    set.seed(12345)
    data &lt;- rmvnorm(1000, c(0, 0), matrix(c(1, .5, .5, 1), 2, 2))
    x &lt;- data[,1]
    y &lt;- data[,2]
    cor(x, y)  # sample correlation
    }
if(require(mvtnorm)){
    y &lt;- cut(y, c(-Inf, -1, .5, 1.5, Inf))
    polyserial(x, y)  # 2-step estimate
    }
if(require(mvtnorm)){
    polyserial(x, y, ML=TRUE, std.err=TRUE) # ML estimate
    }
</code></pre>


</div>
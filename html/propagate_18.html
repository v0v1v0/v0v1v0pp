<div class="container">

<table style="width: 100%;"><tr>
<td>predictNLS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Confidence/prediction intervals for (weighted) nonlinear models based on uncertainty propagation</h2>

<h3>Description</h3>

<p>A function for calculating confidence/prediction intervals of (weighted) nonlinear models for the supplied or new predictor values, by using first-/second-order Taylor expansion and Monte Carlo simulation. This approach can be used to construct more realistic error estimates and confidence/prediction intervals for nonlinear models than what is possible with only a simple linearization (first-order Taylor expansion) approach. Another application is when there is an "error in x" setup with uncertainties in the predictor variable (See 'Examples'). This function will also work in the presence of multiple predictors with/without errors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">predictNLS(model, newdata, newerror, interval = c("confidence", "prediction", "none"),
           alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a model obtained from <code>nls</code> or <code>nlsLM</code> (package 'minpack.lm').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>a data frame with new predictor values, having the same column names as in <code>model</code>. See <code>predict.nls</code> and 'Examples'. If omitted, the model's predictor values are employed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newerror</code></td>
<td>
<p>a data frame with optional error values, having the same column names as in <code>model</code> and in the same order as in <code>newdata</code>. See 'Examples'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>A character string indicating if confidence/prediction intervals are to be calculated or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>the <code class="reqn">\alpha</code> level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other parameters to be supplied to <code>propagate</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculation of the propagated uncertainty <code class="reqn">\sigma_y</code> using <code class="reqn">\nabla \Sigma \nabla^T</code> is called the "Delta Method" and is widely applied in NLS fitting. However, this method is based on first-order Taylor expansion and thus assummes linearity around <code class="reqn">f(x)</code>. The second-order approach as implemented in the <code>propagate</code> function can partially correct for this restriction by using a second-order polynomial around <code class="reqn">f(x)</code>.<br>
Confidence and prediction intervals are calculated in a usual way using <code class="reqn">t(1 - \frac{\alpha}{2}, \nu) \cdot \sigma_y</code> (1) or <code class="reqn">t(1 - \frac{\alpha}{2}, \nu) \cdot \sqrt{\sigma_y^2 + \textcolor{red}{\sigma_r^2}}</code> (2), respectively, where the residual variance <code class="reqn">\textcolor{red}{\sigma_r^2} = \frac{\sum_{i=1}^n (y_i - \hat{y}_i)^2}{n - \nu}</code> (3).
The inclusion of <code class="reqn">\textcolor{red}{\sigma_r^2}</code> in the prediction interval is implemented as an extended gradient and "augmented" covariance matrix. So instead of using <code class="reqn">y = f(x, \beta)</code> (4) we take <code class="reqn">y = f(x, \beta) + \textcolor{red}{\sigma_r^2}</code> (5) as the expression and augment the <code class="reqn">n \times n</code> covariance matrix <code class="reqn">C</code> to an <code class="reqn">n+1 \times n+1</code> covariance matrix, where <code class="reqn">C_{n+1, n+1} = \textcolor{red}{\sigma_r^2}</code>. Partial differentiation and matrix multiplication will then yield, for example with two coefficients <code class="reqn">\beta_1</code> and <code class="reqn">\beta_2</code> and their corresponding covariance matrix <code class="reqn">\Sigma</code>:     
</p>
<p style="text-align: center;"><code class="reqn">\left[\frac{\partial f}{\partial \beta_1}\; \frac{\partial f}{\partial \beta_2}\; \textcolor{red}{1}\right] \left[ \begin{array}{ccc} \sigma_1^2 &amp; \sigma_1\sigma_2 &amp; 0 \\ \sigma_2\sigma_1 &amp; \sigma_2^2 &amp; 0 \\ 0 &amp; 0 &amp; \textcolor{red}{\sigma_r^2} \end{array} \right] \left[ \begin{array}{c} \frac{\partial f}{\partial \beta_1} \\ \frac{\partial f}{\partial \beta_2} \\ \textcolor{red}{1} \end{array} \right] = \left(\frac{\partial f}{\partial \beta_1}\right)^2\sigma_1^2 + 2 \frac{\partial f}{\partial \beta_1} \frac{\partial f}{\partial \beta_2} \sigma_1 \sigma_2 + \left(\frac{\partial f}{\partial \beta_2}\right)^2\sigma_2^2 + \textcolor{red}{\sigma_r^2}</code>
</p>

<p><code class="reqn">\equiv \sigma_y^2 + \textcolor{red}{\sigma_r^2}</code>, where <code class="reqn">\sigma_y^2 + \textcolor{red}{\sigma_r^2}</code> then goes into (2).<br>
The advantage of the augmented covariance matrix is that it can be exploited for creating Monte Carlo simulation-based prediction intervals. This is new from version 1.0-6 and is based on the paradigm that we simply add another dimension with <code class="reqn">\mu = 0</code> and <code class="reqn">\sigma^2 = \textcolor{red}{\sigma_r^2}</code> to the multivariate t-distribution random number generator (in our case <code>rtmvt</code>). All <code class="reqn">n</code> simulations are then evaluated with (5) and the usual <code class="reqn">[1 - \frac{\alpha}{2}, \frac{\alpha}{2}]</code> quantiles calculated.<br> 
If errors are supplied to the predictor values in <code>newerror</code>, they need to have the same column names and order than the new predictor values. 
</p>


<h3>Value</h3>

<p>A list with the following items:<br><code>summary</code>: The mean/error estimates obtained from first-/second-order Taylor expansion and Monte Carlo simulation, together with calculated confidence/prediction intervals based on asymptotic normality.<br><code>prop</code>: the complete output from <code>propagate</code> for each value in <code>newdata</code>.
</p>


<h3>Author(s)</h3>

<p>Andrej-Nikolai Spiess
</p>


<h3>References</h3>

<p>Nonlinear Regression.<br>
Seber GAF &amp; Wild CJ.<br>
John Wiley &amp; Sons; 1ed, 2003.
</p>
<p>Nonlinear Regression Analysis and its Applications.<br>
Bates DM &amp; Watts DG.<br>
Wiley-Interscience; 1ed, 2007.
</p>
<p>Statistical Error Propagation.<br>
Tellinghuisen J.<br><em>J. Phys. Chem. A</em> (2001), <b>47</b>: 3917-3921.
</p>
<p>Least-squares analysis of data with uncertainty in x and y: A Monte Carlo
methods comparison.<br>
Tellinghuisen J.<br><em>Chemometr Intell Lab</em> (2010), <b>47</b>: 160-169.
</p>
<p>From the author's blog:<br>
http://rmazing.wordpress.com/2013/08/14/predictnls-part-1-monte-carlo-simulation-confidence-intervals-for-nls-models/<br>
http://rmazing.wordpress.com/2013/08/26/predictnls-part-2-taylor-approximation-confidence-intervals-for-nls-models/
</p>


<h3>Examples</h3>

<pre><code class="language-R">## In these examples, 'nsim = 100000' to save
## Rcmd check time (CRAN). It is advocated
## to use at least 'nsim = 1000000' though...

## Example from ?nls.
DNase1 &lt;- subset(DNase, Run == 1)
fm3DNase1 &lt;- nls(density ~ Asym/(1 + exp((xmid - log(conc))/scal)),
                 data = DNase1, start = list(Asym = 3, xmid = 0, scal = 1))

## Using a single predictor value without error.
PROP1 &lt;- predictNLS(fm3DNase1, newdata = data.frame(conc = 2), nsim = 100000)
PRED1 &lt;- predict(fm3DNase1, newdata = data.frame(conc = 2), nsim = 100000)
PROP1$summary
PRED1
## =&gt; Prop.Mean.1 equal to PRED1

## Using a single predictor value with error.
PROP2 &lt;- predictNLS(fm3DNase1, newdata = data.frame(conc = 2), 
                    newerror = data.frame(conc = 0.5), nsim = 100000)
PROP2$summary

## Not run: 
## Using a sequence of predictor values without error.
CONC &lt;- seq(1, 12, by = 1)
PROP3 &lt;- predictNLS(fm3DNase1, newdata = data.frame(conc = CONC))
PRED3 &lt;- predict(fm3DNase1, newdata = data.frame(conc = CONC))
PROP3$summary
PRED3
## =&gt; Prop.Mean.1 equal to PRED3

## Plot mean and confidence values from first-/second-order 
## Taylor expansion and Monte Carlo simulation.
plot(DNase1$conc, DNase1$density)
lines(DNase1$conc, fitted(fm3DNase1), lwd = 2, col = 1)
points(CONC, PROP3$summary[, 1], col = 2, pch = 16)
lines(CONC, PROP3$summary[, 5], col = 2)
lines(CONC, PROP3$summary[, 6], col = 2)
lines(CONC, PROP3$summary[, 11], col = 4)
lines(CONC, PROP3$summary[, 12], col = 4)

## Using a sequence of predictor values with error.
PROP4 &lt;- predictNLS(fm3DNase1, newdata = data.frame(conc = 1:5), 
                    newerror = data.frame(conc = (1:5)/10))
PROP4$summary

## Using multiple predictor values.
## 1: Setup of response values with gaussian error of 10%.
x &lt;- seq(1, 10, by = 0.01)
y &lt;- seq(10, 1, by = -0.01)
a &lt;- 2
b &lt;- 5
c &lt;- 10
z &lt;- a * exp(b * x)^sin(y/c)
z &lt;- z + sapply(z, function(x) rnorm(1, x, 0.10 * x))

## 2: Fit 'nls' model.
MOD &lt;- nls(z ~ a * exp(b * x)^sin(y/c), 
           start = list(a = 2, b = 5, c = 10))

## 3: Single newdata without errors.
DAT1 &lt;- data.frame(x = 4, y = 3)
PROP5 &lt;- predictNLS(MOD, newdata = DAT1)
PROP5$summary

## 4: Single newdata with errors.
DAT2 &lt;- data.frame(x = 4, y = 3)
ERR2 &lt;- data.frame(x = 0.2, y = 0.1)
PROP6 &lt;- predictNLS(MOD, newdata = DAT2, newerror = ERR2)
PROP6$summary

## 5: Multiple newdata with errors.
DAT3 &lt;- data.frame(x = 1:4, y = 3)
ERR3 &lt;- data.frame(x = rep(0.2, 4), y = seq(1:4)/10)
PROP7 &lt;- predictNLS(MOD, newdata = DAT3, newerror = ERR3)
PROP7$summary

## 6: Linear model to compare conf/pred intervals.
set.seed(123)
X &lt;- 1:20
Y &lt;- 3 + 2 * X + rnorm(20, 0, 2)
plot(X, Y)
LM &lt;- lm(Y ~ X)
NLS &lt;- nlsLM(Y ~ a + b * X, start = list(a = 3, b = 2)) 
predict(LM, newdata = data.frame(X = 14.5), interval = "conf") 
predictNLS(NLS, newdata = data.frame(X = 14.5), interval = "conf")$summary
predict(LM, newdata = data.frame(X = 14.5), interval = "pred")
predictNLS(NLS, newdata = data.frame(X = 14.5), interval = "pred")$summary

## 7: compare to 'predFit' function of 'investr' package.
## Same results when using only first-order Taylor expansion.
require(investr)
data(Puromycin, package = "datasets")
Puromycin2 &lt;- Puromycin[Puromycin$state == "treated", ][, 1:2]
Puro.nls &lt;- nls(rate ~ Vm * conc/(K + conc), data = Puromycin2,
                start = c(Vm = 200, K = 0.05))
PRED1 &lt;- predFit(Puro.nls, interval = "prediction")
PRED2 &lt;- predictNLS(Puro.nls, interval = "prediction", second.order = FALSE, do.sim = FALSE)
all.equal(PRED1[, "lwr"], PRED2$summary[, 5]) # =&gt; TRUE

## End(Not run) 
</code></pre>


</div>
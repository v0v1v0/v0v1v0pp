<div class="container">

<table style="width: 100%;"><tr>
<td>pdynmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized Method of Moments (GMM) Estimation of Linear Dynamic Panel Data
Models.</h2>

<h3>Description</h3>

<p><code>pdynmc</code> fits a linear dynamic panel data model based on moment
conditions with the Generalized Method of Moments (GMM).
</p>


<h3>Usage</h3>

<pre><code class="language-R">pdynmc(
  dat = NULL,
  varname.i = NULL,
  varname.t = NULL,
  use.mc.diff = NULL,
  use.mc.lev = NULL,
  use.mc.nonlin = NULL,
  use.mc.nonlinAS = NULL,
  inst.collapse = FALSE,
  inst.stata = FALSE,
  include.y,
  varname.y = NULL,
  lagTerms.y = NULL,
  maxLags.y = NULL,
  include.x = FALSE,
  varname.reg.end = NULL,
  lagTerms.reg.end = NULL,
  maxLags.reg.end = NULL,
  varname.reg.pre = NULL,
  lagTerms.reg.pre = NULL,
  maxLags.reg.pre = NULL,
  varname.reg.ex = NULL,
  lagTerms.reg.ex = NULL,
  maxLags.reg.ex = NULL,
  inst.reg.ex.expand = TRUE,
  include.x.instr = FALSE,
  varname.reg.instr = NULL,
  include.x.toInstr = FALSE,
  varname.reg.toInstr = NULL,
  fur.con = FALSE,
  fur.con.diff = NULL,
  fur.con.lev = NULL,
  varname.reg.fur = NULL,
  lagTerms.reg.fur = NULL,
  include.dum = FALSE,
  dum.diff = NULL,
  dum.lev = NULL,
  varname.dum = NULL,
  col_tol = 0.65,
  w.mat = "iid.err",
  w.mat.stata = FALSE,
  std.err = "corrected",
  estimation = "iterative",
  max.iter = 100,
  iter.tol = 0.01,
  inst.thresh = NULL,
  opt.meth = "BFGS",
  hessian = FALSE,
  optCtrl = list(kkt = FALSE, kkttol = .Machine$double.eps^(1/3), kkt2tol =
    .Machine$double.eps^(1/3), starttests = TRUE, dowarn = TRUE, badval = (0.25) *
    .Machine$double.xmax, usenumDeriv = FALSE, reltol = 1e-12, maxit = 200, trace = TRUE,
    follow.on = FALSE, save.failures = TRUE, maximize = FALSE, factr = 1e+07, pgtol = 0,
    all.methods = FALSE),
  custom.start.val = FALSE,
  start.val = NULL,
  start.val.lo = -1,
  start.val.up = 1,
  seed.input = 42
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>A dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varname.i</code></td>
<td>
<p>The name of the cross-section identifier.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varname.t</code></td>
<td>
<p>The name of the time-series identifier.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.mc.diff</code></td>
<td>
<p>A logical variable indicating whether moment conditions from
equations in differences (i.e. instruments in levels) should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.mc.lev</code></td>
<td>
<p>A logical variable indicating whether moment conditions from
equations in levels (i.e. instruments in differences) should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.mc.nonlin</code></td>
<td>
<p>A logical variable indicating whether nonlinear (quadratic)
moment conditions should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.mc.nonlinAS</code></td>
<td>
<p>A logical variable indicating whether only the nonlinear
(quadratic) moment conditions in the form proposed by
Ahn and Schmidt (1995) should be used (is set to 'TRUE'
when nonlinear moment conditions are employed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inst.collapse</code></td>
<td>
<p>A logical variable indicating whether to collapse the set
of moment conditions as proposed by (Roodman 2009)
(defaults to 'FALSE').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inst.stata</code></td>
<td>
<p>A logical variable indicating whether to use the moment
conditions from equations in levels as in Stata implementations xtabond2
Roodman (2018) and xtdpdgmm
Kripfganz (2019).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.y</code></td>
<td>
<p>A logical variable indicating whether instruments should be
derived from the lags of the dependent variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varname.y</code></td>
<td>
<p>A character string denoting the name of the dependent variable
in the dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lagTerms.y</code></td>
<td>
<p>An integer indicating the number of lags of the dependent
variable. Note that setting 'lagTerms.y' to zero excludes the dependent
variable from the right-hand-side of the model specification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxLags.y</code></td>
<td>
<p>An integer indicating the maximum number of lags of the
dependent variable from which instruments should be derived.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.x</code></td>
<td>
<p>A logical variable indicating whether instruments should be
derived from the covariates. Setting the argument to 'TRUE' requires
specifying whether the covariates are endogenous, predetermined, or
(strictly) exogenous (defaults to 'FALSE').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varname.reg.end</code></td>
<td>
<p>One or more character strings denoting the covariate(s)
in the dataset to be treated as endogenous (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lagTerms.reg.end</code></td>
<td>
<p>One or more integers indicating the number of lags of
the endogenous covariate(s). One integer per covariate needs to be given
in the same order as the covariate names (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxLags.reg.end</code></td>
<td>
<p>One or more integers indicating the maximum number of
lags of the endogenous covariate(s) used for deriving instruments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varname.reg.pre</code></td>
<td>
<p>One or more character strings denoting the covariate(s)
in the dataset to be treated as predetermined (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lagTerms.reg.pre</code></td>
<td>
<p>One or more integers indicating the number of lags of
the predetermined covariate(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxLags.reg.pre</code></td>
<td>
<p>One or more integers indicating the maximum number of
lags of the predetermined covariate(s) used for deriving instruments. One
integer per covariate needs to be given in the same order as the covariate
names (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varname.reg.ex</code></td>
<td>
<p>One or more character strings denoting the covariate(s)
in the dataset to be treated as (strictly) exogenous (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lagTerms.reg.ex</code></td>
<td>
<p>One or more integers indicating the number of lags of
the (strictly) exogenous covariate(s). One integer per covariate needs to
be given in the same order as the covariate name (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxLags.reg.ex</code></td>
<td>
<p>One or more integers indicating the maximum number of
lags of the (strictly) exogenous covariate(s) used for deriving instruments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inst.reg.ex.expand</code></td>
<td>
<p>A logical variable that allows for using all past,
present, and future observations of 'varname.reg.ex' to derive instruments
(defaults to 'TRUE'). If set to 'FALSE', only past and present time periods
are used to derive instruments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.x.instr</code></td>
<td>
<p>A logical variable that allows to include additional
IV-type instruments (i.e., include covariates which are used as instruments
but for which no parameters are estimated; defaults to 'FALSE').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varname.reg.instr</code></td>
<td>
<p>One or more character strings denoting the covariate(s)
in the dataset treated as instruments in estimation (defaults to 'NULL').
Note that the instrument type needs to be specified by including the names
of the covariate(s) in any of the arguments 'varname.reg.end',
'varname.reg.pre', or 'varname.reg.ex'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.x.toInstr</code></td>
<td>
<p>A logical variable that allows to instrument covariate(s)
(i.e., covariates which are not used as instruments but for which parameters
are estimated; defaults to 'FALSE').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varname.reg.toInstr</code></td>
<td>
<p>One or more character strings denoting the covariate(s)
in the dataset to be instrumented (defaults to 'NULL'). Note that the names of
the covariate(s) should not be included in any other function argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fur.con</code></td>
<td>
<p>A logical variable indicating whether further control variables
(covariates) are included (defaults to 'FALSE').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fur.con.diff</code></td>
<td>
<p>A logical variable indicating whether to include further
control variables in equations from differences (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fur.con.lev</code></td>
<td>
<p>A logical variable indicating whether to include further
control variables in equations from level (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varname.reg.fur</code></td>
<td>
<p>One or more character strings denoting covariate(s) in
the dataset to treat as further controls (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lagTerms.reg.fur</code></td>
<td>
<p>One or more integers indicating the number of lags of
the further controls. One integer per further control needs to be given in
the same order as the corresponding variable names (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.dum</code></td>
<td>
<p>A logical variable indicating whether dummy variables for
the time periods are included (defaults to 'FALSE').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dum.diff</code></td>
<td>
<p>A logical variable indicating whether dummy variables are
included in the equations in first differences (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dum.lev</code></td>
<td>
<p>A logical variable indicating whether dummy variables are
included in the equations in levels (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varname.dum</code></td>
<td>
<p>One or more character strings from which time dummies should
be derived (can be different from varname.t; defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_tol</code></td>
<td>
<p>A numeric variable in [0,1] indicating the absolute correlation
threshold for collinearity checks (columns are omitted when pairwise
correlations are above the threshold; defaults to 0.65).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.mat</code></td>
<td>
<p>One of the character strings c('"iid.err"', '"identity"',
'"zero.cov"') indicating the type of weighting matrix to use (defaults to
'"iid.err"').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.mat.stata</code></td>
<td>
<p>A logical variable that slightly adjusts the weighting
matrix according to the Stata function xtdpdgmm (defaults to 'FALSE').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.err</code></td>
<td>
<p>One of the character strings c('"corrected"', '"unadjusted"',
'"dbl.corrected"').
The second and third options compute corrected standard error according
to Windmeijer (2005) and
Hwang et al. (2021), respectively
(defaults to '"corrected"').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimation</code></td>
<td>
<p>One of the character strings c('"onestep"', '"twostep"',
'"iterative"'). Denotes the number of iterations of the parameter procedure
(defaults to '"twostep"').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>An integer indicating the maximum number of iterations
(defaults to 'NULL'; if estimation is set to '"iterative"', 'max.iter'
defaults to 100).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.tol</code></td>
<td>
<p>A numeric variable in [0,1] indicating the tolerance for
determining convergence of the iterative approach (defaults to 'NULL';
if estimation is set to '"iterative"', iter.tol defaults to 0.01).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inst.thresh</code></td>
<td>
<p>An integer denoting above which instrument count a
generalized inverse is used to invert the weighting matrix (defaults to
'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.meth</code></td>
<td>
<p>A character string denoting the numerical optimization procedure.
When no nonlinear moment conditions are employed in estimation, closed form
estimates can be computed by setting the argument to '"none"' (defaults to
'"BFGS"'; for details on the further available optimizers see the
documentation of package <span class="pkg">optimx</span>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>A logical variable indicating if the hessian matrix should be
approximated in optimization (defaults to 'FALSE').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optCtrl</code></td>
<td>
<p>A list of arguments that are passed to <span class="pkg">optimx</span>.
For details on the arguments and the available options see the package
documentation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>custom.start.val</code></td>
<td>
<p>A logical variable indicating whether prespecified
starting values for the parameters are provided by the user (defaults to
'FALSE'; if set to 'TRUE', starting values need to be provided via argument
'start.val').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.val</code></td>
<td>
<p>A vector of numeric variables denoting the starting values
for the parameter vector for numeric optimization (defaults to 'NULL').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.val.lo</code></td>
<td>
<p>A numeric variable denoting the lower limit for drawing
starting values with uniform density (defaults to -1; ignored if
'custom.start.val' is set to 'TRUE').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.val.up</code></td>
<td>
<p>A numeric variable denoting the lower limit for drawing
starting values with uniform density (defaults to 1; ignored if
'custom.start.val' is set to 'TRUE').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed.input</code></td>
<td>
<p>An integer used as seed for drawing starting values (defaults
to 42; required if custom.start.val is set to 'FALSE').</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function estimates a linear dynamic panel data model of the form
</p>
<p style="text-align: center;"><code class="reqn">y_{i,t} = y_{i,t-1} \rho_1 + \boldsymbol{x}_{i,t}' \boldsymbol{\beta} + a_i + \varepsilon_{i,t}</code>
</p>

<p>where <code class="reqn">y_{i,t-1}</code> is the lagged dependent variable, <code class="reqn">\rho_1</code> is
the lag parameter, <code class="reqn">\boldsymbol{x}_{i,t}</code> are further covariates,
<code class="reqn">\boldsymbol{\beta}</code> are the corresponding parameters, <code class="reqn">a_i</code>
is an unobserved individual specific effect, and
<code class="reqn">\varepsilon_{i,t}</code> is an idiosyncratic remainder component. The
model structure accounts for unobserved individual specific heterogeneity
and dynamics. Note that the specification given above is simplified for
illustatory purposes and more general lag structures are allowed in
<code>pdynmc</code>.
</p>
<p>Estimation of the model parameters in <code>pdynmc</code> is based on
moment conditions with the generalized method of moments (GMM). Linear
dynamic panel data models  The moment conditions employed in estimation can be linear and
nonlinear in parameters and estimation is carried out iteratively. In case
only linear moment conditions are used in estimation, closed form solutions
can be for computing parameter estimates – while when nonlinear moment
conditions are employed, parameter estimation relies on numerical
optimization of the objective function.
</p>
<p>'pdynmc' provides an implementation of some of the functionality available
in the Stata library xtdpdgmm Kripfganz (2019) and allows
for '"onestep"', '"twostep"', and '"iterative"' GMM estimation based on the
moment conditions of Holtz-Eakin et al. (1988),
Arellano and Bover (1995), and
Ahn and Schmidt (1995). Standard error corrections
according to Windmeijer (2005) and
Hwang et al. (2021) are available.
For further details, please see
Fritsch et al. (2021).
</p>


<h3>Value</h3>

<p>An object of class 'pdynmc' with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a vector containing the coefficient estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a list of elements on which computation of the model fit is based</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dep.clF</code></td>
<td>
<p>a list of vectors containing the dependent variable for the
cross-sectional observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat.clF</code></td>
<td>
<p>a list of matrices containing the covariates for the
cross-sectional observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.mat</code></td>
<td>
<p>a list of weighting matrices for the different estimation steps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H_i</code></td>
<td>
<p>a matrix used to create the weighting matrix for the first estimation
step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.optim</code></td>
<td>
<p>a list of vectors containing the parameter estimates obtained
from numerical optimization for the estimation steps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctrl.optim</code></td>
<td>
<p>a list of control parameters used in numerical optimization for
the estimation steps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.clForm</code></td>
<td>
<p>a list of vectors containing the parameter estimates obtained
from the closed form for the estimation steps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>a scalar denoting the number of iteration steps carried out to
obtain parameter estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>a list for each estimation step that contains a list of
vectors of fitted values for each cross-sectional observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>a list for each estimation step that contains a list of vectors
of residuals for each cross-sectional observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>a list of matrices containing the variance covariance matrix of the
parameter estimates for each estimation step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stderr</code></td>
<td>
<p>a list of vectors containing the standard errors of the parameter
estimates for each estimation step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zvalue</code></td>
<td>
<p>a list of vectors containing the z scores for the parameter
estimates for each estimation step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pvalue</code></td>
<td>
<p>a list of vectors containing the p-values for the parameter
estimates for each estimation step</p>
</td>
</tr>
</table>
<p>It has 'case.names', 'coef', 'dum.coef', 'fitted', 'model.matrix', 'ninst',
'nobs', 'optimIn', 'plot', 'print','residuals', 'summary', 'variable.names',
'vcov', and 'wmat' methods.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>References</h3>

<p>Ahn SC, Schmidt P (1995).
“Efficient estimation of models for dynamic panel data.”
<em>Journal of Econometrics</em>, <b>68</b>(1), 5–27.
<a href="https://doi.org/10.1016/0304-4076%2894%2901641-C">doi:10.1016/0304-4076(94)01641-C</a>.<br><br> Arellano M, Bover O (1995).
“Another look at the instrumental variable estimation of error-components models.”
<em>Journal of Econometrics</em>, <b>68</b>(1), 29–51.
<a href="https://doi.org/10.1016/0304-4076%2894%2901642-D">doi:10.1016/0304-4076(94)01642-D</a>.<br><br> Fritsch M, Pua AAY, Schnurbus J (2021).
“pdynmc: A Package for Estimating Linear Dynamic Panel Data Models Based on Nonlinear Moment Conditions.”
<em>The R Journal</em>, <b>13</b>(1), 218–231.
<a href="https://doi.org/10.32614/RJ-2021-035">doi:10.32614/RJ-2021-035</a>.<br><br> Holtz-Eakin D, Newey WK, Rosen HS (1988).
“Estimating Vector Autoregressions with Panel Data.”
<em>Econometrica</em>, <b>56</b>(6), 1371–1395.
<a href="https://doi.org/10.2307/1913103">doi:10.2307/1913103</a>.<br><br> Hwang J, Kang B, Lee S (2021).
“A doubly corrected robust variance estimator for linear GMM.”
<em>Journal of Econometrics</em>, <b>forthcoming</b>.
<a href="https://doi.org/10.1016/j.jeconom.2020.09.010">doi:10.1016/j.jeconom.2020.09.010</a>.<br><br> Kripfganz S (2019).
“XTDPDGMM: Stata module to perform generalized method of moments estimation of linear dynamic panel data models.”
<a href="https://econpapers.repec.org/RePEc:boc:bocode:s458395">https://econpapers.repec.org/RePEc:boc:bocode:s458395</a>.<br><br> Roodman D (2009).
“A Note on the Theme of Too Many Instruments.”
<em>Oxford Bulletin of Economics and Statistics</em>, <b>71</b>(1), 135–158.
<a href="https://doi.org/10.1111/j.1468-0084.2008.00542.x">doi:10.1111/j.1468-0084.2008.00542.x</a>.<br><br> Roodman D (2018).
“xtabond2: Stata module to extend xtabond dynamic panel data estimator.”
<a href="https://econpapers.repec.org/software/bocbocode/s435901.htm">https://econpapers.repec.org/software/bocbocode/s435901.htm</a>.<br><br> Windmeijer F (2005).
“A finite sample correction for the variance of linear efficient two-step GMM estimators.”
<em>Journal of Econometrics</em>, <b>126</b>(1), 25–51.
<a href="https://doi.org/10.1016/j.jeconom.2004.02.005">doi:10.1016/j.jeconom.2004.02.005</a>.
</p>


<h3>See Also</h3>

<p><code>wald.fct</code> for Wald tests,
<code>jtest.fct</code> for the Hansen J test, and
<code>mtest.fct</code> for serial correlation tests.
<code>optimx</code> for details on alternative routines and options
for numerical optimization
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
         use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
         include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
         fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
         varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
         include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
         w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
         opt.meth = "none")
summary(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Arellano and Bond (1991) estimation in Table 4, column (a1)
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
         use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
         include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
         fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
         varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
         include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
         w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
         opt.meth = "none")
 summary(m1)

## Arellano and Bond (1991) estimation in Table 4, column (a2)
 m2 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
         use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
         include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
         fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
         varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
         include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
         w.mat = "iid.err", std.err = "corrected", estimation = "twostep",
         opt.meth = "none")
 summary(m2)

## Arellano and Bond (1991) twostep estimation extended by nonlinear moment
## conditions
 m3 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
         use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = TRUE,
         include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
         fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
         varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
         include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
         w.mat = "iid.err", std.err = "corrected", estimation = "twostep",
         opt.meth = "BFGS")
 summary(m3)

## Arellano and Bond (1991) iterative estimation extended by nonlinear moment
## conditions
 m4 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
         use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = TRUE,
         include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
         fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
         varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
         include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
         w.mat = "iid.err", std.err = "corrected", estimation = "iterative",
         max.iter = 4, opt.meth = "BFGS")
 summary(m4)

## Arellano and Bond (1991) twostep estimation extended by linear moment
## conditions from equations in levels
 m5 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
         use.mc.diff = TRUE, use.mc.lev = TRUE, use.mc.nonlin = FALSE,
         include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
         fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
         varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
         include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
         w.mat = "iid.err", std.err = "corrected", estimation = "twostep",
         opt.meth = "none")
 summary(m5)



</code></pre>


</div>
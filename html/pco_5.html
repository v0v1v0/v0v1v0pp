<div class="container">

<table style="width: 100%;"><tr>
<td>pedroni99</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>

panel cointegration tests - bivatiate case
</h2>

<h3>Description</h3>


<p>Computation of the Pedroni (1999) panel cointegration test statistics.  
All statistics are asymptotically normal. Reported are their empirical values and their standardized values (as suggested in Pedroni, 1999).  
</p>


<h3>Usage</h3>

<pre><code class="language-R">pedroni99(Y, X, kk = 0, type.stat = 1, ka = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>


<p>The 'dependent' variable in the cointegration regression.  Must be a matrix (TxN), 'time' in rows, 'individuals' in columns.  No missing values are allowed.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>


<p>The 'independent' variable in the cointegration regression.  Must be a matrix (TxN), 'time' in rows, 'individuals' in columns.  No missing values are allowed.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kk</code></td>
<td>


<p>Parameter for the Newey-West (1994) long term variance estimation (number of lags).  Can be a vector, with a different value for each individual series, or a scalar.  By default it is set to 'round(4 * (T/100)^(2/9))'.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.stat</code></td>
<td>


<p>Type of the main regresion: 1 - 'none', 2 - 'intercept', 3 - 'intercept and time trend'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ka</code></td>
<td>


<p>Number of lags for the ADF type regression on residuals, for the parametric statistics. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p>The function closely follows the instructions in Pedroni (1999).  Calculated and reported are the 7 statistics on page 660 in Pedroni (1999) for the bivariate case.  Also reported are their standardized values, as described on page 665 and by use of the adjustment terms in Table 2, page 666, op.cit.  
H0 is 'no cointegration'.  
</p>


<h3>Value</h3>






<table>
<tr style="vertical-align: top;">
<td><code>CALL</code></td>
<td>
<p>The result of 'match.call()'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>METHOD</code></td>
<td>
<p>Title of the test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>STATISTIC</code></td>
<td>
<p>The 7 test statistics in Pedroni (1999), in two columns - for the empirical and the standardized values.</p>
</td>
</tr>
</table>
<h3>Note</h3>


<p>Under H0 ('no cointegration') the autoregressive coefficients, gamma_i = 1 for all i, versus H1: gamma_i &lt; 1 for all i.  
</p>
<p>The standardized values of the test statistics are asymptotically normal (0,1) under H0.  
</p>


<h3>Author(s)</h3>


<p>Georgi Marinov
</p>


<h3>References</h3>


<p>Newey, Whitney K.; West, Kenneth D. (1994). "Automatic lag selection in covariance matrix estimation". Review of Economic Studies 61 (4): 631-654. 
</p>
<p>Pedroni, Peter, 1999. "Critical Values for Cointegration Tests in Heterogeneous Panels with Multiple Regressors," Oxford Bulletin of Economics and Statistics, Department of Economics, University of Oxford, vol. 61(0), pages 653-70, Special I. 
</p>


<h3>See Also</h3>


<p><code>pedroni99m</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(gdi)
data(gds)
# An illustration for the (non-existent) Feldstein-Horioka paradox.
pedroni99(gdi,gds) 

## The function is currently defined as
function (Y, X, kk = 0, type.stat = 1, ka = 2) 
{
    ff &lt;- function(Y1, X1) {
        NN = ncol(X1)
        sapply(1:NN, function(l) {
            lm(Y1[, l] ~ X1[, l] - 1)$residuals
        })
    }
    ff1 &lt;- function(Y1, X1) {
        NN = ncol(X1)
        sapply(1:NN, function(l) {
            lm(Y1[, l] ~ X1[, l])$residuals
        })
    }
    ff2 &lt;- function(Y1, X1) {
        NN = ncol(X1)
        trend = 1:nrow(X1)
        sapply(1:NN, function(l) {
            lm(Y1[, l] ~ X1[, l] + trend)$residuals
        })
    }
    nw &lt;- function(xx, ki) {
        tt = length(xx)
        (1/tt) * sum(sapply(1:ki, function(s) {
            (1 - s/(ki + 1)) * sum(xx[(s + 1):tt] * xx[1:(tt - 
                s)])
        }))
    }
	adfl&lt;-function (ee, lags) {
		nn&lt;-length(ee)
		z&lt;-ee[(lags+1):nn]
		zl&lt;-ee[lags:(nn-1)]
		zd&lt;-matrix(cbind(rep(z,lags)),ncol=lags)
		ii&lt;-embed(1:nn,lags)
		ii&lt;-ii[-(nrow(ii)),]
		zd&lt;-zd-ee[ii]
		zd&lt;-zd[,-1]
		z&lt;-ee[(lags+1):nn]
		zl&lt;-ee[lags:(nn-1)]
		return(lm(z ~ zl + zd -1)$residuals)
	}
    Y &lt;- as.matrix(Y)
    X &lt;- as.matrix(X)
    if (any((dim(Y) != dim(X)))) {
        stop("Y and X are not compatible.")
    }
    na.fail(Y)
    na.fail(X)
    TD = nrow(X)
    N = ncol(X)
    if (is.vector(kk) &amp;&amp; length(kk) == N) {
        k = kk
    }
    else if (kk &gt; 0) {
        k = rep(round(kk), N)
    }
    else {
        i = round(4 * (TD/100)^(2/9))
        k = rep(i, N)
    }
    if (ka &lt; 2) {
        ka = 2
        warning("Parameter 'ka' was changed to 2.")
    }
    ka &lt;- as.vector(ka)
    if (length(ka) != N) {
        ka &lt;- rep(ka[1], N)
    }
    stats &lt;- matrix(nrow = 7, ncol = 2)
    rownames(stats) &lt;- c("nipanel", "rhopanel", "tpanelnonpar", 
        "tpanelpar", "rhogroup", "tgroupnonpar", "tgrouppar")
    colnames(stats) &lt;- c("empirical", "standardized")
    statsm &lt;- cbind(c(6.982, -6.388, -1.662, -1.662, -9.889, 
        -1.992, -1.992), c(11.754, -9.495, -2.177, -2.177, -12.938, 
        -2.453, -2.453), c(21.162, -14.011, -2.648, -2.648, -17.359, 
        -2.872, -2.872))
    rownames(statsm) &lt;- c("nipanel", "rhopanel", "tpanel", "tpanelp", 
        "rhogroup", "tgroup", "tgroupp")
    colnames(statsm) &lt;- c("none", "intercept", "trend")
    statsv &lt;- cbind(c(81.145, 64.288, 1.559, 1.559, 41.943, 0.649, 
        0.649), c(104.546, 57.61, 0.964, 0.964, 51.49, 0.618, 
        0.618), c(160.249, 64.219, 0.69, 0.69, 66.387, 0.555, 
        0.555))
    rownames(statsv) &lt;- c("nipanel", "rhopanel", "tpanel", "tpanelp", 
        "rhogroup", "tgroup", "tgroupp")
    colnames(statsv) &lt;- c("none", "intercept", "trend")
    e &lt;- matrix(ncol = N, nrow = TD)
    if (type.stat == 2) {
        e &lt;- ff1(Y, X)
    }
    else if (type.stat == 3) {
        e &lt;- ff2(Y, X)
    }
    else {
        e &lt;- ff(Y, X)
        type.stat = 1
    }
    De &lt;- diff(e)
    estar &lt;- e
    Destar &lt;- diff(estar)
    DX &lt;- diff(X)
    DY &lt;- diff(Y)
    eta &lt;- matrix(ncol = ncol(DX), nrow = nrow(DX))
    eta &lt;- ff(DY, DX)
    L11hat2 &lt;- sapply(1:N, function(i) {
        (1/nrow(eta)) * sum(eta[, i]^2) + 2 * nw(eta[, i], k[i])
    })
    mu &lt;- matrix(ncol = ncol(DX), nrow = nrow(DX))
    mu &lt;- ff(e[2:TD, ], e[1:(TD - 1), ])
    lambdahat &lt;- sapply(1:N, function(i) {
        nw(mu[, i], k[i])
    })
    mustar &lt;- matrix(ncol = ncol(DX), nrow = nrow(DX))
    mustar &lt;- sapply(1:N, function(i) {
        adfl(e[, i], ka[i])
    })
    shatstar2 &lt;- sapply(1:N, function(i) {
        (1/nrow(mustar)) * sum(mustar[, i]^2)
    })
    stildestar2 &lt;- (1/N) * sum(shatstar2)
    shat2 &lt;- sapply(1:N, function(i) {
        (1/nrow(mu)) * sum(mu[, i]^2)
    })
    sigmahat2 &lt;- shat2 + 2 * lambdahat
    sigmatilde2 &lt;- (1/N) * sum(L11hat2^(-2) * sigmahat2)
    nipa &lt;- sum(sapply(1:N, function(i) {
        sum((L11hat2[i]^(-2)) * (e[1:(TD - 1), i]^2))
    }))
    lel &lt;- sum(sapply(1:N, function(i) {
        (L11hat2[i]^(-2)) * sum(sapply(1:(nrow(De)), function(ttt) {
            (e[(ttt), i] * De[ttt, i] - lambdahat[i])
        }))
    }))
    nipanel &lt;- (TD^2) * (N^(3/2)) * nipa^(-1)
    stats[1, 1] &lt;- nipanel
    rhopanel &lt;- TD * (N^(1/2)) * (nipa^(-1)) * lel
    stats[2, 1] &lt;- rhopanel
    tpanelnonpar &lt;- ((sigmatilde2 * nipa)^(-1/2)) * lel
    stats[3, 1] &lt;- tpanelnonpar
    tpanelpar &lt;- ((stildestar2 * sum(sapply(1:N, function(i) {
        sum((L11hat2[i]^(-2)) * estar[1:(nrow(estar) - 1), i]^2)
    })))^(-1/2)) * sum(sapply(1:N, function(i) {
        sum(sapply(1:(nrow(Destar)), function(ttt) {
            (L11hat2[i]^(-2)) * (estar[ttt, i] * Destar[ttt, 
                i])
        }))
    }))
    stats[4, 1] &lt;- tpanelpar
    rhogroup &lt;- TD * (N^(-1/2)) * sum(sapply(1:N, function(i) {
        ((sum(e[1:(nrow(e) - 1), i]^2))^(-1)) * sum(sapply(1:(nrow(De)), 
            function(ttt) {
                (e[ttt, i] * De[ttt, i] - lambdahat[i])
            }))
    }))
    stats[5, 1] &lt;- rhogroup
    tgroupnonpar &lt;- (N^(-1/2)) * sum(sapply(1:N, function(i) {
        ((sigmahat2[i] * sum(e[1:(nrow(e) - 1), i]^2))^(-1/2)) * 
            sum(sapply(1:(nrow(De)), function(ttt) {
                (e[(ttt), i] * De[ttt, i] - lambdahat[i])
            }))
    }))
    stats[6, 1] &lt;- tgroupnonpar
    tgrouppar &lt;- (N^(-1/2)) * sum(sapply(1:N, function(i) {
        (sum(shat2[i] * estar[1:(nrow(estar) - 1), i]^2))^(-1/2) * 
            sum(estar[1:(nrow(estar) - 1), i] * Destar[1:(nrow(estar) - 
                1), i])
    }))
    stats[7, 1] &lt;- tgrouppar
    stats[, 2] &lt;- sapply(1:7, function(i) {
        (stats[i, 1] - statsm[i, type.stat] * sqrt(N))/sqrt(statsv[i, 
            type.stat])
    })
    list(CALL = match.call(), METHOD = "Pedroni(1999) panel tests for cointegration", 
        STATISTIC = stats)
  }
</code></pre>


</div>
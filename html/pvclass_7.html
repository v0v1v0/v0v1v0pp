<div class="container">

<table style="width: 100%;"><tr>
<td>cvpvs.logreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Cross-Validated P-Values (Penalized Multicategory Logistic Regression) </h2>

<h3>Description</h3>

<p>Computes cross-validated nonparametric p-values for the potential class memberships of the training data. The p-values are based on 'penalized logistic regression'.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cvpvs.logreg(X, Y, tau.o=10, find.tau=FALSE, delta=2, tau.max=80, tau.min=1,
             pen.method = c("vectors", "simple", "none"), progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p> matrix containing training observations, where each observation is a row vector. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p> vector indicating the classes which the training observations belong to. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.o</code></td>
<td>
<p> the penalty parameter (see section 'Details' below). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>find.tau</code></td>
<td>
<p> logical. If TRUE the program searches for the best <code>tau</code>. For more information see section 'Details'. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p> factor for the penalty parameter. Should be greater than 1. Only needed if <code>find.tau == TRUE</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.max</code></td>
<td>
<p> maximal penalty parameter considered.  Only needed if <code>find.tau == TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.min</code></td>
<td>
<p> minimal penalty parameter considered.  Only needed if <code>find.tau == TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pen.method</code></td>
<td>
<p> the method of penalization (see section 'Details' below). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p> optional parameter for reporting the status of the computations. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Computes cross-validated nonparametric p-values for the potential class memberships of the training data. Precisely, for each feature vector <code>X[i,]</code> and each class <code>b</code> the number <code>PV[i,b]</code> is a p-value for the null hypothesis that <code>Y[i]</code> equals <code>b</code>, based on the remaining training observations.
<br>
This p-value is based on a permutation test applied to an estimated Bayesian likelihood ratio, using 'penalized logistic regression'. This means, the conditional probability of <code class="reqn">Y = y</code>, given <code class="reqn">X = x</code>, is assumed to be proportional to <code class="reqn">exp(a_y + b_y^T x)</code>. The parameters <code class="reqn">a_y</code>, <code class="reqn">b_y</code> are estimated via penalized maximum log-likelihood. The penalization is either a weighted sum of the euclidean norms of the vectors <code class="reqn">(b_1[j],b_2[j],\ldots,b_L[j])</code> (<code>pen.method=='vectors'</code>) or a weighted sum of all moduli <code class="reqn">|b_y[j]|</code> (<code>pen.method=='simple'</code>). The weights are given by <code>tau.o</code> times the sample standard deviation (within groups) of the <code class="reqn">j</code>-th components of the feature vectors. 
In case of <code>pen.method=='none'</code>, no penalization is used, but this option may be unstable.
<br>
If <code>find.tau == TRUE</code>, the program searches for the best penalty parameter. To determine the best parameter <code>tau</code> for the p-value <code>PV[i,b]</code>, the class label of the training observation <code>X[i,]</code> is set temporarily to <code>b</code> and then for all training observations with <code>Y[j] != b</code> the estimated probability of <code>X[j,]</code> belonging to class <code>b</code> is computed. Then the <code>tau</code> which minimizes the sum of these values is chosen. First, <code>tau.o</code> is compared with <code>tau.o*delta</code>. If <code>tau.o*delta</code> is better, it is compared with <code>tau.o*delta^2</code>, etc. The maximal parameter considered is <code>tau.max</code>. If <code>tau.o</code> is better than <code>tau.o*delta</code>, it is compared with <code>tau.o*delta^-1</code>, etc. The minimal parameter considered is <code>tau.min</code>. 
</p>


<h3>Value</h3>

<p><code>PV</code> is a matrix containing the cross-validated p-values. Precisely, for each feature vector <code>X[i,]</code> and each class <code>b</code> the number <code>PV[i,b]</code> is a p-value for the null hypothesis that <code class="reqn">Y[i] = b</code>, based on the remaining training observations.
<br>
If <code>find.tau == TRUE</code>, <code>PV</code> has an attribute <code>"tau.opt"</code>, which is a matrix and <code>tau.opt[i,b]</code> is the best <code>tau</code> for observation <code>X[i,]</code> and class <code>b</code> (see section 'Details'). <code>tau.opt[i,b]</code> is used to compute the p-value for observation <code>X[i,]</code> and class <code>b</code>.
</p>


<h3>Author(s)</h3>

<p>Niki Zumbrunnen <a href="mailto:niki.zumbrunnen@gmail.com">niki.zumbrunnen@gmail.com</a> <br>
Lutz Dümbgen <a href="mailto:lutz.duembgen@stat.unibe.ch">lutz.duembgen@stat.unibe.ch</a> <br><a href="www.imsv.unibe.ch/duembgen/index_ger.html">www.imsv.unibe.ch/duembgen/index_ger.html</a>
</p>


<h3>References</h3>

<p>Zumbrunnen N. and Dümbgen L. (2017)
pvclass: An R Package for p Values for Classification.
<em>Journal of Statistical Software <b>78(4)</b></em>, 1–19.
doi:10.18637/jss.v078.i04
</p>
<p>Dümbgen L., Igl B.-W. and Munk A. (2008)
P-Values for Classification.
<em>Electronic Journal of Statistics <b>2</b></em>, 468–493, available at <a href="http://dx.doi.org/10.1214/08-EJS245">http://dx.doi.org/10.1214/08-EJS245</a>.
</p>
<p>Zumbrunnen N. (2014)
P-Values for Classification – Computational Aspects and Asymptotics.
Ph.D. thesis, University of Bern, available at <a href="http://boris.unibe.ch/id/eprint/53585">http://boris.unibe.ch/id/eprint/53585</a>.
</p>


<h3>See Also</h3>

 
<p><code>cvpvs, cvpvs.gaussian, cvpvs.knn, cvpvs.wnn</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
X &lt;- iris[, 1:4]
Y &lt;- iris[, 5]

cvpvs.logreg(X, Y, tau.o=1, pen.method="vectors",progress=TRUE)

## End(Not run)

# A bigger data example: Buerk's hospital data.
## Not run: 
data(buerk)
X.raw &lt;- as.matrix(buerk[,1:21])
Y.raw &lt;- buerk[,22]
n0.raw &lt;- sum(1 - Y.raw)
n1 &lt;- sum(Y.raw)
n0 &lt;- 3*n1

X0 &lt;- X.raw[Y.raw==0,]
X1 &lt;- X.raw[Y.raw==1,]

tmpi0 &lt;- sample(1:n0.raw,size=n0,replace=FALSE)
tmpi1 &lt;- sample(1:n1    ,size=n1,replace=FALSE)

X &lt;- rbind(X0[tmpi0,],X1)
Y &lt;- c(rep(1,n0),rep(2,n1))

str(X)
str(Y)

PV &lt;- cvpvs.logreg(X,Y,
	tau.o=5,pen.method="v",progress=TRUE)

analyze.pvs(Y=Y,pv=PV,pvplot=FALSE)

## End(Not run)

</code></pre>


</div>
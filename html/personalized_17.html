<div class="container">

<table style="width: 100%;"><tr>
<td>summarize.subgroups</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Summarizing covariates within estimated subgroups</h2>

<h3>Description</h3>

<p>Summarizes covariate values within the estimated subgroups
</p>


<h3>Usage</h3>

<pre><code class="language-R">summarize.subgroups(x, ...)

## Default S3 method:
summarize.subgroups(x, subgroup, ...)

## S3 method for class 'subgroup_fitted'
summarize.subgroups(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a fitted object from <code>fit.subgroup()</code> or a matrix of covariate values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional arguments to <code>summarize.subgroups</code> methods</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subgroup</code></td>
<td>
<p>vector of indicators of same length as the number of rows in x if x is a matrix.
A value of 1 in the ith position of <code>subgroup</code> indicates patient i is in the subgroup
of patients recommended the treatment and a value of 0 in the ith position of <code>subgroup</code> indicates patient i is in the subgroup
of patients recommended the control.
If x is a fitted object returned by <code>fit.subgroup()</code>, <code>subgroup</code> is not needed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The p-values shown are raw p-values and are not adjusted for multiple comparisons.
</p>


<h3>See Also</h3>

<p><code>fit.subgroup</code> for function which fits subgroup identification models and
<code>print.subgroup_summary</code> for arguments for printing options for <code>summarize.subgroups()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(personalized)

set.seed(123)
n.obs  &lt;- 1000
n.vars &lt;- 50
x &lt;- matrix(rnorm(n.obs * n.vars, sd = 3), n.obs, n.vars)


# simulate non-randomized treatment
xbetat   &lt;- 0.5 + 0.5 * x[,21] - 0.5 * x[,41]
trt.prob &lt;- exp(xbetat) / (1 + exp(xbetat))
trt01    &lt;- rbinom(n.obs, 1, prob = trt.prob)

trt      &lt;- 2 * trt01 - 1

# simulate response
delta &lt;- 2 * (0.5 + x[,2] - x[,3] - x[,11] + x[,1] * x[,12])
xbeta &lt;- x[,1] + x[,11] - 2 * x[,12]^2 + x[,13]
xbeta &lt;- xbeta + delta * trt

# continuous outcomes
y &lt;- drop(xbeta) + rnorm(n.obs, sd = 2)

# create function for fitting propensity score model
prop.func &lt;- function(x, trt)
{
    # fit propensity score model
    propens.model &lt;- cv.glmnet(y = trt,
                               x = x, family = "binomial")
    pi.x &lt;- predict(propens.model, s = "lambda.min",
                    newx = x, type = "response")[,1]
    pi.x
}

subgrp.model &lt;- fit.subgroup(x = x, y = y,
                             trt = trt01,
                             propensity.func = prop.func,
                             loss   = "sq_loss_lasso",
                             nfolds = 5)    # option for cv.glmnet

comp &lt;- summarize.subgroups(subgrp.model)
print(comp, p.value = 0.01)

# or we can simply supply the matrix x and the subgroups
comp2 &lt;- summarize.subgroups(x, subgroup = 1 * (subgrp.model$benefit.scores &gt; 0))

print(comp2, p.value = 0.01)

</code></pre>


</div>
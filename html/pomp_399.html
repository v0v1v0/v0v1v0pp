<div class="container">

<table style="width: 100%;"><tr>
<td>skeleton_spec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>skeleton specification</h2>

<h3>Description</h3>

<p>Specification of the deterministic skeleton.
</p>


<h3>Usage</h3>

<pre><code class="language-R">vectorfield(f)

map(f, delta.t = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>procedure for evaluating the deterministic skeleton
This can be a C snippet, an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function, or the name of a native routine in a dynamically linked library.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.t</code></td>
<td>
<p>positive numerical value; the size of the discrete time step corresponding to an application of the map</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The skeleton is a dynamical system that expresses the central tendency of the unobserved Markov state process.
As such, it is not uniquely defined, but can be both interesting in itself and useful in practice.
In <span class="pkg">pomp</span>, the skeleton is used by <code>trajectory</code> and <code>traj_objfun</code>.
</p>
<p>If the state process is a discrete-time stochastic process, then the skeleton is a discrete-time map.
To specify it, provide </p>
<pre>
  skeleton = map(f, delta.t)</pre>
<p>to <code>pomp</code>, where <code>f</code> implements the map and <code>delta.t</code> is the size of the timestep covered at one map iteration.
</p>
<p>If the state process is a continuous-time stochastic process, then the skeleton is a vectorfield (i.e., a system of ordinary differential equations).
To specify it, supply </p>
<pre>
  skeleton = vectorfield(f)</pre>
<p>to <code>pomp</code>, where <code>f</code> implements the vectorfield, i.e., the right-hand-size of the differential equations.
</p>
<p>In either case, <code>f</code> can be furnished either as a C snippet (the preferred choice), or an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function.
General rules for writing C snippets can be found here.
In writing a <code>skeleton</code> C snippet, be aware that:
</p>

<ol>
<li>
<p> For each state variable, there is a corresponding component of the deterministic skeleton.
The goal of such a snippet is to compute all the components.
</p>
</li>
<li>
<p> When the skeleton is a map, the component corresponding to state variable <code>x</code> is named <code>Dx</code> and is the new value of <code>x</code> after one iteration of the map.
</p>
</li>
<li>
<p> When the skeleton is a vectorfield, the component corresponding to state variable <code>x</code> is named <code>Dx</code> and is the value of <code class="reqn">dx/dt</code>.
</p>
</li>
<li>
<p> As with the other C snippets, all states, parameters and covariates, as well as the current time, <code>t</code>, will be defined in the context within which the snippet is executed.
</p>
</li>
<li> <p><b>NB:</b> When the skeleton is a map, the duration of the timestep will <b>not</b> be defined in the context within which the snippet is executed.
When the skeleton is a vectorfield, of course, no timestep is defined.
In this regard, C snippets for the skeleton and rprocess components differ.
</p>
</li>
</ol>
<p>The tutorials on the <a href="https://kingaa.github.io/pomp/">package website</a> give some examples.
</p>
<p>If <code>f</code> is an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function, its arguments should be taken from among the state variables, parameters, covariates, and time.
It must also take the argument ‘<code>...</code>’.
As with the other basic components, <code>f</code> may take additional arguments, provided these are passed along with it in the call to <code>pomp</code>.
The function <code>f</code> must return a numeric vector of the same length as the number of state variables, which contains the value of the map or vectorfield at the required point and time.
</p>


<h3>Masking of <code>map</code>
</h3>

<p>Other packages (most notably the <span class="pkg">tidyverse</span> package <span class="pkg">purrr</span>) have functions named ‘map’.
Beware that, if you load one of these packages after you load <span class="pkg">pomp</span>, the <span class="pkg">pomp</span> function <code>map</code> described here will be masked.
You can always access the <span class="pkg">pomp</span> function by calling <code>pomp::map</code>.
</p>


<h3>Default behavior</h3>

<p>The default <code>skeleton</code> is undefined.
It will yield missing values (<code>NA</code>) for all state variables.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code>cdir</code> and <code>cfile</code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p><code>skeleton</code>
</p>
<p>More on implementing POMP models: 
<code>Csnippet</code>,
<code>accumvars</code>,
<code>basic_components</code>,
<code>betabinomial</code>,
<code>covariates</code>,
<code>dinit_spec</code>,
<code>dmeasure_spec</code>,
<code>dprocess_spec</code>,
<code>emeasure_spec</code>,
<code>eulermultinom</code>,
<code>parameter_trans()</code>,
<code>pomp-package</code>,
<code>pomp_constructor</code>,
<code>prior_spec</code>,
<code>rinit_spec</code>,
<code>rmeasure_spec</code>,
<code>rprocess_spec</code>,
<code>transformations</code>,
<code>userdata</code>,
<code>vmeasure_spec</code>
</p>
<p>More on methods for deterministic process models: 
<code>flow()</code>,
<code>skeleton()</code>,
<code>traj_match</code>,
<code>trajectory()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  ## Starting with an existing pomp object,
  ## e.g., the continuous-time Verhulst-Pearl model,

  verhulst() -&gt; po
  
  ## we add or change the deterministic skeleton
  ## using the 'skeleton' argument in any 'pomp'
  ## elementary or estimation function
  ## (or in the 'pomp' constructor itself).
  ## Here, we pass the skeleton specification
  ## to 'trajectory' as an R function.
  ## Since this is a continuous-time POMP, the
  ## skeleton is a vectorfield.

  po |&gt;
    trajectory(
      skeleton=vectorfield(
        function(r, K, n, ...) {
          c(n=r*n*(1-n/K))
        }
      ),
      format="data.frame"
    ) -&gt; traj

  ## We can also pass it as a C snippet:

  po |&gt;
    traj_objfun(
      skeleton=vectorfield(Csnippet("Dn=r*n*(1-n/K);")),
      paramnames=c("r","K"),
      statenames="n"
    ) -&gt; ofun

  ofun()

  ## For a discrete-time POMP, the deterministic skeleton
  ## is a map.  For example,

  gompertz() -&gt; po

  po |&gt;
    traj_objfun(
      skeleton=map(
        Csnippet("
          double dt = 1.0;
          double s = exp(-r*dt);
          DX = pow(K,(1-s))*pow(X,s);"
        ), delta.t=1
      ),
      paramnames=c("r","K"),
      statenames=c("X")
    ) -&gt; ofun

  ofun()


</code></pre>


</div>
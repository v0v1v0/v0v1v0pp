<div class="container">

<table style="width: 100%;"><tr>
<td>rankings</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rankings Object</h2>

<h3>Description</h3>

<p>Create a <code>"rankings"</code> object from data or convert a matrix of rankings
or ordered items to a <code>"rankings"</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rankings(data, id, item, rank, aggregate = FALSE, verbose = TRUE, ...)

as.rankings(x, ..., verbose = TRUE)

## Default S3 method:
as.rankings(
  x,
  input = c("rankings", "orderings"),
  freq = NULL,
  index = NULL,
  aggregate = FALSE,
  items = NULL,
  labels = NULL,
  ...,
  verbose = TRUE
)

## S3 method for class 'grouped_rankings'
as.rankings(x, ..., verbose = TRUE)

## S3 method for class 'matrix'
as.rankings(
  x,
  input = c("rankings", "orderings"),
  freq = NULL,
  index = NULL,
  aggregate = FALSE,
  items = NULL,
  labels = NULL,
  ...,
  verbose = TRUE
)

## S3 method for class 'rankings'
x[i, j, ..., drop = TRUE, as.rankings = TRUE]

## S3 method for class 'rankings'
format(x, width = 40L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame with columns specified by <code>id</code>, <code>item</code> and
<code>rank</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>an index of <code>data</code> specifying the column containing ranking
IDs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item</code></td>
<td>
<p>an index of <code>data</code> specifying the column containing item
IDs,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>an index of <code>data</code> specifying the column containing item
ranks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate</code></td>
<td>
<p>if <code>TRUE</code>, aggregate the rankings via
<code>aggregate()</code> before returning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; if <code>TRUE</code> print messages when changes are made
to rankings data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to/from methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>for <code>as.rankings</code>, a matrix with one column per item and one
row per ranking, or an object that can be coerced to such as matrix; for
<code>[</code> and <code>format</code>, a <code>"rankings"</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>for <code>as.rankings</code>, whether rows in the input matrix
contain numeric <code>"rankings"</code> (dense, standard/modified competition or
fractional rankings) or <code>"orderings"</code>, i.e. the items ordered by rank.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq</code></td>
<td>
<p>an optional column index (number, character or logical)
specifying a column of <code>x</code> that holds ranking frequencies, or a vector
of ranking frequencies. If provided, an <code>"aggregated_rankings"</code> object
will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>an optional column index (number, character or logical)
specifying a column of <code>x</code> that holds a grouping index, or a
numeric vector to for grouping. If provided, the rankings will be grouped by
<code>group()</code> before returning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>items</code></td>
<td>
<p>for <code>input = "orderings"</code>, a character vector specifying
the full set of items. Values in <code>x</code> are matched to this by value (if
character) or position (if numeric). Use <code>decode()</code> for orderings requiring
more complex decoding.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>for <code>input = "orderings"</code> an optional vector of labels for
the items, corresponding to the sorted unique values of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>indices specifying rankings to extract, as for <code>[</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>j</code></td>
<td>
<p>indices specifying items to extract, as for <code>[</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>if <code>TRUE</code> return single row/column matrices as a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.rankings</code></td>
<td>
<p>if <code>TRUE</code> return a rankings object, otherwise return
a matrix/vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>the width in number of characters to format each ranking -
rankings that are too wide will be truncated.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Each ranking in the input data will be converted to a dense ranking, which
rank items from 1 (first place) to <code class="reqn">n_r</code> (last place). Items not ranked
should have a rank of 0 or <code>NA</code>. Tied items are given the same rank with no
rank skipped. For example 1, 0, 2, 1, ranks the first and fourth items in
first place and the third item in second place; the second item is unranked.
</p>
<p>Records in <code>data</code> with missing <code>id</code> or <code>item</code> are dropped. Duplicated items
in the rankings are resolved if possible: redundant or inconsistent ranks
are set to <code>NA</code>. Rankings with only 1 item are set to <code>NA</code> (rankings with
zero items are automatically treated as <code>NA</code>). Any issues
causing records to be removed or recoded produce a message if
<code>verbose = TRUE</code>.
</p>
<p>For <code>as.rankings</code> with <code>input = "orderings"</code>, unused ranks may be filled with
zeroes for numeric <code>x</code> or <code>NA</code>. It is only necessary to have as many columns
as ranks that are used.
</p>
<p>The method for <code>[</code> will return a reduced rankings object by default,
recoding as dense rankings and setting invalid rankings to <code>NA</code> as necessary.
To extract rows and/or columns of the rankings as a matrix or vector,
set <code>as.rankings = FALSE</code>, see examples.
</p>


<h3>Value</h3>

<p>By default, a <code>"rankings"</code> object, which is a
matrix of dense rankings with methods for several generics including
<code>aggregate</code>, <code>[</code>, <code>format</code>, <code>rbind()</code> and
<code>as.matrix()</code>.
</p>
<p>If the object is created with <code>aggregate = TRUE</code>, or ranking frequencies are
specified via <code>freq</code>, the rankings are post-processed to create an
<code>"aggregated_rankings"</code> object.
</p>
<p>If a group index is specified via <code>index</code>, the (possibly aggregated) rankings
are post-processed to create a <code>"grouped_rankings"</code> object.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># create rankings from data in long form

# example long form data
x &lt;- data.frame(ranking = c(rep(1:4, each = 4), 5, 5, 5),
                letter = c(LETTERS[c(1:3, 3, 1:4, 2:5, 1:2, 1)], NA,
                           LETTERS[3:5]),
                rank = c(4:1, rep(NA, 4), 3:4, NA, NA, 1, 3, 4, 2, 2, 2, 3))

# ranking 1 has different rank for same item, but order of items unambiguous
# all ranks are missing in ranking 2
# some ranks are missing in ranking 3
# ranking 4 has inconsistent ranks for two items and a rank with missing item
# ranking 5 is fine - an example of a tie
split(x, x$ranking)

# fix issues when creating rankings object
rankings(x, id = "ranking", item = "letter", rank = "rank")

# convert existing matrix of rankings

R &lt;- matrix(c(1, 2, 0, 0,
              4, 1, 2, 3,
              2, 1, 1, 1,
              1, 2, 3, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) &lt;- c("apple", "banana", "orange", "pear")
R &lt;- as.rankings(R)

# first three rankings
R[1:3,]

# exclude pear from the rankings
R[, -4]

# extract rankings 2 and 3 as numeric matrix
R[2:3, , as.rankings = FALSE]

# same as
as.matrix(R)[2:3,]

# extract rankings for item 1 as a vector
R[,1, as.rankings = FALSE]

</code></pre>


</div>
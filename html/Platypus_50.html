<div class="container">

<table style="width: 100%;"><tr>
<td>VDJ_phylogenetic_trees</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Creates phylogenetic trees from a VDJ dataframe</h2>

<h3>Description</h3>

<p>Creates phylogenetic trees as tidytree dataframes from an input VDJ dataframe. The resulting phylogenetic trees can be plotted using VDJ_phylogenetic_trees_plot. Both of these functions require the tidytree and ggtree packages.
</p>


<h3>Usage</h3>

<pre><code class="language-R">VDJ_phylogenetic_trees(
  VDJ,
  sequence.type,
  as.nucleotide,
  trimmed,
  include.germline,
  global.clonotype,
  VDJ.VJ.1chain,
  additional.feature.columns,
  filter.na.columns,
  maximum.lineages,
  minimum.sequences,
  maximum.sequences,
  tree.algorithm,
  tree.level,
  n.trees.combined,
  germline.scale.factor,
  output.format,
  parallel
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>VDJ</code></td>
<td>
<p>VDJ or VDJ.GEX.matrix[[1]] object, as obtained from the VDJ_GEX_matrix function in Platypus.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sequence.type</code></td>
<td>
<p>string - sequences which will be used when creating the phylogenetic trees. 'cdr3' for CDR3s of both VDJs and VJs, 'cdrh3' for VDJ CDR3s, 'VDJ.VJ' for pasted full sequences of both VDJ and VJ, 'VDJ' for full VDJ sequences, 'VJ' for full VJ.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.nucleotide</code></td>
<td>
<p>boolean - if T, will only consider the DNA sequences specified by sequence.type, else it will consider the amino acid ones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trimmed</code></td>
<td>
<p>boolean - in the case of full VDJ or VJ nt sequences, if the trimmed sequences should be consider (trimmed=T), or raw ones. You need to call MIXCR first on the VDJ dataframe using VDJ_call_MIXCR().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.germline</code></td>
<td>
<p>boolean - if T, a germline sequence will be included in the trees (root), obtained by pasting the VDJ_trimmed_ref and VJ_trimmed_ref sequences. You need to call MIXCR first on the VDJ dataframe using VDJ_call_MIXCR().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>global.clonotype</code></td>
<td>
<p>boolean - if T, will ignore samples from the sample_id column, creating global clonotypes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VDJ.VJ.1chain</code></td>
<td>
<p>boolean - if T, will remove aberrant cells from the VDJ matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>additional.feature.columns</code></td>
<td>
<p>list of strings or NULL - VDJ column names which will comprise the per-sequence features to be included in the tidytree dataframe, which will be used to label nodes/ determines their color/ size etc. See also the VDJ_phylogenetic_trees_plot function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.na.columns</code></td>
<td>
<p>list of strings - VDJ columns names: if a phylogenetic tree/tidytree dataframe has all elements = NA in that feature, that tree will be completely removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maximum.lineages</code></td>
<td>
<p>integer or 'all' - maximum number of clonotypes to create trees for. If 'all', will create trees for all clonotypes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minimum.sequences</code></td>
<td>
<p>integer - lower bound of sequences for a tree. Defaults to 3. Trees with a lower number will be automatically removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maximum.sequences</code></td>
<td>
<p>integer - upper bound of sequences for a tree. Additional sequences will be removed, after being ordered by their total frequency.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree.algorithm</code></td>
<td>
<p>string - the algorithm used when constructing the phylogenetic trees. 'nj' for Neighbour-Joining, 'bionj', 'fastme.bal', and 'fastme.ols'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree.level</code></td>
<td>
<p>string - level at which to build phylogenetic trees. 'intraclonal' - tree per clonotype, per sample, 'global.clonotype' - global clonotype trees (include.germline must be F), irrespective of sample, 'combine.first.trees' will combine the trees for the most expanded clonotypes, per sample (include.germline must be F).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.trees.combined</code></td>
<td>
<p>integer - number of trees to combine if tree.level='combine.first.trees'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>germline.scale.factor</code></td>
<td>
<p>numeric - as germlines are incredibly distant from their closest neighbours (in the tree), this controls the scale factor for the germline tree branch length for more intelligible downstream plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output.format</code></td>
<td>
<p>string - 'tree.df.list' returns a nested list of tidytree dataframes, per clonotype and per sample; 'lineage.df.list' returns a list of lineage dataframes - unique sequences per clonotype,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>string - parallelization method to be used to accelerate computations, 'none', 'mclapply', or 'parlapply'.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Nested list of tidytree dataframes or lineage dataframes.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
try({
VDJ_phylogenetic_trees(VDJ=Platypus::small_vgm[[1]], sequence.type='VDJ.VJ',
trimmed=TRUE, as.nucleotide=TRUE, include.germline=TRUE,
additional.feature.columns=NULL, tree.level='intraclonal',
output.format='tree.df.list')
})

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>VDJ_abundances</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate abundances/counts of specific features for a VDJ dataframe</h2>

<h3>Description</h3>

<p>Calculate the absolute counts or proportions of a specific cell-level feature (column in the VDJ/VDJ.GEX.matrix[[1]] object), per an optional specific grouping factor (e.g., clonotype via 'clonotype_id') and an optional sample factor(e.g., 'sample_id'). Outputs either a count dataframe of the specific feature or a ggplot2 barplot.
</p>


<h3>Usage</h3>

<pre><code class="language-R">VDJ_abundances(
  VDJ,
  feature.columns,
  proportions,
  specific.features,
  grouping.column,
  max.groups,
  specific.groups,
  sample.column,
  VDJ.VJ.1chain,
  treat.incomplete.groups,
  treat.incomplete.features,
  combine.features,
  treat.combined.features,
  treat.combined.groups,
  specific.feature.colors,
  output.format
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>VDJ</code></td>
<td>
<p>VDJ or VDJ.GEX.matrix[[1]] object, as obtained from the VDJ_GEX_matrix function in Platypus.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>feature.columns</code></td>
<td>
<p>vector of strings, denoting the columns of the VDJ/VDJ.GEX.matrix[[1]] object from which to extract the unique feature values (for which we will calculate the counts or proportions).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proportions</code></td>
<td>
<p>string, 'absolute' will return the absolute counts, 'group.level.proportions' will return the counts divided by the total number or elements/values in the specific groups (group level proportions), 'sample.level.proportions' will return the counts divided by the total number of elements in the sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>specific.features</code></td>
<td>
<p>vector of specific feature values (or NULL) for which to calculate counts/proportions, from the specified feature.columns parameter (only works if a single feature column is specified in feature.columns).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grouping.column</code></td>
<td>
<p>string, vector of strings, or 'none' - represents the column from the VDJ/VDJ.GEX.matrix[[1]] object by which to group counting process. This is usually the 'clonotype_id' column to calculate frequencies at the clonotype level. If 'none', no grouping will be done. To group by multiple columns, input the specific columns as a vector of strings.
For example, if feature.columns='VDJ_cgene' and grouping.column='clonotype_id', we will obtain a count dataframe of the frequencies of each isotype per unique clonotype (per sample if sample.column='sample_id').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.groups</code></td>
<td>
<p>integer or NULL, the maximum number of groups for which to count features. If NULL, it will count for all groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>specific.groups</code></td>
<td>
<p>vector of strings (or 'none'), if the counting should be done only for specific groups (e.g., count the frequency of isotype only for clonotypes 1 and 2 if feature.columns='VDJ_cgene', grouping.column='clonotype_id' and specific.groups=c('clonotype1', 'clonotype2'))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.column</code></td>
<td>
<p>string, represents the sample column if your VDJ/VDJ.GEX.matrix[[1]] object has multiple samples (usually 'sample_id')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VDJ.VJ.1chain</code></td>
<td>
<p>boolean, if T will remove aberrant cells (more than 1 VDJ of VJ chain), if F it will keep them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treat.incomplete.groups</code></td>
<td>
<p>string, method of dealing with groups which are missing the features in the feature.columns parameter (e.g., a clonotype which does not have any transcriptomic clusters annotations if feature.columns='transcript_cluster').'exclude' - excludes groups with no cells for the specific features, 'unknown' - sets them as unknown</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treat.incomplete.features</code></td>
<td>
<p>string, method of dealing with missing feature values (e.g., a clonotype has several NA values for the 'VDJ_cgene' feature.column - cells with NA values). 'unknown' - counted as unknown, 'exclude' - excludes completely, 'max.global' - replaces value by max value of that feature across the repertoire, 'max.group' - replaced by the max feature value inside that group, 'proportional' - iteratively assigns the missing values to the known groups, keeping the same proportions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>combine.features</code></td>
<td>
<p>boolean - if T and we have two columns in feature.columns, will combine the feature values for each cell in the VDJ object, counting them as a single feature when calculating proportions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treat.combined.features</code></td>
<td>
<p>string, method of dealing with combined features with missing values. 'exclude' will be treated similarly to excluding incomplete feature values (excluding them completely if a single value is missing from the combination), or 'include' and will be treated as a new feature value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treat.combined.groups</code></td>
<td>
<p>string, method of dealing with combined groups with missing values, in case the grouping.column parameter is a vector of strings. 'exclude' will exclude the combined group altogether if a group value is missing/NA. 'include' will include such groups in the analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>specific.feature.colors</code></td>
<td>
<p>named list of specific colors to be used in the final barplots, for each unique feature value in the VDJ object's feature.columns values.
For example, if we have a feature column of binders with unique values=c('yes', 'no'), specific.feature.colors=list('yes'='blue', 'no'='red') will color them accordingly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output.format</code></td>
<td>
<p>string, either 'plots' to obtain barplots, 'abundance.df' to obtain the count dataframe, or 'abundance.df.list' to obtain a list of count dataframes, for each sample.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Either a count dataframe with the following columns: group(=unique group value, e.g., 'clonotype1' if grouping.column='clonotype_id'), sample, group_frequency, unique_feature_values, feature_value_counts, total_feature_names
or a barplot of the counts/proportions per feature, per group.
</p>


<h3>Examples</h3>

<pre><code class="language-R">VDJ_abundances(VDJ = Platypus::small_vgm[[1]],
feature.columns='VDJ_cgene', proportions='absolute',
grouping.column='clonotype_id', specific.groups='none',
output.format='plot')

</code></pre>


</div>
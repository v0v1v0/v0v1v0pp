<div class="container">

<table style="width: 100%;"><tr>
<td>leader</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Leader Algorithm for Data Partitioning</h2>

<h3>Description</h3>

<p>Partitions the data according to Hartigan's leader algorithm, and 
provides ranges, centroids, and variances for the partitions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">leader(data, radius = NULL, scale = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>A numeric vector or matrix of observations. If a matrix, rows
correspond to observations and columns correspond to variables. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>

<p>A vector of values for the partitioning radius. Wilkinson's default
radius is used if <code>radius</code> is left unspecified (see function 
<code>LWradius</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>

<p>A logical variable indicating whether or not the data should be mapped
to the unit hypercube. The default is to scale the data. Values of the
radius will not be scaled; they should be specifed relative to the unit 
hypercube unless <code>scale = F</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a partitioning radius <code>r</code>, the leader algorithm makes one pass 
through the data, designating an observation as a new leader if it is not 
within <code>r</code> of an existing leader, and otherwise assigning it to the
partition associated with the nearest existing leader. The set of leaders 
typically depends on the order of the data observations. <br>
If <code>radius = 0</code>, then all of the data observations are leaders, and
only <code>radius</code> and <code>leaders</code> are returned as output components. <br>
This implementation does a completely new nearest-neighbor search for
each observation and for each radius. A more efficient approach would be to 
maintain, for each radius, a data structure (such as a kd-tree) allowing 
fast nearest-neighbor search. These data structures could then be updated 
to account for new observations. Currently, there doesn't seem to be a way 
to do this in R.
</p>


<h3>Value</h3>

<p>A list with one component for each value of <code>radius</code>, each having the
following sub-components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>The value of the radius associated with the partitioning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partitions</code></td>
<td>

<p>A list with one component for each partition, giving the indexes (as
observations in the data) of the members of the partition. The first 
index is that of the associated <em>leader</em> (sometimes called 
<em>exemplar</em>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leaders</code></td>
<td>

<p>The indexes of the leaders for each partition.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centroids</code></td>
<td>

<p>The centroids for each partition, as a matrix with rows corresponding to
the partitions and columns corresponding to variables if multidimensional.
These will be the data if <code>radius == 0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variances</code></td>
<td>

<p>The variances for each partition, as a matrix with rows corresponding to
the partitions and columns corresponding to variables if multidimensional.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranges</code></td>
<td>

<p>A list with two components: <code>min</code> and <code>max</code> giving the
minimum and maximum values for each variable for each partition.
These <code>range</code> components are given as a matrix with rows 
corresponding to the partitions and columns corresponding to variables 
if multidimensional.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxdist</code></td>
<td>

<p>A vector with one value for each partition, giving the largest distance
from each leader to any member of its partition.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>J. A. Hartigan, <em>Clustering Algorithms</em>, Wiley, 1975.
</p>
<p>L. Wilkinson, Visualizing Outliers, Technical Report, University of
Illinois at Chicago, 2016.
<code>https://www.cs.uic.edu/~wilkinson/Publications/outliers.pdf</code>
</p>


<h3>See Also</h3>

<p><code>LWradius</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
 radius.default &lt;- LWradius(nrow(faithful),ncol(faithful))
 lead &lt;- leader(faithful, radius = c(0,radius.default))

# number of partitions for each radius
 sapply(lead, function(x) length(x$partitions))

# plot the leaders for the non-zero radius
 plot( faithful[,1], faithful[,2], 
       main = "blue indicates leaders (default radius)", 
       pch = 16, cex = .5)
 ldrs &lt;- lead[[2]]$leaders
 points( faithful[ldrs,1], faithful[ldrs,2], 
         pch = 8, col = "dodgerblue", cex = .5)

</code></pre>


</div>
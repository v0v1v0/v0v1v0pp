<div class="container">

<table style="width: 100%;"><tr>
<td>despike</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Remove spikes from spectrum</h2>

<h3>Description</h3>

<p>Function that returns an R object with observations corresponding to spikes
replaced by values computed from neighboring pixels. Spikes are values in
spectra that are unusually high compared to neighbors. They are usually
individual values or very short runs of similar "unusual" values. Spikes
caused by cosmic radiation are a frequent problem in Raman spectra. Another
source of spikes are "hot pixels" in CCD and diode array detectors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">despike(x, z.threshold, max.spike.width, window.width, method, na.rm, ...)

## Default S3 method:
despike(
  x,
  z.threshold = NA,
  max.spike.width = NA,
  window.width = NA,
  method = "run.mean",
  na.rm = FALSE,
  ...
)

## S3 method for class 'numeric'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...
)

## S3 method for class 'data.frame'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...,
  y.var.name = NULL,
  var.name = y.var.name
)

## S3 method for class 'generic_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  y.var.name = NULL,
  var.name = y.var.name,
  ...
)

## S3 method for class 'source_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'response_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'filter_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  filter.qty = getOption("photobiology.filter.qty", default = "transmittance"),
  ...
)

## S3 method for class 'reflector_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...
)

## S3 method for class 'solute_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...
)

## S3 method for class 'cps_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...
)

## S3 method for class 'raw_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...
)

## S3 method for class 'generic_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...,
  y.var.name = NULL,
  var.name = y.var.name,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'source_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'response_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'filter_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  filter.qty = getOption("photobiology.filter.qty", default = "transmittance"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'reflector_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'solute_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'cps_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'raw_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an R object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.threshold</code></td>
<td>
<p>numeric Modified Z values larger than <code>z.threshold</code>
are considered to correspond to spikes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.spike.width</code></td>
<td>
<p>integer Wider regions with high Z values are not detected as
spikes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window.width</code></td>
<td>
<p>integer. The full width of the window used for the
running mean used as replacement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character The name of the method: <code>"run.mean"</code> is running
mean as described in Whitaker and Hayes (2018); <code>"adj.mean"</code> is mean
of adjacent neighbors (isolated bad pixels only).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be treated
as spikes and replaced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed by name to <code>find_spikes()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.name, y.var.name</code></td>
<td>
<p>character Names of columns where to look
for spikes to remove.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit.out</code></td>
<td>
<p>character One of "energy" or "photon"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.qty</code></td>
<td>
<p>character One of "transmittance" or "absorbance"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Spikes are detected based on a modified Z score calculated from the
differenced spectrum. The Z threshold used should be adjusted to the
characteristics of the input and desired sensitivity. The lower the
threshold the more stringent the test becomes, resulting in most cases in
more spikes being detected. A modified version of the algorithm is used if
a value different from <code>NULL</code> is passed as argument to
<code>max.spike.width</code>. In such a case, an additional step filters out
broader spikes (or falsely detected steep slopes) from the returned values.
</p>
<p>Simple interpolation replaces values of isolated bad pixels by the mean of
their two closest neighbors. The running mean approach allows the
replacement of short runs of bad pixels by the running mean of neighboring
pixels within a window of user-specified width. The first approach works
well for spectra from array spectrometers to correct for hot and dead
pixels in an instrument. The second approach is most suitable for Raman
spectra in which spikes triggered by radiation are wider than a single
pixel but usually not more than five pixels wide.
</p>
<p>When the argument passed to <code>x</code> contains multiple spectra, the spikes
are searched for and replaced in each spectrum independently of other
spectra.
</p>


<h3>Value</h3>

<p>A copy of the object passed as argument to <code>x</code> with values
detected as spikes replaced by a local average of adjacent neighbors
outside the spike.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>despike(default)</code>: Default returning always NA.
</p>
</li>
<li> <p><code>despike(numeric)</code>: Default function usable on numeric vectors.
</p>
</li>
<li> <p><code>despike(data.frame)</code>: Method for "data.frame" objects.
</p>
</li>
<li> <p><code>despike(generic_spct)</code>: Method for "generic_spct" objects.
</p>
</li>
<li> <p><code>despike(source_spct)</code>: Method for "source_spct" objects.
</p>
</li>
<li> <p><code>despike(response_spct)</code>: Method for "response_spct" objects.
</p>
</li>
<li> <p><code>despike(filter_spct)</code>: Method for "filter_spct" objects.
</p>
</li>
<li> <p><code>despike(reflector_spct)</code>: Method for "reflector_spct" objects.
</p>
</li>
<li> <p><code>despike(solute_spct)</code>: Method for "solute_spct" objects.
</p>
</li>
<li> <p><code>despike(cps_spct)</code>: Method for "cps_spct" objects.
</p>
</li>
<li> <p><code>despike(raw_spct)</code>: Method for "raw_spct" objects.
</p>
</li>
<li> <p><code>despike(generic_mspct)</code>: Method for "generic_mspct" objects.
</p>
</li>
<li> <p><code>despike(source_mspct)</code>: Method for "source_mspct" objects.
</p>
</li>
<li> <p><code>despike(response_mspct)</code>: Method for "cps_mspct" objects.
</p>
</li>
<li> <p><code>despike(filter_mspct)</code>: Method for "filter_mspct" objects.
</p>
</li>
<li> <p><code>despike(reflector_mspct)</code>: Method for "reflector_mspct" objects.
</p>
</li>
<li> <p><code>despike(solute_mspct)</code>: Method for "solute_mspct" objects.
</p>
</li>
<li> <p><code>despike(cps_mspct)</code>: Method for "cps_mspct" objects.
</p>
</li>
<li> <p><code>despike(raw_mspct)</code>: Method for "raw_mspct" objects.
</p>
</li>
</ul>
<h3>Note</h3>

<p>Current algorithm misidentifies steep smooth slopes as spikes, so
manual inspection is needed together with adjustment by trial and error
of a suitable argument value for <code>z.threshold</code>.
</p>


<h3>See Also</h3>

<p>See the documentation for <code>find_spikes</code> and
<code>replace_bad_pixs</code> for details of the algorithm and
implementation.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
white_led.raw_spct[120:125, ]

# find and replace spike at 245.93 nm
despike(white_led.raw_spct,
        z.threshold = 10,
        window.width = 25)[120:125, ]

</code></pre>


</div>
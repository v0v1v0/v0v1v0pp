<div class="container">

<table style="width: 100%;"><tr>
<td>rvar_apply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Random variable resulting from a function applied over margins of an array or random variable</h2>

<h3>Description</h3>

<p>Returns an <code>rvar</code> obtained by applying a function to margins of an array or <code>rvar</code>.
Acts like <code>apply()</code>, except that the function supplied (<code>.f</code>) should return an <code>rvar</code>,
and the final result is always an <code>rvar</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rvar_apply(.x, .margin, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.x</code></td>
<td>
<p>An array or an <code>rvar</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.margin</code></td>
<td>
<p>(multiple options) The subscripts which the function will be applied over:
</p>

<ul>
<li>
<p> An integer vector. E.g., for a matrix <code>1</code> indicates rows, <code>2</code> indicates
columns, <code>c(1, 2)</code> indicates rows and columns.
</p>
</li>
<li>
<p> A character vector of dimension names if <code>.x</code> has named dimensions.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.f</code></td>
<td>
<p>(function) The function to be applied. The function <code>.f</code> must
return an <code>rvar</code> and the dimensions of the result of <code>.f</code> applied to each
margin of <code>.x</code> must be able to be broadcasted to a common shape (otherwise
the resulting <code>rvar</code> cannot be simplified). See <strong>Details</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments passed to <code>.f</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function acts much like <code>apply()</code>, except that the function passed to it (<code>.f</code>)
must return <code>rvar</code>s, and the result is simplified into an <code>rvar</code>. Unlike
<code>apply()</code>, it also keeps the dimensions of the returned values along each margin,
rather than simplifying each margin to a vector, and if the results of <code>.f</code> do
not all have the same dimensions, it applies the <code>rvar</code> broadcasting rules to
bind results together rather than using vector recycling.
</p>
<p>If you wish to apply functions over <code>rvar</code>s where the result is not intended to
be simplified into an <code>rvar</code>, you can use the standard <code>apply()</code>, <code>lapply()</code>,
<code>sapply()</code>, or <code>vapply()</code> functions.
</p>


<h3>Value</h3>

<p>An <code>rvar</code>.
</p>
<p>If the result of each call to <code>.f</code> returns an <code>rvar</code> of dimension <code>d</code> after
being broadcast to a common shape, then <code>rvar_apply()</code> returns an <code>rvar</code> of
dimension <code>c(d, dim(.x)[.margin])</code>. If the last dimension of the result would
be <code>1</code>, it is dropped (other dimensions equal to <code>1</code> are retained). If <code>d</code> is
<code>0</code>, the result has length <code>0</code> but not necessarily the 'correct' dimension.
</p>


<h3>See Also</h3>

<p><code>as_rvar()</code> to convert objects to <code>rvar</code>s. See <code>rdo()</code>, <code>rfun()</code>, and
<code>rvar_rng()</code> for higher-level interfaces for creating <code>rvar</code>s.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(3456)
x &lt;- rvar_rng(rnorm, 24, mean = 1:24)
dim(x) &lt;- c(2,3,4)

# we can find the distributions of marginal means of the above array
# using rvar_mean along with rvar_apply
rvar_apply(x, 1, rvar_mean)
rvar_apply(x, 2:3, rvar_mean)

</code></pre>


</div>
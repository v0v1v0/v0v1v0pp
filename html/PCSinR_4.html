<div class="container">

<table style="width: 100%;"><tr>
<td>PCS_run</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate the run of a PCS model</h2>

<h3>Description</h3>

<p><code>PCS_run</code> simulates a PCS network given a pre-specified interconnection
matrix and model parameters, according to the mechanism outlines by
McClelland and Rumelhart (1981).
</p>


<h3>Usage</h3>

<pre><code class="language-R">PCS_run(interconnection_matrix, initial_state, resting_levels, reset,
  node_names = NULL, stability_criterion = 10^-6, max_iterations = Inf,
  convergence_criteria = c(PCS_convergence_McCandR),
  convergence_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>interconnection_matrix</code></td>
<td>
<p>A square, matrix representing the link weights
between nodes, such that each entry w_ij represents the link strength
between nodes i and j. Accordingly, for a network of n nodes, the matrix
must be of six n*n. In most applications, the matrix will be symmetric,
meaning that links are bidirectional.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_state</code></td>
<td>
<p>Initial node activations before the first iteration is
run. In most cases, this will be a vector of zeros, with the length
corresponding to the number of nodes in the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resting_levels</code></td>
<td>
<p>Resting activation level for each node. In most cases,
this will be a vector of zeros, with its length corresponding to the number
of nodes in the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reset</code></td>
<td>
<p>Vector denoting nodes with stable activation values. The vector
contains a value for each node; if it is unequal to zero, the node
activation will be reset to this value after each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node_names</code></td>
<td>
<p>Vector specifying human-readable labels for every node, or
<code>'default'</code>, in which case nodes are automatically named.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stability_criterion</code></td>
<td>
<p>Stability theshold for convergence criteria. If
energy changes across iterations fall below this threshold, the model is
considered to have converged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iterations</code></td>
<td>
<p>Maximum number of iterations to run before terminating
the simulation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence_criteria</code></td>
<td>
<p>Array of convergence criteria to apply. This PCS
implementation allows users to define and observe multiple convergence
criteria in one model. Each entry in this array is a convergence criterion,
which is representated as a function that receives the current iteration,
energy, model state history and the <code>stability_criterion</code> defined
above and returns a boolean value representing whether the particular
criterion is met given the model's current state.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence_names</code></td>
<td>
<p>Human-readable labels for the convergence criteria,
or <code>'default'</code>, in which case the criteria are numbered automatically,
in which case the criteria are numbered automatically.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list representing the model state after all convergence criteria
have been fullfilled. The key <code>iterations</code> contains the model state
over its entire run, while the key <code>convergence</code> defines which
convergence criteria have been met at which iteration. Together, these
provide an exhaustive summary of the model's behavior.
</p>


</div>
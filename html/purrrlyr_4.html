<div class="container">

<table style="width: 100%;"><tr>
<td>dmap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Map over the columns of a data frame</h2>

<h3>Description</h3>

<p><code>dmap()</code> is just like <code>purrr::map()</code> but always returns a
data frame. In addition, it handles grouped or sliced data frames.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dmap(.d, .f, ...)

dmap_at(.d, .at, .f, ...)

dmap_if(.d, .p, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.d</code></td>
<td>
<p>A data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li>
<p> For a single argument function, use <code>.</code>
</p>
</li>
<li>
<p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li>
<p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li>
</ul>
<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.at</code></td>
<td>
<p>A character vector of names, positive numeric vector of
positions to include, or a negative numeric vector of positions to
exlude. Only those elements corresponding to <code>.at</code> will be modified.
If the <code>tidyselect</code> package is installed, you can use <code>vars()</code> and
the <code>tidyselect</code> helpers to select elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.p</code></td>
<td>
<p>A single predicate function, a formula describing such a
predicate function, or a logical vector of the same length as <code>.x</code>.
Alternatively, if the elements of <code>.x</code> are themselves lists of
objects, a string indicating the name of a logical element in the
inner lists. Only those elements where <code>.p</code> evaluates to
<code>TRUE</code> will be modified.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>dmap_at()</code> and <code>dmap_if()</code> recycle length 1 vectors to
the group sizes.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># dmap() always returns a data frame:
dmap(mtcars, summary)

# dmap() also supports sliced data frames:
sliced_df &lt;- mtcars[1:5] %&gt;% slice_rows("cyl")
sliced_df %&gt;% dmap(mean)
sliced_df %&gt;% dmap(~ .x / max(.x))

# This is equivalent to the combination of by_slice() and dmap()
# with 'rows' collation of results:
sliced_df %&gt;% by_slice(dmap, mean, .collate = "rows")
</code></pre>


</div>
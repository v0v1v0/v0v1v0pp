<div class="container">

<table style="width: 100%;"><tr>
<td>parse_installed</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>List metadata of installed packages</h2>

<h3>Description</h3>

<p>This function is similar to <code>utils::installed.packages()</code>.
See the differences below.
</p>


<h3>Usage</h3>

<pre><code class="language-R">parse_installed(
  library = .libPaths(),
  priority = NULL,
  lowercase = FALSE,
  reencode = TRUE,
  packages = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>library</code></td>
<td>
<p>Character vector of library paths.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priority</code></td>
<td>
<p>If not <code>NULL</code> then it may be a <code>"base"</code> <code>"recommended"</code>
<code>NA</code> or a vector of these to select <em>base</em> packages, <em>recommended</em>
packages or <em>other</em> packages. (These are the official, CRAN supported
package priorities, but you may introduce others in non-CRAN packages.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lowercase</code></td>
<td>
<p>Whether to convert keys in <code>DESCRIPTION</code> to lowercase.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reencode</code></td>
<td>
<p>Whether to re-encode strings in UTF-8, from the
encodings specified in the <code>DESCRIPTION</code> files. Re-encoding is
somewhat costly, and sometimes it is not important (e.g. when you only
want to extract the dependencies of the installed packages).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>packages</code></td>
<td>
<p>If not <code>NULL</code>, then it must be a character vector,
and only these packages will be listed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Differences with <code>utils::installed.packages()</code>:
</p>

<ul>
<li> <p><code>parse_installed()</code> cannot subset the extracted fields. (But you can
subset the result.)
</p>
</li>
<li> <p><code>parse_installed()</code> does not cache the results.
</p>
</li>
<li> <p><code>parse_installed()</code> handles errors better. See Section 'Errors' below.
#' * <code>parse_installed()</code> uses the <code>DESCRIPTION</code> files in the installed packages
instead of the <code>Meta/package.rds</code> files. This should not matter,
but because of a bug <code>Meta/package.rds</code> might contain the wrong
<code>Archs</code> field on multi-arch platforms.
</p>
</li>
<li> <p><code>parse_installed()</code> reads <em>all</em> fields from the <code>DESCRIPTION</code> files.
<code>utils::installed.packages()</code> only reads the specified fields.
</p>
</li>
<li> <p><code>parse_installed()</code> converts its output to UTF-8 encoding, from the
encodings declared in the <code>DESCRIPTION</code> files.
</p>
</li>
<li> <p><code>parse_installed()</code> is considerably faster.
</p>
</li>
</ul>
<h4>Encodings</h4>

<p><code>parse_installed()</code> always returns its result in UTF-8 encoding.
It uses the <code>Encoding</code> fields in the <code>DESCRIPTION</code> files to learn their
encodings. <code>parse_installed()</code> does not check that an UTF-8 file has a
valid encoding. If it fails to convert a string to UTF-8 from another
declared encoding, then it leaves it as <code>"bytes"</code> encoded, without a
warning.
</p>



<h4>Errors</h4>

<p>pkgcache silently ignores files and directories inside the library
directory.
</p>
<p>The result also omits broken package installations. These include
</p>

<ul>
<li>
<p> packages with invalid <code>DESCRIPTION</code> files, and
</p>
</li>
<li>
<p> packages the current user have no access to.
</p>
</li>
</ul>
<p>These errors are reported via a condition with class
<code>pkgcache_broken_install</code>. The condition has an <code>errors</code> entry, which
is a data frame with columns
</p>

<ul>
<li> <p><code>file</code>: path to the <code>DESCRIPTION</code> file of the broken package,
</p>
</li>
<li> <p><code>error</code>: error message for this particular failure.
</p>
</li>
</ul>
<p>If you intend to handle broken package installation, you need to catch
this condition with <code>withCallingHandlers()</code>.
</p>



</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>polyCub.midpoint</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Two-Dimensional Midpoint Rule</h2>

<h3>Description</h3>

<p>The surface is converted to a binary pixel image
using the <code>as.im.function</code> method from package
<a href="https://CRAN.R-project.org/package=spatstat.geom"><span class="pkg">spatstat.geom</span></a> (Baddeley et al., 2015).
The integral under the surface is then approximated as the
sum over (pixel area * f(pixel midpoint)).
</p>


<h3>Usage</h3>

<pre><code class="language-R">polyCub.midpoint(polyregion, f, ..., eps = NULL, dimyx = NULL,
  plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>polyregion</code></td>
<td>
<p>a polygonal integration domain.
It can be any object coercible to the <span class="pkg">spatstat.geom</span> class
<code>"owin"</code> via a corresponding
<code>as.owin</code>-method.
Note that this includes polygons of the classes <code>"gpc.poly"</code> and
<code>"SpatialPolygons"</code>, because <span class="pkg">polyCub</span> defines
methods <code>as.owin.gpc.poly</code> and
<code>as.owin.SpatialPolygons</code>, respectively.
<span class="pkg">sf</span> also registers suitable <code>as.owin</code> methods for its
<code>"(MULTI)POLYGON"</code> classes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>a two-dimensional real-valued function.
As its first argument it must take a coordinate matrix, i.e., a
numeric matrix with two columns, and it must return a numeric vector of
length the number of coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments for <code>f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>width and height of the pixels (squares),
see <code>as.mask</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimyx</code></td>
<td>
<p>number of subdivisions in each dimension,
see <code>as.mask</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>logical indicating if an illustrative plot of the numerical
integration should be produced.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The approximated value of the integral of <code>f</code> over
<code>polyregion</code>.
</p>


<h3>References</h3>

<p>Baddeley A, Rubak E, Turner R (2015).
<em>Spatial Point Patterns: Methodology and Applications with R</em>.
Chapman and Hall/CRC Press, London.
</p>


<h3>See Also</h3>

<p>Other polyCub-methods: 
<code>polyCub()</code>,
<code>polyCub.SV()</code>,
<code>polyCub.exact.Gauss()</code>,
<code>polyCub.iso()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## a function to integrate (here: isotropic zero-mean Gaussian density)
f &lt;- function (s, sigma = 5)
    exp(-rowSums(s^2)/2/sigma^2) / (2*pi*sigma^2)

## a simple polygon as integration domain
hexagon &lt;- list(
    list(x = c(7.33, 7.33, 3, -1.33, -1.33, 3),
         y = c(-0.5, 4.5, 7, 4.5, -0.5, -3))
)

if (require("spatstat.geom")) {
    hexagon.owin &lt;- owin(poly = hexagon)

    show_midpoint &lt;- function (eps)
    {
        plotpolyf(hexagon.owin, f, xlim = c(-8,8), ylim = c(-8,8),
                  use.lattice = FALSE)
        ## add evaluation points to plot
        with(as.mask(hexagon.owin, eps = eps),
             points(expand.grid(xcol, yrow), col = t(m), pch = 20))
        title(main = paste("2D midpoint rule with eps =", eps))
    }

    ## show nodes (eps = 0.5)
    show_midpoint(0.5)

    ## show pixel image (eps = 0.5)
    polyCub.midpoint(hexagon.owin, f, eps = 0.5, plot = TRUE)

    ## use a decreasing pixel size (increasing number of nodes)
    for (eps in c(5, 3, 1, 0.5, 0.3, 0.1))
        cat(sprintf("eps = %.1f: %.7f\n", eps,
                    polyCub.midpoint(hexagon.owin, f, eps = eps)))
}
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>mutate_joins</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mutating Joins</h2>

<h3>Description</h3>

<p>The mutating joins add columns from <code>y</code> to <code>x</code>, matching rows based on the keys:
</p>

<ul>
<li> <p><code>inner_join()</code>: includes all rows in <code>x</code> and <code>y</code>.
</p>
</li>
<li> <p><code>left_join()</code>: includes all rows in <code>x</code>.
</p>
</li>
<li> <p><code>right_join()</code>: includes all rows in <code>y</code>.
</p>
</li>
<li> <p><code>full_join()</code>: includes all rows in <code>x</code> or <code>y</code>.
</p>
</li>
</ul>
<p>If a row in <code>x</code> matches multiple rows in <code>y</code>, all the rows in <code>y</code> will be returned once for each matching row in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">inner_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  ...,
  na_matches = c("na", "never")
)

left_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)

right_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)

full_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>The <code>data.frame</code>s to join.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>A character vector of variables to join by. If <code>NULL</code>, the default, <code style="white-space: pre;">⁠*_join()⁠</code> will do a natural join,
using all variables with common names across the two tables. A message lists the variables so that you can check
they're right (to suppress the message, simply explicitly list the variables that you want to join).
</p>
<p>To join by different variables on x and y use a named vector. For example, <code>by = c("a" = "b")</code> will match <code>x.a</code> to
<code>y.b</code>.
</p>
<p>To join by multiple variables, use a vector with length &gt; 1. For example, <code>by = c("a", "b")</code> will match <code>x$a</code> to
<code>y$a</code> and <code>x$b</code> to <code>y$b</code>. Use a named vector to match different variables in <code>x</code> and <code>y</code>. For example,
<code>by = c("a" = "b", "c" = "d")</code> will match <code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, use <code>by = character()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p><code>character(2)</code>. If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be
added to the output to disambiguate them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to <code>merge()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_matches</code></td>
<td>
<p>Should <code>NA</code> and <code>NaN</code> values match one another?
</p>
<p>The default, <code>"na"</code>, treats two <code>NA</code> or <code>NaN</code> values as equal, like <code>%in%</code>, <code>match()</code>, <code>merge()</code>.
</p>
<p>Use <code>"never"</code> to always treat two <code>NA</code> or <code>NaN</code> values as different, like joins for database sources, similarly to
<code>merge(incomparables = FALSE)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p><code>logical(1)</code>. Should the join keys from both <code>x</code> and <code>y</code> be preserved in the output? Only applies to
<code>left_join()</code>, <code>right_join()</code>, and <code>full_join()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>data.frame</code>. The order of the rows and columns of <code>x</code> is preserved as much as possible. The output has the
following properties:
</p>

<ul>
<li>
<p> For <code>inner_join()</code>, a subset of <code>x</code> rows.
For <code>left_join()</code>, all <code>x</code> rows.
For <code>right_join()</code>, a subset of <code>x</code> rows, followed by unmatched <code>y</code> rows.
For <code>full_join()</code>, all <code>x</code> rows, followed by unmatched <code>y</code> rows.
</p>
</li>
<li>
<p> For all joins, rows will be duplicated if one or more rows in <code>x</code> matches multiple rows in <code>y</code>.
</p>
</li>
<li>
<p> Output columns include all <code>x</code> columns and all <code>y</code> columns. If columns in <code>x</code> and <code>y</code> have the same name (and
aren't included in <code>by</code>), <code>suffix</code>es are added to disambiguate.
</p>
</li>
<li>
<p> Output columns included in <code>by</code> are coerced to common type across <code>x</code> and <code>y</code>.
</p>
</li>
<li>
<p> Groups are taken from <code>x</code>.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># If a row in `x` matches multiple rows in `y`, all the rows in `y` will be
# returned once for each matching row in `x`
df1 &lt;- data.frame(x = 1:3)
df2 &lt;- data.frame(x = c(1, 1, 2), y = c("first", "second", "third"))
df1 %&gt;% left_join(df2)

# By default, NAs match other NAs so that there are two
# rows in the output of this join:
df1 &lt;- data.frame(x = c(1, NA), y = 2)
df2 &lt;- data.frame(x = c(1, NA), z = 3)
left_join(df1, df2)

# You can optionally request that NAs don't match, giving a
# a result that more closely resembles SQL joins
left_join(df1, df2, na_matches = "never")

</code></pre>


</div>
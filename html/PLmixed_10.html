<div class="container">

<table style="width: 100%;"><tr>
<td>PLmixed</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit GLMM with Factor Structure</h2>

<h3>Description</h3>

<p>Fit a (generalized) linear mixed effects model (GLMM) with factor structures. Utilizes both the
<span class="pkg">lme4</span> package and <code>optim</code> function for estimation using a profile-likelihood based
approach.
</p>


<h3>Usage</h3>

<pre><code class="language-R">PLmixed(
  formula,
  data,
  family = gaussian,
  load.var = NULL,
  lambda = NULL,
  factor = NULL,
  init = 1,
  nlp = NULL,
  init.nlp = 1,
  nAGQ = 1,
  method = "L-BFGS-B",
  lower = -Inf,
  upper = Inf,
  lme4.optimizer = "bobyqa",
  lme4.start = NULL,
  lme4.optCtrl = list(),
  opt.control = NULL,
  REML = FALSE,
  SE = 1,
  ND.method = "simple",
  check = "stop",
  est = TRUE,
  iter.count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula following that of <span class="pkg">lme4</span>, with the addition that factors can be specified
as random effects. Factor names should not be names of variables in the data set, and are instead
defined with the <code>factor</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame containing the variables used in the model (but not factor names).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A GLM family, see <code>glm</code> and <code>family</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>load.var</code></td>
<td>
<p>A variable in the dataframe identifying what the factors load onto. Each unique element in <code>load.var</code> will have
a unique factor loading. All rows in the dataset with the same value for <code>load.var</code> will have the same factor loading.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A matrix or list of matrices corresponding to the loading matrices. A value of NA
indicates the loading is freely estimated, while a numeric entry indicates a constraint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor</code></td>
<td>
<p>A list of factors corresponding to the loading matrices and factors specified in model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>A scalar (default = <code>1</code>) or vector of initial lambda values. If a scalar, the value is applied to all lambda parameters.
If a vector, the values apply in row by column by matrix order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlp</code></td>
<td>
<p>A character vector containing the names of additional nonlinear parameters that are in the model formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.nlp</code></td>
<td>
<p>A scalar (default = <code>1</code>) or vector of initial nlp values. If a scalar, the value is applied to all nlp parameters.
If a vector, the values apply in the order listed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nAGQ</code></td>
<td>
<p>If family is non-gaussian, the number of points per axis for evaluating the adaptive
Gauss-Hermite approximation to the log-likelihood. Defaults to <code>1</code>, corresponding to the Laplace approximation.
See <code>glmer</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The <code>optimx</code> optimization method. Defaults to <code>L-BFGS-B</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>Lower bound on lambda parameters if applicable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>Upper bound on lambda parameters if applicable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lme4.optimizer</code></td>
<td>
<p>The <span class="pkg">lme4</span> optimization method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lme4.start</code></td>
<td>
<p>Start values used for <span class="pkg">lme4</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lme4.optCtrl</code></td>
<td>
<p>A list controlling the lme4 optimization. See <code>lmerControl</code>
or <code>glmerControl</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.control</code></td>
<td>
<p>Controls for the <code>optimx</code> optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>REML</code></td>
<td>
<p>Use REML if model is linear? Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SE</code></td>
<td>
<p>Method of calculating standard errors for fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ND.method</code></td>
<td>
<p>Method of calculating numerical derivatives.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>Check number of observations vs. levels and number of observations vd. random effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est</code></td>
<td>
<p>Return parameter estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.count</code></td>
<td>
<p>Print the iteration counter during optimization.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Factors are listed within the <code>formula</code> in the same way that random effects are specified
in <span class="pkg">lme4</span>. The grouping variable listed after <code>|</code> defines what the factor values randomly
vary over, just as <code>|</code> does for other random effects. The names of factors and other random
effect terms can be listed within the same set of parentheses, allowing the covariance between the
factor(s) and random effect(s) to be estimated. The same factor may be specified for multiple grouping
variables, allowing for multilevel or crossed effects.
</p>
<p>The <code>factor</code> argument must list any factor that appears in the <code>formula</code>. The ordering will
depend on the ordering of the matrices listed within <code>lambda</code>. The matrices in <code>lambda</code>
specify the factor loading matrices. The number of matrices in <code>lambda</code> should equal the number
of character vectors in <code>factor</code> and the number of elements in <code>load.var</code>. The number of
rows in the <em>k</em>th matrix listed in <code>lambda</code> should correspond to the number of unique elements
in the dataset for the <em>k</em>th variable listed in <code>load.var</code>, and the number of columns in the <em>k</em>th
matrix should correspond to the number of factors listed in the <em>k</em>th character vector of <code>factor</code>.
</p>
<p>Within the <em>k</em>th matrix, the <em>(i, j)</em> cell corresponds to the factor loading for the <em>i</em>th unique element
of the <em>k</em>th variable listed in <code>load.var</code> on the <em>j</em>th factor listed in the <em>k</em>th character vector
of <code>factor</code>. Each element of the matrix should be either a number or <code>NA</code>. If the element is a
number, the loading will be constrained to that value. If the element is an <code>NA</code>, the loading will
be freely estimated. For identification, it is necessary (but not sufficient) for at least one element in
each column to be constrained.
</p>
<p>The <code>nlp</code> argument can be viewed as a special case of the <code>factor</code> argument, where the character vector
listed in <code>nlp</code> is automatically linked to 1 x p lambda matrix, where p is the number of elements in <code>nlp</code>.
The <code>load.var</code> for these parameters is viewed as a constant, so that the <code>nlp</code> parameters are equivalent for
all rows in the dataset. Thus, <code>nlp</code> simplifies the process of adding additional nonlinear parameters to the model
without having to specify corresponding <code>lambda</code> and <code>load.var</code> values.
</p>


<h3>Value</h3>

<p>An object of class <code>PLmod</code>, which contains an object of class <code>merMod</code> as one of its elements.
Some functions for class <code>merMod</code> have been adapted to work with class <code>PLmod</code>. Others can be utilized
using <code>object$'lme4 Model'</code>, where <code>object</code> is an object of class <code>PLmod</code>.
</p>


<h3>References</h3>

<p>Rockwood, N. J., &amp; Jeon, M. (2019). Estimating complex measurement and growth models
using the R package PLmixed.<em>Multivariate Behavioral Research, 54</em>(2), 288-306.
</p>
<p>Jeon, M., &amp; Rabe-Hesketh, S. (2012). Profile-likelihood approach for estimating
generalized linear mixed models with factor structures. <em>Journal of Educational
and Behavioral Statistics, 37</em>(4), 518-542.
</p>


<h3>See Also</h3>

<p><span class="pkg">lme4</span>
</p>
<p><code>glmer</code>
</p>
<p><code>lmer</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("IRTsim") # Load the IRTsim data

IRTsub &lt;- IRTsim[IRTsim$item &lt; 4, ] # Select items 1-3
set.seed(12345)
IRTsub &lt;- IRTsub[sample(nrow(IRTsub), 300), ] # Randomly sample 300 responses

IRTsub &lt;- IRTsub[order(IRTsub$item), ] # Order by item
irt.lam = c(1, NA, NA) # Specify the lambda matrix

# Below, the # in front of family = binomial can be removed to change the response distribution
# to binomial, where the default link function is logit.

irt.model &lt;- PLmixed(y ~ 0 + as.factor(item) + (0 + abil.sid |sid) +(0 + abil.sid |school),
                     data = IRTsub, load.var = c("item"), # family = binomial,
                     factor = list(c("abil.sid")), lambda = list(irt.lam))
summary(irt.model)

## Not run: 
# A more time-consuming example.
# ~ 5-10 minutes

data("KYPSsim") # Load the KYPSsim data

kyps.lam &lt;- rbind(c( 1,  0),  # Specify the lambda matrix
                  c(NA,  0),
                  c(NA,  1),
                  c(NA, NA))

kyps.model &lt;- PLmixed(esteem ~ as.factor(time) +  (0 + hs | hid)
                      + (0 + ms | mid) + (1 | sid), data = KYPSsim,
                      factor = list(c("ms", "hs")), load.var = c("time"),
                      lambda = list(kyps.lam))
summary(kyps.model)

data("JUDGEsim")
JUDGEsim &lt;- JUDGEsim[order(JUDGEsim$item), ] # Order by item
unique(JUDGEsim$item)

# Specify Lambda matrix
judge.lam &lt;- rbind(c( 1,  0,  1,  0,  0,  0),
                   c(NA,  0, NA,  0,  0,  0),
                   c(NA,  0, NA,  0,  0,  0),
                   c( 0,  1,  0,  1,  0,  0),
                   c( 0, NA,  0, NA,  0,  0),
                   c( 0, NA,  0, NA,  0,  0),
                   c( 0,  0,  0,  0,  1,  0),
                   c( 0,  0,  0,  0, NA,  0),
                   c( 0,  0,  0,  0, NA,  0),
                   c( 0,  0,  0,  0,  0,  1),
                   c( 0,  0,  0,  0,  0, NA),
                   c( 0,  0,  0,  0,  0, NA))

# Conduct analysis
judge.example &lt;- PLmixed(response ~ 0 + as.factor(item) + (1 | class)
                         + (0 + trait1.t + trait2.t + trait1.s + trait2.s | stu)
                         + (0 + teacher1 + teacher2 | tch), data = JUDGEsim,
                         lambda = list(judge.lam), load.var = "item",
                         factor = list(c("teacher1", "teacher2", "trait1.t",
                                         "trait2.t", "trait1.s", "trait2.s")))

summary(judge.example)

data("KYPSitemsim")

time.lam &lt;- rbind(c( 1,  0),  # Specify time lambda matrix
                  c(NA,  0),
                  c(NA,  1),
                  c(NA, NA))

item.lam &lt;- c(1, NA, NA, NA, NA, NA) # Specify item lambda matrix

KYPSitemsim$time2 &lt;- (KYPSitemsim$time == 2) * 1
KYPSitemsim$time3 &lt;- (KYPSitemsim$time == 3) * 1
KYPSitemsim$time4 &lt;- (KYPSitemsim$time == 4) * 1

kyps.item.model &lt;- PLmixed(response ~ 0 + as.factor(item) + lat.var:time2
                           + lat.var:time3 + lat.var:time4 + (0 + hs:lat.var | hid)
                           + (0 + ms:lat.var | mid) + (0 + lat.var:as.factor(time) | id),
                           data = KYPSitemsim, lambda = list(time.lam, item.lam),
                           factor = list(c("ms", "hs"), "lat.var"),
                           load.var = c("time", "item"))

summary(kyps.item.model)


## End(Not run)

</code></pre>


</div>
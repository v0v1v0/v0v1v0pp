<div class="container">

<table style="width: 100%;"><tr>
<td>satisfy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Matching input using a logical function</h2>

<h3>Description</h3>

<p><code>satisfy()</code> turns a logical function into a parser that recognizes strings.
</p>


<h3>Usage</h3>

<pre><code class="language-R">satisfy(b)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>a boolean function to determine if the string is accepted.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Notice (see pseudocode) that <code>satisfy</code> fails when presented with empty
input, so it is futile to write predicate functions that would recognize
such input.
</p>


<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
satisfy(b)(x):
  if x==null then fail()(x)
  else if b(x[1]) then succeed(x[1])(x[-1]) else fail()(x)
</pre>
<p>where <code>x[1]</code> is the first element of <code>x</code>, <code>x[-1]</code> all subsequent elements
(or <code>null</code> if it only has one element). <code>null</code> is the empty vector,
equivalent to <code>character(0)</code> in R.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># define a predicate function that tests whether the next element starts
# with an 'a'
starts_with_a &lt;- function(x) grepl("^a",x)
# Use it in the satisfy parser
satisfy(starts_with_a)(c("abc","def")) # success
satisfy(starts_with_a)(c("bca","def")) # failure
# Using an anonymous function
satisfy(function(x) {as.numeric(x)&gt;10})("15") # success

</code></pre>


</div>
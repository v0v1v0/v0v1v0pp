<div class="container">

<table style="width: 100%;"><tr>
<td>pdfCluster</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Clustering via nonparametric density estimation</h2>

<h3>Description</h3>

<p>Cluster analysis is performed by the density-based procedures described in 
Azzalini and Torelli (2007) and Menardi and Azzalini (2014), and summarized
in Azzalini and Menardi (2014). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'numeric'
pdfCluster(x, graphtype, hmult, Q = "QJ", lambda = 0.1, 
   grid.pairs = 10, n.grid = min(round((5 + sqrt(NROW(x))) * 4), NROW(x)), ...)

## S4 method for signature 'matrix'
pdfCluster(x, graphtype, hmult, Q = "QJ", lambda = 0.1, 
	grid.pairs = 10, n.grid = min(round((5 + sqrt(NROW(x))) * 4), NROW(x)), ...)

## S4 method for signature 'data.frame'
pdfCluster(x, graphtype, hmult, Q = "QJ", lambda = 0.1, 
	grid.pairs = 10, n.grid = min(round((5 + sqrt(NROW(x))) * 4), NROW(x)), ...)
	  
## S4 method for signature 'pdfCluster'
pdfCluster(x, graphtype, hmult, Q, lambda = 0.1, 
	grid.pairs, n.grid = min(round((5 + sqrt(NROW(x@x))) * 4), NROW(x@x)), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>A vector, a matrix or a data frame of numeric data to be partitioned. 
Since density-based clustering is designed for continuous data only, 
if discrete data are provided, a warning message is displayed.
Alternatively, <code>x</code> can be an object of <code>pdfCluster-class</code>
itself, obtained when <code>graphtype</code> is set to "pairs". See Section Details below.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graphtype</code></td>
<td>

<p>Either "unidimensional", "delaunay" or "pairs", it defines the procedure used 
to build the graph associated with the data. If missing, a "delaunay" graph is 
built for data having dimension less than 7, otherwise a "pairs" graph is built. 
See details below. This argument has not to be set when <code>x</code> is of
<code>pdfCluster-class</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hmult</code></td>
<td>

<p>A shrink factor to be multiplied by the smoothing parameter <code>h</code> of function <code>kepdf</code>.
If missing, it is taken to be 1 when data have dimension greater than 6, 0.75 otherwise. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>

<p>Optional arguments to be given when <code>graphtype = "delaunay"</code>. See 
<code>delaunayn</code> in package <code>geometry</code> 
for further details. This argument has not to be set when <code>graphtype = "pairs"</code>, 
when <code>graphtype = "unidimensional"</code> or when <code>x</code> is of <code>pdfCluster-class</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>Tolerance threshold to be used when <code>graphtype = "pairs"</code>. An edge is set 
between two observations if the density function, evaluated along the segment
linking them, does not exhibit any valley having a measure exceeding <code>lambda</code>.
Its range is <code class="reqn">[0,1)</code> but a value larger than 0.3 is not recommended; default value
is set to 0.10. This argument has not to be set when <code>graphtype = "delaunay"</code>
or <code>graphtype = "unidimensional"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid.pairs</code></td>
<td>

<p>When <code>graphtype = "pairs"</code>, this arguments defines the length of the grid of
points along the segment linking each pair of observations, on which the density
is evaluated. Default is 10. This argument has not to be set when <code>graphtype = "delaunay"</code>, 
when <code>graphtype = "unidimensional"</code> or when <code>x</code> is of <code>pdfCluster-class</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.grid</code></td>
<td>

<p>Defines the length of the grid on which evaluating the connected 
components of the density level sets. The default value is set to the minimum
between the number of data rows <code class="reqn">n</code> and <code class="reqn">\lfloor{(5 + \sqrt(n))4 + 0.5}\rfloor</code>,
an empirical rule of thumb which indicates that the length of the grid grows with the square root
of the number of rows data.
</p>
</td>
</tr>
</table>
<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments to be passed to <code>kepdf</code> or to 
<code>pdfClassification</code>. 
</p>
</td>
</tr></table>
<h3>Details</h3>












<p>Clusters are associated to the connected components of the level sets of the 
density underlying the data.
Density estimation is performed by kernel methods and the connected regions 
are approximated by the connected components of a graph built on data. 
Three alternative procedures to build the graph are adopted:
</p>

<dl>
<dt>Unidimensional procedure</dt>
<dd>
<p>When data are univariate an edge is set between
two observations when all the data points included in the segment between the two 
candidate observations belong to the same level set.</p>
</dd>
<dt>Delaunay triangulation</dt>
<dd>
<p>An edge is set between two observations when 
they are contiguous in the Voronoi diagram; see Azzalini and Torelli (2007). </p>
</dd>
<dt>Pairs evaluation</dt>
<dd>
<p>An edge is set between two observations when the 
density function, evaluated along the segment joining them, does not exhibit 
any valley having a relative amplitude greater than a tolerance threshold
<code class="reqn">0 \le \lambda &lt; 1</code>. Being a tolerance threshold, sensible values of 
<code class="reqn">\lambda</code> are, in practice, included in <code class="reqn">[0, 0.3]</code>; see Menardi and Azzalini (2013). </p>
</dd> 
</dl>
<p>As the level set varies, the number of detected components gives rise to the
tree of clusters, where each leave corresponds to a mode of the density 
function. Observations around these modes form a number of cluster cores, 
while the lower density observations are allocated according to a 
classification procedure; see also <code>pdfClassification</code>. 
</p>


<h3>Value</h3>

<p>An S4 object of <code>pdfCluster-class</code> with slots:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call </code></td>
<td>
<p>The matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x </code></td>
<td>
<p>The matrix of data input. If a vector of data is provided as input,
a one-column matrix is returned as output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdf </code></td>
<td>
<p>An object of class <code>list</code> providing information about the 
density estimate. It includes: 
</p>

<ul>
<li> <p><code>kernel</code> character vector defining the kernel function used to 
estimate the density;
</p>
</li>
<li> <p><code>bwtype</code> character vector defining if a fixed or an adaptive kernel
estimator has been used;
</p>
</li>
<li> <p><code>par</code> list of components defining the parameters used in density 
estimation;
</p>
</li>
<li> <p><code>estimate</code> vector of density estimates evaluated at the data points.
</p>
</li>
</ul>
<p>See <code>kepdf</code> for further details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc </code></td>
<td>
<p>An object of class <code>list</code> defining details about the 
identification of the connected regions. It includes:
</p>

<ul>
<li> <p><code>nc</code> number of connected sets for each density level set.
</p>
</li>
<li> <p><code>p</code>  vector of level sets, giving the proportions of data with 
estimated density below a threshold.
</p>
</li>
<li> <p><code>id</code> group label of each point at different sections of the 
density estimate. Negative values of <code>id</code> mean that the estimated 
density is below the considered threshold.
</p>
</li>
<li> <p><code>pq</code> for each <code>p</code> gives the corresponding quantile <code>q</code>
of the values of the density.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>An object of class <code>list</code> defining details about the graph 
built to find the connected sets of high density regions. Its length
depends on the value of its first element:
</p>

<ul>
<li> <p><code>type</code> either "unidimensional", "delaunay" or "pairs", 
defines the procedure used to set edges among the observations. 
In the last case only, the list includes also the following elements:
</p>
</li>
<li> <p><code>comp.area</code> a list containing the vector <code>area</code> and the 
matrix <code>pairs.ord</code>. The element <code class="reqn">i</code> of vector <code>area</code> is the
measure of the maximum valley in the density function linking the 
observations having row position as given in column <code class="reqn">i</code> of 
<code>pairs.ord</code>.  		 
</p>
</li>
<li> <p><code>lambda</code> tolerance threshold.    
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster.cores</code></td>
<td>
<p>A vector with the same length as <code>NROW(x)</code>, defining
the cluster cores membership. <code>NA</code> values correspond to low density, 
unlabeled data, to be classified in the second phase of the procedure by the
intarnal call of <code>pdfClassification</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree </code></td>
<td>
<p>Cluster tree with leaves corresponding to the connected 
components associated to different sections of the density estimate.
The object is of class <code>dendrogram</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noc </code></td>
<td>
<p>Number of clusters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stages </code></td>
<td>
<p>List with elements corresponding to the data allocation to 
groups at the different stages of the classification procedure.
<code>NA</code> values correspond to unlabeled data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusters </code></td>
<td>
<p>Set to <code>NULL</code> if <code>n.stages</code> = 0, that is, if data
belonging to the cluster cores only have been allocated. 
Otherwise it reports the final label groups. This component is obsolete. Use function
<code>groups</code>, instead.
</p>
</td>
</tr>
</table>
<h3>Methods</h3>


<dl>
<dt><code>signature(x="data.frame")</code></dt>
<dd>
<p>This method applies the <code>pdfCluster</code> procedure to objects of class 
<code>data.frame</code>.</p>
</dd>
<dt><code>signature(x="matrix")</code></dt>
<dd>
<p>This method applies the <code>pdfCluster</code> procedure to objects of class 
<code>matrix</code>.</p>
</dd>
<dt><code>signature(x="numeric")</code></dt>
<dd>
<p>This method applies the <code>pdfCluster</code> procedure to objects of class 
<code>numeric</code>.</p>
</dd>
<dt><code>signature(x="pdfCluster")</code></dt>
<dd>
<p>This method applies to objects of <code>pdfCluster-class</code> when the graph
has been built according to the "pairs" procedure. It allows to save time and
computations if the user wants to compare results of cluster analysis for 
different values of the <code>lambda</code> parameter. See examples below.</p>
</dd>
</dl>
<h3>Warning </h3>

<p>It may happen that the variability of the estimated density is so high that not 
all jumps in the mode function can be detected by the selected grid scanning 
the density function. In that case, no output is produced and a message is displayed.
As this may be associated to the occurrence of some spurious connected components, 
which appear and disappear within the range between two subsequent values of the grid,
a natural solution is to increase the value of <code>n.grid</code>. 
Alternatively either <code>lambda</code> or <code>hmult</code> may be increased to alleviate
the chance of detecting spurious connected components.
</p>
<p>Using <code>graphtype= 'delaunay'</code> when the dimensionality <code class="reqn">d</code> of data is 
greater than 6 is highly time-consuming unless the number of rows <code class="reqn">n</code> 
is fairly small, since the number of operations to run the Delaunay triangulation 
grows exponentially with <code class="reqn">d</code>.
Use <code>graphtype= "pairs"</code>, instead, whose computational complexity grows quadratically 
with the number of observations.  
</p>


<h3>References</h3>

<p>Azzalini, A., Menardi, G. (2014). Clustering via nonparametric density estimation: the R package pdfCluster.
<em>Journal of Statistical Software</em>, 57(11), 1-26,
URL http://www.jstatsoft.org/v57/i11/.
</p>
<p>Azzalini A., Torelli N. (2007). Clustering via nonparametric density estimation.
<em>Statistics and Computing</em>. 17, 71-80.
</p>
<p>Menardi, G., Azzalini, A. (2014). An advancement in clustering via nonparametric
density estimation. <em>Statistics and Computing</em>. DOI: 10.1007/s11222-013-9400-x.
</p>


<h3>See Also</h3>

<p><code>kepdf</code>, <code>pdfCluster-class</code>, <code>pdfClassification</code>.  
</p>


<h3>Examples</h3>

<pre><code class="language-R">##########
#example 1
###########
# not run here for time reasons
#loading data
data(oliveoil)

#preparing data
olive1 &lt;- 1 + oliveoil[, 3:10]
margin &lt;- apply(data.matrix(olive1),1,sum)
olive1 &lt;- olive1/margin
alr &lt;- (-log( olive1[, -4]/olive1[, 4]))
#select the first 5 principal components
x &lt;- princomp(alr, cor=TRUE)$scores[, 1:5]

#clustering
# not run here for time reasons
#cl &lt;- pdfCluster(x, h = h.norm(x), hmult=0.75)
#summary(cl)
#plot(cl)

#comparing groups with original macro-area membership
#groups &lt;- groups(cl)
#table(oliveoil$macro.area, groups)

#cluster cores
#table(groups(cl, stage = 0))

##########
#example 2
###########
# not run here for time reasons
# loading data
#data(wine)
#x &lt;-wine[ ,-1]
#gr &lt;- wine[ ,1]

# when data are high-dimensional, an adaptive kernel estimator is preferable 
# building the Delaunay graph entails a too high computational effort
# use option "pairs" to build the graph 
# it is the default option for dimension &gt;6 


# cl &lt;- pdfCluster(x, graphtype="pairs", bwtype="adaptive")
# summary(cl)
# plot(cl)

#comparison with original groups
#table(groups(cl),gr)

# a better classification is obtained with larger value of lambda
# not necessary to run the whole procedure again
# a pdfCluster method applies on pdfCluster-class objects!

#cl1 &lt;- pdfCluster(cl, lambda=0.25)
#table(gr, groups(cl1))
</code></pre>


</div>
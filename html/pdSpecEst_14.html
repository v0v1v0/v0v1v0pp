<div class="container">

<table style="width: 100%;"><tr>
<td>pdNeville</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Polynomial interpolation of curves (1D) or surfaces (2D) of HPD matrices</h2>

<h3>Description</h3>

<p><code>pdNeville</code> performs intrinsic polynomial interpolation of curves or surfaces of HPD matrices
in the metric space of HPD matrices equipped with the affine-invariant Riemannian metric (see (Bhatia 2009)[Chapter 6]
or (Pennec et al. 2006)) via Neville's algorithm based on iterative geodesic interpolation detailed
in (Chau and von
Sachs 2019) and in Chapter 3 and 5 of (Chau 2018).
</p>


<h3>Usage</h3>

<pre><code class="language-R">pdNeville(P, X, x, metric = "Riemannian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>for polynomial curve interpolation, a <code class="reqn">(d, d, N)</code>-dimensional array corresponding to a length <code class="reqn">N</code> sequence
of <code class="reqn">(d, d)</code>-dimensional HPD matrices (control points) through which the interpolating polynomial
curve passes. For polynomial surface interpolation, a <code class="reqn">(d, d, N_1, N_2)</code>-dimensional array corresponding
to a tensor product grid of <code class="reqn">(d, d)</code>-dimensional HPD matrices (control points) through which the interpolating
polynomial surface passes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>for polynomial curve interpolation, a numeric vector of length <code class="reqn">N</code> specifying the time points at which
the interpolating polynomial passes through the control points <code>P</code>. For polynomial surface interpolation, a list
with as elements two numeric vectors <code>x</code> and <code>y</code> of length <code class="reqn">N_1</code> and <code class="reqn">N_2</code> respectively. The numeric
vectors specify the time points on the tensor product grid <code>expand.grid(X$x, X$y)</code> at which the interpolating
polynomial passes trough the control points <code>P</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>for polynomial curve interpolation, a numeric vector specifying the time points (locations) at which the
interpolating polynomial is evaluated. For polynomial surface interpolation, a list with as elements two numeric vectors
<code>x</code> and <code>y</code> specifying the time points (locations) on the tensor product grid <code>expand.grid(x$x, x$y)</code> at which the
interpolating polynomial surface is evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>the metric on the space of HPD matrices, by default <code>metric = "Riemannian"</code>, but instead of the Riemannian metric
this can also be set to <code>metric = "Euclidean"</code> to perform (standard) Euclidean polynomial interpolation of curves or
surfaces in the space of HPD matrices.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For polynomial curve interpolation, given <code class="reqn">N</code> control points (i.e., HPD matrices), the degree of the
interpolated polynomial is <code class="reqn">N - 1</code>. For polynomial surface interpolation, given <code class="reqn">N_1 \times N_2</code> control points
(i.e., HPD matrices) on a tensor product grid, the interpolated polynomial surface is of bi-degree <code class="reqn">(N_1 - 1, N_2 - 1)</code>.
Depending on the input array <code>P</code>, the function decides whether polynomial curve or polynomial surface interpolation
is performed.
</p>


<h3>Value</h3>

<p>For polynomial curve interpolation, a <code>(d, d, length(x))</code>-dimensional array corresponding to the interpolating polynomial
curve of <code class="reqn">(d,d)</code>-dimensional matrices of degree <code class="reqn">N-1</code> evaluated at times <code>x</code> and passing through the control points <code>P</code>
at times <code>X</code>. For polynomial surface interpolation, a <code>(d, d, length(x$x), length(x$y))</code>-dimensional array corresponding to the
interpolating polynomial surface of <code class="reqn">(d,d)</code>-dimensional matrices of bi-degree <code class="reqn">N_1 - 1, N_2 - 1</code> evaluated at times <code>expand.grid(x$x, x$y)</code>
and passing through the control points <code>P</code> at times <code>expand.grid(X$x, X$y)</code>.
</p>


<h3>Note</h3>

<p>If <code>metric = "Euclidean"</code>, the interpolating curve or surface may not be positive definite everywhere as the space of HPD
matrices equipped with the Euclidean metric has its boundary at a finite distance.
</p>
<p>The function does not check for positive definiteness of the input matrices, and may fail if <code>metric = "Riemannian"</code> and
the input matrices are close to being singular.
</p>


<h3>References</h3>

<p>Bhatia R (2009).
<em>Positive Definite Matrices</em>.
Princeton University Press, New Jersey.<br><br> Chau J (2018).
<em>Advances in Spectral Analysis for Multivariate, Nonstationary and Replicated Time Series</em>.
phdthesis, Universite catholique de Louvain.<br><br> Chau J, von
Sachs R (2019).
“Intrinsic wavelet regression for curves of Hermitian positive definite matrices.”
<em>Journal of the American Statistical Association</em>.
doi: <a href="https://doi.org/10.1080/01621459.2019.1700129">10.1080/01621459.2019.1700129</a>.<br><br> Pennec X, Fillard P, Ayache N (2006).
“A Riemannian framework for tensor computing.”
<em>International Journal of Computer Vision</em>, <b>66</b>(1), 41–66.
</p>


<h3>See Also</h3>

<p><code>pdPolynomial</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Polynomial curve interpolation
P &lt;- rExamples1D(50, example = 'gaussian')$f[, , 10*(1:5)]
P.poly &lt;- pdNeville(P, (1:5)/5, (1:50)/50)
## Examine matrix-component (1,1)
plot((1:50)/50, Re(P.poly[1, 1, ]), type = "l") ## interpolated polynomial
lines((1:5)/5, Re(P[1, 1, ]), col = 2) ## control points

### Polynomial surface interpolation
P.surf &lt;- array(P[, , 1:4], dim = c(2,2,2,2)) ## control points
P.poly &lt;- pdNeville(P.surf, list(x = c(0, 1), y = c(0, 1)), list(x = (0:10)/10, y = (0:10)/10))

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>marxan_problem</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
<em>Marxan</em> conservation problem</h2>

<h3>Description</h3>

<p>Create a conservation planning <code>problem()</code> following the
mathematical formulations used in <em>Marxan</em> (detailed in Beyer
<em>et al.</em> 2016). Note that these problems are solved using
exact algorithms and not simulated annealing (i.e., the <em>Marxan</em> software).
</p>


<h3>Usage</h3>

<pre><code class="language-R">marxan_problem(x, ...)

## Default S3 method:
marxan_problem(x, ...)

## S3 method for class 'data.frame'
marxan_problem(x, spec, puvspr, bound = NULL, blm = 0, symmetric = TRUE, ...)

## S3 method for class 'character'
marxan_problem(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>character</code> file path for a <em>Marxan</em> input file (typically
called <code>"input.dat"</code>), or <code>data.frame</code> containing planning unit
data (typically called <code>"pu.dat"</code>). If the argument to <code>x</code> is a
<code>data.frame</code>, then each row corresponds to a different planning unit,
and it must have the following columns:
</p>

<dl>
<dt>id</dt>
<dd>
<p><code>integer</code> unique identifier for each planning unit.
These identifiers are used in the argument to <code>puvspr</code>.</p>
</dd>
<dt>cost</dt>
<dd>
<p><code>numeric</code> cost of each planning unit.</p>
</dd>
<dt>status</dt>
<dd>
<p><code>integer</code> indicating if each planning unit
should not be locked in the solution (0) or if it should be locked in
(2) or locked out (3) of the solution. Although <em>Marxan</em> allows
planning units to be selected in the initial solution (using values of
1), these values have no effect here. This column is optional.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spec</code></td>
<td>
<p><code>data.frame</code> containing information on the features.
The argument to <code>spec</code> must follow the conventions used by
<em>Marxan</em> for the species data file (conventionally called
<code>"spec.dat"</code>). Each row corresponds to a different feature and
each column corresponds to different information about the features. It
must contain the columns listed below. Note that the argument to
<code>spec</code> must contain at least one column named <code>"prop"</code> or
<code>"amount"</code>—<strong>but not both columns with both of these
names</strong>—to specify the target for each feature.
</p>

<dl>
<dt>id</dt>
<dd>
<p><code>integer</code> unique identifier for each feature
These identifiers are used in the argument to <code>puvspr</code>.</p>
</dd>
<dt>name</dt>
<dd>
<p><code>character</code> name for each feature.</p>
</dd>
<dt>prop</dt>
<dd>
<p><code>numeric</code> relative target for each feature
(optional).</p>
</dd>
</dl>
<p>'
</p>
<dl>
<dt>amount</dt>
<dd>
<p><code>numeric</code> absolute target for each
feature (optional).</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>puvspr</code></td>
<td>
<p><code>data.frame</code> containing information on the amount of
each feature in each planning unit. The argument to
<code>puvspr</code> must follow the conventions used in the <em>Marxan</em> input
data file (conventionally called <code>"puvspr.dat"</code>). It must contain the
following columns:
</p>

<dl>
<dt>pu</dt>
<dd>
<p><code>integer</code> planning unit identifier.</p>
</dd>
<dt>species</dt>
<dd>
<p><code>integer</code> feature identifier.</p>
</dd>
<dt>amount</dt>
<dd>
<p><code>numeric</code> amount of the feature in the
planning unit.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bound</code></td>
<td>
<p><code>NULL</code> object indicating that no boundary data
is required for the conservation planning problem, or a <code>data.frame</code>
containing information on the planning units' boundaries. The argument to
<code>bound</code> must follow the conventions used in the <em>Marxan</em> input
data file (conventionally called <code>"bound.dat"</code>). It must contain the
following columns:
</p>

<dl>
<dt>id1</dt>
<dd>
<p><code>integer</code> planning unit identifier.</p>
</dd>
<dt>id2</dt>
<dd>
<p><code>integer</code> planning unit identifier.</p>
</dd>
<dt>boundary</dt>
<dd>
<p><code>numeric</code> length of shared boundary
between the planning units identified in the previous two columns.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blm</code></td>
<td>
<p><code>numeric</code> boundary length modifier. This argument only
has an effect when argument to <code>x</code> is a <code>data.frame</code>. The
default argument is zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p><code>logical</code> does the boundary data (i.e., argument to
<code>bound</code>) describe symmetric relationships between planning units?
If the boundary data contain asymmetric connectivity data,
this parameter should be set to <code>FALSE</code>.
Defaults to <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is provided as a convenient wrapper for solving
<em>Marxan</em> problems using the <span class="pkg">prioritizr</span> package.
Please note that it requires installation of the <span class="pkg">data.table</span> package
to import <em>Marxan</em> data files.
</p>


<h3>Value</h3>

<p>A <code>problem()</code> object.
</p>


<h3>Notes</h3>

<p>In previous versions, this function could not accommodate asymmetric
connectivity data. It has now been updated to handle asymmetric connectivity
data.
</p>


<h3>References</h3>

<p>Ball IR, Possingham HP, and Watts M (2009) <em>Marxan and relatives:
Software for spatial conservation prioritisation</em> in Spatial conservation
prioritisation: Quantitative methods and computational tools. Eds Moilanen
A, Wilson KA, and Possingham HP. Oxford University Press, Oxford, UK.
</p>
<p>Beyer HL, Dujardin Y, Watts ME, and Possingham HP (2016) Solving
conservation planning problems with integer linear programming.
<em>Ecological Modelling</em>, 228: 14–22.
</p>


<h3>See Also</h3>

<p>For more information on the correct format for
for <em>Marxan</em> input data, see the
<a href="https://marxansolutions.org">official <em>Marxan</em> website</a> and Ball
<em>et al.</em> (2009).
</p>


<h3>Examples</h3>

<pre><code class="language-R"># create Marxan problem using Marxan input file
# (note this example requires the data.table package to be installed)
## Not run: 
input_file &lt;- system.file("extdata/marxan/input.dat", package = "prioritizr")
p1 &lt;-
  marxan_problem(input_file) %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# print solution
head(s1)

# create Marxan problem using data.frames that have been loaded into R
# (note this example also requires the data.table package to be installed)
## load in planning unit data
pu_path &lt;- system.file("extdata/marxan/input/pu.dat", package = "prioritizr")
pu_dat &lt;- data.table::fread(pu_path, data.table = FALSE)
head(pu_dat)

## load in feature data
spec_path &lt;- system.file(
  "extdata/marxan/input/spec.dat", package = "prioritizr"
)
spec_dat &lt;- data.table::fread(spec_path, data.table = FALSE)
head(spec_dat)

## load in planning unit vs feature data
puvspr_path &lt;- system.file(
  "extdata/marxan/input/puvspr.dat", package = "prioritizr"
)
puvspr_dat &lt;- data.table::fread(puvspr_path, data.table = FALSE)
head(puvspr_dat)

## load in the boundary data
bound_path &lt;- system.file(
  "extdata/marxan/input/bound.dat", package = "prioritizr"
)
bound_dat &lt;- data.table::fread(bound_path, data.table = FALSE)
head(bound_dat)

# create problem without the boundary data
p2 &lt;-
  marxan_problem(pu_dat, spec_dat, puvspr_dat) %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# print solution
head(s2)

# create problem with the boundary data and a boundary length modifier
# set to 5
p3 &lt;-
  marxan_problem(pu_dat, spec_dat, puvspr_dat, bound_dat, blm = 5) %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# print solution
head(s3)

## End(Not run)
</code></pre>


</div>
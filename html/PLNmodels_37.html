<div class="container">

<table style="width: 100%;"><tr>
<td>PLNLDAfit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>An R6 Class to represent a PLNfit in a LDA framework</h2>

<h3>Description</h3>

<p>The function <code>PLNLDA()</code> produces an instance of an object with class <code>PLNLDAfit</code>.
</p>
<p>This class comes with a set of methods, some of them being useful for the user:
See the documentation for the methods inherited by <code>PLNfit()</code>, the <code>plot()</code> method for
LDA visualization and <code>predict()</code> method for prediction
</p>


<h3>Super class</h3>

<p><code>PLNmodels::PLNfit</code> -&gt; <code>PLNLDAfit</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>rank</code></dt>
<dd>
<p>the dimension of the current model</p>
</dd>
<dt><code>nb_param</code></dt>
<dd>
<p>number of parameters in the current PLN model</p>
</dd>
<dt><code>model_par</code></dt>
<dd>
<p>a list with the matrices associated with the estimated parameters of the PLN model: B (covariates), Sigma (latent covariance), C (latent loadings), P (latent position) and Mu (group means)</p>
</dd>
<dt><code>percent_var</code></dt>
<dd>
<p>the percent of variance explained by each axis</p>
</dd>
<dt><code>corr_map</code></dt>
<dd>
<p>a matrix of correlations to plot the correlation circles</p>
</dd>
<dt><code>scores</code></dt>
<dd>
<p>a matrix of scores to plot the individual factor maps</p>
</dd>
<dt><code>group_means</code></dt>
<dd>
<p>a matrix of group mean vectors in the latent space.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PLNLDAfit-new"><code>PLNLDAfit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-optimize"><code>PLNLDAfit$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-postTreatment"><code>PLNLDAfit$postTreatment()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-setVisualization"><code>PLNLDAfit$setVisualization()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-plot_individual_map"><code>PLNLDAfit$plot_individual_map()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-plot_correlation_map"><code>PLNLDAfit$plot_correlation_map()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-plot_LDA"><code>PLNLDAfit$plot_LDA()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-predict"><code>PLNLDAfit$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-show"><code>PLNLDAfit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-PLNLDAfit-clone"><code>PLNLDAfit$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="optimize_vestep"><a href="../../PLNmodels/html/PLNfit.html#method-PLNfit-optimize_vestep"><code>PLNmodels::PLNfit$optimize_vestep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="predict_cond"><a href="../../PLNmodels/html/PLNfit.html#method-PLNfit-predict_cond"><code>PLNmodels::PLNfit$predict_cond()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="print"><a href="../../PLNmodels/html/PLNfit.html#method-PLNfit-print"><code>PLNmodels::PLNfit$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfit" data-id="update"><a href="../../PLNmodels/html/PLNfit.html#method-PLNfit-update"><code>PLNmodels::PLNfit$update()</code></a></span></li>
</ul></details><hr>
<a id="method-PLNLDAfit-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Initialize a <code>PLNLDAfit</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$new(
  grouping,
  responses,
  covariates,
  offsets,
  weights,
  formula,
  control
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grouping</code></dt>
<dd>
<p>a factor specifying the class of each observation used for discriminant analysis.</p>
</dd>
<dt><code>responses</code></dt>
<dd>
<p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt>
<dd>
<p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt>
<dd>
<p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt>
<dd>
<p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>formula</code></dt>
<dd>
<p>model formula used for fitting, extracted from the formula in the upper-level call</p>
</dd>
<dt><code>control</code></dt>
<dd>
<p>list controlling the optimization and the model</p>
</dd>
</dl>
</div>


<hr>
<a id="method-PLNLDAfit-optimize"></a>



<h4>Method <code>optimize()</code>
</h4>

<p>Compute group means and axis of the LDA (noted B in the model) in the
latent space, update corresponding fields
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$optimize(grouping, responses, covariates, offsets, weights, config)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grouping</code></dt>
<dd>
<p>a factor specifying the class of each observation used for discriminant analysis.</p>
</dd>
<dt><code>responses</code></dt>
<dd>
<p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt>
<dd>
<p>design matrix. Automatically built from the covariates and the formula from the call</p>
</dd>
<dt><code>offsets</code></dt>
<dd>
<p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>weights</code></dt>
<dd>
<p>an optional vector of observation weights to be used in the fitting process.</p>
</dd>
<dt><code>config</code></dt>
<dd>
<p>list controlling the optimization</p>
</dd>
<dt><code>X</code></dt>
<dd>
<p>Abundance matrix.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-PLNLDAfit-postTreatment"></a>



<h4>Method <code>postTreatment()</code>
</h4>

<p>Update R2, fisher and std_err fields and visualization
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$postTreatment(
  grouping,
  responses,
  covariates,
  offsets,
  config_post,
  config_optim
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grouping</code></dt>
<dd>
<p>a factor specifying the class of each observation used for discriminant analysis.</p>
</dd>
<dt><code>responses</code></dt>
<dd>
<p>the matrix of responses (called Y in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>covariates</code></dt>
<dd>
<p>design matrix (called X in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>offsets</code></dt>
<dd>
<p>offset matrix (called O in the model). Will usually be extracted from the corresponding field in PLNfamily-class</p>
</dd>
<dt><code>config_post</code></dt>
<dd>
<p>a list for controlling the post-treatments (optional bootstrap, jackknife, R2, etc.).</p>
</dd>
<dt><code>config_optim</code></dt>
<dd>
<p>list controlling the optimization parameters</p>
</dd>
</dl>
</div>


<hr>
<a id="method-PLNLDAfit-setVisualization"></a>



<h4>Method <code>setVisualization()</code>
</h4>

<p>Compute LDA scores in the latent space and update corresponding fields.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$setVisualization(scale.unit = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scale.unit</code></dt>
<dd>
<p>Logical. Should LDA scores be rescaled to have unit variance</p>
</dd>
</dl>
</div>


<hr>
<a id="method-PLNLDAfit-plot_individual_map"></a>



<h4>Method <code>plot_individual_map()</code>
</h4>

<p>Plot the factorial map of the LDA
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$plot_individual_map(
  axes = 1:min(2, self$rank),
  main = "Individual Factor Map",
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>axes</code></dt>
<dd>
<p>numeric, the axes to use for the plot when map = "individual" or "variable". Default it c(1,min(rank))</p>
</dd>
<dt><code>main</code></dt>
<dd>
<p>character. A title for the single plot (individual or variable factor map). If NULL (the default), an hopefully appropriate title will be used.</p>
</dd>
<dt><code>plot</code></dt>
<dd>
<p>logical. Should the plot be displayed or sent back as ggplot object</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a <code>ggplot</code> graphic
</p>


<hr>
<a id="method-PLNLDAfit-plot_correlation_map"></a>



<h4>Method <code>plot_correlation_map()</code>
</h4>

<p>Plot the correlation circle of a specified axis for a <code>PLNLDAfit</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$plot_correlation_map(
  axes = 1:min(2, self$rank),
  main = "Variable Factor Map",
  cols = "default",
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>axes</code></dt>
<dd>
<p>numeric, the axes to use for the plot when map = "individual" or "variable". Default it c(1,min(rank))</p>
</dd>
<dt><code>main</code></dt>
<dd>
<p>character. A title for the single plot (individual or variable factor map). If NULL (the default), an hopefully appropriate title will be used.</p>
</dd>
<dt><code>cols</code></dt>
<dd>
<p>a character, factor or numeric to define the color associated with the variables. By default, all variables receive the default color of the current palette.</p>
</dd>
<dt><code>plot</code></dt>
<dd>
<p>logical. Should the plot be displayed or sent back as ggplot object</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a <code>ggplot</code> graphic
</p>


<hr>
<a id="method-PLNLDAfit-plot_LDA"></a>



<h4>Method <code>plot_LDA()</code>
</h4>

<p>Plot a summary of the <code>PLNLDAfit</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$plot_LDA(
  nb_axes = min(3, self$rank),
  var_cols = "default",
  plot = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nb_axes</code></dt>
<dd>
<p>scalar: the number of axes to be considered when map = "both". The default is min(3,rank).</p>
</dd>
<dt><code>var_cols</code></dt>
<dd>
<p>a character, factor or numeric to define the color associated with the variables. By default, all variables receive the default color of the current palette.</p>
</dd>
<dt><code>plot</code></dt>
<dd>
<p>logical. Should the plot be displayed or sent back as ggplot object</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a <code>grob</code> object
</p>


<hr>
<a id="method-PLNLDAfit-predict"></a>



<h4>Method <code>predict()</code>
</h4>

<p>Predict group of new samples
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$predict(
  newdata,
  type = c("posterior", "response", "scores"),
  scale = c("log", "prob"),
  prior = NULL,
  control = PLN_param(backend = "nlopt"),
  envir = parent.frame()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newdata</code></dt>
<dd>
<p>A data frame in which to look for variables, offsets and counts  with which to predict.</p>
</dd>
<dt><code>type</code></dt>
<dd>
<p>The type of prediction required. The default are posterior probabilities for each group (in either unnormalized log-scale or natural probabilities, see "scale" for details), "response" is the group with maximal posterior probability and "scores" is the average score along each separation axis in the latent space, with weights equal to the posterior probabilities.</p>
</dd>
<dt><code>scale</code></dt>
<dd>
<p>The scale used for the posterior probability. Either log-scale ("log", default) or natural probabilities summing up to 1 ("prob").</p>
</dd>
<dt><code>prior</code></dt>
<dd>
<p>User-specified prior group probabilities in the new data. If NULL (default), prior probabilities are computed from the learning set.</p>
</dd>
<dt><code>control</code></dt>
<dd>
<p>a list for controlling the optimization. See <code>PLN()</code> for details.</p>
</dd>
<dt><code>envir</code></dt>
<dd>
<p>Environment in which the prediction is evaluated</p>
</dd>
</dl>
</div>


<hr>
<a id="method-PLNLDAfit-show"></a>



<h4>Method <code>show()</code>
</h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$show()</pre></div>


<hr>
<a id="method-PLNLDAfit-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PLNLDAfit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p>The function <code>PLNLDA</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(trichoptera)
trichoptera &lt;- prepare_data(trichoptera$Abundance, trichoptera$Covariate)
myPLNLDA &lt;- PLNLDA(Abundance ~ 1, grouping = Group, data = trichoptera)
class(myPLNLDA)
print(myPLNLDA)

## End(Not run)
</code></pre>


</div>
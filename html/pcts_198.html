<div class="container">

<table style="width: 100%;"><tr>
<td>pc.filter.xarma</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Filter time series with periodic arma filters </h2>

<h3>Description</h3>

<p>Filter time series with periodic arma filters with or options for
periodic and non-periodic intercepts.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pc.filter.xarma(x, eps, phi, theta, period, p, q, n, from,
              seasonof1st = 1, intercept = NULL, nintercept = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> the time series to be filtered, a vector. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p> the innovations, a vector.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p> the autoregression parameters, a matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p> the moving average parameters, a matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p> the period (number of seasons in a year). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>

<p>the autoregression orders, recycled to <code>period</code>
if <code>length(p)=1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>

<p>the moving average orders, recycled to <code>period</code> if
<code>length(q)=1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>a positive  integer, the time index of the last observation to be
filtered.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>

<p>a positive  integer, the time index of the first observation to be
filtered.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seasonof1st</code></td>
<td>

<p>a positive  integer, the season of the time index of <code>x[1]</code>,
see Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>

<p>the intercepts of the seasons, a vector of length <code>period</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nintercept</code></td>
<td>

<p>intercepts, a vector of the same length as <code>x</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p><code>pc.filter.xarma</code> is somewhat lower level.
The user level function is <code>pc.filter</code> which uses
<code>pc.filter.xarma</code> to do the computations.

</p>































<p><code>pc.filter.xarma</code> filters the time series <code>x</code> by the
following formula (for <code>t=from,...,n</code>):
</p>
<p style="text-align: center;"><code class="reqn"> x_t
    =   c_t
      + \sum_{i=1}^{p_t} \phi  _t(i)x          _{t-i}
      + \sum_{i=1}^{q_t} \theta_t(i)\varepsilon_{t-i}
      + \varepsilon_t,
    </code>
</p>

<p>where <code class="reqn">c_t</code> is the overall intercept at time <code class="reqn">t</code>, see
below.  Values of <code>x[t]</code> for <code>t</code> outside the range
<code>from,n</code>, if any, are left unchanged. Values for <code>t&lt;from</code>
are used as initial values when needed.
</p>
<p>Two intercepts are provided for convenience and some flexibility.  The
periodic intercept, <code>intercept</code>, is a vector of length
<code>period</code>. It is replicated to length <code>n</code>, taking care to
ensure that the first element of the resulting vector, say <code class="reqn">a</code>,
starts with <code>intercept[seasonof1st]</code>.  <code>nintercept</code> can be
an arbitrary vector of length <code>n</code>. It can be used to represent
trend or contributions from covariates.  <code>nintercept</code> is not
necessarilly periodic and argument <code>seasonof1st</code> does not affect
its use.  The overall intercept is obtained as the sum <code>c = a +
  nintercept</code>.
</p>
<p>Usually <code>x</code> is a numeric vector but it can also be a matrix in
which each column represents the data for one “year”.
Also, the length of <code>x</code> is typically, but not necessarilly, equal
to <code>n</code>. It is prudent to ensure that <code>length(x) &gt;= n</code> and
this must be done if <code>x</code> is a matrix.
</p>







<p>Argument <code>phi</code> is ignored if <code>p==0</code>,
argument <code>theta</code> is ignored if <code>q==0</code>.
</p>
<p><code>pc.filter.xarma</code> is meant to be called by other functions whose
task is to prepare the arguments with proper checks.  It does not make
much sense to repeat the checks in <code>pc.filter.xarma</code>.  In
particular, no check is made to ensure that <code>from</code> and <code>n</code>
are correctly specified.
</p>
<p><b>This is a low level function meant to be used with basic vectors
and matrices.  TODO: Implement in C/C++.</b>  In the current
implementation. it accesses the elements of the arguments with
straightforward indexing, so objects from classes may be used as
well, provided that <code>x[t]</code>, <code>eps[t]</code>, <code>phi[t,i]</code>,
<code>theta[t,i]</code>, as well as assignment to <code>x[t]</code>, are defined
for scalar indices.
</p>


<h3>Value</h3>

<p>Returns <code>x</code> with <code>x[from]</code> to <code>x[n]</code> filled with the
filtered values and values outside the interval <code>from,...,n</code>
left unchanged.
</p>
<p>The mode of <code>x</code> is left unchanged. In particular, <code>x</code> may be
a matrix with each row representing the data for a season. This is
convenient since periodic time series are often more easily processed
in this form.
</p>


<h3>Level</h3>

<p>0 (base) </p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

 <p><code>pc.filter</code> </p>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>grouped_plm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Grouped Panel Data Model</h2>

<h3>Description</h3>

<p>Estimate a grouped panel data model given an observed group structure. Slope parameters are homogeneous within groups but heterogeneous across groups.
This function supports both static and dynamic panel data models, with or without endogenous regressors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">grouped_plm(
  formula,
  data,
  groups,
  index = NULL,
  n_periods = NULL,
  method = "PLS",
  Z = NULL,
  bias_correc = FALSE,
  rho = 0.07 * log(N * n_periods)/sqrt(N * n_periods),
  verbose = TRUE,
  parallel = TRUE,
  ...
)

## S3 method for class 'gplm'
print(x, ...)

## S3 method for class 'gplm'
formula(x, ...)

## S3 method for class 'gplm'
df.residual(object, ...)

## S3 method for class 'gplm'
summary(object, ...)

## S3 method for class 'gplm'
coef(object, ...)

## S3 method for class 'gplm'
residuals(object, ...)

## S3 method for class 'gplm'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula object describing the model to be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> holding a panel data set. If no <code>index</code> variables are provided, the panel must be balanced and ordered in the long format <code class="reqn">\bold{Y}=(Y_1^\prime, \dots, Y_N^\prime)^\prime</code>, <code class="reqn">Y_i = (Y_{i1}, \dots, Y_{iT})^\prime</code> with <code class="reqn">Y_{it} = (y_{it}, x_{it}^\prime)^\prime</code>. Conversely, if <code>data</code> is not ordered or not balanced, <code>data</code> must include two index variables that declare the cross-sectional unit <code class="reqn">i</code> and the time period <code class="reqn">t</code> of each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>a numerical or character vector of length <code class="reqn">N</code> that indicates the group membership of each cross-sectional unit <code class="reqn">i</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>a character vector holding two strings. The first string denotes the name of the index variable identifying the cross-sectional unit <code class="reqn">i</code>, and the second string represents the name of the variable declaring the time period <code class="reqn">t</code>. In case of a balanced panel data set that is ordered in the long format, <code>index</code> can be left empty if the the number of time periods <code>n_periods</code> is supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_periods</code></td>
<td>
<p>the number of observed time periods <code class="reqn">T</code>. If an <code>index</code> is passed, this argument can be left empty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the estimation method. Options are
</p>

<dl>
<dt><code>"PLS"</code></dt>
<dd>
<p>for using the penalized least squares (<em>PLS</em>) algorithm. We recommend <em>PLS</em> in case of (weakly) exogenous regressors (Mehrabani, 2023, sec. 2.2).</p>
</dd>
<dt><code>"PGMM"</code></dt>
<dd>
<p>for using the penalized Generalized Method of Moments (<em>PGMM</em>). <em>PGMM</em> is required when instrumenting endogenous regressors, in which case a matrix <code class="reqn">\bold{Z}</code> containing the necessary exogenous instruments must be supplied (Mehrabani, 2023, sec. 2.3).</p>
</dd>
</dl>
<p> Default is <code>"PLS"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>a <code class="reqn">NT \times q</code> <code>matrix</code> or <code>data.frame</code> of exogenous instruments, where <code class="reqn">q \geq p</code>, <code class="reqn">\bold{Z}=(z_1, \dots, z_N)^\prime</code>, <code class="reqn">z_i = (z_{i1}, \dots, z_{iT})^\prime</code> and <code class="reqn">z_{it}</code> is a <code class="reqn">q \times 1</code> vector. <code>Z</code> is only required when <code>method = "PGMM"</code> is selected. When using <code>"PLS"</code>, the argument can be left empty or it is disregarded. Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bias_correc</code></td>
<td>
<p>logical. If <code>TRUE</code>, a Split-panel Jackknife bias correction following Dhaene and Jochmans (2015) is applied to the slope parameters. We recommend using the correction when working with dynamic panels. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>a tuning parameter balancing the fitness and penalty terms in the IC. If left unspecified, the heuristic <code class="reqn">\rho = 0.07 \frac{\log(NT)}{\sqrt{NT}}</code> of Mehrabani (2023, sec. 6) is used. We recommend the default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, helpful warning messages are shown. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical. If <code>TRUE</code>, certain operations are parallelized across multiple cores. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>ellipsis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>of class <code>gplm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>of class <code>gplm</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Consider the grouped panel data model
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + \beta^\prime_{i} x_{it} + \epsilon_{it}, \quad i = 1, \dots, N, \; t = 1, \dots, T,</code>
</p>

<p>where <code class="reqn">y_{it}</code> is the scalar dependent variable, <code class="reqn">\gamma_i</code> is an individual fixed effect, <code class="reqn">x_{it}</code> is a <code class="reqn">p \times 1</code> vector of explanatory variables, and <code class="reqn">\epsilon_{it}</code> is a zero mean error.
The coefficient vector <code class="reqn">\beta_i</code> is subject to the observed group pattern
</p>
<p style="text-align: center;"><code class="reqn">\beta_i = \sum_{k = 1}^K \alpha_k \bold{1} \{i \in G_k \},</code>
</p>

<p>with <code class="reqn">\cup_{k = 1}^K G_k = \{1, \dots, N\}</code>, <code class="reqn">G_k \cap G_j = \emptyset</code> and <code class="reqn">\| \alpha_k - \alpha_j \| \neq 0</code> for any <code class="reqn">k \neq j</code>, <code class="reqn">k = 1, \dots, K</code>.
</p>
<p>Using <em>PLS</em>, the group-specific coefficients for group <code class="reqn">k</code> are obtained via <em>OLS</em>
</p>
<p style="text-align: center;"><code class="reqn">\hat{\alpha}_k = \left( \sum_{i \in G_k} \sum_{t = 1}^T \tilde{x}_{it} \tilde{x}_{it}^\prime \right)^{-1} \sum_{i \in G_k} \sum_{t = 1}^T \tilde{x}_{it} \tilde{y}_{it},</code>
</p>

<p>where <code class="reqn">\tilde{a}_{it} = a_{it} - T^{-1} \sum_{t=1}^T a_{it}</code>, <code class="reqn">a = \{y, x\}</code> to concentrate out the individual fixed effects <code class="reqn">\gamma_i</code> (within-transformation).
</p>
<p>In case of <em>PGMM</em>, the slope coefficients are derived as
</p>
<p style="text-align: center;"><code class="reqn">
\hat{\alpha}_k = \left( \left[ \sum_{i \in G_k} T^{-1} \sum_{t = 1}^T z_{it} \Delta x_{it} \right]^\prime W_k \left[ \sum_{i \in G_k} T^{-1} \sum_{t = 1}^T z_{it} \Delta x_{it} \right] \right)^{-1}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\quad \quad \left[ \sum_{i \in G_k} T^{-1} \sum_{t = 1}^T z_{it} \Delta x_{it} \right]^\prime W_k \left[ \sum_{i \in G_k} T^{-1} \sum_{t = 1}^T z_{it} \Delta y_{it} \right],
</code>
</p>

<p>where <code class="reqn">W_k</code> is a <code class="reqn">q \times q</code> p.d. symmetric weight matrix and <code class="reqn">\Delta</code> denotes the first difference operator <code class="reqn">\Delta x_{it} = x_{it} - x_{it-1}</code> (first-difference transformation).
</p>


<h3>Value</h3>

<p>An object of class <code>gplm</code> holding
</p>
<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a <code>data.frame</code> containing the dependent and explanatory variables as well as cross-sectional and time indices,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">K \times p</code> matrix of the group-specific parameter estimates,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>a <code>list</code> containing (i) the total number of groups <code class="reqn">K</code> and (ii) a vector of group memberships <code class="reqn">g_1, \dots, g_N)</code>, where <code class="reqn">g_i = k</code> if <code class="reqn">i</code> is assigned to group <code class="reqn">k</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>a vector of residuals of the demeaned model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted</code></td>
<td>
<p>a vector of fitted values of the demeaned model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args</code></td>
<td>
<p>a <code>list</code> of additional arguments,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IC</code></td>
<td>
<p>a <code>list</code> containing (i) the value of the IC and (ii) the <em>MSE</em>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the function call.</p>
</td>
</tr>
</table>
<p>A <code>gplm</code> object has <code>print</code>, <code>summary</code>, <code>fitted</code>, <code>residuals</code>, <code>formula</code>, <code>df.residual</code>, and <code>coef</code> S3 methods.
</p>


<h3>Author(s)</h3>

<p>Paul Haimerl
</p>


<h3>References</h3>

<p>Dhaene, G., &amp; Jochmans, K. (2015). Split-panel jackknife estimation of fixed-effect models. <em>The Review of Economic Studies</em>, 82(3), 991-1030. <a href="https://doi.org/10.1093/restud/rdv007">doi:10.1093/restud/rdv007</a>.
Mehrabani, A. (2023). Estimation and identification of latent group structures in panel data. <em>Journal of Econometrics</em>, 235(2), 1464-1482. <a href="https://doi.org/10.1016/j.jeconom.2022.12.002">doi:10.1016/j.jeconom.2022.12.002</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Simulate a panel with a group structure
sim &lt;- sim_DGP(N = 20, n_periods = 80, p = 2, n_groups = 3)
y &lt;- sim$y
X &lt;- sim$X
groups &lt;- sim$groups
df &lt;- cbind(y = c(y), X)

# Estimate the grouped panel data model
estim &lt;- grouped_plm(y ~ ., data = df, groups = groups, n_periods = 80, method = "PLS")
summary(estim)

# Lets pass a panel data set with explicit cross-sectional and time indicators
i_index &lt;- rep(1:20, each = 80)
t_index &lt;- rep(1:80, 20)
df &lt;- data.frame(y = c(y), X, i_index = i_index, t_index = t_index)
estim &lt;- grouped_plm(
  y ~ ., data = df, index = c("i_index", "t_index"), groups = groups, method = "PLS"
)
summary(estim)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>all_passed</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Did all of the validations fully <em>pass</em>?</h2>

<h3>Description</h3>

<p>Given an agent's validation plan that had undergone interrogation via
<code>interrogate()</code>, did every single validation step result in zero <em>failing</em>
test units? Using the <code>all_passed()</code> function will let us know whether that's
<code>TRUE</code> or not.
</p>


<h3>Usage</h3>

<pre><code class="language-R">all_passed(agent, i = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>agent</code></td>
<td>
<p><em>The pointblank agent object</em>
</p>
<p><code style="white-space: pre;">⁠obj:&lt;ptblank_agent&gt;⁠</code> // <strong>required</strong>
</p>
<p>A <strong>pointblank</strong> <em>agent</em> object that is commonly created through the use of
the <code>create_agent()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p><em>Validation step numbers</em>
</p>
<p><code style="white-space: pre;">⁠vector&lt;integer&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A vector of validation step numbers. These values are assigned to each
validation step by <strong>pointblank</strong> in the order of definition. If <code>NULL</code>
(the default), all validation steps will be used for the evaluation of
complete <em>passing</em>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>all_passed()</code> function provides a single logical value based on an
interrogation performed in the <em>agent</em>-based workflow. For very large-scale
validation (where data quality is a known issue, and is perhaps something to
be tamed over time) this function is likely to be less useful since it is
quite stringent (all test units must pass across all validation steps).
</p>
<p>Should there be a requirement for logical values produced from validation, a
more flexible alternative is in using the test (<code style="white-space: pre;">⁠test_*()⁠</code>) variants of the
validation functions. Each of those produce a single logical value and each
and have a <code>threshold</code> option for failure levels. Another option is to
utilize post-interrogation objects within the <em>agent</em>'s x-list (obtained by
using the <code>get_agent_x_list()</code> function). This allows for many possibilities
in producing a single logical value from an interrogation.
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<p>Create a simple table with a column of numerical values.
</p>
<div class="sourceCode r"><pre>tbl &lt;- dplyr::tibble(a = c(4, 5, 7, 8))

tbl
#&gt; # A tibble: 4 x 1
#&gt;       a
#&gt;   &lt;dbl&gt;
#&gt; 1     4
#&gt; 2     5
#&gt; 3     7
#&gt; 4     8
</pre></div>
<p>Validate that values in column <code>a</code> are always greater than 4.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  create_agent(tbl = tbl) %&gt;%
  col_vals_gt(columns = a, value = 3) %&gt;%
  col_vals_lte(columns = a, value = 10) %&gt;%
  col_vals_increasing(columns = a) %&gt;%
  interrogate()
</pre></div>
<p>Determine if these column validations have all passed by using <code>all_passed()</code>
(they do).
</p>
<div class="sourceCode r"><pre>all_passed(agent = agent)
</pre></div>
<div class="sourceCode"><pre>#&gt; [1] TRUE
</pre></div>


<h3>Function ID</h3>

<p>8-4
</p>


<h3>See Also</h3>

<p>Other Post-interrogation: 
<code>get_agent_x_list()</code>,
<code>get_data_extracts()</code>,
<code>get_sundered_data()</code>,
<code>write_testthat_file()</code>
</p>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>it.reb</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Iterative steps of Response-Based Unit Segmentation (REBUS)</h2>

<h3>Description</h3>

<p>REBUS-PLS is an iterative algorithm for performing
response based clustering in a PLS-PM framework.
<code>it.reb</code> allows to perform the iterative steps of
the REBUS-PLS Algorithm. It provides summarized results
for final local models and the final partition of the
units. Before running this function, it is necessary to
run the <code>res.clus</code> function to choose the
number of classes to take into account.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  it.reb(pls, hclus.res, nk, Y = NULL, stop.crit = 0.005,
    iter.max = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pls</code></td>
<td>
<p>an object of class <code>"plspm"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hclus.res</code></td>
<td>
<p>object of class <code>"res.clus"</code>
returned by <code>res.clus</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nk</code></td>
<td>
<p>integer larger than 1 indicating the number of
classes. This value should be defined according to the
dendrogram obtained by performing
<code>res.clus</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>optional data matrix used when <code>pls$data</code>
is <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop.crit</code></td>
<td>
<p>Number indicating the stop criterion for
the iterative algorithm. It is suggested to use the
threshold of less than 0.05% of units changing class
from one iteration to the other as stopping rule.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max</code></td>
<td>
<p>integer indicating the maximum number of
iterations</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an object of class <code>"rebus"</code>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>Matrix of standardized loadings (i.e.
correlations with LVs.) for each local model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path.coefs</code></td>
<td>
<p>Matrix of path coefficients for each
local model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quality</code></td>
<td>
<p>Matrix containing the average
communalities, the average redundancies, the R2 values,
and the GoF index for each local model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segments</code></td>
<td>
<p>Vector defining the class membership of
each unit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origdata.clas</code></td>
<td>
<p> The numeric matrix with original
data and with a new column defining class membership of
each unit</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Laura Trinchera, Gaston Sanchez
</p>


<h3>References</h3>

<p>Esposito Vinzi, V., Trinchera, L., Squillacciotti, S.,
and Tenenhaus, M. (2008) REBUS-PLS: A Response-Based
Procedure for detecting Unit Segments in PLS Path
Modeling. <em>Applied Stochastic Models in Business and
Industry (ASMBI)</em>, <b>24</b>, pp. 439-458.
</p>
<p>Trinchera, L. (2007) Unobserved Heterogeneity in
Structural Equation Models: a new approach to latent
class detection in PLS Path Modeling. <em>Ph.D.
Thesis</em>, University of Naples "Federico II", Naples,
Italy.
</p>


<h3>See Also</h3>

<p><code>plspm</code>, <code>rebus.pls</code>,
<code>res.clus</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Example of REBUS PLS with simulated data

# load simdata
data("simdata", package='plspm')

# Calculate global plspm
sim_inner = matrix(c(0,0,0,0,0,0,1,1,0), 3, 3, byrow=TRUE)
dimnames(sim_inner) = list(c("Price", "Quality", "Satisfaction"),
                           c("Price", "Quality", "Satisfaction"))
sim_outer = list(c(1,2,3,4,5), c(6,7,8,9,10), c(11,12,13))
sim_mod = c("A", "A", "A")  # reflective indicators
sim_global = plspm(simdata, sim_inner,
                   sim_outer, modes=sim_mod)
sim_global

## Then compute cluster analysis on residuals of global model
sim_clus = res.clus(sim_global)

## To complete REBUS, run iterative algorithm
rebus_sim = it.reb(sim_global, sim_clus, nk=2,
                   stop.crit=0.005, iter.max=100)

## You can also compute complete outputs
## for local models by running:
local_rebus = local.models(sim_global, rebus_sim)

# Display plspm summary for first local model
summary(local_rebus$loc.model.1)

## End(Not run)
</code></pre>


</div>
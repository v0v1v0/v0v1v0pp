<div class="container">

<table style="width: 100%;"><tr>
<td>d.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Long memory parameter estimation</h2>

<h3>Description</h3>

<p>Let <code class="reqn">\theta_h</code> be the copula parameter associated to
<code class="reqn">(X_t,X_{t+h})</code> and <code class="reqn">\hat\theta_h</code> be an estimate of <code class="reqn">\theta_h</code>
based on pseudo observations. The long memory parameter
<code class="reqn">d</code> is estimated by
</p>
<p style="text-align: center;"><code class="reqn">\hat d:=\mathrm{argmin}_{|d|&lt;0.5}\bigg\{\sum_{h=s}^m \bigg|{\hat K_1}(\hat\theta_h-a)-\frac{\Gamma(1-d)}{\Gamma(d)}h^{2d-1}\bigg|^r\bigg\}, \quad r &gt; 0</code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">d.fit(xt, copula = gauss, dCdtheta = dCtheta_gauss, theta.lower = -1,
  theta.upper = 1, optim.method = "Brent", method = "mpl", s = 1,
  m = 24, theta.start = 0.1, empirical = TRUE, r = 2, a = 0,
  d.interval = c(-0.5, 0.5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xt</code></td>
<td>
<p>a vector with the observed time series. Missing observations are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copula</code></td>
<td>
<p>an object of class ‘copula’. Readily available options
are <code>frank</code>, <code>amh</code>, <code>fgm</code> and  <code>gauss</code>. Other
copulas can be used but the user must provide the corresponding <code>dCdtheta</code>.
Default is <code>gauss</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dCdtheta</code></td>
<td>
<p>a two parameter function that returns the limit of the copula
derivative, with respect to <code class="reqn">\theta</code>, as <code class="reqn">\theta</code> goes to <code class="reqn">a</code>, where <code class="reqn">a</code> is
such that <code class="reqn">C_a(u,v)=uv</code>. Readily available
options are <code>dCtheta_frank</code>, <code>dCtheta_amh</code>, <code>dCtheta_fgm</code>
and  <code>dCtheta_gauss</code>. Default is  <code>dCtheta_gauss</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.lower</code></td>
<td>
<p>the lower bound for <code class="reqn">\theta</code>. Default is -1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.upper</code></td>
<td>
<p>the upper bound for <code class="reqn">\theta</code>. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.method</code></td>
<td>
<p>a character string specifying the optimization method.
For all available options see <code>optim</code>.
Default is ‘Brent’. See <cite>fitCopula</cite> for
more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string specifying the copula parameter
estimator used. This can be one of: ‘mpl’, ‘itau’, ‘irho’,
‘itau.mpl’ or ‘ml’. See <cite>fitCopula</cite> for details.
Default is ‘mpl’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>integer. The smallest lag <code class="reqn">h</code> considered in the estimation. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>integer. The  largest lag <code class="reqn">h</code> considered in the estimation. Default is 24.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.start</code></td>
<td>
<p>starting value for the parameter optimization via <code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>empirical</code></td>
<td>
<p>logical. If <code>TRUE</code>, the sample estimators for the density
and quantile functions are considered. Otherwhise, the gaussian density and
quantile functions are used. Default is <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>the exponent used in the Minkowski distance used to calculate <code class="reqn">\hat d</code>.
Default is 2, the Euclidean distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>the value of <code class="reqn">\theta</code> such that <code class="reqn">\lim_{\theta \to a} C_\theta(u,v)=uv</code>,
is the product (or independence) copula. Default is 0, which is the common value for
the available copulas, namely, <code>frank</code>, <code>amh</code>, <code>fgm</code> and  <code>gauss</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.interval</code></td>
<td>
<p>a vector of size 2 giving the lower and upper bound for the
long memory parameter <code class="reqn">d</code>. Default is <code>c(-0.5,0.5)</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code class="reqn">\hat d</code>, the estimated value of <code class="reqn">d</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#-------------------------
# ARFIMA(0,d,0) process
#-------------------------
trunc &lt;- 50000
n = 1000
cks &lt;- arfima.coefs(d = 0.25, trunc = trunc)
eps &lt;- rnorm(trunc+n)
x &lt;- sapply(1:n, function(t) sum(cks*rev(eps[t:(t+trunc)])))

#----------------------
# Original time series
#-----------------------
# For Frank copula, -Inf &lt; theta &lt; Inf. However, "Brent" requires
# finite lower and upper bounds so we use c(-100, 100) here
d_frank &lt;- d.fit(xt = x, copula = frank, dCdtheta = dCtheta_frank,
                 theta.lower = -100, theta.upper = 100)
d_amh &lt;- d.fit(xt = x, copula = amh, dCdtheta = dCtheta_amh,
                 theta.lower = -1, theta.upper = 1)
d_fgm &lt;- d.fit(xt = x, copula = fgm, dCdtheta = dCtheta_fgm,
                 theta.lower = -1, theta.upper = 1)
d_gauss &lt;- d.fit(xt = x, copula = gauss, dCdtheta = dCtheta_gauss,
                 theta.lower = -1, theta.upper = 1)

c(FRANK = d_frank, AMH = d_amh, FGM = d_fgm, GAUSS = d_gauss)

#----------------------------
# Adding some missing values
#----------------------------
index &lt;- sample(1:n, size = round(0.2*n))
xt &lt;- x
xt[index] &lt;- NA

d_frank_m &lt;- d.fit(xt = xt, copula = frank,
                   dCdtheta = dCtheta_frank,
                   theta.lower = -100, theta.upper = 100)
d_amh_m &lt;- d.fit(xt = xt, copula = amh, dCdtheta = dCtheta_amh,
                 theta.lower = -1, theta.upper = 1)
d_fgm_m &lt;- d.fit(xt = xt, copula = fgm, dCdtheta = dCtheta_fgm,
                 theta.lower = -1, theta.upper = 1)
d_gauss_m &lt;- d.fit(xt = xt, copula = gauss,
                   dCdtheta = dCtheta_gauss,
                   theta.lower = -1, theta.upper = 1)

data.frame(
  series = c("Complete", "Missing"),
  FRANK = c(d_frank, d_frank_m),
  AMH = c(d_amh, d_amh_m),
  FGM = c(d_fgm, d_fgm_m),
  GAUSS = c(d_gauss, d_gauss_m))

#-------------------------
# ARFIMA(1,d,1) process
#-------------------------
# For a faster algorithm to generate ARFIMA processes,
# see the package "arfima"
trunc &lt;- 50000
cks &lt;- arfima.coefs(d = 0.35, trunc = trunc, ar = -0.2, ma = 0.4)
n = 1000
eps &lt;- rnorm(trunc+n)
x &lt;- sapply(1:n, function(t) sum(cks*rev(eps[t:(t+trunc)])))

#----------------------
# Original time series
#-----------------------
# For Frank copula, -Inf &lt; theta &lt; Inf. However, "Brent" requires
# finite lower and upper bounds so we use c(-100, 100) here
d_frank &lt;- d.fit(xt = x, copula = frank, dCdtheta = dCtheta_frank,
                 theta.lower = -100, theta.upper = 100)
d_amh &lt;- d.fit(xt = x, copula = amh, dCdtheta = dCtheta_amh,
                 theta.lower = -1, theta.upper = 1)
d_fgm &lt;- d.fit(xt = x, copula = fgm, dCdtheta = dCtheta_fgm,
                 theta.lower = -1, theta.upper = 1)
d_gauss &lt;- d.fit(xt = x, copula = gauss, dCdtheta = dCtheta_gauss,
                 theta.lower = -1, theta.upper = 1)

c(FRANK = d_frank, AMH = d_amh, FGM = d_fgm, GAUSS = d_gauss)

#----------------------------
# Adding some missing values
#----------------------------
n = 1000
index &lt;- sample(1:n, size = round(0.2*n))
xt &lt;- x
xt[index] &lt;- NA

d_frank_m &lt;- d.fit(xt = xt, copula = frank,
                   dCdtheta = dCtheta_frank,
                   theta.lower = -100, theta.upper = 100)
d_amh_m &lt;- d.fit(xt = xt, copula = amh, dCdtheta = dCtheta_amh,
                 theta.lower = -1, theta.upper = 1)
d_fgm_m &lt;- d.fit(xt = xt, copula = fgm, dCdtheta = dCtheta_fgm,
                 theta.lower = -1, theta.upper = 1)
d_gauss_m &lt;- d.fit(xt = xt, copula = gauss,
                   dCdtheta = dCtheta_gauss,
                   theta.lower = -1, theta.upper = 1)

data.frame(
  series = c("Complete", "Missing"),
  FRANK = c(d_frank, d_frank_m),
  AMH = c(d_amh, d_amh_m),
  FGM = c(d_fgm, d_fgm_m),
  GAUSS = c(d_gauss, d_gauss_m))


</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>penhdfeppml_int</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>One-Shot Penalized PPML Estimation with HDFE</h2>

<h3>Description</h3>

<p><code>penhdfeppml_int</code> is the internal algorithm called by <code>penhdfeppml</code> to fit a penalized PPML
regression for a given type of penalty and a given value of the penalty parameter. It takes a vector
with the dependent variable, a regressor matrix and a set of fixed effects (in list form: each element
in the list should be a separate HDFE). The penalty can be either lasso or ridge, and the plugin
method can be enabled via the <code>method</code> argument.
</p>


<h3>Usage</h3>

<pre><code class="language-R">penhdfeppml_int(
  y,
  x,
  fes,
  lambda,
  tol = 1e-08,
  hdfetol = 1e-04,
  glmnettol = 1e-12,
  penalty = "lasso",
  penweights = NULL,
  saveX = TRUE,
  mu = NULL,
  colcheck = TRUE,
  colcheck_x = colcheck,
  colcheck_x_fes = colcheck,
  init_z = NULL,
  post = FALSE,
  verbose = FALSE,
  phipost = TRUE,
  standardize = TRUE,
  method = "placeholder",
  cluster = NULL,
  debug = FALSE,
  gamma_val = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Dependent variable (a vector)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Regressor matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fes</code></td>
<td>
<p>List of fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Penalty parameter (a number).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance parameter for convergence of the IRLS algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hdfetol</code></td>
<td>
<p>Tolerance parameter for the within-transformation step,
passed on to <code>collapse::fhdwithin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glmnettol</code></td>
<td>
<p>Tolerance parameter to be passed on to <code>glmnet</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>A string indicating the penalty type. Currently supported: "lasso" and "ridge".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penweights</code></td>
<td>
<p>Optional: a vector of coefficient-specific penalties to use in plugin lasso when
<code>method == "plugin"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveX</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it returns the values of x and z after partialling out the
fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>A vector of initial values for mu that can be passed to the command.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colcheck</code></td>
<td>
<p>Logical. If <code>TRUE</code>, performs both checks in <code>colcheck_x</code> and <code>colcheck_x_fes</code>.
If the user specifies <code>colcheck_x</code> and <code>colcheck_x_fes</code> individually, this option is overwritten.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colcheck_x</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks collinearity between the independent variables and drops the
collinear variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colcheck_x_fes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks whether the independent variables are perfectly explained
by the fixed effects drops those that are perfectly explained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init_z</code></td>
<td>
<p>Optional: initial values of the transformed dependent variable, to be used in the
first iteration of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post</code></td>
<td>
<p>Logical. If <code>TRUE</code>, estimates a post-penalty regression with the selected variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it prints information to the screen while evaluating.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phipost</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the plugin coefficient-specific penalty weights are iteratively
calculated using estimates from a post-penalty regression when <code>method == "plugin"</code>. Otherwise,
these are calculated using estimates from a penalty regression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, x variables are standardized before estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The user can set this equal to "plugin" to perform the plugin algorithm with
coefficient-specific penalty weights (see details). Otherwise, a single global penalty is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Optional: a vector classifying observations into clusters (to use when calculating SEs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this helps with debugging penalty weights by printing output
of the first iteration to the console and stopping the estimation algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma_val</code></td>
<td>
<p>Numerical value that determines the regularization threshold as defined in Belloni, Chernozhukov, Hansen, and Kozbur (2016). NULL default sets parameter to 0.1/log(n).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>More formally, <code>penhdfeppml_int</code> performs iteratively re-weighted least squares (IRLS) on a
transformed model, as described in Breinlich, Corradi, Rocha, Ruta, Santos Silva and Zylkin (2020).
In each iteration, the function calculates the transformed dependent variable, partials out the fixed
effects (calling <code>collapse::fhdwithin</code>) and then and then calls <code>glmnet</code> if the selected
penalty is lasso (the default). If the user selects ridge, the analytical solution is instead
computed directly using fast C++ implementation.
</p>
<p>For information on the plugin lasso method, see penhdfeppml_cluster_int.
</p>


<h3>Value</h3>

<p>If <code>method == "lasso"</code> (the default), an object of class <code>elnet</code> with the elements
described in glmnet, as well as:
</p>

<ul>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>phi</code>: coefficient-specific penalty weights (only if <code>method == "plugin"</code>.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li>
</ul>
<p>If <code>method == "ridge"</code>, a list with the following elements:
</p>

<ul>
<li> <p><code>beta</code>: a 1 x <code>ncol(x)</code> matrix with coefficient (beta) estimates.
</p>
</li>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li>
</ul>
<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
"Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements",
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). "Fast Poisson estimation with high dimensional
fixed effects", <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). "OLS with multiple high dimensional category variables",
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). "Regularization paths for generalized linear
models via coordinate descent", <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). "Inference in high dimensional panel
models with an application to gun control", <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# To reduce run time, we keep only countries in the Americas:
americas &lt;- countries$iso[countries$region == "Americas"]
trade &lt;- trade[(trade$imp %in% americas) &amp; (trade$exp %in% americas), ]
# Now generate the needed x, y and fes objects:
y &lt;- trade$export
x &lt;- data.matrix(trade[, -1:-6])
fes &lt;- list(exp_time = interaction(trade$exp, trade$time),
            imp_time = interaction(trade$imp, trade$time),
            pair     = interaction(trade$exp, trade$imp))
# Finally, we try penhdfeppml_int with a lasso penalty (the default):
reg &lt;- penhdfeppml_int(y = y, x = x, fes = fes, lambda = 0.1)

# We can also try ridge:
\donttest{reg &lt;- penhdfeppml_int(y = y, x = x, fes = fes, lambda = 0.1, penalty = "ridge")}

## End(Not run)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>Rfr_normdiff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>reflectance:reflectance normalised difference</h2>

<h3>Description</h3>

<p>This function returns the reflectance normalized difference index for a given
pair of wavebands of a reflector spectrum.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Rfr_normdiff(
  spct,
  w.band.plus,
  w.band.minus,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## Default S3 method:
Rfr_normdiff(
  spct,
  w.band.plus,
  w.band.minus,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## S3 method for class 'reflector_spct'
Rfr_normdiff(
  spct,
  w.band.plus = NULL,
  w.band.minus = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...
)

## S3 method for class 'reflector_mspct'
Rfr_normdiff(
  spct,
  w.band.plus = NULL,
  w.band.minus = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>spct</code></td>
<td>
<p>an object of class "reflector_spct".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.band.plus, w.band.minus</code></td>
<td>
<p>waveband object(s) or a list(s) of waveband
objects used to compute the additive and subtractive reflectance terms of
the normalized difference index.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert "hinges" into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantity</code></td>
<td>
<p>character One of "total", "average" or "mean".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>naming</code></td>
<td>
<p>character one of "long", "default", "short" or "none". Used to
select the type of names to assign to returned value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr2tb</code></td>
<td>
<p>character vector, see <code>add_attr2tb</code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>With the default <code>quantity = "mean"</code> or
<code>quantity = "average"</code> the ratio is based on
two <strong>mean spectral photon reflectances</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{plus}) - \overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{minus})}{\overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{plus}) + \overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{minus})}</code>
</p>

<p>If the argument is set to <code>quantity = "total"</code> the fraction is based on
two <strong>photon reflectances</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\mathrm{Rfr}(s, wb_\mathrm{plus}) - \mathrm{Rfr}(s, wb_\mathrm{minus})}{\mathrm{Rfr}(s, wb_\mathrm{plus}) + \mathrm{Rfr}(s, wb_\mathrm{minus})}</code>
</p>

<p>Only if the wavelength expanse of the two wavebands is the same, these two
ratios are numerically identical.
</p>


<h3>Value</h3>

<p>In the case of methods for individual spectra, a <code>numeric</code>
vector with name attribute set. The name is based on the name of the
wavebands unless a named list of wavebands is supplied in which case the
names of the list elements are used. "[Rfr:Rfr]" is appended if <code>quantity
  = "total"</code> and "[Rfr(wl):Rfr(wl)]" if <code>quantity = "mean"</code> or
<code>quantity = "average"</code>.
</p>
<p>A <code>data.frame</code> is returned in the case of collections of spectra,
containing one column for each fraction definition, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>Fraction definitions are "assembled" from the arguments passed to
<code>w.band.num</code> and <code>w.band.denom</code>. If both arguments are lists of
waveband definitions, with an equal number of members, then the wavebands
are paired to obtain as many fractions as the number of wavebands in each
list. Recycling for wavebands takes place when the number of denominator
and numerator wavebands differ.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>Rfr_normdiff(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>Rfr_normdiff(reflector_spct)</code>: Method for <code>reflector_spct</code> objects
</p>
</li>
<li> <p><code>Rfr_normdiff(reflector_mspct)</code>: Calculates Rfr:Rfr from a <code>reflector_mspct</code>
object.
</p>
</li>
</ul>
<h3>Note</h3>

<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult =T RUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>See Also</h3>

<p><code>normalized_diff_ind</code>, accepts different summary
functions.
</p>
<p>Other Reflectance ratio functions: 
<code>Rfr_fraction()</code>,
<code>Rfr_ratio()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">Rfr_normdiff(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"))
Rfr_normdiff(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"),
             quantity = "total")
Rfr_normdiff(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"),
             quantity = "mean")

</code></pre>


</div>
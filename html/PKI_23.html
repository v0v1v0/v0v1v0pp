<div class="container">

<table style="width: 100%;"><tr>
<td>X509</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Public Key Instraftructure (X509) functions
</h2>

<h3>Description</h3>

<p><code>PKI.load.cert</code> creates a certificate object from a string,
connection or file.
</p>
<p><code>PKI.verifyCA</code> verifies a certificate against a given chain of
trust.
</p>
<p><code>PKI.pubkey</code> extracts public key from a certificate.  
</p>
<p><code>PKI.get.subject</code> extracts the subject name from the certificate.
</p>
<p><code>PKI.get.cert.info</code> decodes information from the certificate.
</p>


<h3>Usage</h3>

<pre><code class="language-R">PKI.load.cert(what, format = c("PEM", "DER"), file)
PKI.verifyCA(certificate, ca, default = FALSE, partial = FALSE)
PKI.pubkey(certificate)
PKI.get.subject(certificate)
PKI.get.cert.info(certificate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>string, raw vector or connection to load the certificate
from</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format</code></td>
<td>
<p>format used to encode the certificate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>filename to load the certificate from - <code>what</code> and
<code>file</code> are mutually exclusive</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>certificate</code></td>
<td>
<p>a certificate object (as returned by
<code>PKI.load.cert</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ca</code></td>
<td>
<p>a certificate object of the Certificate Authority (CA) or a
list of such objects if a chain of certificates is involved</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default</code></td>
<td>
<p>logical, if <code>TRUE</code> then root CAs known to OpenSSL
will be added to the trust store. In that case <code>ca</code> can also
be <code>NULL</code> if the certificate is directly signed by the root
CA (very uncommon).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partial</code></td>
<td>
<p>logical, if <code>TRUE</code> then the CAs listed in
<code>ca</code> are trusted even if they are neither root nor self-signed
CAs.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>PKI.verifyCA</code> is used to verify the validity of a certificate
by following a chain of trust. In the most simple case the
certificate was issued by a certificate authority (CA) directly,
which has a self-signed certificate. This is typically the case when
you (or your organization) have created your own CA for internal use.
In that case you only need to supply that CA's certificate to
<code>ca</code> and that's it. It is also possible that your self-signed
CA issued an intermediate certificate - if that is the case then pass
a list of both certificates (order doesn't matter) to <code>ca</code>.
</p>
<p>Another use case is that you have a certificate which has been issued
by publicly trusted CA - this is commonly the case with SSL
certificates used by web servers. In that case, the chain doesn't
end with an internal self-signed certificate, but instead it will
end with a publicly known root CA. OpenSSL manages a list of such
trusted CAs and you can check against them with
<code>default=TRUE</code>. However, in most cases your certificate won't
be issued directly by a root CA, but by an intermetiate authority so
you have to pass the intermediate certificate(s) in the <code>ca</code>
argument.
</p>
<p>Finally, it is sometimes possible that the default list of trusted
certificates does not include the root CA that you need. If that is
the case, and you still want to trust that chain, you can set
<code>partial=TRUE</code> and then <code>PKI.verifyCA</code> will trust the
certificates provided in <code>ca</code> unconditinally, even if they
don't lead to a trusted root or are not self-signed. Note, however,
that this is the least secure option and you should only use it if
the certificates are supplied by you and not the user. If you want
to support user-supplied intermediate certificates then you can use
<code>PKI.verifyCA</code> first to verify the integrity of the
user-supplied chain with <code>partial=TRUE</code> and then verify just
the intermediate certificate against your trusted certificate. That
way you won't trust the intermediate certificate inadvertently.
</p>


<h3>Value</h3>

<p><code>PKI.load.cert</code>: a certificate object
</p>
<p><code>PKI.verifyCA</code>: <code>TRUE</code> is the certificate can be trusted,
<code>FALSE</code> otherwise
</p>
<p><code>PKI.pubkey</code>: public key object
</p>
<p><code>PKI.get.subject</code>: string containing the subject information in
one-line RFC2253 format but in UTF8 encoding instead of MBS escapes.
NOTE: this is experimantal, we may choose to parse the contents and
return it in native R form as a named vector instead.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>Examples</h3>

<pre><code class="language-R">  (ca &lt;- PKI.load.cert(file=system.file("certs", "RForge-ca.crt", package="PKI")))
  (my.cert &lt;- PKI.load.cert(readLines(system.file("certs", "demo.crt", package="PKI"))))
  PKI.verifyCA(my.cert, ca)
  PKI.pubkey(my.cert)
  PKI.get.subject(my.cert)
  PKI.get.cert.info(my.cert)
</code></pre>


</div>
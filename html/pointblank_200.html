<div class="container">

<table style="width: 100%;"><tr>
<td>yaml_write</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Write <strong>pointblank</strong> objects to YAML files</h2>

<h3>Description</h3>

<p>With <code>yaml_write()</code> we can take different <strong>pointblank</strong> objects (these are
the <code>ptblank_agent</code>, <code>ptblank_informant</code>, and <code>tbl_store</code>) and write them to
YAML. With an <em>agent</em>, for example, <code>yaml_write()</code> will write that everything
that is needed to specify an <em>agent</em> and it's validation plan to a YAML file.
With YAML, we can modify the YAML markup if so desired, or, use as is to
create a new agent with the <code>yaml_read_agent()</code> function. That <em>agent</em> will
have a validation plan and is ready to <code>interrogate()</code> the data. We can go a
step further and perform an interrogation directly from the YAML file with
the <code>yaml_agent_interrogate()</code> function. That returns an agent with intel
(having already interrogated the target data table). An <em>informant</em> object
can also be written to YAML with <code>yaml_write()</code>.
</p>
<p>One requirement for writing an <em>agent</em> or an <em>informant</em> to YAML is that we
need to have a table-prep formula specified (it's an R formula that is used
to read the target table when <code>interrogate()</code> or <code>incorporate()</code> is called).
This option can be set when using <code>create_agent()</code>/<code>create_informant()</code> or
with <code>set_tbl()</code> (useful with an existing agent or informant object).
</p>


<h3>Usage</h3>

<pre><code class="language-R">yaml_write(
  ...,
  .list = list2(...),
  filename = NULL,
  path = NULL,
  expanded = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p><em>Pointblank agents, informants, table stores</em>
</p>
<p><code style="white-space: pre;">⁠&lt;series of obj:&lt;ptblank_agent|ptblank_informant|tbl_store&gt;&gt;⁠</code>
// <strong>required</strong>
</p>
<p>Any mix of <strong>pointblank</strong> objects such as the <em>agent</em>
(<code>ptblank_agent</code>), the <em>informant</em> (<code>ptblank_informant</code>), or the table
store (<code>tbl_store</code>). The agent and informant can be combined into a single
YAML file (so long as both objects refer to the same table). A table store
cannot be combined with either an agent or an informant so it must undergo
conversion alone.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.list</code></td>
<td>
<p><em>Alternative to <code>...</code></em>
</p>
<p><code style="white-space: pre;">⁠&lt;list of multiple expressions&gt;⁠</code> // <strong>required</strong> (or, use <code>...</code>)
</p>
<p>Allows for the use of a list as an input alternative to <code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p><em>File name</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The name of the YAML file to create on disk. It is recommended that either
the <code>.yaml</code> or <code>.yml</code> extension be used for this file. If not provided then
default names will be used (<code>"tbl_store.yml"</code>) for a table store and the
other objects will get default naming to the effect of
<code>"&lt;object&gt;-&lt;tbl_name&gt;.yml"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p><em>File path</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional path to which the YAML file should be saved (combined with
<code>filename</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expanded</code></td>
<td>
<p><em>Expand validation when repeating across multiple columns</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;logical&gt;⁠</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should the written validation expressions for an <em>agent</em> be expanded such
that <strong>tidyselect</strong> expressions for columns are evaluated, yielding a
validation function per column? By default, this is <code>FALSE</code> so expressions
as written will be retained in the YAML representation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p><em>Inform (or not) upon file writing</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;logical&gt;⁠</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>.  Should the function <em>not</em> inform when the file is written?</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Invisibly returns <code>TRUE</code> if the YAML file has been written.
</p>


<h3>Examples</h3>



<h4>Writing an <code>agent</code> object to a YAML file</h4>

<p>Let's go through the process of developing an agent with a validation plan.
We'll use the <code>small_table</code> dataset in the following examples, which will
eventually offload the developed validation plan to a YAML file.
</p>
<div class="sourceCode r"><pre>small_table
#&gt; # A tibble: 13 x 8
#&gt;    date_time           date           a b             c      d e     f    
#&gt;    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;
#&gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high
</pre></div>
<p>Creating an <code>action_levels</code> object is a common workflow step when creating a
<strong>pointblank</strong> agent. We designate failure thresholds to the <code>warn</code>, <code>stop</code>,
and <code>notify</code> states using <code>action_levels()</code>.
</p>
<div class="sourceCode r"><pre>al &lt;- 
  action_levels(
    warn_at = 0.10,
    stop_at = 0.25,
    notify_at = 0.35
  )
</pre></div>
<p>Now let's create the <code>agent</code> and pass it the <code>al</code> object (which serves as a
default for all validation steps which can be overridden). The data will be
referenced in <code>tbl</code> with a leading <code>~</code> and this is a requirement for writing
to YAML since the preparation of the target table must be self contained.
</p>
<div class="sourceCode r"><pre>agent &lt;- 
  create_agent(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "A simple example with the `small_table`.",
    actions = al
  )
</pre></div>
<p>Then, as with any <code>agent</code> object, we can add steps to the validation plan by
using as many validation functions as we want.
</p>
<div class="sourceCode r"><pre>agent &lt;-
  agent %&gt;% 
  col_exists(columns = c(date, date_time)) %&gt;%
  col_vals_regex(
    columns = b,
    regex = "[0-9]-[a-z]{3}-[0-9]{3}"
  ) %&gt;%
  rows_distinct() %&gt;%
  col_vals_gt(columns = d, value = 100) %&gt;%
  col_vals_lte(columns = c, value = 5)
</pre></div>
<p>The agent can be written to a <strong>pointblank</strong>-readable YAML file with the
<code>yaml_write()</code> function. Here, we'll use the filename
<code>"agent-small_table.yml"</code> and, after writing, the YAML file will be in the
working directory:
</p>
<div class="sourceCode r"><pre>yaml_write(agent, filename = "agent-small_table.yml")
</pre></div>
<p>We can view the YAML file in the console with the <code>yaml_agent_string()</code>
function.
</p>
<div class="sourceCode r"><pre>yaml_agent_string(filename = "agent-small_table.yml")
</pre></div>
<div class="sourceCode yaml"><pre>type: agent
tbl: ~small_table
tbl_name: small_table
label: A simple example with the `small_table`.
lang: en
locale: en
actions:
  warn_fraction: 0.1
  stop_fraction: 0.25
  notify_fraction: 0.35
steps:
- col_exists:
    columns: c(date, date_time)
- col_vals_regex:
    columns: c(b)
    regex: '[0-9]-[a-z]{3}-[0-9]{3}'
- rows_distinct:
    columns: ~
- col_vals_gt:
    columns: c(d)
    value: 100.0
- col_vals_lte:
    columns: c(c)
    value: 5.0
</pre></div>
<p>Incidentally, we can also use <code>yaml_agent_string()</code> to print YAML in the
console when supplying an agent as the input. This can be useful for
previewing YAML output just before writing it to disk with <code>yaml_write()</code>.
</p>



<h4>Reading an <code>agent</code> object from a YAML file</h4>

<p>There's a YAML file available in the <strong>pointblank</strong> package that's also
called <code>"agent-small_table.yml"</code>. The path for it can be accessed through
<code>system.file()</code>:
</p>
<div class="sourceCode r"><pre>yml_file_path &lt;- 
  system.file(
    "yaml", "agent-small_table.yml",
    package = "pointblank"
  )
</pre></div>
<p>The YAML file can be read as an agent with a pre-existing validation plan by
using the <code>yaml_read_agent()</code> function.
</p>
<div class="sourceCode r"><pre>agent &lt;- yaml_read_agent(filename = yml_file_path)

agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_write_1.png" alt="This image was generated from the first code example in the `yaml_write()` help file." style="width:100%;"><p>This particular agent is using <code>~ tbl_source("small_table", "tbl_store.yml")</code>
to source the table-prep from a YAML file that holds a table store (can be
seen using <code>yaml_agent_string(agent = agent)</code>). Let's put that file in the
working directory (the <strong>pointblank</strong> package has the corresponding YAML
file):
</p>
<div class="sourceCode r"><pre>yml_tbl_store_path &lt;-
  system.file(
    "yaml", "tbl_store.yml",
    package = "pointblank"
  )

file.copy(from = yml_tbl_store_path, to = ".")
</pre></div>
<p>As can be seen from the validation report, no interrogation was yet
performed. Saving an agent to YAML will remove any traces of interrogation
data and serve as a plan for a new interrogation on the same target table. We
can either follow this up with with <code>interrogate()</code> and get an agent with
intel, or, we can interrogate directly from the YAML file with
<code>yaml_agent_interrogate()</code>:
</p>
<div class="sourceCode r"><pre>agent &lt;- yaml_agent_interrogate(filename = yml_file_path)

agent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_write_2.png" alt="This image was generated from the second code example in the `yaml_write()` help file." style="width:100%;"><h4>Writing an <code>informant</code> object to a YAML file</h4>

<p>Let's walk through how we can generate some useful information for a really
small table. We can create an <code>informant</code> object with <code>create_informant()</code>
and we'll again use the <code>small_table</code> dataset.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  create_informant(
    tbl = ~ small_table,
    tbl_name = "small_table",
    label = "A simple example with the `small_table`."
  )
</pre></div>
<p>Then, as with any <code>informant</code> object, we can add info text to the
using as many <code style="white-space: pre;">⁠info_*()⁠</code> functions as we want.
</p>
<div class="sourceCode r"><pre>informant &lt;- 
  informant %&gt;%
  info_columns(
    columns = a,
    info = "In the range of 1 to 10. (SIMPLE)"
  ) %&gt;%
  info_columns(
    columns = starts_with("date"),
    info = "Time-based values (e.g., `Sys.time()`)."
  ) %&gt;%
  info_columns(
    columns = date,
    info = "The date part of `date_time`. (CALC)"
  )
</pre></div>
<p>The informant can be written to a <strong>pointblank</strong>-readable YAML file with the
<code>yaml_write()</code> function. Here, we'll use the filename
<code>"informant-small_table.yml"</code> and, after writing, the YAML file will be in
the working directory:
</p>
<div class="sourceCode r"><pre>yaml_write(informant, filename = "informant-small_table.yml")
</pre></div>
<p>We can inspect the YAML file in the working directory and expect to see the
following:
</p>
<div class="sourceCode yaml"><pre>type: informant
tbl: ~small_table
tbl_name: small_table
info_label: A simple example with the `small_table`.
lang: en
locale: en
table:
  name: small_table
  _columns: 8
  _rows: 13.0
  _type: tbl_df
columns:
  date_time:
  _type: POSIXct, POSIXt
info: Time-based values (e.g., `Sys.time()`).
date:
  _type: Date
  info: Time-based values (e.g., `Sys.time()`). The date part of `date_time`.
a:
  _type: integer
  info: In the range of 1 to 10. (SIMPLE)
b:
  _type: character
c:
  _type: numeric
d:
  _type: numeric
e:
  _type: logical
f:
  _type: character
</pre></div>



<h4>Reading an <code>informant</code> object from a YAML file</h4>

<p>There's a YAML file available in the <strong>pointblank</strong> package that's also
called <code>"informant-small_table.yml"</code>. The path for it can be accessed through
<code>system.file()</code>:
</p>
<div class="sourceCode r"><pre>yml_file_path &lt;- 
  system.file(
    "yaml", "informant-small_table.yml",
    package = "pointblank"
  )
</pre></div>
<p>The YAML file can be read as an informant by using the
<code>yaml_read_informant()</code> function.
</p>
<div class="sourceCode r"><pre>informant &lt;- yaml_read_informant(filename = yml_file_path)

informant
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_yaml_write_3.png" alt="This image was generated from the third code example in the `yaml_write()` help file." style="width:100%;"><p>As can be seen from the information report, the available table metadata was
restored and reported. If you expect metadata to change with time, it might
be beneficial to use <code>incorporate()</code> to query the target table. Or, we can
perform this querying directly from the YAML file with
<code>yaml_informant_incorporate()</code>:
</p>
<div class="sourceCode r"><pre>informant &lt;- yaml_informant_incorporate(filename = yml_file_path)
</pre></div>
<p>There will be no apparent difference in this particular case since
<code>small_data</code> is a static table with no alterations over time. However,
using <code>yaml_informant_incorporate()</code> is good practice since this refreshing
of data will be important with real-world datasets.
</p>



<h3>Function ID</h3>

<p>11-1
</p>


<h3>See Also</h3>

<p>Other pointblank YAML: 
<code>yaml_agent_interrogate()</code>,
<code>yaml_agent_show_exprs()</code>,
<code>yaml_agent_string()</code>,
<code>yaml_exec()</code>,
<code>yaml_informant_incorporate()</code>,
<code>yaml_read_agent()</code>,
<code>yaml_read_informant()</code>
</p>


</div>
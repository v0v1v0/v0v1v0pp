<div class="container">

<table style="width: 100%;"><tr>
<td>penhdfeppml_cluster_int</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plugin Lasso Estimation</h2>

<h3>Description</h3>

<p>Performs plugin lasso - PPML estimation with HDFE. This is an internal function, called by <code>mlfitppml_int</code> and
<code>penhdfeppml_int</code> when users select the <code>method = "plugin"</code> option, but it's made available
as a stand-alone option for advanced users who may prefer to avoid some overhead imposed by the
wrappers.
</p>


<h3>Usage</h3>

<pre><code class="language-R">penhdfeppml_cluster_int(
  y,
  x,
  fes,
  cluster,
  tol = 1e-08,
  hdfetol = 1e-04,
  glmnettol = 1e-12,
  penalty = "lasso",
  penweights = NULL,
  saveX = TRUE,
  mu = NULL,
  colcheck = TRUE,
  colcheck_x = colcheck,
  colcheck_x_fes = colcheck,
  K = 15,
  init_z = NULL,
  post = FALSE,
  verbose = FALSE,
  lambda = NULL,
  phipost = TRUE,
  gamma_val = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Dependent variable (a vector)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Regressor matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fes</code></td>
<td>
<p>List of fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Optional: a vector classifying observations into clusters (to use when calculating SEs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance parameter for convergence of the IRLS algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hdfetol</code></td>
<td>
<p>Tolerance parameter for the within-transformation step,
passed on to <code>collapse::fhdwithin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glmnettol</code></td>
<td>
<p>Tolerance parameter to be passed on to <code>glmnet</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>Only "lasso" is supported at the present stage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penweights</code></td>
<td>
<p>Optional: a vector of coefficient-specific penalties to use in plugin lasso when
<code>method == "plugin"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveX</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it returns the values of x and z after partialling out the
fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>A vector of initial values for mu that can be passed to the command.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colcheck</code></td>
<td>
<p>Logical. If <code>TRUE</code>, performs both checks in <code>colcheck_x</code> and <code>colcheck_x_fes</code>.
If the user specifies <code>colcheck_x</code> and <code>colcheck_x_fes</code> individually, this option is overwritten.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colcheck_x</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks collinearity between the independent variables and drops the
collinear variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colcheck_x_fes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this checks whether the independent variables are perfectly explained
by the fixed effects drops those that are perfectly explained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init_z</code></td>
<td>
<p>Optional: initial values of the transformed dependent variable, to be used in the
first iteration of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post</code></td>
<td>
<p>Logical. If <code>TRUE</code>, estimates a post-penalty regression with the selected variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it prints information to the screen while evaluating.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Penalty parameter (a number).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phipost</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the plugin coefficient-specific penalty weights are iteratively
calculated using estimates from a post-penalty regression. Otherwise, these are calculated using
estimates from a penalty regression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma_val</code></td>
<td>
<p>Numerical value that determines the regularization threshold as defined in Belloni, Chernozhukov, Hansen, and Kozbur (2016). NULL default sets parameter to 0.1/log(n).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The plugin method uses coefficient-specific penalty weights that account for heteroskedasticity. The
penalty parameters are calculated automatically by the function using statistical theory - for a
brief discussion of this, see Breinlich, Corradi, Rocha, Ruta, Santos Silva and Zylkin (2021), and
for a more in-depth analysis, check Belloni, Chernozhukov, Hansen, and Kozbur (2016), which introduced
the specific implementation used in this package. Heuristically, the penalty parameters are set at
a level high enough so that the absolute value of the score for each regressor must be statistically
large relative to its standard error in order for the regressors to be selected.
</p>


<h3>Value</h3>

<p>An object of class <code>elnet</code> with the elements described in glmnet, as
well as the following:
</p>

<ul>
<li> <p><code>mu</code>: a 1 x <code>length(y)</code> matrix with the final values of the conditional mean <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>deviance</code>.
</p>
</li>
<li> <p><code>bic</code>: Bayesian Information Criterion.
</p>
</li>
<li> <p><code>phi</code>: coefficient-specific penalty weights.
</p>
</li>
<li> <p><code>x_resid</code>: matrix of demeaned regressors.
</p>
</li>
<li> <p><code>z_resid</code>: vector of demeaned (transformed) dependent variable.
</p>
</li>
</ul>
<h3>References</h3>

<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C. and T. Zylkin (2021).
"Machine Learning in International Trade Research: Evaluating the Impact of Trade Agreements",
Policy Research Working Paper; No. 9629. World Bank, Washington, DC.
</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). "Fast Poisson estimation with high dimensional
fixed effects", <em>STATA Journal</em>, 20, 90-115.
</p>
<p>Gaure, S (2013). "OLS with multiple high dimensional category variables",
<em>Computational Statistics &amp; Data Analysis</em>, 66, 8-18.
</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). "Regularization paths for generalized linear
models via coordinate descent", <em>Journal of Statistical Software</em>, 33, 1-22.
</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016). "Inference in high dimensional panel
models with an application to gun control", <em>Journal of Business &amp; Economic Statistics</em>, 34, 590-605.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# To reduce run time, we keep only countries in Latin America and the Caribbean:
LatAmericaCar &lt;- countries$iso[countries$sub.region == "Latin America and the Caribbean"]
trade &lt;- trade[(trade$imp %in% LatAmericaCar) &amp; (trade$exp %in% LatAmericaCar), ]
# Now generate the needed x, y and fes objects:
y &lt;- trade$export
x &lt;- data.matrix(trade[, -1:-6])
fes &lt;- list(exp_time = interaction(trade$exp, trade$time),
            imp_time = interaction(trade$imp, trade$time),
            pair     = interaction(trade$exp, trade$imp))
# Finally, we try penhdfeppml_cluster_int:
reg &lt;- penhdfeppml_cluster_int(y = y, x = x, fes = fes, cluster = fes$pair)

## End(Not run)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>sexp_type</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Inspect internal attributes of R objects.</h2>

<h3>Description</h3>

<p><code>typename</code> determines the internal C typename, <code>address</code>
returns the memory location of the object, and <code>refs</code> returns the
number of references pointing to the underlying object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sexp_type(x)

inspect(x, env = parent.frame())

refs(x)

address(x)

typename(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>name of object to inspect. This can not be a value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>When inspecting environments, don't go past this one.</p>
</td>
</tr>
</table>
<h3>Non-standard evaluation</h3>

<p>All functions uses non-standard evaluation to capture the symbol you are
referring to and the environment in which it lives. This means that you can
not call any of these functions on objects created in the function call.
All the underlying C level functions use <code>Rf_findVar</code> to get to the
underlying SEXP.
</p>


<h3>See Also</h3>

<p>Other object inspection: 
<code>ftype()</code>,
<code>otype()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- 1:10
## Not run: .Internal(inspect(x))

typename(x)
refs(x)
address(x)

y &lt;- 1L
typename(y)
z &lt;- list(1:10)
typename(z)
delayedAssign("a", 1 + 2)
typename(a)
a
typename(a)

x &lt;- 1:5
address(x)
x[1] &lt;- 3L
address(x)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>estimateKappaByC1Density.PairedPSCBS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate global background in segmented copy numbers</h2>

<h3>Description</h3>

<p>Estimate global background in segmented copy numbers based on the location of peaks in a weighted
density estimator of the minor copy number mean levels.
</p>
<p>The global background, here called <code class="reqn">\kappa</code>,
may have multiple origins where normal contamination is one,
but not necessarily the only one.
</p>
<p><em>Assumptions:</em>  This estimator assumes that there are segments
with C1=0 and C1=1, i.e. some deletions and, typically, some normal
segements.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'PairedPSCBS'
estimateKappaByC1Density(this, typeOfWeights=c("dhNbrOfLoci", "sqrt(dhNbrOfLoci)"),
  adjust=1, from=0, minDensity=0.2, ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>typeOfWeights</code></td>
<td>
<p>A <code>character</code> string specifying how weights
are calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust</code></td>
<td>
<p>A <code>numeric</code> scale factor specifying the size of
the bandwidth parameter used by the density estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>A <code>numeric</code> scalar specifying the lower bound for the
support of the estimated density.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minDensity</code></td>
<td>
<p>A non-negative <code>numeric</code> threshold specifying
the minimum density a peak should have in order to consider
it a peak.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>See <code>Verbose</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns the background estimate as a <code>numeric</code> scalar.
</p>


<h3>Algorithm</h3>


<ul>
<li>
<p> Retrieve segment-level minor copy numbers and corresponding weights:
</p>

<ol>
<li>
<p> Grabs the segment-level C1 estimates.
</p>
</li>
<li>
<p> Calculate segment weights.
The default (<code>typeOfWeights="dhNbrOfLoci"</code>) is to use
weights proportional to the number of heterozygous SNPs.
An alternative (<code>typeOfWeights="sqrt(dhNbrOfLoci)"</code>) is
to use the square root of those counts.
</p>
</li>
</ol>
</li>
<li>
<p> Identify subset of regions with C1=0:
</p>

<ol>
<li>
<p> Estimates the weighted empirical density function
(truncated at zero below).  Tuning parameter 'adjust'.
</p>
</li>
<li>
<p> Find the first two peaks
(with a density greater than tuning parameter 'minDensity').
</p>
</li>
<li>
<p> Assumes that the two peaks corresponds to C1=0 and C1=1.
</p>
</li>
<li>
<p> Defines threshold Delta0.5 as the center location between
these two peaks.
</p>
</li>
</ol>
</li>
<li>
<p> Estimate the global background signal:
</p>

<ol>
<li>
<p> For all segments with C1 &lt; Delta0.5, calculate the weighted
median of their C1:s.
</p>
</li>
<li>
<p> Let kappa be the above weighted median.
This is the estimated background.
</p>
</li>
</ol>
</li>
</ul>
<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Instead of calling this method explicitly, it is recommended
to use the <code>*estimateKappa()</code> method.
</p>


</div>
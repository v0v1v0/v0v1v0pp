<div class="container">

<table style="width: 100%;"><tr>
<td>minCharChange</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimating the Minimum Number of Character Transitions Using Maximum Parsimony</h2>

<h3>Description</h3>

<p><code>minCharChange</code> is a function which takes a cladogram and a discrete trait and finds the
solutions of inferred character states for ancestral nodes that minimizes the number of
character state transitions (either gains or losses/reversals) for a given topology and a set of
discrete character data. <code>minCharChange</code> relies on <code>ancPropStateMat</code>, which is a wrapper
for <code>phangorn</code>'s function <code>ancestral.pars</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">minCharChange(
  trait,
  tree,
  randomMax = 10000,
  maxParsimony = TRUE,
  orderedChar = FALSE,
  type = "MPR",
  cost = NULL,
  printMinResult = TRUE,
  ambiguity = c(NA, "?"),
  dropAmbiguity = FALSE,
  polySymbol = "&amp;",
  contrast = NULL
)

ancPropStateMat(
  trait,
  tree,
  orderedChar = FALSE,
  type = "MPR",
  cost = NULL,
  ambiguity = c(NA, "?"),
  dropAmbiguity = FALSE,
  polySymbol = "&amp;",
  contrast = NULL,
  returnContrast = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>trait</code></td>
<td>
<p>A vector of trait values for a discrete character, preferably named with taxon names
identical to the tip labels on the input tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>
<p>A cladogram of type <code>phylo</code>. Any branch lengths are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randomMax</code></td>
<td>
<p>The maximum number of cladograms examined when searching a large number of solutions
consistent with the reconstructed ancestral states from <code>ancestral.pars</code> with the minimum number
of character state transitions. If the number of potential solutions is less than <code>randomMax</code>, then
solutions are exhaustively searched.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxParsimony</code></td>
<td>
<p>If <code>TRUE</code> (the default), then only solutions
with the smallest number of total transitions examined will be returned.
Note that since solutions are stochastically 'guessed' at, and the number
of possible solutions may not be exhaustively searched, there may have
been solutions not examined with a lower number of transitions
even if <code>maxParsimony = TRUE</code>. Regardless, one may want to
do <code>maxParsimony = FALSE</code> if one is interested in whether there are solutions with a
smaller number of gains or losses and thus wants to return all solutions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orderedChar</code></td>
<td>
<p>If <code>TRUE</code> (not the default), then the
character will be reconstructed with a cost (step)
matrix of a linear, ordered character. This is not applicable
if <code>type = "ACCTRAN"</code>, as cost matrices cannot
be used with ACCTRAN in <code>ancestral.pars</code>, and an error will
be returned if <code>orderedChar = TRUE</code> but
a cost matrix is given, as the only reason to use <code>orderedChar</code>
is to produce a cost matrix automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The parsimony algorithm applied by
<code>ancestral.pars</code>, which can apply one of two:
<code>"MPR"</code> (the default) is a relatively fast algorithm developed
by Hanazawa et al. (1995) and Narushima
and Hanazawa (1997), which relies on reconstructing the
states at each internal node by re-rooting at
that node.  <code>"ACCTRAN"</code>, the "accelerated transitions"
algorithm (Swofford and Maddison, 1987), favors character reversal
over independent gains when there is ambiguity. The <code>"ACCTRAN"</code> option in
<code>ancestral.pars</code> avoids repeated rerooting of the tree to
search for a smaller set of maximum-parsimony solutions that satisfy
the <code>"ACCTRAN"</code> algorithm, but does so by assigning edge weights.
As of phangorn v1.99-12, "MPR" is calculated using the Sankoff parsimony
algorithm, which allows multifurcations (polytomies). This is <em>not</em> true for
<code>"ACCTRAN"</code>, which uses the Fitch algorithm, which does not allow
for multifurcations. An error is returned if a tree with multifurcations
is passed and a user tries <code>type = "ACCTRAN"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>
<p>A matrix of the cost (i.e. number of steps) necessary to
change between states of the input character trait.
If <code>NULL</code> (the default), the character is assumed to be
unordered with equal cost to change from any state to another.
Cost matrices only impact the "MPR" algorithm; if a cost matrix
is given but <code>type = "ACCTRAN"</code>, an error is issued.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printMinResult</code></td>
<td>
<p>If <code>TRUE</code> (the default), a summary of
the results is printed to the terminal. The information in this summary
may be more detailed if the results of the analysis are
simpler (i.e.  fewer unique solutions).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ambiguity</code></td>
<td>
<p>A vector of values which indicate ambiguous
(i.e. missing or unknown) character state codings
in supplied <code>trait</code> data. Taxa coded ambiguously as treated
as being equally likely to be any state coding.
By default, <code>NA</code> values and "?" symbols are treated as
ambiguous character codings, in agreement with behavior 
of functions in packages <code>phangorn</code> and <code>Claddis</code>. 
This argument is designed to mirror an hidden argument with
an identical name in function <code>phyDat</code> in package <code>phangorn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropAmbiguity</code></td>
<td>
<p>A logical. If <code>TRUE</code> (which is not
the default), all taxa with ambiguous codings as defined
by argument <code>ambiguity</code> will be dropped prior to ancestral
nodes being inferred. This may result in too few taxa.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>polySymbol</code></td>
<td>
<p>A single symbol which separates alternative
states for polymorphic codings; the default symbol is
<code>"&amp;"</code>, following the output by <code>Claddis</code>'s
<code>ReadMorphNexus</code> function, where polymorphic taxa are indicated
by default with a string with state labels separated by an <code>"&amp;"</code> symbol.
For example, a taxon coded as polymorphic for states
1 or 2, would be indicated by the string <code>"1&amp;2"</code>.
<code>polySymbol</code> is used to break up these strings
and automatically construct a fitting <code>contrast</code> table
for use with this data, including for ambiguous character state codings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrast</code></td>
<td>
<p>A matrix of type integer with cells of 0
and 1, where each row is labeled with a string value
used for indicating character states in <code>trait</code>,
and each column is labeled with the formal state label to
be used for assign taxa to particular character states.
A value of 1 indicates that the respective coding string for
that row should be interpreted as reflecting the character
state listed for that column. A coding could reflect multiple
states (such as might occur when taxa are polymorphic for
some morphological character), so the sums of rows and
columns can sum to more than 1.  If <code>contrast</code> is
not <code>NULL</code> (the default), the arguments will nullify
This argument is designed to mirror an hidden argument with
an identical name in function <code>phyDat</code> in package <code>phangorn</code>.
This structure is based on <code>phangorn</code>'s use of
<code>contrasts</code> table used for statistical evaluation of factors.
See the <code>phangorn</code> vignette "Special features of phangorn" for more details
on its implementation within <code>phangorn</code> including an example.
See examples below for the construction of an example contrast
matrix for character data with polymorphisms, coded as character
data output by <code>Claddis</code>'s <code>ReadMorphNexus</code> function,
where polymorphic taxa are indicated with a string with
state labels separated by an <code>"&amp;"</code> symbol.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnContrast</code></td>
<td>
<p>If <code>TRUE</code>, the contrast table
used by <code>ancestral.pars</code> will be output instead for
user evaluation that polymorphic symbols and ambiguous
states are being parsed correctly.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The wrapper function <code>ancPropStateMat</code> simply automates
the application of functions <code>ancestral.pars</code> and <code>phyDat</code>
from <code>phangorn</code>, along with several additional checks
and code to present the result as a matrix, rather than a specialized list. 
</p>
<p>Note that although the default <code>orderedChar</code> argument
assumes that multistate characters are unordered,
the results of character change will always be reported as
gains and losses relative to the numbering of the
states in the output <code>transitionSumChanges</code>, exactly
as if they had been ordered. In the case
where the character is actually ordered, this may be
considered a conservative approach, as using a parsimony
algorithm for unordered character states allows fewer
gains or losses to be counted on branches where multiple
gains and losses are reported. If the character is
presumably unordered <em>and multistate</em>, however,
then the gains and losses division is <em>arbitrary nonsense</em>
and should be combined to to obtain the total number of character changes.
</p>


<h3>Value</h3>

<p>By default, <code>ancPropStateMat</code> returns a matrix,
with rows corresponding to the ID numbers of tips and nodes in
<code>$edge</code>, and columns corresponding to character
states, with the value representing the proportional
weight of that node being that state under the
algorithm used (known tip values are always 1). If argument
<code>returnContrast</code> is <code>TRUE</code> then
<code>ancPropStateMat</code> will instead return the final
contrast table used by <code>phyDat</code> for
interpreting character state strings.
</p>
<p><code>minCharChange</code> invisibly returns a list containing
the following elements, several of which are printed
by default to the console, as controlled by
argument <code>printMinResult</code>:
</p>

<dl>
<dt><code>message</code></dt>
<dd>
<p>Describes the performance of
<code>minCharChange</code> at searching for a minimum solution.</p>
</dd>
<dt><code>sumTransitions</code></dt>
<dd>
<p>A vector recording the total
number of necessary transitions (sum total of gains
and losses/reversal) for each solution;
effectively the parsimony cost of each solution.</p>
</dd>
<dt><code>minTransitions</code></dt>
<dd>
<p>A symmetrical matrix
with number of rows and columns equal to the number of
character states, with values in each cell indicating
the minimum number of transitions from one ancestral
state (i.e. the rows) to a descendant state (i.e.
the columns), taken across the set of kept solutions
(dependent on which are kept as decided by
argument <code>maxParsimony</code>).  Generally guaranteed not to
add up to the number of edges contained within the input
tree, and thus may not represent any realistic
evolutionary scenario but does represent a conservative
approach for asking 'what is the smallest possible
number of transitions from 0 to 1' or 'smallest possible
number of transitions from 1 to 0', independently of each other.</p>
</dd>
<dt><code>solutionArray</code></dt>
<dd>
<p>A three-dimensional array,
where for each solution, we have a matrix with edges
for rows and two columns indicating the ancestral and
child nodes of that edge, with values indicating the
states inferred for those nodes in a particular solution.</p>
</dd>
<dt><code>transitionArray</code></dt>
<dd>
<p>A labeled three-dimensional
array where for each solution we have a symmetrical
matrix with number of rows and columns equal to the
number of character states, with values in each cell
indicating the total number of transitions from one
ancestral state (i.e. the rows) to a descendant state
(i.e. the columns).</p>
</dd>
<dt><code>transitionSumChanges</code></dt>
<dd>
<p>Which is a three
column matrix with a row for every solution, with the
values in the three columns measuring the number of
edges (branches) inferred to respectively have gains,
no change or losses (i.e. reversals), as calculated
relative to the order of character states.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>David W. Bapst
</p>


<h3>References</h3>

<p>Hanazawa, M., H. Narushima, and N. Minaka. 1995.
Generating most parsimonious reconstructions on
a tree: A generalization of the Farris-Swofford-Maddison
method. Discrete Applied Mathematics
56(2-3):245-265.
</p>
<p>Narushima, H., and M. Hanazawa. 1997. A more efficient
algorithm for MPR problems in phylogeny.
Discrete Applied Mathematics 80(2-3):231-238.
</p>
<p>Schliep, K. P. 2011. phangorn: phylogenetic analysis
in R. <em>Bioinformatics</em> 27(4):592-593.
</p>
<p>Swofford, D. L., and W. P. Maddison. 1987.
Reconstructing ancestral character states under
Wagner parsimony. <em>Mathematical Biosciences</em> 87(2):199-229.
</p>


<h3>See Also</h3>

<p>The functions described here are effectively
wrappers of <code>phangorn</code>'s function
<code>ancestral.pars</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# let's write a quick &amp; dirty ancestral trait plotting function

quickAncPlotter &lt;- function(tree, ancData, cex){
    ancCol &lt;- (1:ncol(ancData))+1
        plot(tree,
           show.tip.label = FALSE,
           no.margin = TRUE, 
           direction = "upwards")
        tiplabels(pch = 16,
           pie = ancData[(1:Ntip(tree)),],
           cex = cex,
           piecol = ancCol,
           col = 0)
    nodelabels(pie = ancData[-(1:Ntip(tree)),],
        cex = cex,
        piecol = ancCol)	
    }

# example with retiolitid graptolite data

data(retiolitinae)

#unordered, MPR
ancMPR &lt;- ancPropStateMat(retioTree, 
        trait = retioChar[,2], 
        type = "MPR")
quickAncPlotter(retioTree,
   ancMPR, cex = 0.5)
text(x = 4,y = 5,
   "type = 'MPR'", cex = 1.5)

minCharChange(retioTree,
        trait = retioChar[,2],
        type = "MPR")

# with simulated data

set.seed(444)
tree &lt;- rtree(50)
#simulate under a likelihood model
char &lt;- rTraitDisc(tree, 
        k = 3, rate = 0.7)
tree$edge.length &lt;- NULL
tree &lt;- ladderize(tree)

#unordered, MPR
ancMPR &lt;- ancPropStateMat(tree, 
        trait = char, 
        type = "MPR")
#unordered, ACCTRAN
ancACCTRAN &lt;- ancPropStateMat(tree, 
        trait = char, 
        type = "ACCTRAN")
#ordered, MPR
ancMPRord &lt;- ancPropStateMat(tree, 
        trait = char, 
        orderedChar = TRUE, 
        type = "MPR")

#let's compare MPR versus ACCTRAN results
layout(1:2)
quickAncPlotter(tree,
       ancMPR, cex = 0.3)
text(x = 8, y = 15,
       "type = 'MPR'", cex = 1.5)
quickAncPlotter(tree,
       ancACCTRAN, cex = 0.3)
text(x = 9, y = 15,
       "type = 'ACCTRAN'",cex = 1.5)
       
# MPR has much more uncertainty in node estimates
	  # but that doesn't mean ACCTRAN is preferable

#let's compare unordered versus ordered under MPR
layout(1:2)
quickAncPlotter(tree,
        ancMPR, cex = 0.3)
text(x = 8, y = 15,
        "unordered char\nMPR", cex = 1.5)
quickAncPlotter(tree,
        ancMPRord,cex = 0.3)
text(x = 9, y = 15,
        "ordered char\nMPR", cex = 1.5)
layout(1)


## Not run: 
# what ancPropStateMat automates (with lots of checks):

require(phangorn)
char1 &lt;- matrix(char,,1)
rownames(char1) &lt;- names(char)
#translate into something for phangorn to read
char1 &lt;- phangorn::phyDat(char1,
        type = "USER",
        levels = sort(unique(char1))
        )
x &lt;- phangorn::ancestral.pars(tree,
        char1,type = "MPR")
y &lt;- phangorn::ancestral.pars(tree,
        char1,type = "ACCTRAN")

## End(Not run)

#estimating minimum number of transitions with MPR 
minCharChange(tree,
        trait = char,
        type = "MPR")

 # and now with ACCTRAN
 minCharChange(tree,
        trait = char,
        type = "ACCTRAN")

#POLYMORPHISM IN CHARACTER DATA


# example trait data with a polymorphic taxon
     # separated with '&amp;' symbol
# similar to polymorphic data output by ReadMorphNexus from package Claddis
charPoly &lt;- as.character(
        c(1,2,NA,0,0,1,"1&amp;2",
            2,0,NA,0,2,1,1,"1&amp;2")
            )
#simulate a tree with 16 taxa
set.seed(444)
tree &lt;- rtree(15)
tree$edge.length &lt;- NULL
tree &lt;- ladderize(tree)
names(charPoly) &lt;- tree$tip.label
charPoly

# need a contrast matrix that takes this into account
    #can build row by row, by hand

#first, build contrast matrix for basic states
contrast012 &lt;- rbind(c(1,0,0),
                     c(0,1,0),
                     c(0,0,1))
colnames(contrast012) &lt;- rownames(contrast012) &lt;- 0:2
contrast012

#add polymorphic state and NA ambiguity as new rows
contrastPoly &lt;- c(0,1,1)
contrastNA &lt;- c(1,1,1)
contrastNew &lt;- rbind(contrast012,
        '1&amp;2' = contrastPoly,
        contrastNA)
rownames(contrastNew)[5] &lt;- NA

#let's look at contrast
contrastNew

# now try this contrast table we've assembled
    # default: unordered, MPR
ancPoly &lt;- ancPropStateMat(tree, 
        trait = charPoly, 
        contrast = contrastNew)

# but...!
# we can also do it automatically, 
    # by default, states with '&amp;' are automatically treated
    # as polymorphic character codings by ancPropStateMat
ancPolyAuto &lt;- ancPropStateMat(tree,
        trait = charPoly, 
        polySymbol = "&amp;")

# but does this match what the table we constructed?
ancPropStateMat(tree, 
        trait = charPoly,
		   polySymbol = "&amp;", 
        returnContrast = TRUE)

# compare to contrastNew above!
# only difference should be the default ambiguous
	# character '?' is added to the table

#compare reconstructions
layout(1:2)
quickAncPlotter(tree,
        ancPoly, cex = 0.5)
text(x = 3.5, y = 1.2,
        "manually-constructed\ncontrast", cex = 1.3)
quickAncPlotter(tree,
        ancPolyAuto, cex = 0.5)
text(x = 3.5, y = 1.2,
        "auto-constructed\ncontrast", cex = 1.3)
layout(1)

# look pretty similar!

# i.e. the default polySymbol = "&amp;", but could be a different symbol
     # such as "," or "\"... it can only be *one* symbol, though

# all of this machinery should function just fine in minCharChange
		# again, by default polySymbol = "&amp;" (included anyway here for kicks)
minCharChange(tree, 
        trait = charPoly, 
        polySymbol = "&amp;")

</code></pre>


</div>
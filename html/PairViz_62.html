<div class="container">

<table style="width: 100%;"><tr>
<td>weighted_hpaths</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constructs weight decreasing hamiltonian paths </h2>

<h3>Description</h3>

<p>Returns a modified version of <code>paths</code>, where 
component paths/cycles are re-oriented so low weight edges occur first, and the component paths/cycles are then permuted so low-weight paths are first. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">weighted_hpaths(d, path1 = NULL, paths=NULL, matrix=TRUE, cycle=NULL, 
path_weight=sum, path_dir = path_cor,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>A <code>dist</code>, used to provide edge weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path1</code></td>
<td>
<p>A vector giving a hamiltonian. 
This will be the first path of the returned hamiltonian. The default is obtained from <code>order_tsp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>paths</code></td>
<td>
<p>A matrix where each row is a hamiltonian. Default comes from <code>hpaths</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrix</code></td>
<td>
<p>if <code>TRUE</code>, returns a matrix where each row is a hamiltonian 
path, otherwise concatenates the rows into a vector. For odd <code>n</code>, the starting node is appended to close the eulerian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cycle</code></td>
<td>
<p>If <code>TRUE</code>, the <code>weighted_hpaths</code> algorithm evaluates 
<code>path_weight</code> on  hamiltonian cycles, if <code>FALSE</code>, on open hamiltonian paths.
Default  is <code>TRUE</code> for odd n and <code>FALSE</code> for even <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path_weight</code></td>
<td>
<p>A function used  combine path weights into a single value. Default function is <code>path_cor</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path_dir</code></td>
<td>
<p>A function used  to evaluate a path start and orientation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>passed to <code>path_weight</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>path</code> is not provided, find the hamiltonian (path for even n, cycle for odd n) with the smallest total 
weight. Applying <code>path_dir</code> to edge weights, pick the  starting and point orientation for path1 giving the largest <code>path_dir</code> value. (For open paths, there are only two possible starts, for cycles there are n). 
Apply this node labelling to the  hamiltonians in the  rows of paths. 
Use criterion <code>path_dir</code>  again to find the best orientation for each of rows 2... of paths and
permute these rows in order of increasing <code>path_weight</code>.
</p>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>see overview</p>


<h3>See Also</h3>

<p><code>hpaths</code>, <code>eulerian</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">
require(PairViz)

weighted_hpaths(dist(rnorm(6)))

weighted_hpaths(dist(rnorm(7)))



</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>slice</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Subset rows by position</h2>

<h3>Description</h3>

<p>Subset rows by their original position in the <code>data.frame</code>. Grouped <code>data.frame</code>s use the position within each group.
</p>


<h3>Usage</h3>

<pre><code class="language-R">slice(.data, ...)

slice_head(.data, ..., n, prop)

slice_tail(.data, ..., n, prop)

slice_min(.data, order_by, ..., n, prop, with_ties = TRUE)

slice_max(.data, order_by, ..., n, prop, with_ties = TRUE)

slice_sample(.data, ..., n, prop, weight_by = NULL, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For <code>slice()</code>: integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop. The values provided must be either all positive
or negative. Indices beyond the number of rows in the input are silently ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n, prop</code></td>
<td>
<p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the proportion of rows to select. If neither are
supplied, <code>n = 1</code> will be used.
</p>
<p>If <code>n</code> is greater than the number of rows in the group (or <code>prop &gt; 1</code>), the result will be silently truncated to the
group size. If the <code>prop</code>ortion of a group size is not an integer, it is rounded down.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order_by</code></td>
<td>
<p>The variable to order by.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with_ties</code></td>
<td>
<p><code>logical(1)</code>. Should ties be kept together? The default, <code>TRUE</code>, may return more rows than you
request. Use <code>FALSE</code> to ignore ties, and return the first <code>n</code> rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_by</code></td>
<td>
<p>Sampling weights. This must evaluate to a vector of non-negative numbers the same length as the
input. Weights are automatically standardised to sum to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p><code>logical(1)</code>. Should sampling be performed with (<code>TRUE</code>) or without (<code>FALSE</code>, the default)
replacement.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following properties:
</p>

<ul>
<li>
<p> Each row may appear 0, 1, or many times in the output.
</p>
</li>
<li>
<p> Columns are not modified.
</p>
</li>
<li>
<p> Groups are not modified.
</p>
</li>
<li>
<p> Data frame attributes are preserved.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">slice(mtcars, c(1, 2, 3))
mtcars %&gt;% slice(1:3)

# Similar to head(mtcars, 1)
mtcars %&gt;% slice(1L)

# Similar to tail(mtcars, 1):
mtcars %&gt;% slice(n())
mtcars %&gt;% slice(5:n())
# Rows can be dropped with negative indices:
slice(mtcars, -(1:4))

# First and last rows based on existing order
mtcars %&gt;% slice_head(n = 5)
mtcars %&gt;% slice_tail(n = 5)

# Grouped operations:
mtcars %&gt;% group_by(am, cyl, gear) %&gt;% slice_head(n = 2)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>sun_angles</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solar angles</h2>

<h3>Description</h3>

<p>Function <code>sun_angles()</code> returns the solar angles and Sun to Earth
relative distance for given times and locations using a very precise
algorithm. Convenience functions <code>sun_azimuth()</code>,
<code>sun_elevation()</code>, <code>sun_zenith_angle()</code> and
<code>distance_to_sun()</code> are wrappers on <code>sun_angles()</code> that return
individual vectors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sun_angles(
  time = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)

sun_angles_fast(time, tz, geocode, use.refraction)

sun_elevation(
  time = lubridate::now(),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)

sun_zenith_angle(
  time = lubridate::now(),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)

sun_azimuth(
  time = lubridate::now(),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)

distance_to_sun(
  time = lubridate::now(),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>A "vector" of POSIXct Time, with any valid time zone (TZ) is
allowed, default is current time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tz</code></td>
<td>
<p>character string indicating time zone to be used in output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geocode</code></td>
<td>
<p>data frame with variables lon and lat as numeric values
(degrees), nrow &gt; 1, allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.refraction</code></td>
<td>
<p>logical Flag indicating whether to correct for
fraction in the atmosphere.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is an implementation of Meeus equations as used in
NOAAs on-line web calculator, which are precise and valid for a very broad
range of dates (years -1000 to 3000 at least). The apparent solar
elevations near sunrise and sunset are affected by refraction in the
atmosphere, which does in turn depend on weather conditions. The effect of
refraction on the apparent position of the sun is only an estimate based on
"typical" conditions for the atmosphere. The computation is not defined for
latitudes 90 and -90 degrees, i.e. exactly at the poles. The function is
vectorized and in particular passing a vector of times for a single geocode
enhances performance very much as the equation of time, the most time
consuming step, is computed only once.
</p>
<p>For improved performance, if more than one angle is needed it
is preferable to directly call <code>sun_angles</code> instead of the wrapper
functions as this avoids the unnecesary recalculation.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with variables <code>time</code> (in same TZ as input),
<code>TZ</code>, <code>solartime</code>, <code>longitude</code>, <code>latitude</code>,
<code>address</code>, <code>azimuth</code>, <code>elevation</code>, <code>declination</code>,
<code>eq.of.time</code>, <code>hour.angle</code>, and <code>distance</code>. If a data frame
with multiple rows is passed to <code>geocode</code> and a vector of times longer
than one is passed to <code>time</code>, sun position for all combinations of
locations and times are returned by <code>sun_angles</code>. Angles are expressed
in degrees, <code>solartime</code> is a vector of class <code>"solar.time"</code>,
<code>distance</code> is expressed in relative sun units.
</p>


<h3>Important!</h3>

<p>Given an instant in time and a time zone, the date is
computed from these, and may differ by one day to that at the location
pointed by <code>geocode</code> at the same instant in time, unless the argument
passed to <code>tz</code> matches the time zone at this location.
</p>


<h3>Note</h3>

<p>There exists a different R implementation of the same algorithms called
"AstroCalcPureR" available as function <code>astrocalc4r</code> in package
'fishmethods'. Although the equations used are almost all the same, the
function signatures and which values are returned differ. In particular,
the present implementation splits the calculation into two separate
functions, one returning angles at given instants in time, and a separate
one returning the timing of events for given dates.
</p>


<h3>References</h3>

<p>The primary source for the algorithm used is the book:
Meeus, J. (1998) Astronomical Algorithms, 2 ed., Willmann-Bell, Richmond,
VA, USA. ISBN 978-0943396613.
</p>
<p>A different implementation is available at
<a href="https://github.com/NEFSC/READ-PDB-AstroCalc4R/">https://github.com/NEFSC/READ-PDB-AstroCalc4R/</a>.
</p>
<p>An interactive web page using the same algorithms is available at
<a href="https://gml.noaa.gov/grad/solcalc/">https://gml.noaa.gov/grad/solcalc/</a>. There are small
differences in the returned times compared to our function that seem to be
related to the estimation of atmospheric refraction (about 0.1 degrees).
</p>


<h3>See Also</h3>

<p>Other astronomy related functions: 
<code>day_night()</code>,
<code>format.solar_time()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(lubridate)
sun_angles()
sun_azimuth()
sun_elevation()
sun_zenith_angle()
sun_angles(ymd_hms("2014-09-23 12:00:00"))
sun_angles(ymd_hms("2014-09-23 12:00:00"),
           geocode = data.frame(lat=60, lon=0))
sun_angles(ymd_hms("2014-09-23 12:00:00") + minutes((0:6) * 10))

</code></pre>


</div>
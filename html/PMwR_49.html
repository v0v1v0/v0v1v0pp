<div class="container">

<table style="width: 100%;"><tr>
<td>journal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Journal
</h2>

<h3>Description</h3>

<p>Create and manipulate a journal of financial transactions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">journal(amount, ...)

as.journal(x, ...)

is.journal(x)

## Default S3 method:
journal(amount, price, timestamp, instrument,
        id = NULL, account = NULL, ...)

## S3 method for class 'journal'
c(..., recursive = FALSE)

## S3 method for class 'journal'
length(x)

## S3 method for class 'journal'
aggregate(x, by, FUN, ...)

## S3 method for class 'journal'
print(x, ...,
      width = getOption("width"), max.print = getOption("max.print"),
      exclude = NULL, include.only = NULL)

## S3 method for class 'journal'
sort(x, decreasing = FALSE, by = "timestamp", ..., na.last = TRUE)

## S3 method for class 'journal'
summary(object, by = "instrument", drop.zero = TRUE,
      na.rm = FALSE, ...)

## S3 method for class 'journal'
subset(x, ...)

## S3 method for class 'journal'
x[i, match.against = NULL,
                    ignore.case = TRUE, perl = FALSE, fixed = FALSE,
                    useBytes = FALSE, ..., invert = FALSE]

## S3 replacement method for class 'journal'
x[i, match.against = NULL,
                    ignore.case = TRUE, ..., invert = FALSE] &lt;- value

## S3 method for class 'journal'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S3 method for class 'journal'
head(x, n = 6L, ..., by = "instrument")

## S3 method for class 'journal'
tail(x, n = 6L, ..., by = "instrument")

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>timestamp</code></td>
<td>

<p>An atomic vector of mode numeric or character. Timestamps should
typically be sortable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amount</code></td>
<td>

<p>numeric
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>price</code></td>
<td>

<p>numeric
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>instrument</code></td>
<td>

<p>character or numeric (though typically character)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>

<p>An atomic vector. Default is <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>account</code></td>
<td>

<p>An atomic vector. Default is <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>For <code>journal</code>: further arguments, which must all be named.
</p>
<p>For <code>subset</code>: an expression that evaluates to a logical vector. The
expression may use all fields of the passed journal; see Examples.
</p>
<p>For <code>`[`</code>: arguments other than <code>ignore.case</code> to be passed
to <code>grep</code>.
</p>
<p>For <code>sort</code>: arguments passed to <code>sort</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a <code>journal</code> or an object to be coerced to class <code>journal</code> (for
<code>as.journal</code>) or to be checked if it inherits from journal (for
<code>is.journal</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>a <code>journal</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>

<p>integer. See <code>options</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>

<p>passed to <code>sort</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>

<p><code>sort</code>: sort by field. <code>head</code>/<code>tail</code>: by field
(default is instrument).
<code>summary</code>: a vector of keywords (or <code>NULL</code>); supported are
<code>"instrument"</code>, <code>"year"</code> and <code>"month"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.zero</code></td>
<td>
<p>logical</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.last</code></td>
<td>

<p>arguments passed to sort
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.print</code></td>
<td>

<p>maximum number of transactions to print
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>

<p>character: fields that should not be printed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.only</code></td>
<td>

<p>character: print only those fields. (Not supported yet.)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>

<p>see <code>as.data.frame</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optional</code></td>
<td>

<p>see <code>as.data.frame</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recursive</code></td>
<td>

<p>ignored (see <code>c</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>

<p>integer, logical or character.  The latter is interpreted as a
regexp (see <code>grep</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>integer
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>match.against</code></td>
<td>

<p>character vector of field names. Default is <code>NULL</code>, which
means to match against all character fields.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.case</code></td>
<td>

<p>logical: passed to <code>grepl</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perl</code></td>
<td>

<p>logical: passed to <code>grepl</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>

<p>logical: passed to <code>grepl</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useBytes</code></td>
<td>

<p>logical: passed to <code>grepl</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invert</code></td>
<td>

<p>logical. If <code>TRUE</code>, invert selection (when <code>i</code> is of mode
<code>character</code>, select journal entries that do not match regular
expression)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>

<p>either a function that takes as input a journal and evaluates to a
journal, or a list of named functions
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>

<p>a replacement value
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>journal</code> function creates a list of its arguments
and attaches a class attribute (‘<code>journal</code>’).
It is a generic function; the default method creates a
journal from atomic vectors. The <code>btest</code> method
extracts the journal from the results of a backtest; see
<code>btest</code>.
</p>
<p><code>as.journal</code> coerces an object to a journal and is
primarily used for creating a journal from a
<code>data.frame</code>.
Calling <code>as.journal</code> on an unnamed numeric vector
interprets the vector as amounts.  If the vector is named,
these are interpreted as instruments; see Examples.  Calling
<code>as.journal</code> on a journal returns the journal itself.
</p>
<p><code>journal</code> methods are available for several generic
functions, for instance:
</p>

<dl>
<dt><code>all.equal</code></dt>
<dd>
<p>compare contents of two journals</p>
</dd>
<dt><code>aggregate</code></dt>
<dd>
<p>Splits a journal according to
<code>by</code>, applies a function to every sub-journal and
recombines the results into a journal.</p>
</dd>
<dt><code>as.data.frame</code></dt>
<dd>
<p>Coerce journal to
<code>data.frame</code>.</p>
</dd>
<dt><code>c</code></dt>
<dd>
<p>Combine several journals into one.  Note
that the first argument to <code>c.journal</code> must inherit
from <code>journal</code>, or else the method dispatch will
fail.  For empty journals, use <code>journal()</code> (not
<code>NULL</code>).</p>
</dd>
<dt><code>length</code></dt>
<dd>
<p>number of transactions in a journal;
it uses the length of <code>amount</code></p>
</dd>
<dt><code>split</code></dt>
<dd>
<p>Splits a journal according to
<code>f</code>, yielding a list of journals.  Often used
interactively to have information per sub-journal
printed.</p>
</dd>
<dt><code>subset</code></dt>
<dd>
<p>evaluates an expression in an
environment that can access all fields of the journal.
The function is meant for interactive analysis; care is
needed when it is used within other functions: see
Examples and the Manual.</p>
</dd>
<dt><code>summary</code></dt>
<dd>
<p>provides summary statistics, such as
number of trades and average buy/sell prices</p>
</dd>
<dt><code>toOrg</code></dt>
<dd>
<p>converts a journal to an Org table;
package <span class="pkg">orgutils</span> must be available</p>
</dd>
</dl>
<p>For journals that have a length, missing arguments will be
coded as <code>NA</code> except for <code>id</code> and
<code>account</code>, which become <code>NULL</code>.  In
zero-length (i.e. ‘empty’) journals, all fields have
length 0.  A zero-length journal is created, for instance,
by saying <code>journal()</code> or when an zero-row
<code>data.frame</code> is passed to <code>as.journal</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>journal</code>, which is a list of atomic
vectors.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann &lt;es@enricoschumann.net&gt;
</p>


<h3>References</h3>

<p>Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/R/packages/PMwR/">https://enricoschumann.net/R/packages/PMwR/</a>;
in particular, see<br><a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#journals">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#journals</a>
</p>


<h3>See Also</h3>

<p><code>position</code>, <code>pl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">j &lt;- journal(timestamp = 1:3,
             amount = c(1,2,3),
             price = 101:103,
             instrument = c("Stock A", "Stock A", "Stock B"))

## *** subset *** in functions
##   this should work as expected ...
t0 &lt;- 2.5
subset(j, timestamp &gt; t0)

##   ... but here?!
tradesAfterT &lt;- function(j, t0)
    subset(j, timestamp &gt; t0)
tradesAfterT(j, 0)

##   if really required
tradesAfterT &lt;- function(j, t0) {
    e &lt;- substitute(timestamp &gt; t0, list(t0 = t0))
    do.call(subset, list(j, e))
}
tradesAfterT(j, 0)

##   ... or much simpler
tradesAfterT &lt;- function(j, t0)
    j[j$timestamp &gt; t0]
tradesAfterT(j, 0)


## *** aggregate ***
##   several buys and sells on two days
##   aim: find average buy/sell price per day
j &lt;- journal(timestamp = structure(c(15950, 15951, 15950, 15951, 15950,
                                     15950, 15951, 15951, 15951, 15951),
                                   class = "Date"),
             amount = c(-3, -4, -3, -1, 3, -2, 1, 3, 5, 3),
             price = c(104, 102, 102, 110, 106, 104, 104, 106, 108, 107),
             instrument = c("B", "B", "A", "A", "B", "B", "A", "B", "A", "A"))

by &lt;- list(j$instrument, sign(j$amount), as.Date(j$timestamp))
fun &lt;- function(x) {
    journal(timestamp = as.Date(x$timestamp[1]),
            amount = sum(x$amount),
            price = sum(x$amount*x$price)/sum(x$amount),
            instrument = x$instrument[1L])
}
aggregate(j, by = by, FUN = fun)


## *** iterate over transactions in (previously defined) journal ***
for (j in split(j, seq_along(j)))
    print(j)



## as.journal with numeric vector
as.journal(1:3)
##    amount
## 1       1
## 2       2
## 3       3
##
## 3 transactions

## as.journal with *named* numeric vector
x &lt;- 1:3; names(x) &lt;- LETTERS[1:3]
as.journal(x)
##    instrument  amount
## 1           A       1
## 2           B       2
## 3           C       3
##
## 3 transactions

x &lt;- 1:3; names(x) &lt;- c("A", "B", "A")
as.journal(x)
##    instrument  amount
## 1           A       1
## 2           B       2
## 3           A       3
##
## 3 transactions
</code></pre>


</div>
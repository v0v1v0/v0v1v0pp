<div class="container">

<table style="width: 100%;"><tr>
<td>model_formula</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Formulas with special terms in tidymodels</h2>

<h3>Description</h3>

<p>In R, formulas provide a compact, symbolic notation to specify model terms.
Many modeling functions in R make use of "specials",
or nonstandard notations used in formulas. Specials are defined and handled as
a special case by a given modeling package. For example, the mgcv package,
which provides support for
generalized additive models in R, defines a
function <code>s()</code> to be in-lined into formulas. It can be used like so:
</p>
<div class="sourceCode r"><pre>mgcv::gam(mpg ~ wt + s(disp, k = 5), data = mtcars)
</pre></div>
<p>In this example, the <code>s()</code> special defines a smoothing term that the mgcv
package knows to look for when preprocessing model input.
</p>
<p>The parsnip package can handle most specials without issue. The analogous
code for specifying this generalized additive model
with the parsnip "mgcv" engine
looks like:
</p>
<div class="sourceCode r"><pre>gen_additive_mod() %&gt;%
  set_mode("regression") %&gt;%
  set_engine("mgcv") %&gt;%
  fit(mpg ~ wt + s(disp, k = 5), data = mtcars)
</pre></div>
<p>However, parsnip is often used in conjunction with the greater tidymodels
package ecosystem, which defines its own pre-processing infrastructure and
functionality via packages like hardhat and recipes. The specials defined
in many modeling packages introduce conflicts with that infrastructure.
</p>
<p>To support specials while also maintaining consistent syntax elsewhere in
the ecosystem, <strong>tidymodels delineates between two types of formulas:
preprocessing formulas and model formulas</strong>. Preprocessing formulas specify
the input variables, while model formulas determine the model structure.
</p>


<h3>Example</h3>

<p>To create the preprocessing formula from the model formula, just remove
the specials, retaining references to input variables themselves. For example:
</p>
<div class="sourceCode"><pre>model_formula &lt;- mpg ~ wt + s(disp, k = 5)
preproc_formula &lt;- mpg ~ wt + disp
</pre></div>

<ul>
<li> <p><strong>With parsnip,</strong> use the model formula:
</p>
<div class="sourceCode r"><pre>model_spec &lt;-
  gen_additive_mod() %&gt;%
  set_mode("regression") %&gt;%
  set_engine("mgcv")

model_spec %&gt;%
  fit(model_formula, data = mtcars)
</pre></div>
</li>
<li> <p><strong>With recipes</strong>, use the preprocessing formula only:
</p>
<div class="sourceCode r"><pre>library(recipes)

recipe(preproc_formula, mtcars)
</pre></div>
<p>The recipes package supplies a large variety of preprocessing techniques
that may replace the need for specials altogether, in some cases.
</p>
</li>
<li> <p><strong>With workflows,</strong> use the preprocessing formula everywhere, but
pass the model formula to the <code>formula</code> argument in <code>add_model()</code>:
</p>
<div class="sourceCode r"><pre>library(workflows)

wflow &lt;-
  workflow() %&gt;%
  add_formula(preproc_formula) %&gt;%
  add_model(model_spec, formula = model_formula)

fit(wflow, data = mtcars)
</pre></div>
<p>The workflow will then pass the model formula to parsnip, using the
preprocessor formula elsewhere. We would still use the preprocessing
formula if we had added a recipe preprocessor using <code>add_recipe()</code>
instead a formula via <code>add_formula()</code>.
</p>
</li>
</ul>
</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>approxMaxMin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Approximate coordinate profile functions</h2>

<h3>Description</h3>

<p>Evaluate profile extrema over other variables with approximations at few values
</p>


<h3>Usage</h3>

<pre><code class="language-R">approxMaxMin(f, fprime = NULL, d, opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>the function to be evaluated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fprime</code></td>
<td>
<p>derivative of the function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>dimension of the input domain</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opts</code></td>
<td>
<p>a list containing the options for this function and the subfunctions getMax, getMin or getMaxMinMC, see documentation of getMax, getMin, getMaxMinMC for details. The options only for approxMaxMin are
</p>

<ul>
<li>
<p><code>limits:</code>an optional list with the upper and lower limits of each dimension, if NULL then for each dimension limits are 0,1
</p>
</li>
<li>
<p><code>smoother:</code>Select which smoother to use:a string that selects which smoother to use: </p>

<ul>
<li>
<p><code>"1order"</code>: first order interpolation with gradient
</p>
</li>
<li>
<p><code>"splineSmooth"</code>: smoothing spline with default degrees of freedom (DEFAULT OPTION)
</p>
</li>
<li>
<p><code>"quantSpline"</code>: profile inf and profile sup approximated with quantile spline regression at levels 0.1 and 0.9 respectively
</p>
</li>
</ul>
</li>
<li>
<p><code>heavyReturn:</code>If TRUE returns also all minimizers, default is FALSE.
</p>
</li>
<li>
<p><code>initDesign:</code>The design of few points where the expensive sup is evaluated.
</p>
</li>
<li>
<p><code>fullDesignSize:</code>The full design where the function is approximated.
</p>
</li>
<li>
<p><code>multistart:</code>number of multistarts for optim procedure.
</p>
</li>
<li>
<p><code>MonteCarlo:</code>if TRUE, computes sup with Monte Carlo procedure.
</p>
</li>
<li>
<p><code>numMCsamples:</code>number of MC samples for the sup.
</p>
</li>
<li>
<p><code>plts:</code>If TRUE, plots the max/min functions at each coordinate, default is FALSE.
</p>
</li>
<li>
<p><code>verb:</code>If TRUE, outputs intermediate results, default is FALSE.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list of two data frames (min, max) of the evaluations of <code class="reqn">f_sup(x_i) = sup_{x_j \neq i} f(x_1,\dots,x_d) </code> and <code class="reqn">f_inf(x_i) = inf_{x_j \neq i} f(x_1,\dots,x_d) </code>
for each i at the design Design. By default Design is a 100 equally spaced points for each dimension. It can be changed by defining it in options$Design
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
# Compute the coordinate profile extrema with full optimization on 2d example

# Define the function
g=function(x){
  return(-branin(x))
}
# Define the gradient
gprime = function(x){
  x1 = x[1]*15-5
  x2 = x[2]*15
  f1prime = (15*25)/(4*pi^4)*x1^3 - (15*75)/(2*pi^3)*x1^2 +
  (80*15)/(pi^2)*x1 - (5*15)/(pi^2)*x2*x1 +
  10*15/pi*x2 - 60*15/pi-10*15* (1 - 1/(8*pi))*sin(x1)
  f2prime = 2*15*(x2-5/(4*pi^2)*x1^2 +5/pi*x1-6)
  return(matrix(c(-f1prime,-f2prime),nrow=1))
}

# generic approximation options
init_des&lt;-lhs::maximinLHS(15,2)
options_approx&lt;- list(multistart=4,heavyReturn=TRUE,initDesign=init_des,fullDesignSize=100)

# 1order approximation
options_approx$smoother&lt;-"1order"
coordProf_approx_1order&lt;-approxMaxMin(f = g,fprime = gprime,d=2,opts = options_approx)

# quantile regression
options_approx$smoother&lt;-"quantSpline"
coordProf_approx_quantReg&lt;-approxMaxMin(f = g,fprime = gprime,d=2,opts = options_approx)



# Consider threshold=-10
threshold&lt;- -10
# obtain the points where the profiles take the threshold value
pp_change&lt;-getChangePoints(threshold = threshold,allRes = coordProf_approx_quantReg)
# evaluate g at a grid and plot the image
x&lt;-seq(0,1,,100)
grid&lt;-expand.grid(x,x)
g_evals&lt;- apply(X = grid,MARGIN = 1,FUN = g)
image(x = x,y = x,z = matrix(g_evals,nrow = 100),col = grey.colors(20))
contour(x=x,y=x,z=matrix(g_evals,nrow = 100), add=TRUE, nlevels = 20)
contour(x=x,y=x,z=matrix(g_evals,nrow = 100), add=TRUE, levels = threshold,col=2)
abline(h = pp_change$neverEx$`-10`[[2]],col="darkgreen",lwd=2)
abline(v = pp_change$neverEx$`-10`[[1]],col="darkgreen",lwd=2)
# Plot the coordinate profiles and a threshold
plotMaxMin(allRes = coordProf_approx_1order,threshold = threshold,changes = TRUE)
plotMaxMin(allRes = coordProf_approx_quantReg,threshold = threshold,changes = TRUE)

</code></pre>


</div>
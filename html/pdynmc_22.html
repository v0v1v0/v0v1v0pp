<div class="container">

<table style="width: 100%;"><tr>
<td>plot.pdynmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot Coefficient Estimates and Corresponding Ranges of Fitted Model.</h2>

<h3>Description</h3>

<p><code>plot.pdynmc</code> Plot methods for objects of class 'pdynmc'. The
available plot options visualize: Fitted values versus residuals,
coefficient ranges across GMM iterations, coefficient paths and
objective function values across GMM iterations as proposed by
Hansen and Lee (2021).
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'pdynmc'
plot(
  x,
  type = "fire",
  include.dum = FALSE,
  include.fur.con = FALSE,
  col.coefRange = 1,
  col.coefInitial = "darkgrey",
  col.coefEst = "royalblue",
  omit1step = FALSE,
  boxplot.coef = FALSE,
  co = NULL,
  add.se.approx = NULL,
  conf.lev = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class 'pdynmc'. The function requires
twostep or iterative GMM estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Whether to plot fitted values against residuals (argument
'fire'; default), coefficient ranges (argument 'coef.range';
this requires twostep or iterative GMM estimates), path of
coefficient estimates across GMM iterations (argument 'coef.path';
this requires twostep or iterative GMM estimates).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.dum</code></td>
<td>
<p>Include estimates of parameters corresponding to time
dummies (defaults to 'black'; requires 'type = coef.range').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.fur.con</code></td>
<td>
<p>Include estimates of parameters corresponding to
further controls (defaults to 'FALSE'; requires 'type = coef.range').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.coefRange</code></td>
<td>
<p>Specify color for plotting range of coefficient
estimates (defaults to 'NULL'; requires 'type = coef.range').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.coefInitial</code></td>
<td>
<p>Specify color for plotting initial coefficient
estimates (defaults to 'darkgrey'; requires 'type = coef.range').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.coefEst</code></td>
<td>
<p>Specify color for plotting coefficient estimate
(defaults to 'royalblue'; requires 'type = coef.range').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omit1step</code></td>
<td>
<p>Omit coefficient estimates from one-step GMM
estimation in coefficient range plot. The argument can after
obtaining coefficient estimates from numerical optimization
methods to exclude the randomly drawn starting values from the
plotted coefficient range (defaults to 'FALSE'). Set to 'TRUE' to
exert the option; this argument requires iterative GMM estimates
and argument 'type = coef.range'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boxplot.coef</code></td>
<td>
<p>Whether to draw boxplots for coefficient estimates
(defaults to 'FALSE'); requires iterative GMM with at least 10
iterations and argument 'type = coef.range'. Proceed with caution
as this argument is experimental.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>co</code></td>
<td>
<p>Character string denoting the variable name(s) for which to
plot the path of coefficient estimate(s) across GMM iterations
(defaults to 'NULL') as proposed in Hansen and Lee (2021);
if no coefficient name is given, all coefficient paths are plotted;
requires at least two iterations and argument 'type = coef.path'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.se.approx</code></td>
<td>
<p>A logical variable indicating if standard errors
should be added to the plot of the path of coefficient estimate(s)
across GMM iterations (defaults to 'NULL'); requires at least
two iterations and argument 'type = coef.path'. This option is
only available when plotting a single coefficient path (i.e.,
when 'co' contains only a single variable name).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.lev</code></td>
<td>
<p>A numeric variable indicating the confidence
level for approximating standard errors in the plot of the path
of coefficient estimate(s) across GMM iterations (defaults to
0.95; sensible values lie in the interval ]0,1[); requires
argument 'type = coef.path' and argument 'add.se.approx = TRUE'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Plot fitted values against residuals ('type = fire') or
coefficient estimates and coefficient estimate ranges
('type = coef.range') for object of class 'pdynmc'. The latter
plot requires twostep or iterative GMM estimates.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch and Joachim Schnurbus
</p>


<h3>References</h3>

<p>Hansen BE, Lee S (2021).
“Inference for Iterated GMM Under Misspecification.”
<em>Econometrica</em>, <b>89</b>(3), 1419–1447.
<a href="https://doi.org/10.3982/ECTA16274">doi:10.3982/ECTA16274</a>.
</p>


<h3>See Also</h3>

<p><code>pdynmc</code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "twostep",
    opt.meth = "none")
plot(m1)
plot(m1, type = "coef.range")
plot(m1, type = "coef.path")


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Further code example
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "iterative",
    opt.meth = "none")
 plot(m1)
 plot(m1, type = "coef.range")
 plot(m1, type = "coef.path")



</code></pre>


</div>
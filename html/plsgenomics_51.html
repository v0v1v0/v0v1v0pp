<div class="container">

<table style="width: 100%;"><tr>
<td>spls</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Adaptive Sparse Partial Least Squares (SPLS) regression</h2>

<h3>Description</h3>

<p>The function <code>spls.adapt</code> performs compression and variable selection 
in the context of linear regression (with possible prediction) 
using Durif et al. (2018) adaptive SPLS algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spls(
  Xtrain,
  Ytrain,
  lambda.l1,
  ncomp,
  weight.mat = NULL,
  Xtest = NULL,
  adapt = TRUE,
  center.X = TRUE,
  center.Y = TRUE,
  scale.X = TRUE,
  scale.Y = TRUE,
  weighted.center = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Xtrain</code></td>
<td>
<p>a (ntrain x p) data matrix of predictor values. 
<code>Xtrain</code> must be a matrix. Each row corresponds to an observation 
and each column to a predictor variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ytrain</code></td>
<td>
<p>a (ntrain) vector of (continuous) responses. <code>Ytrain</code> 
must be a vector or a one column matrix, and contains the response variable 
for each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.l1</code></td>
<td>
<p>a positive real value, in [0,1]. <code>lambda.l1</code> is the 
sparse penalty parameter for the dimension reduction step by sparse PLS 
(see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>a positive integer. <code>ncomp</code> is the number of PLS 
components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.mat</code></td>
<td>
<p>a (ntrain x ntrain) matrix used to weight the l2 metric 
in the observation space, it can be the covariance inverse of the Ytrain 
observations in a heteroskedastic context. If NULL, the l2 metric is the 
standard one, corresponding to homoskedastic model (<code>weight.mat</code> is the 
identity matrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xtest</code></td>
<td>
<p>a (ntest x p) matrix containing the predictor values for the 
test data set. <code>Xtest</code> may also be a vector of length p 
(corresponding to only one test observation). Default value is NULL, 
meaning that no prediction is performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt</code></td>
<td>
<p>a boolean value, indicating whether the sparse PLS selection 
step sould be adaptive or not (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center.X</code></td>
<td>
<p>a boolean value indicating whether the data matrices 
<code>Xtrain</code> and <code>Xtest</code> (if provided) should be centered or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center.Y</code></td>
<td>
<p>a boolean value indicating whether the response values 
<code>Ytrain</code> set should be centered or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.X</code></td>
<td>
<p>a boolean value indicating whether the data matrices 
<code>Xtrain</code> and <code>Xtest</code> (if provided) should be scaled or not 
(<code>scale.X=TRUE</code> implies <code>center.X=TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.Y</code></td>
<td>
<p>a boolean value indicating whether the response values 
<code>Ytrain</code> should be scaled or not (<code>scale.Y=TRUE</code> implies 
<code>center.Y=TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted.center</code></td>
<td>
<p>a boolean value indicating whether the centering 
should take into account the weighted l2 metric or not 
(if TRUE, it requires that weighted.mat is non NULL).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The columns of the data matrices <code>Xtrain</code> and <code>Xtest</code> may 
not be standardized, since standardizing can be performed by the function 
<code>spls</code> as a preliminary step.
</p>
<p>The procedure described in Durif et al. (2018) is used to compute 
latent sparse components that are used in a regression model.
In addition, when a matrix <code>Xtest</code> is supplied, the procedure 
predicts the response associated to these new values of the predictors.
</p>


<h3>Value</h3>

<p>An object of class <code>spls</code> with the following attributes
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Xtrain</code></td>
<td>
<p>the ntrain x p predictor matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ytrain</code></td>
<td>
<p>the response observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sXtrain</code></td>
<td>
<p>the centered if so and scaled if so predictor matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sYtrain</code></td>
<td>
<p>the centered if so and scaled if so response.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betahat</code></td>
<td>
<p>the linear coefficients in model 
<code>sYtrain = sXtrain %*% betahat + residuals</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betahat.nc</code></td>
<td>
<p>the (p+1) vector containing the coefficients and intercept 
for the non centered and non scaled model 
<code>Ytrain = cbind(rep(1,ntrain),Xtrain) %*% betahat.nc + residuals.nc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanXtrain</code></td>
<td>
<p>the (p) vector of Xtrain column mean, 
used for centering if so.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmaXtrain</code></td>
<td>
<p>the (p) vector of Xtrain column standard deviation, 
used for scaling if so.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanYtrain</code></td>
<td>
<p>the mean of Ytrain, used for centering if so.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmaYtrain</code></td>
<td>
<p>the standard deviation of Ytrain, used for centering 
if so.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.score</code></td>
<td>
<p>a (n x ncomp) matrix being the observations coordinates or 
scores in the new component basis produced by the compression step 
(sparse PLS). Each column t.k of <code>X.score</code> is a SPLS component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.score.low</code></td>
<td>
<p>a (n x ncomp) matrix being the PLS components only 
computed with the selected predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.loading</code></td>
<td>
<p>the (ncomp x p) matrix of coefficients in regression of 
Xtrain over the new components <code>X.score</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y.loading</code></td>
<td>
<p>the (ncomp) vector of coefficients in regression of Ytrain 
over the SPLS components <code>X.score</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.weight</code></td>
<td>
<p>a (p x ncomp) matrix being the coefficients of predictors 
in each components produced by sparse PLS. Each column w.k of 
<code>X.weight</code> verifies t.k = Xtrain x w.k (as a matrix product).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>the (ntrain) vector of residuals in the model 
<code>sYtrain = sXtrain %*% betahat + residuals</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals.nc</code></td>
<td>
<p>the (ntrain) vector of residuals in the non centered 
and non scaled model 
<code>Ytrain = cbind(rep(1,ntrain),Xtrain) %*% betahat.nc + residuals.nc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hatY</code></td>
<td>
<p>the (ntrain) vector containing the estimated reponse values 
on the train set of centered and scaled (if so) predictors 
<code>sXtrain</code>, <code>hatY = sXtrain %*% betahat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hatY.nc</code></td>
<td>
<p>the (ntrain) vector containing the estimated reponse value 
on the train set of non centered and non scaled predictors <code>Xtrain</code>, 
<code>hatY.nc = cbind(rep(1,ntrain),Xtrain) %*% betahat.nc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hatYtest</code></td>
<td>
<p>the (ntest) vector containing the predicted values 
for the response on the centered and scaled test set <code>sXtest</code>
(if provided), <code>hatYtest = sXtest %*% betahat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hatYtest.nc</code></td>
<td>
<p>the (ntest) vector containing the predicted values 
for the response on the non centered and non scaled test set <code>Xtest</code> 
(if provided), 
<code>hatYtest.nc = cbind(rep(1,ntest),Xtest) %*% betahat.nc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>the active set of predictors selected by the procedures. <code>A</code> 
is a subset of <code>1:p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betamat</code></td>
<td>
<p>a (ncomp) list of coefficient vector betahat in the model 
with <code>k</code> components, for <code>k=1,...,ncomp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new2As</code></td>
<td>
<p>a (ncomp) list of subset of <code>(1:p)</code> indicating the 
variables that are selected when constructing the 
components <code>k</code>, for <code>k=1,...,ncomp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.l1</code></td>
<td>
<p>the sparse hyper-parameter used to fit the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>the number of components used to fit the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>the (ntrain x ntrain) matrix used to weight the metric in 
the sparse PLS step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt</code></td>
<td>
<p>a boolean value, indicating whether the sparse PLS selection 
step was adaptive or not.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Ghislain Durif (<a href="https://gdurif.perso.math.cnrs.fr/">https://gdurif.perso.math.cnrs.fr/</a>). 
</p>
<p>Adapted in part from spls code by H. Chun, D. Chung and S.Keles 
(<a href="https://CRAN.R-project.org/package=spls">https://CRAN.R-project.org/package=spls</a>).
</p>


<h3>References</h3>

<p>Durif, G., Modolo, L., Michaelsson, J., Mold, J.E., Lambert-Lacroix, S., 
Picard, F., 2018. High dimensional classification with combined 
adaptive sparse PLS and logistic regression. Bioinformatics 34, 
485–493. <a href="https://doi.org/10.1093/bioinformatics/btx571">doi:10.1093/bioinformatics/btx571</a>.
Available at <a href="http://arxiv.org/abs/1502.05933">http://arxiv.org/abs/1502.05933</a>.
</p>
<p>Chun, H., &amp; Keles, S. (2010). Sparse partial least squares regression for 
simultaneous dimension reduction and variable selection.  Journal of the 
Royal Statistical Society. Series B (Methodological), 72(1), 3-25. 
doi:10.1111/j.1467-9868.2009.00723.x
</p>


<h3>See Also</h3>

<p><code>spls.cv</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">### load plsgenomics library
library(plsgenomics)

### generating data
n &lt;- 100
p &lt;- 100
sample1 &lt;- sample.cont(n=n, p=p, kstar=10, lstar=2, beta.min=0.25, 
                       beta.max=0.75, mean.H=0.2, sigma.H=10, 
                       sigma.F=5, sigma.E=5)
X &lt;- sample1$X
Y &lt;- sample1$Y
### splitting between learning and testing set
index.train &lt;- sort(sample(1:n, size=round(0.7*n)))
index.test &lt;- (1:n)[-index.train]
Xtrain &lt;- X[index.train,]
Ytrain &lt;- Y[index.train,]
Xtest &lt;- X[index.test,]
Ytest &lt;- Y[index.test,]

### fitting the model, and predicting new observations
model1 &lt;- spls(Xtrain=Xtrain, Ytrain=Ytrain, lambda.l1=0.5, ncomp=2, 
               weight.mat=NULL, Xtest=Xtest, adapt=TRUE, center.X=TRUE, 
               center.Y=TRUE, scale.X=TRUE, scale.Y=TRUE, 
               weighted.center=FALSE)

str(model1)

### plotting the estimation versus real values for the non centered response
plot(model1$Ytrain, model1$hatY.nc, 
     xlab="real Ytrain", ylab="Ytrain estimates")
points(-1000:1000,-1000:1000, type="l")

### plotting residuals versus centered response values
plot(model1$sYtrain, model1$residuals, xlab="sYtrain", ylab="residuals")

### plotting the predictor coefficients
plot(model1$betahat.nc, xlab="variable index", ylab="coeff")

### mean squares error of prediction on test sample
sYtest &lt;- as.matrix(scale(Ytest, center=model1$meanYtrain, scale=model1$sigmaYtrain))
sum((model1$hatYtest - sYtest)^2) / length(index.test)

### plotting predicted values versus non centered real response values 
## on the test set
plot(model1$hatYtest, sYtest, xlab="real Ytest", ylab="predicted values")
points(-1000:1000,-1000:1000, type="l")

</code></pre>


</div>
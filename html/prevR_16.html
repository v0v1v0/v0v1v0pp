<div class="container">

<table style="width: 100%;"><tr>
<td>krige,ANY,prevR-method</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatial interpolation (kriging and inverse distance weighting) for objects
of class prevR.</h2>

<h3>Description</h3>

<p>These functions execute a spatial interpolation of a variable of the slot
<code>rings</code> of an object of class prevR. The method <code>krige()</code>
implements the ordinary kriging technique. The method <code>idw()</code> executes
an inverse distance weighting interpolation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'ANY,prevR'
krige(
  formula,
  locations,
  N = NULL,
  R = Inf,
  model = NULL,
  nb.cells = 100,
  cell.size = NULL,
  fit = "auto",
  keep.variance = FALSE,
  show.variogram = FALSE,
  ...
)

## S4 method for signature 'ANY,prevR'
idw(
  formula,
  locations,
  N = NULL,
  R = Inf,
  nb.cells = 100,
  cell.size = NULL,
  idp = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>variable(s) to interpolate (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locations</code></td>
<td>
<p>object of class prevR.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>integer or list of integers corresponding to the rings to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>integer or list of integers corresponding to the rings to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a variogram model returned by the function <code>gstat::vgm()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb.cells</code></td>
<td>
<p>number of cells on the longest side of the studied area
(unused if <code>cell.size</code> is defined).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell.size</code></td>
<td>
<p>size of each cell (in the unit of the projection).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p><code>"auto"</code> for using a variogram automatically fitted from the data,
only if <code>model</code> is not defined (<code>NULL</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.variance</code></td>
<td>
<p>return variance of estimates?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.variogram</code></td>
<td>
<p>plot the variogram?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments transmitted to <code>gstat::krige()</code>
or <code>gstat::idw()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idp</code></td>
<td>
<p>inverse distance weighting power (see <code>gstat::idw()</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>formula</code> specifies the variable(s) to interpolate. Only variables
available in the slot <code>rings</code> of <code>locations</code> could be used. Possible values
are <code>"r.pos"</code>, <code>"r.n"</code>, <code>"r.prev"</code>, <code>"r.radius"</code>, <code>"r.clusters"</code>, <code>"r.wpos"</code>,
<code>"r.wn"</code> or <code>"r.wprev"</code>. Variables could be specified with a character
string or a formula (example: <code style="white-space: pre;">⁠list(r.pos ~ 1, r.prev ~ 1}⁠</code>. Only formula
like <code>variable.name ~ 1</code> are accepted. For more complex interpolations,
use directly functions <code>gstat::krige()</code> and <code>gstat::idw()</code> from <span class="pkg">gstat</span>.
</p>
<p><code>N</code> and <code>R</code> determine the rings to use for the interpolation. If they are
not defined, surfaces will be estimated for each available couples (N,R).
Several interpolations could be simultaneously calculated if several
variables and/or several values of N and R are defined.
</p>
<p>A suggested value of N could be computed with <code>Noptim()</code>.
</p>
<p>In the case of an ordinary kriging, the method <code>krige()</code> from <span class="pkg">prevR</span>
will try to fit automatically a exponential variogram to the sample variogram
(<code>fit = "auto"</code>). You can also specify directly the variogram to use with
the parameter <code>model</code>.
</p>
<p>Interpolations are calculated on a spatial grid obtained with
<code>make.grid.prevR()</code>.
</p>


<h3>Value</h3>

<p>Object of class sf::sf.
The name of estimated surfaces depends on the name of the interpolated
variable, N and R (for example: <em>r.radius.N300.RInf</em>).
If you ask the function to return variance (<code>keep.variance=TRUE</code>),
corresponding surfaces names will have the suffix <em>.var</em>.
</p>


<h3>Note</h3>

<p>Results could be plotted with <code>sf::plot()</code> or with <span class="pkg">ggplot2</span>
using <code>ggplot2::geom_sf()</code>. See examples.
</p>
<p><span class="pkg">prevR</span> provides several continuous color palettes
(see prevR.colors).
</p>
<p>Results could be turned into a <span class="pkg">stars</span> raster using
<code>stars::st_rasterize()</code>.
</p>
<p>To export to ASCII grid, rasterize the results with <code>stars::st_rasterize()</code>,
convert to <code>SpatRast</code> with <code>terra::rast()</code>, extract the desired layer with
<code style="white-space: pre;">⁠[[]]⁠</code> and then use <code>terra::writeRaster()</code>. See examples.
</p>


<h3>References</h3>

<p>Larmarange Joseph, Vallo Roselyne, Yaro Seydou, Msellati Philippe and Meda
Nicolas (2011) "Methods for mapping regional trends of HIV prevalence from
Demographic and Health Surveys (DHS)",
<em>Cybergeo: European Journal of Geography</em>, no 558,
<a href="https://journals.openedition.org/cybergeo/24606">https://journals.openedition.org/cybergeo/24606</a>,
DOI: 10.4000/cybergeo.24606.
</p>


<h3>See Also</h3>

<p><code>gstat::krige()</code>, <code>gstat::idw()</code>, <code>rings()</code>, <code>Noptim()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  ## Not run: 
    dhs &lt;- rings(fdhs, N = c(100,200,300,400,500))
    radius.N300 &lt;- krige('r.radius', dhs, N = 300, nb.cells = 50)
    prev.krige &lt;- krige(r.wprev ~ 1, dhs, N = c(100, 300, 500))

    plot(prev.krige, lty = 0)

    library(ggplot2)
    ggplot(prev.krige) +
      aes(fill = r.wprev.N300.RInf) +
      geom_sf(colour = "transparent") +
      scale_fill_gradientn(colors = prevR.colors.red()) +
      theme_prevR_light()

    # Export r.wprev.N300.RInf surface in ASCII Grid
    r &lt;- terra::rast(stars::st_rasterize(prev.krige))
    # writeRaster(r[[2]], "wprev.N300.asc")
  
## End(Not run)

</code></pre>


</div>
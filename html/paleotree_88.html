<div class="container">

<table style="width: 100%;"><tr>
<td>minBranchLength</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Scales Edge Lengths of a Phylogeny to a Minimum Branch Length</h2>

<h3>Description</h3>

<p>Rescales a tree with edge lengths so that all edge lengths
are at least some minimum branch length 
(sometimes abbreviated as "<code>MBL</code>" or "<code>mbl</code>").
Edge lengths are transformed so they are
greater than or equal to the input minimum branch length, by
subtracting edge length from more root-ward edges
and added to later branches. 
This may or may not change the age of the root divergence, depending on the
distribution of short branch lengths close to the root.
</p>


<h3>Usage</h3>

<pre><code class="language-R">minBranchLength(tree, mbl, modifyRootAge = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>
<p>A phylogeny with edge lengths of class <code>phylo</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mbl</code></td>
<td>
<p>The minimum branch length</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modifyRootAge</code></td>
<td>
<p>If <code>TRUE</code> (the default), the input tree is checked for
a root age given as <code>$root.time</code> and if present it is checked
and fixed for any possible movement backwards due to short
branches close to the root node.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function was formally an internal segment in
<code>timePaleoPhy</code>, and now is called by <code>timePaleoPhy</code>
instead, allowing users to apply <code>minBranchLength</code>
to trees that already have edge lengths.
</p>


<h3>Value</h3>

<p>A phylogeny with edge lengths of class <code>phylo</code>.
</p>


<h3>Author(s)</h3>

<p>David W. Bapst
</p>


<h3>See Also</h3>

<p>This function was originally an internal
piece of <code>timePaleoPhy</code>,
which implements the minimum branch
length time-scaling method along with others,
which may be what you're looking for
(instead of this miscellaneous function).
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#simulation with an example non-ultrametric tree

tree &lt;- rtree(20)
# randomly replace edges with ZLBs
   # similar to multi2di output
tree &lt;- degradeTree(tree,0.3,
   leave.zlb = TRUE) 	

tree2 &lt;- minBranchLength(tree,0.1)

layout(1:2)

plot(tree)
axisPhylo()
plot(tree2)
axisPhylo()

layout(1)


#now let's try it with an ultrametric case

# get a random tree
tree &lt;- rtree(30)
# randomly replace edges with ZLBs
   # similar to multi2di output
tree &lt;- degradeTree(tree,0.5,leave.zlb = TRUE) 
# now randomly resolve	
tree &lt;- di2multi(tree)
# give branch lengths so its ultrametric
tree &lt;- compute.brlen(tree)

# and we have an ultrametric tree with polytomies, yay!
plot(tree) 

# now randomly resolve
tree2 &lt;- multi2di(tree)
# get new branch lengths as would with real data
tree2 &lt;- minBranchLength(tree2,0.1)

layout(1:2)
plot(tree,show.tip.label = FALSE)
axisPhylo()
plot(tree2,show.tip.label = FALSE)
axisPhylo()

layout(1)

# check that root ages aren't being left unmodified
   # create a tree with lots of ZBLs at the root
x &lt;- stree(10)
x$edge.length &lt;- runif(Nedge(x))
x &lt;- multi2di(x)
# give it a root age
x$root.time &lt;- max(node.depth.edgelength(x))

z &lt;- minBranchLength(tree = x, mbl = 1)
plot(z)

</code></pre>


</div>
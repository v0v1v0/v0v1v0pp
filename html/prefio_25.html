<div class="container">

<table style="width: 100%;"><tr>
<td>preferences</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Preferences Object</h2>

<h3>Description</h3>

<p>Create a <code>preferences</code> object for representing Ordinal Preference datasets.
</p>


<h3>Usage</h3>

<pre><code class="language-R">preferences(
  data,
  format = c("long", "ordering", "ranking"),
  id = NULL,
  rank = NULL,
  item = NULL,
  item_names = NULL,
  frequencies = NULL,
  aggregate = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'preferences'
x[i, j, ..., by.rank = FALSE, as.ordering = FALSE]

as.preferences(x, ...)

## S3 method for class 'grouped_preferences'
as.preferences(x, aggregate = FALSE, verbose = TRUE, ...)

## Default S3 method:
as.preferences(
  x,
  format = c("long", "ranking", "ordering"),
  id = NULL,
  item = NULL,
  rank = NULL,
  item_names = NULL,
  aggregate = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'matrix'
as.preferences(
  x,
  format = c("long", "ranking"),
  id = NULL,
  item = NULL,
  rank = NULL,
  item_names = NULL,
  aggregate = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'aggregated_preferences'
as.preferences(x, ...)

## S3 method for class 'preferences'
format(x, width = 40L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame or matrix in one of three formats:
</p>

<dl>
<dt>"ordering"</dt>
<dd>
<p>Orderings must be a data frame with list-valued
columns. Each row represents an ordering of the items
from first to last, representing ties by a list of
vectors corresponding to the items.</p>
</dd>
<dt>"ranking"</dt>
<dd>
<p>Each row assigns a rank to each item, with columns
representing items.  Note that rankings will be converted
to 'dense' rankings in the output (see Details).</p>
</dd>
<dt>"long"</dt>
<dd>
<p>Three columns: an <code>id</code> column grouping the rows which
correspond to a single set of preferences, an
<code>item</code> column specifying (either by index or by
name) the item each row refers to, and a <code>rank</code>
column specifying the rank for the associated
item.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format</code></td>
<td>
<p>The format of the data: one of "ordering", "ranking", or
"long" (see above). By default, <code>data</code> is assumed to be in "long" format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>For <code>data</code> in long-format: the column representing the
preference set grouping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>For <code>data</code> in long-format: the column representing the
rank for the associated item.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item</code></td>
<td>
<p>For <code>data</code> in long-format: the column representing
the items by name or by index, in which case the
<code>item_names</code> parameter should also be passed, or the items will be named as
integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item_names</code></td>
<td>
<p>The names of the full set of items. When loading data using
integer-valued indices in place of item names, the <code>item_names</code> character
vector should be in the correct order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frequencies</code></td>
<td>
<p>An optional integer vector containing the number of
occurences of each preference. If provided, the method will return a
<code>aggregated_preferences</code> object with the
corresponding frequencies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate</code></td>
<td>
<p>If <code>TRUE</code>, aggregate the preferences via
<code>aggregate.preferences</code> before returning. This
returns an <code>aggregated_preferences</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, diagnostic messages will be sent to stdout.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Unused.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The <code>preferences</code> object to subset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>The index of the preference-set to access.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>j</code></td>
<td>
<p>The item names or indices to project onto, e.g. if <code>j = 1</code> the
preferences will be projected only onto the first item; if <code>by.rank = TRUE</code>
<code>j</code> corresponds to the rank of the items to subset to, e.g. if <code>j = 1</code> then
preferences will be truncated to only contain their highest-preference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by.rank</code></td>
<td>
<p>When <code>FALSE</code>, the index <code>j</code> corresponds to items, when true
the index corresponds to rank.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.ordering</code></td>
<td>
<p>When <code>FALSE</code>, returns a <code>preferences</code> object:
internally rows <code class="reqn">i</code> contain the ranking assigned to each item
in preference <code class="reqn">p_i</code>. When <code>TRUE</code>, returns a data frame where
columns group the items by rank.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>The width in number of characters to format each preference,
truncating by "..." when they are too long.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Ordinal preferences can order every item, or they can order a subset. Some
ordinal preference datasets will contain ties between items at a given rank.
Hence, there are four distinct types of preferential data:
</p>

<dl>
<dt><code>soc</code></dt>
<dd>
<p>Strict Orders - Complete List</p>
</dd>
<dt><code>soi</code></dt>
<dd>
<p>Strict Orders - Incomplete List</p>
</dd>
<dt><code>toc</code></dt>
<dd>
<p>Orders with Ties - Complete List</p>
</dd>
<dt><code>toi</code></dt>
<dd>
<p>Orders with Ties - Incomplete List</p>
</dd>
</dl>
<p>The data type is stored alongside the <code>preferences</code> as an attribute
<code>attr(preferences, "preftype")</code>. The data type is determined automatically.
If every preference ranks every item, then the data type will be
"soc" or "soi". Similarly, if no preference contains a tie the data type
will be "toc" or "toi".
</p>
<p>A set of preferences can be represented either by <code>ranking</code> or by
<code>ordering</code>. These correspond to the two ways you can list a set of
preferences in a vector:
</p>

<dl>
<dt><code>ordering</code></dt>
<dd>
<p>The items are listed in order of most preferred to least
preferred, allowing for multiple items being in the
same place in the case of ties.</p>
</dd>
<dt><code>ranking</code></dt>
<dd>
<p>A rank is assigned to each item.  Conventionally, ranks are
integers in increasing order (with larger values
indicating lower preference), but they can be any
ordinal values.  Any given rankings will be converted
to 'dense' rankings: positive integers from 1 to some
maximum rank, with no gaps between ranks.</p>
</dd>
</dl>
<p>When reading preferences from an <code>ordering</code> matrix, the index on the
items is the order passed to the <code>item_names</code> parameter. When reading from
a <code>rankings</code> matrix, if no <code>item_names</code> are provided, the order is inferred
from the named columns.
</p>
<p>A <code>preferences</code> object can also be read from a long-format matrix, where
there are three columns: <code>id</code>, <code>item</code> and <code>rank</code>. The <code>id</code> variable groups
the rows of the matrix which correspond to a single set of preferences, which
the <code>item:rank</code>, pairs indicate how each item is ranked. When reading a
matrix from this format and no <code>item_names</code> parameter is passed, the order is
determined automatically.
</p>


<h3>Value</h3>

<p>By default, a <code>preferences</code> object, which is a data frame with
list-valued columns corresponding to preferences on the items. This may
be an ordering on subsets of the items in the case of ties, or a
potentially-partial strict ordering. In the case of partial or tied
preferences, some entries may be empty lists.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># create rankings from data in long form

# Example long-form data
x &lt;- data.frame(
  id = c(rep(1:4, each = 4), 5, 5, 5),
  item = c(
    LETTERS[c(1:3, 3, 1:4, 2:5, 1:2, 1)], NA,
    LETTERS[3:5]
  ),
  rank = c(4:1, rep(NA, 4), 3:4, NA, NA, 1, 3, 4, 2, 2, 2, 3)
)

# * Set #1 has two different ranks for the same item (item C
# has rank 1 and 2). This item will be excluded from the preferences.
# * All ranks are missing in set #2, a technically valid partial ordering
# * Some ranks are missing in set #3, a perfectly valid partial ordering
# * Set #4 has inconsistent ranks for two items, and a rank with a
# missing item.
# * Set #5 is not a dense ranking. It will be converted to be dense and then
# inferred to be a regular partial ordering with ties.
split(x, x$rank)

# Creating a preferences object with this data will attempt to resolve these
# issues automatically, sending warnings when assumptions need to be made.
preferences(x, id = "id", item = "item", rank = "rank")

# Convert an existing matrix of rankings to a preferences object.
rnk &lt;- matrix(c(
  1, 2, 0, 0,
  4, 1, 2, 3,
  2, 1, 1, 1,
  1, 2, 3, 0,
  2, 1, 1, 0,
  1, 0, 3, 2
), nrow = 6, byrow = TRUE)
colnames(rnk) &lt;- c("apple", "banana", "orange", "pear")

rnk &lt;- as.preferences(rnk, format = "ranking")

# Convert an existing data frame of orderings to a preferences object.
e &lt;- character() # short-hand for empty ranks
ord &lt;- preferences(
  as.data.frame(
    rbind(
      list(1, 2, e, e), # apple, banana
      list("banana", "orange", "pear", "apple"),
      list(c("banana", "orange", "pear"), "apple", e, e),
      list("apple", "banana", "orange", e),
      list(c("banana", "orange"), "apple", e, e),
      list("apple", "pear", "orange", e)
    )
  ),
  format = "ordering",
  item_names = c("apple", "banana", "orange", "pear")
)

# Access the first three sets of preferences
ord[1:3, ]

# Truncate preferences to the top 2 ranks
ord[, 1:2, by_rank = TRUE]

# Exclude pear from the rankings
ord[, -4]

# Get the highest-ranked items and return as a data.frame of orderings
ord[, 1, by_rank = TRUE, as.ordering = TRUE]

# Convert the preferences to a ranking matrix
as.matrix(ord)

# Get the rank of apple in the third preference-set
as.matrix(ord)[3, 1]

# Get all the ranks assigned to apple as a vector
as.matrix(ord)[, "apple"]

</code></pre>


</div>
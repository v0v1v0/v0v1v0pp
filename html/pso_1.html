<div class="container">

<table style="width: 100%;"><tr>
<td>pso-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
A Particle Swarm Optimizer
</h2>

<h3>Description</h3>

<p>The package provides an implementation of particle swarm optimization
which is consistent with the standard
PSO 2007 and 2011 by Maurice Clerc et al. Additionally a number of ancillary
routines are provided for easy testing and graphics.
</p>


<h3>Details</h3>


<table>
<tr>
<td style="text-align: left;">
Package: </td>
<td style="text-align: left;"> pso</td>
</tr>
<tr>
<td style="text-align: left;">
Type: </td>
<td style="text-align: left;"> Package</td>
</tr>
<tr>
<td style="text-align: left;">
Version: </td>
<td style="text-align: left;"> 1.0.4</td>
</tr>
<tr>
<td style="text-align: left;">
Date: </td>
<td style="text-align: left;"> 2022-04-12</td>
</tr>
<tr>
<td style="text-align: left;">
License: </td>
<td style="text-align: left;"> LGPL-3</td>
</tr>
<tr>
<td style="text-align: left;">
Depends: </td>
<td style="text-align: left;"> methods</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>The core function in the package is <code>psoptim</code> which can be
used as a drop in replacement for <code>optim</code>. When used without
additional control parameters the implementation is intended to be
equivalent to SPSO 2007 (by M. Clerc et al.).
</p>
<p>Control parameters can be specified for SPSO 2011 (in its basic
implementation), to clamp the maximal velocity, provide restarting
when the swarm converges to a region as well as using BFGS as a local
search strategy. See <code>psoptim</code> for details.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Claus Bendtsen &lt;papyrus.bendtsen@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code>optim</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Some examples of using the functions in the package

## Using basic "optim" interface to minimize a function
set.seed(1)
psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
        lower=-5,upper=5,control=list(abstol=1e-8))

## Parabola
p &lt;- test.problem("parabola",10) # one local=global minimum
set.seed(1)
o1 &lt;- psoptim(p,control=list(trace=1,REPORT=50))
show(o1)

set.seed(1)
o2 &lt;- psoptim(p,control=list(trace=1,REPORT=50,w=c(.7,.1)))
show(o2)

set.seed(1)
o3 &lt;- psoptim(p,control=list(trace=1,REPORT=1,hybrid=TRUE))
show(o3) ## hybrid much faster

## Griewank
set.seed(2)
p &lt;- test.problem("griewank",10) # lots of local minima
o1 &lt;- psoptim(p,control=list(trace=1,REPORT=50))
show(o1)

## The above sometimes get stuck in a local minima.
## Adding a restart to increase robustness.
set.seed(2)
o2 &lt;- psoptim(p,control=list(trace=1,REPORT=50,reltol=1e-4))
show(o2)

## An then adding the hybrid
set.seed(2)
o3 &lt;- psoptim(p,control=list(trace=1,REPORT=50,reltol=1e-4,
              hybrid=TRUE,hybrid.control=list(maxit=10)))
show(o3)

## Rosenbrock
set.seed(1)
p &lt;- test.problem("rosenbrock",1)
o1 &lt;- psoptim(p,control=list(trace=1,REPORT=50))
show(o1)

## Change to fully informed
set.seed(1)
o2 &lt;- psoptim(p,control=list(trace=1,REPORT=50,p=1))
show(o2)

## Rastrigin
p &lt;- test.problem("rastrigin",10)
set.seed(1)
o1 &lt;- psoptim(p,control=list(trace=1,REPORT=50))
show(o1)

set.seed(1)
o2 &lt;- psoptim(p,control=list(trace=1,REPORT=50,hybrid=TRUE,
              hybrid.control=list(maxit=10)))
show(o2) # better
plot(o1,xlim=c(0,p@maxf),ylim=c(0,100))
lines(o2,col=2) # and much faster convergence

## Ackley
set.seed(1)
p &lt;- test.problem("ackley",10)
o1 &lt;- psoptim(p,control=list(trace=1,REPORT=50))
show(o1)

## End(Not run)</code></pre>


</div>
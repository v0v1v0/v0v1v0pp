<div class="container">

<table style="width: 100%;"><tr>
<td>solar_time</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Local solar time</h2>

<h3>Description</h3>

<p><code>solar_time()</code> computes the time of day expressed in seconds since the
astronomical midnight using and instant in time and a geocode as input. Solar
time is useful when we want to plot data according to the local solar time
rather than the local time in use at a time zone. How the returned instant in
time is expressed depends on the argument passed to <code>unit.out</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">solar_time(
  time = lubridate::now(),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  unit.out = "time"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>POSIXct Time, any valid time zone (TZ) is allowed, default is
current time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geocode</code></td>
<td>
<p>data frame with variables lon and lat as numeric values
(degrees).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit.out</code></td>
<td>
<p>character string, One of "datetime", "time", "hour", "minute", or
"second".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Solar time is determined by the position of the sun in the sky and
it almost always differs from the time expressed in the local time
coordinates in use. The differences can vary from a few minutes up to a
couple of hours depending on the exact location within the time zone and the
use or not of daylight saving time.
</p>


<h3>Value</h3>

<p>In all cases solar time is expressed as time since local astronomical
midnight and, thus, lacks date information. If <code>unit.out = "time"</code>, a
numeric value in seconds with an additional class attribute
"solar_time"; if <code>unit.out = "datetime"</code>, a "POSIXct" value in seconds
from midnight but with an additional class attribute "solar_date"; if
<code>unit.out = "hour"</code> or <code>unit.out = "minute"</code> or <code>unit.out =
  "second"</code>, a numeric value.
</p>


<h3>Warning!</h3>

<p>Returned values are computed based on the time zone of the
argument for parameter time. In the case of solar time, this timezone does
not affect the result. However, in the case of solar dates the date part
may be off by one day, if the time zone does not match the coordinates of
the geocode value provided as argument.
</p>


<h3>Note</h3>

<p>The algorithm is approximate, it calculates the difference between
local solar noon and noon in the time zone of <code>time</code> and uses this
value for the whole day when converting times into solar time. Days are not
exactly 24 h long. Between successive days the shift is only a few seconds,
and this leads to a small jump at midnight.
</p>


<h3>See Also</h3>

<p><code>as_tod</code>
</p>
<p>Other Local solar time functions: 
<code>as.solar_date()</code>,
<code>is.solar_time()</code>,
<code>print.solar_time()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">BA.geocode &lt;-
  data.frame(lon = -58.38156, lat = -34.60368, address = "Buenos Aires, Argentina")
sol_t &lt;- solar_time(lubridate::dmy_hms("21/06/2016 10:00:00", tz = "UTC"),
                    BA.geocode)
sol_t
class(sol_t)

sol_d &lt;- solar_time(lubridate::dmy_hms("21/06/2016 10:00:00", tz = "UTC"),
                    BA.geocode,
                    unit.out = "datetime")
sol_d
class(sol_d)

</code></pre>


</div>
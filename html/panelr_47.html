<div class="container">

<table style="width: 100%;"><tr>
<td>wbm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Panel regression models fit via multilevel modeling</h2>

<h3>Description</h3>

<p>Fit "within-between" and several other regression variants
for panel data in a multilevel modeling framework.
</p>


<h3>Usage</h3>

<pre><code class="language-R">wbm(
  formula,
  data,
  id = NULL,
  wave = NULL,
  model = "w-b",
  detrend = FALSE,
  use.wave = FALSE,
  wave.factor = FALSE,
  min.waves = 2,
  family = gaussian,
  balance.correction = FALSE,
  dt.random = TRUE,
  dt.order = 1,
  pR2 = TRUE,
  pvals = TRUE,
  t.df = "Satterthwaite",
  weights = NULL,
  offset = NULL,
  interaction.style = c("double-demean", "demean", "raw"),
  scale = FALSE,
  scale.response = FALSE,
  n.sd = 1,
  dt_random = dt.random,
  dt_order = dt.order,
  balance_correction = balance.correction,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Model formula. See details for crucial
info on <code>panelr</code>'s formula syntax.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data, either a <code>panel_data</code> object or <code>data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
individual id column as a string. Otherwise, leave as NULL, the default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wave</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
panel wave column as a string. Otherwise, leave as NULL, the default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>One of <code>"w-b"</code>, <code>"within"</code>, <code>"between"</code>,
<code>"contextual"</code>. See details for more on these options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detrend</code></td>
<td>
<p>Adjust within-subject effects for trends in the predictors?
Default is FALSE, but some research suggests this is a better idea
(see Curran and Bauer (2011) reference).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.wave</code></td>
<td>
<p>Should the wave be included as a predictor? Default is
FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wave.factor</code></td>
<td>
<p>Should the wave variable be treated as an unordered
factor instead of continuous? Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.waves</code></td>
<td>
<p>What is the minimum number of waves an individual must
have participated in to be included in the analysis? Default is <code>2</code> and
any valid number is accepted. <code>"all"</code> is also acceptable if you want to
include only complete panelists.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Use this to specify GLM link families. Default is <code>gaussian</code>,
the linear model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balance.correction</code></td>
<td>
<p>Correct between-subject effects for unbalanced
panels following the procedure in Curran and Bauer (2011)? Default is
FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dt.random</code></td>
<td>
<p>Should the detrending procedure be performed with a
random slope for each entity? Default is TRUE but for short panels
FALSE may be better, fitting a trend for all entities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dt.order</code></td>
<td>
<p>If detrending using <code>detrend</code>, what order polynomial
would you like to specify for the relationship between time and the
predictors? Default is 1, a linear model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pR2</code></td>
<td>
<p>Calculate a pseudo R-squared? Default is TRUE, but in some cases
may cause errors or add computation time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pvals</code></td>
<td>
<p>Calculate p values? Default is TRUE but for some complex
linear models, this may take a long time to compute using the <code>pbkrtest</code>
package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.df</code></td>
<td>
<p>For linear models only. User may choose the method for
calculating the degrees of freedom in t-tests. Default is
<code>"Satterthwaite"</code>, but you may also choose <code>"Kenward-Roger"</code>.
Kenward-Roger standard errors/degrees of freedom requires the <code>pbkrtest</code>
package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>If using weights, either the name of the column in the data
that contains the weights or a vector of the weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting. This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code>offset</code>
terms can be included in the formula instead or as well, and if more
than one is specified their sum is used.  See <code>model.offset</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interaction.style</code></td>
<td>
<p>The best way to calculate interactions in within
models is in some dispute. The conventional way (<code>"demean"</code>) is to first
calculate the product of the variables involved in the interaction before
those variables have their means subtracted and then subtract the mean of
the product from the product term (see Schunk and Perales (2017)).
Giesselmann and Schmidt-Catran (2020) show this method carries
between-entity differences that within models are designed to model out.
They suggest an alternate method (<code>"double-demean"</code>) in which the product
term is first calculated using the de-meaned lower-order variables and
then the subject means are subtracted from this product term. Another
option is to simply use the product term of the de-meaned variables
(<code>"raw"</code>), but Giesselmann and Schmidt-Catran (2020) show this method
biases the results towards zero effect. The default is <code>"double-demean"</code>
but if emulating other software is the goal, <code>"demean"</code> might be
preferred.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>If <code>TRUE</code>, reports standardized regression
coefficients by scaling and mean-centering input data (the latter can be
changed via the <code>scale.only</code> argument). Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.response</code></td>
<td>
<p>Should the response variable also be rescaled? Default
is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.sd</code></td>
<td>
<p>How many standard deviations should you divide by for
standardization? Default is 1, though some prefer 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dt_random</code></td>
<td>
<p>Deprecated. Equivalent to <code>dt.random</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dt_order</code></td>
<td>
<p>Deprecated. Equivalent to <code>dt.order</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balance_correction</code></td>
<td>
<p>Deprecated. Equivalent to <code>balance.correction</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments provided to <code>lme4::lmer()</code>,
<code>lme4::glmer()</code>, or <code>lme4::glmer.nb()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Formula syntax</strong>
</p>
<p>The within-between models, and multilevel panel models more generally,
distinguish between time-varying and time-invariant predictors. These are,
as they sound, variables that are either measured repeatedly (in every wave)
in the case of time-varying predictors or only once in the case of
time-invariant predictors. You need to specify these separately in the
formula to tell the model which variables you expect to change over time and
which will not. The primary way of doing so is via the <code>|</code> operator.
</p>
<p>As an example, we can look at the WageData included in this
package. We will create a model that predicts the logarithm of the
individual's wages (<code>lwage</code>) with their union status (<code>union</code>), which can
change over time, and their race (<code>blk</code>; dichotomized as black or
non-black),
which does not change throughout the period of study. Our formula will look
like this:
</p>
<p><code>lwage ~ union | blk</code>
</p>
<p>Put time-varying variables before the first <code>|</code> and time-invariant
variables afterwards. You can specify lags like <code>lag(union)</code> for time-varying
variables; for more than 1 lag, include the number: <code>lag(union, 2)</code>.
</p>
<p>After the first <code>|</code> go the time-invariant variables. Note that if you put a
time-varying variable here, what you get is the observed value rather than
one adjusted to isolate within-entity effects. You may also take a
time-varying variable — let's say weeks worked (<code>wks</code>) — and use
<code>imean(wks)</code> to include the individual's mean across all waves as a
predictor while omitting the per-wave measures.
</p>
<p>There is also a place for a second <code>|</code>. Here you can specify cross-level
interactions (within-level interactions can be specified here as well).
If I wanted the interaction term for <code>union</code> and <code>blk</code> — to see whether
the effect of union status depended on one's race — I would specify the
formula this way:
</p>
<p><code>lwage ~ union | blk | union * blk</code>
</p>
<p>Another use for the post-second <code>|</code> section of the formula is for changing
the random effects specification. By default, only a random intercept is
specified in the call to <code>lme4::lmer()</code>/<code>lme4::glmer()</code>. If you would like
to specify other random slopes, include them here using the typical <code>lme4</code>
syntax:
</p>
<p><code>lwage ~ union | blk | (union | id)</code>
</p>
<p>You can also include the wave variable in a random effects term to
specify a latent growth curve model:
</p>
<p><code>lwage ~ union | blk + t | (t | id)</code>
</p>
<p>One last thing to know: If you want to use the second <code>|</code> but not the first,
put a 1 or 0 after the first, like this:
</p>
<p><code>lwage ~ union | 1 | (union | id)</code>
</p>
<p>Of course, with no time-invariant variables, you need no <code>|</code> operators at
all.
</p>
<p><strong>Models</strong>
</p>
<p>As a convenience, <code>wbm</code> does the heavy lifting for specifying the
within-between model correctly. As a side effect it only
takes a few easy tweaks to specify the model slightly differently. You
can change this behavior with the <code>model</code> argument.
</p>
<p>By default, the argument is <code>"w-b"</code> (equivalently, <code>"within-between"</code>).
This means, for each time-varying predictor, you have two types of
variables in the model. The "between" effect is represented by the
individual-level mean for each entity (e.g., each respondent to a panel
survey). The "within" effect is represented by each wave's measure <em>with
the individual-level mean</em> subtracted. Some refer to this as "de-meaning."
Thinking in a Hausman test framework — with the within-between model as
described here — you should expect the within and between
coefficients to be the same if a random effects model were appropriate.
</p>
<p>The contextual model is very similar (use argument <code>"contextual"</code>). In
some situations, this will be more intuitive to interpret. Empirically,
the only difference compared to the within-between specification is that
the contextual model does not subtract the individual-level means from the
wave-level measures. This also changes the interpretation of the
between-subject coefficients: In the contextual model, they are the
<em>difference</em> between the within and between effects. If there's no
difference between within and between effects, then, the coefficients will
be 0.
</p>
<p>To fit a random effects model, use either <code>"between"</code> or <code>"random"</code>. This
involves no de-meaning and no individual-level means whatsoever.
</p>
<p>To fit a fixed effects model, use either <code>"within"</code> or <code>"fixed"</code>. Any
between-subjects terms in the formula will be ignored. The time-varying
variables will be de-meaned, but the individual-level mean is not included
in the model.
</p>


<h3>Value</h3>

<p>A <code>wbm</code> object, which inherits from <code>merMod</code>.
</p>


<h3>Author(s)</h3>

<p>Jacob A. Long
</p>


<h3>References</h3>

<p>Allison, P. (2009). <em>Fixed effects regression models</em>.
Thousand Oaks, CA: SAGE Publications.
https://doi.org/10.4135/9781412993869.d33
</p>
<p>Bell, A., &amp; Jones, K. (2015). Explaining fixed effects: Random effects
modeling of time-series cross-sectional and panel data.
<em>Political Science Research and Methods</em>, <em>3</em>, 133–153.
https://doi.org/10.1017/psrm.2014.7
</p>
<p>Curran, P. J., &amp; Bauer, D. J. (2011). The disaggregation of within-person
and between-person effects in longitudinal models of change.
<em>Annual Review of Psychology</em>, <em>62</em>, 583–619.
https://doi.org/10.1146/annurev.psych.093008.100356
</p>
<p>Giesselmann, M., &amp; Schmidt-Catran, A. (2018). Interactions in fixed effects
regression models (Discussion Papers of DIW Berlin No. 1748).
<em>DIW Berlin, German Institute for Economic Research</em>.
Retrieved from https://ideas.repec.org/p/diw/diwwpp/dp1748.html
</p>
<p>Schunck, R., &amp; Perales, F. (2017). Within- and between-cluster effects in
generalized linear mixed models: A discussion of approaches and the
<code>xthybrid</code> command. <em>The Stata Journal</em>, <em>17</em>, 89–115.
https://doi.org/10.1177/1536867X1701700106
</p>


<h3>See Also</h3>

<p><code>wbm_stan()</code> for a Bayesian estimation option.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
model &lt;- wbm(lwage ~ lag(union) + wks | blk + fem | blk * lag(union),
         data = wages)
summary(model)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>PeakSegPDPAchrom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PeakSegPDPAchrom</h2>

<h3>Description</h3>

<p>Find the optimal change-points using the Poisson loss and the
PeakSeg constraint. This function is a user-friendly interface to
the <code>PeakSegPDPA</code> function.</p>


<h3>Usage</h3>

<pre><code class="language-R">PeakSegPDPAchrom(count.df, 
    max.peaks = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>count.df</code></td>
<td>
<p>data.frame with columns count, chromStart, chromEnd.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.peaks</code></td>
<td>
<p>integer &gt; 0: maximum number of peaks.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List of data.frames: segments can be used for plotting the
segmentation model, loss describes model loss and feasibility,
modelSelection.feasible describes the set of all linear penalty
(lambda) values which can be used to select the feasible models,
modelSelection.decreasing selects from all models that decrease
the Poisson loss relative to simpler models (same as <code>PeakSegFPOP</code>).</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class="language-R">
## samples for which pdpa recovers a more likely model, but it is
## not feasible for the PeakSeg problem (some segment means are
## equal).
sample.id &lt;- "McGill0322"
sample.id &lt;- "McGill0079"
sample.id &lt;- "McGill0106"
n.peaks &lt;- 3
library(PeakSegOptimal)
data("H3K4me3_XJ_immune_chunk1", envir=environment())
H3K4me3_XJ_immune_chunk1$count &lt;- H3K4me3_XJ_immune_chunk1$coverage
by.sample &lt;-
  split(H3K4me3_XJ_immune_chunk1, H3K4me3_XJ_immune_chunk1$sample.id)
one.sample &lt;- by.sample[[sample.id]]
pdpa.fit &lt;- PeakSegPDPAchrom(one.sample, 9L)
pdpa.segs &lt;- subset(pdpa.fit$segments, n.peaks == peaks)
both.segs.list &lt;- list(pdpa=data.frame(pdpa.segs, algorithm="PDPA"))
pdpa.breaks &lt;- subset(pdpa.segs, 1 &lt; first)
pdpa.breaks$feasible &lt;- ifelse(
  diff(pdpa.segs$mean)==0, "infeasible", "feasible")
both.breaks.list &lt;- list(pdpa=data.frame(pdpa.breaks, algorithm="PDPA"))
if(require(PeakSegDP)){
  dp.fit &lt;- PeakSegDP(one.sample, 9L)
  dp.segs &lt;- subset(dp.fit$segments, n.peaks == peaks)
  dp.breaks &lt;- subset(dp.segs, 1 &lt; first)
  dp.breaks$feasible &lt;- "feasible"
  both.segs.list$dp &lt;- data.frame(dp.segs, algorithm="cDPA")
  both.breaks.list$dp &lt;- data.frame(dp.breaks, algorithm="cDPA")
}
both.segs &lt;- do.call(rbind, both.segs.list)
both.breaks &lt;- do.call(rbind, both.breaks.list)
library(ggplot2)
ggplot()+
  theme_bw()+
  theme(panel.margin=grid::unit(0, "lines"))+
  facet_grid(algorithm ~ ., scales="free")+
  geom_step(aes(chromStart/1e3, coverage),
            data=one.sample, color="grey")+
  geom_segment(aes(chromStart/1e3, mean,
                   xend=chromEnd/1e3, yend=mean),
               color="green",
               data=both.segs)+
  scale_linetype_manual(values=c(feasible="dotted", infeasible="solid"))+
  geom_vline(aes(xintercept=chromStart/1e3, linetype=feasible),
             color="green",
             data=both.breaks)

## samples for which pdpa recovers some feasible models that the
## heuristic dp does not.
sample.id.vec &lt;- c(
  "McGill0091", "McGill0107", "McGill0095",
  "McGill0059", "McGill0029", "McGill0010")
sample.id &lt;- sample.id.vec[4]
one.sample &lt;- by.sample[[sample.id]]
pdpa.fit &lt;- PeakSegPDPAchrom(one.sample, 9L)
gg.loss &lt;- ggplot()+
  scale_color_manual(values=c("TRUE"="black", "FALSE"="red"))+
  scale_size_manual(values=c(cDPA=1.5, PDPA=3))+
  scale_fill_manual(values=c(cDPA="white", PDPA="black"))+
  guides(color=guide_legend(override.aes=list(fill="black")))+
  geom_point(aes(peaks, PoissonLoss,
                 size=algorithm, fill=algorithm, color=feasible),
             shape=21,
             data=data.frame(pdpa.fit$loss, algorithm="PDPA"))
if(require(PeakSegDP)){
  dp.fit &lt;- PeakSegDP(one.sample, 9L)
  gg.loss &lt;- gg.loss+
    geom_point(aes(peaks, error,
                   size=algorithm, fill=algorithm),
               shape=21,
               data=data.frame(dp.fit$error, algorithm="cDPA"))
}
gg.loss

diff.df &lt;- data.frame(
  PeakSegPDPA.loss=pdpa.fit$loss$PoissonLoss,
  PeakSegDP.loss=dp.fit$error$error,
  peaks=dp.fit$error$peaks)
ggplot()+
  geom_point(aes(peaks, PeakSegDP.loss - PeakSegPDPA.loss), data=diff.df)

</code></pre>


</div>
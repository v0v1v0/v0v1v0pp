<div class="container">

<table style="width: 100%;"><tr>
<td>PgR6M</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PgR6 class with methods.</h2>

<h3>Description</h3>

<p>PgR6 with Methods. Final users should use <code>pagoo</code>
instead of this, since is more easy to understand.
Inherits: <code>PgR6</code>
</p>


<h3>Super class</h3>

<p><code>pagoo::PgR6</code> -&gt; <code>PgR6M</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PgR6M-new"><code>PgR6M$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-rarefact"><code>PgR6M$rarefact()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-dist"><code>PgR6M$dist()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-pan_pca"><code>PgR6M$pan_pca()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-pg_power_law_fit"><code>PgR6M$pg_power_law_fit()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-cg_exp_decay_fit"><code>PgR6M$cg_exp_decay_fit()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-gg_barplot"><code>PgR6M$gg_barplot()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-gg_binmap"><code>PgR6M$gg_binmap()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-gg_dist"><code>PgR6M$gg_dist()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-gg_pca"><code>PgR6M$gg_pca()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-gg_pie"><code>PgR6M$gg_pie()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-gg_curves"><code>PgR6M$gg_curves()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-runShinyApp"><code>PgR6M$runShinyApp()</code></a>
</p>
</li>
<li> <p><a href="#method-PgR6M-clone"><code>PgR6M$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="pagoo" data-topic="PgR6" data-id="add_metadata"><a href="../../pagoo/html/PgR6.html#method-PgR6-add_metadata"><code>pagoo::PgR6$add_metadata()</code></a></span></li>
<li><span class="pkg-link" data-pkg="pagoo" data-topic="PgR6" data-id="drop"><a href="../../pagoo/html/PgR6.html#method-PgR6-drop"><code>pagoo::PgR6$drop()</code></a></span></li>
<li><span class="pkg-link" data-pkg="pagoo" data-topic="PgR6" data-id="recover"><a href="../../pagoo/html/PgR6.html#method-PgR6-recover"><code>pagoo::PgR6$recover()</code></a></span></li>
<li><span class="pkg-link" data-pkg="pagoo" data-topic="PgR6" data-id="save_pangenomeRDS"><a href="../../pagoo/html/PgR6.html#method-PgR6-save_pangenomeRDS"><code>pagoo::PgR6$save_pangenomeRDS()</code></a></span></li>
<li><span class="pkg-link" data-pkg="pagoo" data-topic="PgR6" data-id="write_pangenome"><a href="../../pagoo/html/PgR6.html#method-PgR6-write_pangenome"><code>pagoo::PgR6$write_pangenome()</code></a></span></li>
</ul></details><hr>
<a id="method-PgR6M-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a <code>PgR6M</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$new(
  data,
  org_meta,
  cluster_meta,
  core_level = 95,
  sep = "__",
  verbose = TRUE,
  DF,
  group_meta
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt>
<dd>
<p>A <code>data.frame</code> or <code>DataFrame</code> containing at least the
following columns: <code>gene</code> (gene name), <code>org</code> (organism name to which the gene belongs to),
and <code>cluster</code> (group of orthologous to which the gene belongs to). More columns can be added as metadata
for each gene.</p>
</dd>
<dt><code>org_meta</code></dt>
<dd>
<p>(optional) A <code>data.frame</code> or <code>DataFrame</code>
containing additional metadata for organisms. This <code>data.frame</code> must have a column named "org" with
valid organisms names (that is, they should match with those provided in <code>data</code>, column <code>org</code>), and
additional columns will be used as metadata. Each row should correspond to each organism.</p>
</dd>
<dt><code>cluster_meta</code></dt>
<dd>
<p>(optional) A <code>data.frame</code> or <code>DataFrame</code>
containing additional metadata for clusters. This <code>data.frame</code> must have a column named "cluster" with
valid organisms names (that is, they should match with those provided in <code>data</code>, column <code>cluster</code>), and
additional columns will be used as metadata. Each row should correspond to each cluster.</p>
</dd>
<dt><code>core_level</code></dt>
<dd>
<p>The initial core_level (that's the percentage of organisms a core cluster must be in to be
considered as part of the core genome). Must be a number between 100 and 85, (default: 95). You can change it
later by using the <code>$core_level</code> field once the object was created.</p>
</dd>
<dt><code>sep</code></dt>
<dd>
<p>A separator. By default is '__'(two underscores). It will be used to
create a unique <code>gid</code> (gene identifier) for each gene. <code>gid</code>s are created by pasting
<code>org</code> to <code>gene</code>, separated by <code>sep</code>.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p><code>logical</code>. Whether to display progress messages when loading class.</p>
</dd>
<dt><code>DF</code></dt>
<dd>
<p>Deprecated. Use <code>data</code> instead.</p>
</dd>
<dt><code>group_meta</code></dt>
<dd>
<p>Deprecated. Use <code>cluster_meta</code> instead.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An R6 object of class PgR6M. It contains basic fields and methods for analyzing a pangenome. It also
contains additional statistical methods for analyze it, and methods to make basic
exploratory plots.
</p>


<hr>
<a id="method-PgR6M-rarefact"></a>



<h4>Method <code>rarefact()</code>
</h4>

<p>Rarefact pangenome or corgenome. Compute the number of genes which belong to
the pangenome or to the coregenome, for a number of random permutations of
increasingly bigger sample of genomes.
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$rarefact(what = "pangenome", n.perm = 10)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt>
<dd>
<p>One of <code>"pangenome"</code> or <code>"coregenome"</code>.</p>
</dd>
<dt><code>n.perm</code></dt>
<dd>
<p>The number of permutations to compute (default: 10).</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>matrix</code>, rows are the number of genomes added, columns are
permutations, and the cell number is the number of genes in each category.
</p>


<hr>
<a id="method-PgR6M-dist"></a>



<h4>Method <code>dist()</code>
</h4>

<p>Compute distance between all pairs of genomes. The default dist method is
<code>"bray"</code> (Bray-Curtis distance). Another used distance method is <code>"jaccard"</code>,
but you should set <code>binary = FALSE</code> (see below) to obtain a meaningful result.
See <code>vegdist</code> for details, this is just a wrapper function.
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$dist(
  method = "bray",
  binary = FALSE,
  diag = FALSE,
  upper = FALSE,
  na.rm = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt>
<dd>
<p>The distance method to use. See vegdist
for available methods, and details for each one.</p>
</dd>
<dt><code>binary</code></dt>
<dd>
<p>Transform abundance matrix into a presence/absence
matrix before computing distance.</p>
</dd>
<dt><code>diag</code></dt>
<dd>
<p>Compute diagonals.</p>
</dd>
<dt><code>upper</code></dt>
<dd>
<p>Return only the upper diagonal.</p>
</dd>
<dt><code>na.rm</code></dt>
<dd>
<p>Pairwise deletion of missing observations when
computing dissimilarities.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Other parameters. See vegdist for details.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>dist</code> object containing all pairwise dissimilarities between genomes.
</p>


<hr>
<a id="method-PgR6M-pan_pca"></a>



<h4>Method <code>pan_pca()</code>
</h4>

<p>Performs a principal components analysis on the panmatrix
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$pan_pca(center = TRUE, scale. = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>center</code></dt>
<dd>
<p>a logical value indicating whether the variables should be shifted
to be zero centered. Alternately, a vector of length equal the number of columns of x can be
supplied. The value is passed to scale.</p>
</dd>
<dt><code>scale.</code></dt>
<dd>
<p>a logical value indicating whether the variables should be scaled
to have unit variance before the analysis takes place. The default is TRUE.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Other arguments. See prcomp</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Returns a list with class "prcomp". See prcomp for more information.
</p>


<hr>
<a id="method-PgR6M-pg_power_law_fit"></a>



<h4>Method <code>pg_power_law_fit()</code>
</h4>

<p>Fits a power law curve for the pangenome rarefaction simulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$pg_power_law_fit(raref, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raref</code></dt>
<dd>
<p>(Optional) A rarefaction matrix, as returned by <code>rarefact()</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Further arguments to be passed to <code>rarefact()</code>. If <code>raref</code>
is missing, it will be computed with default arguments, or with the ones provided here.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>list</code> of two elements: <code>$formula</code> with a fitted function, and <code>$params</code>
with fitted parameters. An attribute <code>"alpha"</code> is also returned (If
<code>alpha&gt;1</code>, then the pangenome is closed, otherwise is open.
</p>


<hr>
<a id="method-PgR6M-cg_exp_decay_fit"></a>



<h4>Method <code>cg_exp_decay_fit()</code>
</h4>

<p>Fits an exponential decay curve for the coregenome rarefaction simulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$cg_exp_decay_fit(raref, pcounts = 10, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raref</code></dt>
<dd>
<p>(Optional) A rarefaction matrix, as returned by <code>rarefact()</code>.</p>
</dd>
<dt><code>pcounts</code></dt>
<dd>
<p>An integer of pseudo-counts. This is used to better fit the function
at small numbers, as the linearization method requires to subtract a constant C, which is the
coregenome size, from <code>y</code>. As <code>y</code> becomes closer to the coregenome size, this operation
tends to 0, and its logarithm goes crazy. By default <code>pcounts=10</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Further arguments to be passed to <code>rarefact()</code>. If <code>raref</code>
is missing, it will be computed with default arguments, or with the ones provided here.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>list</code> of two elements: <code>$formula</code> with a fitted function, and <code>$params</code>
with fitted intercept and decay parameters.
</p>


<hr>
<a id="method-PgR6M-gg_barplot"></a>



<h4>Method <code>gg_barplot()</code>
</h4>

<p>Plot a barplot with the frequency of genes within the total number of
genomes.
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$gg_barplot()</pre></div>



<h5>Returns</h5>

<p>A barplot, and a <code>gg</code> object (<code>ggplot2</code> package) invisibly.
</p>


<hr>
<a id="method-PgR6M-gg_binmap"></a>



<h4>Method <code>gg_binmap()</code>
</h4>

<p>Plot a pangenome binary map representing the presence/absence of each
gene within each organism.
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$gg_binmap()</pre></div>



<h5>Returns</h5>

<p>A binary map (<code>ggplot2::geom_raster()</code>), and a <code>gg</code> object (<code>ggplot2</code>
package) invisibly.
</p>


<hr>
<a id="method-PgR6M-gg_dist"></a>



<h4>Method <code>gg_dist()</code>
</h4>

<p>Plot a heatmap showing the computed distance between all pairs of organisms.
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$gg_dist(method = "bray", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt>
<dd>
<p>Distance method. One of "Jaccard" (default), or "Manhattan",
see above.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>More arguments to be passed to <code>distManhattan</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A heatmap (<code>ggplot2::geom_tile()</code>), and a <code>gg</code> object (<code>ggplot2</code>
package) invisibly.
</p>


<hr>
<a id="method-PgR6M-gg_pca"></a>



<h4>Method <code>gg_pca()</code>
</h4>

<p>Plot a scatter plot of a Principal Components Analysis.
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$gg_pca(colour = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>colour</code></dt>
<dd>
<p>The name of the column in <code>$organisms</code> field from which points will take
colour (if provided). <code>NULL</code> (default) renders black points.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>More arguments to be passed to <code>ggplot2::autoplot()</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A scatter plot (<code>ggplot2::autoplot()</code>), and a <code>gg</code> object (<code>ggplot2</code>
package) invisibly.
</p>


<hr>
<a id="method-PgR6M-gg_pie"></a>



<h4>Method <code>gg_pie()</code>
</h4>

<p>Plot a pie chart showing the number of clusters of each pangenome category: core,
shell, or cloud.
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$gg_pie()</pre></div>



<h5>Returns</h5>

<p>A pie chart (<code>ggplot2::geom_bar() + coord_polar()</code>), and a <code>gg</code> object
(<code>ggplot2</code> package) invisibly.
</p>


<hr>
<a id="method-PgR6M-gg_curves"></a>



<h4>Method <code>gg_curves()</code>
</h4>

<p>Plot pangenome and/or coregenome curves with the fitted functions returned by <code>pg_power_law_fit()</code>
and <code>cg_exp_decay_fit()</code>. You can add points by adding <code>+ geom_points()</code>, of ggplot2 package
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$gg_curves(what = c("pangenome", "coregenome"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt>
<dd>
<p>One of <code>"pangenome"</code> or <code>"coregenome"</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>????</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A scatter plot, and a <code>gg</code> object (<code>ggplot2</code> package) invisibly.
</p>


<hr>
<a id="method-PgR6M-runShinyApp"></a>



<h4>Method <code>runShinyApp()</code>
</h4>

<p>Launch an interactive shiny app. It contains a sidebar
with controls and switches to interact with the pagoo
object. You can drop/recover organisms from the dataset,
modify the core_level, visualize statistics, plots, and
browse cluster and gene information. In the main body, it
contains 2 tabs to switch between summary statistics plots
and core genome information on one side, and accessory
genome plots and information on the other.
</p>
<p>The lower part of each tab contains two tables, side by
side. On the "Summary" tab, the left one contain
information about core clusters, with one cluster per row.
When one of them is selected (click), the one on the right
is updated to show information about its genes (if
provided), one gene per row. On the "Accessory" tab, a
similar configuration is shown, but on this case only
accessory clusters/genes are displayed. There is a slider
on the sidebar where one can select the accessory
frequency range to display.
</p>
<p>Give it a try!
</p>
<p>Take into account that big pangenomes can slow down the
performance of the app. More than 50-70 organisms often
leads to a delay in the update of the plots/tables.
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$runShinyApp()</pre></div>


<hr>
<a id="method-PgR6M-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PgR6M$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




</div>
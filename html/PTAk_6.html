<div class="container">

<table style="width: 100%;"><tr>
<td>CONTRACTION</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Contraction of two tensors </h2>

<h3>Description</h3>

<p>Computes the contraction product of two tensors as a generalisation of matrix product.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> CONTRACTION(X,z, Xwiz=NULL,zwiX=NULL,rezwiX=FALSE,usetensor=TRUE)
 CONTRACTION.list(X,zlist,moins=1,zwiX=NULL,usetensor=TRUE,withapply=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a tensor(as an array) of any order</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>another tensor  (with at least one space in common)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zlist</code></td>
<td>

<p>a list of lists like a <code>solution.PTAk</code> at least with
<code>v</code> for every list(here <code>v</code> can be any array) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xwiz</code></td>
<td>

<p><code>Xwiz</code> is to specify the entries of <code>X</code> to
contract with entries of <code>z</code> specified by <code>zwiX</code>,
if <code>Xwiz</code> <code>NULL</code> <code>dim(z)[zwiX]</code> matching
<code>dim(X)</code> will do without ambiguity (taking all
<code>z</code> dimensions if <code>zwiX</code> is <code>NULL</code>). In
<code>CONTRACTION.list</code> it is not set as one supposes the
contractions in the list to operate follow the dimensions
of X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zwiX</code></td>
<td>

<p>idem as <code>Xwiz</code>. If both <code>Xwiz</code> and <code>zwiX</code>
are <code>NULL</code> <code>zwiX</code>is replaced by full
possibilities (<code>1:length(dimz)</code>) then <code>Xwiz</code> is
looked for. In <code>CONTRACTION.list</code> it is the vector for
dimensions in the <code>v</code> to contract with X. Only 1-way
dimension for each <code>v</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moins</code></td>
<td>

<p>the elements in <code>zlist</code> to skip (see also
<code>TENSELE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rezwiX</code></td>
<td>

<p>logical if <code>TRUE</code> (and zwiX is <code>NULL</code>) rematches
the dimensions in for <code>zwiX</code>: useful only if the
dimensions of z were not following the Xwiz order and are
not equals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>usetensor</code></td>
<td>
<p>if <code>TRUE</code> uses <code>tensor</code> (add-on package)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withapply</code></td>
<td>
<p>if <code>TRUE</code> (only for vectors in <code>zlist</code> uses <code>apply</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Like two matrices <em>contract</em> according to the
appropriate dimensions (columns matching rows) when one
performs a matrix product, this operation does pretty much
the same thing for tensors(array) and specified contraction
dimensions given by <code>Xwiz</code> and <code>zwiX</code> which
should match. The function is actually written like:
transforms both tensors as matrices with the â€œmatching
tensor product" of their contraction dimensions in columns
(for higher order tensor) and rows (the other one),
performs the matrix product and rebuild the result as a
tensor(array). Without using <code>tensor</code>, if <code>Xwiz</code>
and/or <code>zwiX</code> are not specified the functions tries to
match all <code>z</code> dimensions onto the dimensions of X
where X is the higher order tensor (if it is not the case
in the arguments the function swaps them). </p>


<h3>Value</h3>

<p>A tensor of dimension <code>c(dim(X)[-Xwiz],dim(z)[-zwiX])</code>
if <code>X</code> has got a bigger order than <code>z</code>.</p>


<h3>Note</h3>

<p>This operation generalises the <em>matrix</em> product to the
<em>contracted</em> product of any two tensors(arrays), and
should theoretically perform the tensor product if no
matching (no contraction) but has not been implemented. I
recently put the option of using <code>tensor</code> which does
exactly the same thing faster as well as it is from
<code>C</code>. When using <code>tensor</code> if <code>Xwiz</code> or
<code>zwiX</code> are <code>NULL</code> they are replaced by the full
possibilities.</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Leibovici D and Sabatier R (1998) <em>A Singular Value
Decomposition of a k-ways array for a Principal Component
Analysis of multi-way data, the PTA-k</em>. Linear Algebra and
its Applications, 269:307-329.
</p>
<p>Schwartz L (1975) <em>Les Tenseurs</em>. Herman, Paris. </p>


<h3>See Also</h3>

<p><code>PTAk</code>,  <code>APSOLUk</code> </p>


<h3>Examples</h3>

<pre><code class="language-R"> library(tensor)
   z &lt;-  array(1:12,c(2,3,2))
   X &lt;- array(1:48,c(3,4,2,2))
   Xcz &lt;- CONTRACTION(X,z,Xwiz=c(1,3,4),zwiX=c(2,3,1))
   dim(Xcz)   # 4
   Xcz1 &lt;- CONTRACTION(X,z,Xwiz=c(3,4),zwiX=c(1,3))
   dim(Xcz1) # 3,4,3
   Xcz2 &lt;- CONTRACTION(X,z,Xwiz=c(3,4),zwiX=c(3,1))
   Xcz1[,,1]
   Xcz2[,,1]
   #######
   sval0 &lt;- list(list(v=c(1,2,3,4)),list(v=rep(1,3)),list(v=c(1,3)))
   tew &lt;- array(1:24,c(4,3,2))
    CONTRACTION.list(tew,sval0,moins=1)
       #this is equivalent to the following which may be too expensive for big datasets
    CONTRACTION(tew,TENSELE(sval0,moins=1),Xwiz=c(2,3))
   ##
     CONTRACTION.list(tew,sval0,moins=c(1,2)) #must be equal to
     CONTRACTION(tew,sval0[[3]]$v,Xwiz=3)
   </code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>count_pairwise_trans</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Count pairwise transitions between a given set of states
</h2>

<h3>Description</h3>

<p>Counts the frequencies of transitions between each pair of states from a given set of states.
</p>


<h3>Usage</h3>

<pre><code class="language-R">count_pairwise_trans(net, method = c("BNp", "SDDS", "PEW"), params, states,
                     steps = 1, repeats = 1000, asynchronous = TRUE,
                     update_prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>net</code></td>
<td>
<p>A network structure of the class <code>BooleanNetwork</code> from the <code>BoolNet</code> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The parameterization method to be used. Options are:
</p>

<ul>
<li> <p><code>"BNp"</code>: Boolean network with perturbations.
</p>
</li>
<li> <p><code>"SDDS"</code>: Stochastic discrete dynamical systems.
</p>
</li>
<li> <p><code>"PEW"</code>: Boolean network with probabilistic edge weights.
</p>
</li>
</ul>
<p>Each method requires a different format for the <code>params</code> argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>The parameter values depending on <code>method</code>:
</p>

<ul>
<li>
<p> For <code>method = "BNp"</code>, a single vector of probabilities, equal in length to the number of network nodes.
</p>
</li>
<li>
<p> For <code>method = "SDDS"</code>, a list of four equal-length vectors of probabilities: <code>p00</code>, <code>p01</code>, <code>p10</code>, and <code>p11</code>, each equal in length to the number of network nodes.
</p>
</li>
<li>
<p> For <code>method = "PEW"</code>, a list of two equal-length vectors of probabilities: <code>p_on</code> and <code>p_off</code>, each as long as the number of network edges, ordered according to <code>extract_edges</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>states</code></td>
<td>
<p>The network states among which pairwise transitions are to be counted. This should be a matrix (where the rows represent the binary form of the states) or a vector (for the binary form of a single state). The number of matrix columns (or the length of the vector) should match the number of network nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>The number of time-steps, which should be a non-negative integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeats</code></td>
<td>
<p>The number of repeats, which should be a positive integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asynchronous</code></td>
<td>
<p>If <code>TRUE</code>, the asynchronous update scheme is used, where a single node is updated at each time-step. In this case, <code>update_prob</code> indicates update probabilities. If <code>FALSE</code>, the synchronous update scheme is utilized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update_prob</code></td>
<td>
<p>The probability of updating each variable (node) in each time-step when <code>asynchronous = TRUE</code>. It should be a vector of probabilities for each of the nodes which sums up to one. If <code>NULL</code> (default), nodes are updated randomly based on a uniform distribution. If <code>asynchronous = FALSE</code>, this argument is ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Counting the number of transitions between each pair of states reveals the reachability of one state from another. This function performs simulations by starting from each state in <code>states</code> for <code>steps</code> time-steps and <code>repeats</code> iterations, and counts the number of transitions to other states in <code>states</code>.
</p>


<h3>Value</h3>

<p>A matrix where each element (i, j) represents the number of transitions from the <em>i</em>th state to the <em>j</em>th state across <code>steps</code> time-steps and <code>repeats</code> iterations.
</p>


<h3>References</h3>

<p>Golinelli, O., &amp; Derrida, B. (1989). Barrier heights in the Kauffman model. <em>Journal De Physique</em>, 50(13), 1587-1601.
</p>
<p>Shmulevich, I., Dougherty, E. R., &amp; Zhang, W. (2002). Gene perturbation and intervention in probabilistic Boolean networks. <em>Bioinformatics</em>, 18(10), 1319-1331.
</p>
<p>Trairatphisan, P., Mizera, A., Pang, J., Tantar, A. A., Schneider, J., &amp; Sauter, T. (2013). Recent development and biomedical applications of probabilistic Boolean networks. <em>Cell communication and signaling</em>, 11, 1-25.
</p>
<p>Murrugarra, D., Veliz-Cuba, A., Aguilar, B., Arat, S., &amp; Laubenbacher, R. (2012). Modeling stochasticity and variability in gene regulatory networks. <em>EURASIP Journal on Bioinformatics and Systems Biology</em>, 2012, 1-11.
</p>
<p>Deritei, D., Kunšič, N., &amp; Csermely, P. (2022). Probabilistic edge weights fine-tune Boolean network dynamics. <em>PLoS Computational Biology</em>, 18(10), e1010536.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Load network and generate random initial states  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Load the example network
data(lac_operon_net)

# Generate some random states
states &lt;- matrix(sample(c(0, 1), 10 * length(lac_operon_net$genes),
    replace = TRUE), nrow = 10, ncol = length(lac_operon_net$genes))

# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Method: BNp  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Define the parameters for the BNp method
params &lt;- rep(0.05, length(lac_operon_net$genes))

# Obtain frequency of pairwise transitions
pairwise_trans &lt;- count_pairwise_trans(lac_operon_net, states = states,
    method = "BNp", params = params, steps = 100, repeats = 10)

# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Method: SDDS  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Define the parameters for the SDDS method
props &lt;- rep(0.95, length(lac_operon_net$genes))
params &lt;- list(p00 = props, p01 = props, p10 = props, p11 = props)

# Obtain frequency of pairwise transitions
pairwise_trans &lt;- count_pairwise_trans(lac_operon_net, states = states,
    method = "SDDS", params = params, steps = 100, repeats = 10)

# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Method: PEW  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

# Extract edges from the network
edges &lt;- extract_edges(lac_operon_net)

# Define the parameters for the PEW method
p_on &lt;- runif(nrow(edges))
p_off &lt;- runif(nrow(edges))
params &lt;- list(p_on = p_on, p_off = p_off)

# Obtain frequency of pairwise transitions
pairwise_trans &lt;- count_pairwise_trans(lac_operon_net, states = states,
    method = "PEW", params = params, steps = 100, repeats = 10)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>pp_shape</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Shape object for generating various grobs</h2>

<h3>Description</h3>

<p><code>pp_shape()</code> creates an R6 object with methods for creating various shape based grobs.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pp_shape(label = "rect", theta = 90, radius = 0.2, back = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>
<p>Label of the shape.  One of </p>

<dl>
<dt>“circle”</dt>
<dd>
<p>Circle.</p>
</dd>
<dt>“convexN”</dt>
<dd>
<p>An <code>N</code>-sided convex polygon.
<code>theta</code> controls which direction the first vertex is drawn.</p>
</dd>
<dt>“concaveN”</dt>
<dd>
<p>A “star” (concave) polygon with <code>N</code> “points”.
<code>theta</code> controls which direction the first point is drawn.
<code>radius</code> controls the distance of the “inner” vertices from the center.</p>
</dd>
<dt>“halma”</dt>
<dd>
<p>A 2D outline of a “Halma pawn”.</p>
</dd>
<dt>“kite”</dt>
<dd>
<p>“Kite” quadrilateral shape.</p>
</dd>
<dt>“meeple”</dt>
<dd>
<p>A 2D outline of a “meeple”.</p>
</dd>
<dt>“oval”</dt>
<dd>
<p>Oval.</p>
</dd>
<dt>“pyramid”</dt>
<dd>
<p>An “Isosceles” triangle whose base is the bottom of the viewport.
Typically used to help draw the face of the “pyramid” piece.</p>
</dd>
<dt>“rect”</dt>
<dd>
<p>Rectangle.</p>
</dd>
<dt>“roundrect”</dt>
<dd>
<p>“Rounded” rectangle.  <code>radius</code> controls curvature of corners.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p><code>convex</code> and <code>concave</code> polygon shapes
use this to determine where the first point is drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p><code>concave</code> polygon and <code>roundrect</code> use this
to control appearance of the shape.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>back</code></td>
<td>
<p>Whether the shape should be reflected across a vertical line in the middle of the viewport.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>pp_shape</code> objects serve the following purposes:</p>

<ol>
<li>
<p>Make it easier for developers to customize game piece appearances
either through a "grob_fn" or "op_grob_fn" styles in <code>pp_cfg()</code>
or manipulate a piece post drawing via functions like <code>grid::grid.edit()</code>.
</p>
</li>
<li>
<p>Used internally to generate <code>piecepackr</code>'s built-in game piece grobs.
</p>
</li>
</ol>
<h3>
<code>pp_shape</code> R6 Class Method Arguments</h3>


<dl>
<dt><code>mat_width</code></dt>
<dd>
<p>Numeric vector of mat widths.</p>
</dd>
<dt><code>clip</code></dt>
<dd>
<p>“clip grob” to perform polyclip operation with.
See <code>gridGeometry::grid.polyclip()</code> for more info.</p>
</dd>
<dt><code>op</code></dt>
<dd>
<p>Polyclip operation to perform.
See <code>gridGeometry::grid.polyclip()</code> for more info.</p>
</dd>
<dt><code>pattern</code></dt>
<dd>
<p>Pattern to fill in shape with.
See <code>gridpattern::patternGrob()</code> for more info.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Passed to <code>gridpattern::patternGrob()</code>.</p>
</dd>
<dt><code>name</code></dt>
<dd>
<p>Grid grob <code>name</code> value.</p>
</dd>
<dt><code>gp</code></dt>
<dd>
<p>Grid <code>gpar</code> list.  See <code>grid::gpar()</code> for more info.</p>
</dd>
<dt><code>vp</code></dt>
<dd>
<p>Grid viewport or <code>NULL</code>.</p>
</dd>
</dl>
<h3>
<code>pp_shape</code> R6 Class Methods</h3>


<dl>
<dt><code>checkers(name = NULL, gp = gpar(), vp = NULL)</code></dt>
<dd>
<p>Returns a grob of checkers for that shape.</p>
</dd>
<dt><code>gridlines(name = NULL, gp = gpar(), vp = NULL)</code></dt>
<dd>
<p>Returns a grob of gridlines for that shape.</p>
</dd>
<dt><code>hexlines(name = NULL, gp = gpar(), vp = NULL)</code></dt>
<dd>
<p>Returns a grob of hexlines for that shape.</p>
</dd>
<dt><code>mat(mat_width = 0, name = NULL, gp = gpar(), vp = NULL)</code></dt>
<dd>
<p>Returns a grob for a matting “mat” for that shape.</p>
</dd>
<dt><code>pattern(pattern = "stripe", ..., name = NULL, gp = gpar(), vp = NULL)</code></dt>
<dd>
<p>Fills in the shape's <code>npc_coords</code> with a pattern.
See <code>gridpattern::patternGrob()</code> for more information.
</p>
</dd>
<dt><code>polyclip(clip, op = "intersection", name = NULL, gp = gpar(), vp = NULL)</code></dt>
<dd>
<p>Returns a grob that is an “intersection”, “minus”, “union”, or “xor” of another grob.
Note unlike <code>gridGeometry::polyclipGrob</code> it can directly work with a <code>pieceGrob</code> "clip grob" argument.</p>
</dd>
<dt><code>shape(name = NULL, gp = gpar(), vp = NULL)</code></dt>
<dd>
<p>Returns a grob of the shape.</p>
</dd>
</dl>
<h3>
<code>pp_shape</code> R6 Class Active Bindings</h3>


<dl>
<dt><code>label</code></dt>
<dd>
<p>The shape's label.</p>
</dd>
<dt><code>theta</code></dt>
<dd>
<p>The shape's theta.</p>
</dd>
<dt><code>radius</code></dt>
<dd>
<p>The shape's radius.</p>
</dd>
<dt><code>back</code></dt>
<dd>
<p>A boolean of whether this is the shape's “back” side.</p>
</dd>
<dt><code>npc_coords</code></dt>
<dd>
<p>A named list of “npc” coordinates along the perimeter of the shape.</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R"> if (require("grid", quietly = TRUE)) {
     gp &lt;- gpar(col="black", fill="yellow")
     rect &lt;- pp_shape(label="rect")
     convex6 &lt;- pp_shape(label="convex6")
     circle &lt;- pp_shape(label="circle")

     pushViewport(viewport(x=0.25, y=0.75, width=1/2, height=1/2))
     grid.draw(rect$shape(gp=gp))
     grid.draw(rect$gridlines(gp=gpar(col="blue", lex=4)))
     grid.draw(rect$hexlines(gp=gpar(col="green")))
     popViewport()

     pushViewport(viewport(x=0.75, y=0.75, width=1/2, height=1/2))
     grid.draw(convex6$shape(gp=gp))
     grid.draw(convex6$checkers(gp=gpar(fill="blue")))
     popViewport()

     pushViewport(viewport(x=0.25, y=0.25, width=1/2, height=1/2))
     grid.draw(circle$shape(gp=gp))
     grid.draw(circle$mat(mat_width=0.2, gp=gpar(fill="blue")))
     popViewport()

     pushViewport(viewport(x=0.75, y=0.25, width=1/2, height=1/2))
     grid.draw(rect$shape(gp=gp))
     grid.draw(rect$mat(mat_width=c(0.2, 0.1, 0.3, 0.4), gp=gpar(fill="blue")))
     popViewport()
 }
 if (require("grid", quietly = TRUE)) {
     grid.newpage()
     gp &lt;- gpar(col="black", fill="yellow")

     vp &lt;- viewport(x=1/4, y=1/4, width=1/2, height=1/2)
     grid.draw(pp_shape("halma")$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=3/4, y=1/4, width=1/2, height=1/2)
     grid.draw(pp_shape("pyramid")$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=3/4, y=3/4, width=1/2, height=1/2)
     grid.draw(pp_shape("kite")$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=1/4, y=3/4, width=1/2, height=1/2)
     grid.draw(pp_shape("meeple")$shape(gp=gp, vp=vp))
 }
 if (require("grid", quietly = TRUE)) {
     grid.newpage()
     vp &lt;- viewport(x=1/4, y=1/4, width=1/2, height=1/2)
     grid.draw(pp_shape("convex3", 0)$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=3/4, y=1/4, width=1/2, height=1/2)
     grid.draw(pp_shape("convex4", 90)$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=3/4, y=3/4, width=1/2, height=1/2)
     grid.draw(pp_shape("convex5", 180)$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=1/4, y=3/4, width=1/2, height=1/2)
     grid.draw(pp_shape("convex6", 270)$shape(gp=gp, vp=vp))
 }
 if (require("grid", quietly = TRUE)) {
     grid.newpage()
     vp &lt;- viewport(x=1/4, y=1/4, width=1/2, height=1/2)
     grid.draw(pp_shape("concave3", 0, 0.1)$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=3/4, y=1/4, width=1/2, height=1/2)
     grid.draw(pp_shape("concave4", 90, 0.2)$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=3/4, y=3/4, width=1/2, height=1/2)
     grid.draw(pp_shape("concave5", 180, 0.3)$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=1/4, y=3/4, width=1/2, height=1/2)
     grid.draw(pp_shape("concave6", 270)$shape(gp=gp, vp=vp))
 }
 if (require("grid", quietly = TRUE) &amp;&amp;
     requireNamespace("gridpattern", quietly = TRUE)) {
     grid.newpage()
     hex &lt;- pp_shape("convex6")
     gp &lt;- gpar(fill = c("blue", "yellow", "red"), col = "black")
     grid.draw(hex$pattern("polygon_tiling", gp = gp, spacing = 0.1,
                           type = "truncated_trihexagonal"))
     gp &lt;- gpar(fill = "black", col = NA)
     grid.draw(hex$mat(mat_width = 0.025, gp = gp))
 }
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>BW3stagePPSe</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Estimated relvariance components for 3-stage sample
</h2>

<h3>Description</h3>

<p>Estimate components of relvariance for a sample design where primary sampling units (PSUs) are selected with probability proportional to size with replacement (<em>ppswr</em>) and secondary sampling units (SSUs) and elements within SSUs are selected via simple random sampling (<em>srs</em>). The input is a sample selected in this way.
</p>


<h3>Usage</h3>

<pre><code class="language-R">BW3stagePPSe(dat, v, Ni, Qi, Qij, m, lonely.SSU = "mean", lonely.TSU = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>

<p>data frame for sample elements with PSU and SSU identifiers, weights, and analysis variable(s).  The data frame should be sorted in hierarchical order: by PSU and SSU within PSU.
Required names for columns:
<code>psuID</code> = PSU identifier;
<code>ssuID</code> = SSU identifier. These must be unique, i.e., numbering should not restart within each PSU. Setting <code>ssuID</code> = <code>psuID</code>||(<code>ssuID</code> within PSU) is a method of doing this.
<code>w1i</code>  = vector of weights for PSUs;
<code>w2ij</code> = vector of weights for SSUs (PSU weight*SSU weight within PSU);
<code>w</code> = full sample weight
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>

<p>Name or number of column in data frame <code>dat</code> with variable to be analyzed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ni</code></td>
<td>

<p><code>m</code>-vector of number of SSUs in the population in the sample PSUs; <code>m</code> is number of sample PSUs.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qi</code></td>
<td>

<p><code>m</code>-vector of number of elements in the population in the sample PSUs
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qij</code></td>
<td>

<p>vector of numbers of elements in the population in the sample SSUs
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>number of sample PSUs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lonely.SSU</code></td>
<td>

<p>indicator for how singleton SSUs should be handled when computing the within PSU unit relvariance. Allowable values are <code>"mean"</code> and <code>"zero"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lonely.TSU</code></td>
<td>

<p>indicator for how singleton third-stage units (TSUs) should be handled when computing the within SSU unit relvariance. Allowable values are <code>"mean"</code> and <code>"zero"</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>BW3stagePPSe</code> computes the between and within population relvariance components appropriate
for a three-stage sample in which PSUs are selected with varying probabilities and with replacement.
SSUs and elements within SSUs are selected by simple random sampling.
The estimated components are appropriate for approximating the relvariance of the
<em>pwr</em>-estimator of a total when the same number of SSUs are selected within each PSU,
and the same number of elements are selected within each sample SSU.
</p>
<p>If a PSU contains multiple SSUs, some of which have missing data, or contains only one SSU, a value is imputed. If <code>lonely.SSU = "mean"</code>, the mean of the non-missing PSU contributions is imputed. If <code>lonely.SSU = "zero"</code>, a 0 is imputed. The former would be appropriate if a PSU contains multiple SSUs but one or more of them has missing data in which case R will normally calculate an NA. The latter would be appropriate if the PSU contains only one SSU which would be selected with certainty in any sample. <code>lonely.TSU</code> has a similar purpose for third-stage units.
</p>


<h3>Value</h3>

<p>List with values:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Vpsu</code></td>
<td>
<p>estimated between PSU unit variance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vssu</code></td>
<td>
<p>estimated second-stage unit variance among SSU totals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vtsu</code></td>
<td>
<p>estimated third-stage unit variance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>estimated between PSU unit relvariance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>estimated within PSU unit relvariance computed as if the sample were two-stage</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k1</code></td>
<td>
<p>estimated ratio of <code>B+W</code> to estimated unit relvariance of the analysis variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W2</code></td>
<td>
<p>estimated unit relvariance among SSU totals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W3</code></td>
<td>
<p>estimated third-stage unit relvariance among elements within PSU/SSUs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k2</code></td>
<td>
<p>estimated ratio of <code>W2+W3</code> to estimated unit relvariance of the analysis variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta1</code></td>
<td>
<p>homogeneity measure among elements within PSUs estimated as <code class="reqn">B^2/(B^2+W^2)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta2</code></td>
<td>
<p>homogeneity measure among elements within SSUs estimated as <code class="reqn">W_{2}^2/(W_{2}^2 + W_{3}^2)</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Richard Valliant, Jill A. Dever, Frauke Kreuter
</p>


<h3>References</h3>

<p>Hansen, M.H., Hurwitz, W.N., and Madow, W.G. (1953, chap. 9, sect. 10). <em>Sample Survey Methods and Theory</em>, Vol.II. New York: John Wiley &amp; Sons.
</p>
<p>Valliant, R., Dever, J., Kreuter, F. (2018, sect. 9.4.2). <em>Practical Tools for Designing and Weighting Survey Samples, 2nd edition</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code>BW2stagePPS</code>, <code>BW2stagePPSe</code>, <code>BW2stageSRS</code>, <code>BW3stagePPS</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
    # select 3-stage sample from Maryland population
set.seed(-780087528)
data(MDarea.popA)
MDpop &lt;- MDarea.popA
require(sampling)
require(plyr)      # has function that allows renaming variables
    # make counts of SSUs and elements per PSU
xx &lt;- do.call("rbind",list(by(1:nrow(MDpop),MDpop$SSU,head,1)))
pop.tmp &lt;- MDpop[xx,]
Ni &lt;- table(pop.tmp$PSU)
Qi &lt;- table(MDarea.popA$PSU)
Qij &lt;- table(MDpop$SSU)
m &lt;- 30         # no. of PSUs to select
probi &lt;- m*Qi / sum(Qi)
    # select sample of clusters
sam &lt;- cluster(data=MDpop, clustername="PSU", size=m, method="systematic",
               pik=probi, description=TRUE)
    # extract data for the sample clusters
samclus &lt;- getdata(MDpop, sam)
samclus &lt;- rename(samclus, c("Prob" = "p1i"))
samclus &lt;- samclus[order(samclus$PSU),]
    # treat sample clusters as strata and select srswor of block groups from each
    # identify psu IDs for 1st instance of each ssuID
xx &lt;- do.call("rbind",list(by(1:nrow(samclus),samclus$SSU,head,1)))
SSUs &lt;- cbind(PSU=samclus$PSU[xx], SSU=samclus$SSU[xx])
    # select 2 SSUs per tract
n &lt;- 2
s &lt;- strata(data = as.data.frame(SSUs), stratanames = "PSU",
            size = rep(n,m), method="srswor")
s &lt;- rename(s, c("Prob" = "p2i"))
    # extract the SSU data
    # s contains selection probs of SSUs, need to get those onto data file
SSUsam &lt;- SSUs[s$ID_unit, ]
SSUsam &lt;- cbind(SSUsam, s[, 2:3])
    # identify rows in PSU sample that correspond to sample SSUs
tmp &lt;- samclus$SSU %in% SSUsam$SSU
SSUdat &lt;- samclus[tmp,]
SSUdat &lt;- merge(SSUdat, SSUsam[, c("p2i","SSU")], by="SSU")
    # select srswor from each sample SSU
n.SSU &lt;- m*n
s &lt;- strata(data = as.data.frame(SSUdat), stratanames = "SSU",
            size = rep(50,n.SSU), method="srswor")
s &lt;- rename(s, c("Prob" = "p3i"))
samclus &lt;- getdata(SSUdat, s)
del &lt;- (1:ncol(samclus))[dimnames(samclus)[[2]] %in% c("ID_unit","Stratum")]
samclus &lt;- samclus[, -del]
    # extract pop counts for PSUs in sample
pick &lt;- names(Qi) %in% sort(unique(samclus$PSU))
Qi.sam &lt;- Qi[pick]
    # extract pop counts of SSUs for PSUs in sample
pick &lt;- names(Ni) %in% sort(unique(samclus$PSU))
Ni.sam &lt;- Ni[pick]
    # extract pop counts for SSUs in sample
pick &lt;- names(Qij) %in% sort(unique(samclus$SSU))
Qij.sam &lt;- Qij[pick]
    # compute full sample weight and wts for PSUs and SSUs
wt &lt;- 1 / samclus$p1i / samclus$p2i / samclus$p3i
w1i &lt;- 1 / samclus$p1i
w2ij &lt;- 1 / samclus$p1i / samclus$p2i
samdat &lt;- data.frame(psuID = samclus$PSU, ssuID = samclus$SSU,
                     w1i = w1i, w2ij = w2ij, w = wt,
                     samclus[, c("y1","y2","y3","ins.cov", "hosp.stay")])
BW3stagePPSe(dat=samdat, v="y1", Ni=Ni.sam, Qi=Qi.sam, Qij=Qij.sam, m,
    lonely.SSU = "mean", lonely.TSU = "mean")

</code></pre>


</div>
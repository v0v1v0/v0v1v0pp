<div class="container">

<table style="width: 100%;"><tr>
<td>pedigreeLoops</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pedigree loops</h2>

<h3>Description</h3>

<p>Functions for identifying, breaking and restoring loops in pedigrees.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pedigreeLoops(x)

breakLoops(x, loop_breakers = NULL, verbose = TRUE)

tieLoops(x)

findLoopBreakers(x)

findLoopBreakers2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>linkdat</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loop_breakers</code></td>
<td>
<p>either NULL (resulting in automatic selection of loop
breakers) or a numeric containing IDs of individuals to be used as loop
breakers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a logical: Verbose output or not?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Most of paramlink's handling of pedigree loops is done under the hood - using
the functions described here - without need for explicit action from end
users. When a linkdat object <code>x</code> is created, an internal routine detects
if the pedigree contains loops, in which case <code>x$hasLoops</code> is set to
TRUE. In analyses of <code>x</code> where loops must be broken (e.g. lod score
computation or marker simulation), this is done automatically by calling
<code>breakLoops</code>.
</p>
<p>In some cases with complex inbreeding, it can be instructive to plot the
pedigree after breaking the loops. Duplicated individuals are plotted with
appropriate labels (see examples).
</p>
<p>The function <code>findLoopBreakers</code> identifies a set of individuals breaking
all inbreeding loops, but not marriage loops. These require more machinery
for efficient detection, and paramlink does this is a separate function,
<code>findLoopBreakers2</code>, utilizing methods from the <code>igraph</code> package.
Since this is rarely needed for most users, <code>igraph</code> is not imported
when loading paramlink, only when <code>findLoopBreakers2</code> is called.
</p>
<p>In practice, <code>breakLoops</code> first calls <code>findLoopBreakers</code> and breaks
at the returned individuals. If the resulting linkdat object still has loops,
<code>findLoopBreakers2</code> is called to break any marriage loops.
</p>


<h3>Value</h3>

<p>For <code>breakLoops</code>, a <code>linkdat</code> object in which the indicated
loop breakers are duplicated. The returned object will also have a non-null
<code>loop_breakers</code> entry, namely a matrix with the IDs of the original
loop breakers in the first column and the duplicates in the second.
</p>
<p>For <code>tieLoops</code>, a <code>linkdat</code> object in which any duplicated
individuals (as given in the <code>x$loop_breakers</code> entry) are merged. For
any linkdat object <code>x</code>, the call <code>tieLoops(breakLoops(x))</code> should
return <code>x</code>.
</p>
<p>For <code>pedigreeLoops</code>, a list containing all inbreeding loops (not
marriage loops) found in the pedigree. Each loop is represented as a list
with elements 'top', a 'bottom' individual, 'pathA' (individuals forming a
path from top to bottom) and 'pathB' (creating a different path from top to
bottom, with no individuals in common with pathA). Note that the number of
loops reported here counts all closed paths in the pedigree and will in
general be larger than the genus of the underlying graph.
</p>
<p>For <code>findLoopBreakers</code> and <code>findLoopBreakers2</code>, a numeric vector
of individual ID's.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x = cousinsPed(1, child=TRUE)

# Make the child affected, and homozygous for rare allele.
x = swapAff(x, 9)
x = setMarkers(x, marker(x, 9, c(2,2), alleles=1:2, afreq=c(0.99, 0.01)))

# Compute the LOD score under a recessive model. Loops are automatically broken in lod().
x = setModel(x, 2)
LOD1 = lod(x, theta=0.1)
stopifnot(round(LOD1, 2) == 0.88)

# Or we can break the loop manually before computing the LOD:
loopfree = breakLoops(x, loop_breaker=8)
plot(loopfree)
LOD2 = lod(loopfree, theta=0.1)
stopifnot(all.equal(x, tieLoops(loopfree)))
stopifnot(all.equal(LOD1, LOD2))

# Pedigree with marriage loop: Double first cousins
if(requireNamespace("igraph", quietly = TRUE)) {
    y = doubleCousins(1, 1, child=TRUE)
    findLoopBreakers(y) # --&gt; 9
    findLoopBreakers2(y) # --&gt; 9 and 4
    breakLoops(y) # uses both 9 and 4
}

</code></pre>


</div>
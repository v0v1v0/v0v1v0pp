<div class="container">

<table style="width: 100%;"><tr>
<td>irrad</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Irradiance</h2>

<h3>Description</h3>

<p>This function returns the irradiance for a given waveband of a light source
spectrum.
</p>


<h3>Usage</h3>

<pre><code class="language-R">irrad(
  spct,
  w.band,
  unit.out,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## Default S3 method:
irrad(
  spct,
  w.band,
  unit.out,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## S3 method for class 'source_spct'
irrad(
  spct,
  w.band = NULL,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = !quantity %in% c("average", "mean", "total"),
  naming = "default",
  return.tb = FALSE,
  ...
)

## S3 method for class 'source_mspct'
irrad(
  spct,
  w.band = NULL,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = !quantity %in% c("average", "mean", "total"),
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>spct</code></td>
<td>
<p>an R object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.band</code></td>
<td>
<p>waveband or list of waveband objects The waveband(s) determine
the region(s) of the spectrum that are summarized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit.out</code></td>
<td>
<p>character Allowed values <code>"energy"</code>, and
<code>"photon"</code>, or its alias <code>"quantum"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantity</code></td>
<td>
<p>character string One of "total", "average" or "mean",
"contribution", "contribution.pc", "relative" or "relative.pc".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.unit</code></td>
<td>
<p>character or lubridate::duration object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wb.trim</code></td>
<td>
<p>logical if <code>TRUE</code> wavebands crossing spectral data
boundaries are trimmed, if <code>FALSE</code>, they are discarded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert "hinges" into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands. If NULL, default is chosen based on data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow.scaled</code></td>
<td>
<p>logical indicating whether scaled or normalized spectra
as argument to spct are flagged as an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>naming</code></td>
<td>
<p>character one of <code>"long"</code>, <code>"default"</code>,
<code>"short"</code> or <code>"none"</code>. Used to select the type of names to assign
to returned value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.tb</code></td>
<td>
<p>logical Flag forcing a tibble to be always returned, even
for a single spectrum as argumnet to <code>spct</code>. The default is
<code>FALSE</code> for backwards compatibility.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr2tb</code></td>
<td>
<p>character vector, see <code>add_attr2tb</code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A named <code>numeric</code> vector in the case of a <code>_spct</code> object
containing a single spectrum and <code>return.tb = FALSE</code>. The vector has
one member one value for each <code>waveband</code> passed to parameter
<code>w.band</code>. In all other cases a <code>tibble</code>, containing one column
for each <code>waveband</code> object, an index column with the names of the
spectra, and optionally additional columns with metadata values retrieved
from the attributes of the member spectra.
</p>
<p>If <code>naming = "long"</code> the names generated reflect both quantity and
waveband, if <code>naming = "short"</code>, names are based only on the wavebands,
and if <code>naming = "none"</code> the returned vector has no names.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used. The <code>time.unit</code>
attribute is copied from the spectrum object to the output. Units are as
follows: If time.unit is second, [W m-2 nm-1] -&gt; [mol s-1 m-2] or [W m-2
nm-1] -&gt; [W m-2] If time.unit is day, [J d-1 m-2 nm-1] -&gt; [mol d-1 m-2] or
[J d-1 m-2 nm-1] -&gt; [J m-2]
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>irrad(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>irrad(source_spct)</code>: Calculates irradiance from a <code>source_spct</code>
object.
</p>
</li>
<li> <p><code>irrad(source_mspct)</code>: Calculates irradiance from a <code>source_mspct</code> object.
</p>
</li>
</ul>
<h3>Note</h3>

<p>Formal parameter <code>allow.scaled</code> is used internally for calculation
of ratios, as rescaling and normalization do not invalidate the calculation
of ratios.
</p>
<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult=TRUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>See Also</h3>

<p>Other irradiance functions: 
<code>e_fluence()</code>,
<code>e_irrad()</code>,
<code>fluence()</code>,
<code>q_fluence()</code>,
<code>q_irrad()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">irrad(sun.spct, waveband(c(400,700)))
irrad(sun.spct, waveband(c(400,700)), "energy")
irrad(sun.spct, waveband(c(400,700)), "photon")
irrad(sun.spct, split_bands(c(400,700), length.out = 3))
irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "total")
irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "average")
irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "relative")
irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "relative.pc")
irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "contribution")
irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "contribution.pc")

</code></pre>


</div>
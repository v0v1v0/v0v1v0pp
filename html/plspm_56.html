<div class="container">

<table style="width: 100%;"><tr>
<td>local.models</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PLS-PM for global and local models</h2>

<h3>Description</h3>

<p>Calculates PLS-PM for global and local models from a
given partition
</p>


<h3>Usage</h3>

<pre><code class="language-R">  local.models(pls, y, Y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pls</code></td>
<td>
<p>An object of class <code>"plspm"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>One object of the following classes:
<code>"rebus"</code>, <code>"integer"</code>, or <code>"factor"</code>,
that provides the class partitions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Optional dataset (matrix or data frame) used
when argument <code>dataset=NULL</code> inside <code>pls</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>local.models</code> calculates PLS-PM for the global
model (i.e. over all observations) as well as PLS-PM for
local models (i.e. observations of different partitions).
</p>
<p>When <code>y</code> is an object of class <code>"rebus"</code>,
<code>local.models</code> is applied to the classes obtained
from the REBUS algorithm.
</p>
<p>When <code>y</code> is an <code>integer</code> vector or a
<code>factor</code>, the values or levels are assumed to
represent the group to which each observation belongs. In
this case, the function <code>local.models</code> calculates
PLS-PM for the global model, as well as PLS-PM for each
group (local models).
</p>
<p>When the object <code>pls</code> does not contain a data matrix
(i.e. <code>pls$data=NULL</code>), the user must provide the
data matrix or data frame in <code>Y</code>.
</p>
<p>The original parameters <code>modes</code>, <code>scheme</code>,
<code>scaled</code>, <code>tol</code>, and <code>iter</code> from the
object <code>pls</code> are taken.
</p>


<h3>Value</h3>

<p>An object of class <code>"local.models"</code>, basically a
list of length <code>k+1</code>, where <code>k</code> is the number
of classes.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>glob.model</code></td>
<td>
<p>PLS-PM of the global model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc.model.1</code></td>
<td>
<p>PLS-PM of segment (class) 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc.model.2</code></td>
<td>
<p>PLS-PM of segment (class) 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc.model.k</code></td>
<td>
<p>PLS-PM of segment (class) k</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Each element of the list is an object of class
<code>"plspm"</code>. Thus, in order to examine the results for
each local model, it is necessary to use the
<code>summary</code> function.
</p>


<h3>Author(s)</h3>

<p>Laura Trinchera, Gaston Sanchez
</p>


<h3>See Also</h3>

<p><code>rebus.pls</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Example of REBUS PLS with simulated data

# load simdata
data("simdata", package='plspm')

# Calculate global plspm
sim_inner = matrix(c(0,0,0,0,0,0,1,1,0), 3, 3, byrow=TRUE)
dimnames(sim_inner) = list(c("Price", "Quality", "Satisfaction"),
                           c("Price", "Quality", "Satisfaction"))
sim_outer = list(c(1,2,3,4,5), c(6,7,8,9,10), c(11,12,13))
sim_mod = c("A", "A", "A")  # reflective indicators
sim_global = plspm(simdata, sim_inner,
                   sim_outer, modes=sim_mod)
sim_global

## Then compute cluster analysis on residuals of global model
sim_clus = res.clus(sim_global)

## To complete REBUS, run iterative algorithm
rebus_sim = it.reb(sim_global, sim_clus, nk=2,
                   stop.crit=0.005, iter.max=100)

## You can also compute complete outputs
## for local models by running:
local_rebus = local.models(sim_global, rebus_sim)

# Display plspm summary for first local model
summary(local_rebus$loc.model.1)

## End(Not run)
</code></pre>


</div>
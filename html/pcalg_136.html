<div class="container">

<table style="width: 100%;"><tr>
<td>udag2apag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Last step of RFCI algorithm: Transform partially oriented graph into RFCI-PAG</h2>

<h3>Description</h3>

<p>This function performs the last step of the RFCI algorithm: It
transforms a partially oriented graph in which
the v-structures have been oriented into an RFCI Partial Ancestral
Graph (PAG) (see Colombo et al (2012)).
</p>
<p>While orienting the edges, this function performs some additional
conditional independence tests in orientation rule 4 to ensure
correctness of the ancestral relationships.  As a result of these
additional tests, some additional edges can be deleted.  The result is
the final adjacency matrix indicating also the edge marks and the
updated sepsets.
</p>


<h3>Usage</h3>

<pre><code class="language-R">udag2apag(apag, suffStat, indepTest, alpha, sepset,
          rules = rep(TRUE, 10), unfVect = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>apag</code></td>
<td>
<p>Adjacency matrix of type amat.pag</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffStat</code></td>
<td>
<p>Sufficient statistics: A <code>list</code> containing
all necessary elements for the conditional independence decisions in the
function <code>indepTest</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indepTest</code></td>
<td>
<p>Pre-defined function for testing conditional
independence.  The function is internally called as
<code>indepTest(x,y,S,suffStat)</code>, and tests conditional independence
of <code>x</code> and <code>y</code> given <code>S</code>.  Here, <code>x</code> and <code>y</code>
are variables, and <code>S</code> is a (possibly empty) set of variables
(all variables are coded by their column numbers in the adjacency
matrix).  <code>suffStat</code> is a list containing all relevant elements
for the conditional independence decisions.  The return value of
<code>indepTest</code> is the p-value of the test for conditional
independence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Significance level for the individual conditional
independence tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sepset</code></td>
<td>
<p>List of length p; each element of the list
contains another list of length p.  The element
<code>sepset[[x]][[y]]</code> contains the separation set that made the edge
between <code>x</code> and <code>y</code> drop out. Each separation set is a
vector with (integer) positions of variables in the adjacency
matrix.  This object is thought to be
obtained from a <code>pcAlgo</code>-object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rules</code></td>
<td>
<p>Logical vector of length 10 with <code>TRUE</code> or <code>FALSE</code> for
each rule, where <code>TRUE</code> in position i means that rule i (Ri) will be
applied.  By default, all rules are active.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unfVect</code></td>
<td>
<p>Vector containing numbers that encode the ambiguous
triples (as returned by <code>pc.cons.intern</code>).  This is
needed in the conservative and in the majority rule versions of RFCI.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical indicating if detailed output is to be given.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The partially oriented graph in which the v-structures have been
oriented is transformed into an RFCI-PAG using adapted rules of Zhang
(2008).  This function is similar to <code>udag2pag</code> used to
orient the skeleton into a PAG in the FCI algorithm.  However, it is
slightly more complicated because we perform additional conditional
independence tests when applying rule 4, to ensure correctness of the
ancestral relationships.  As a result, some additional edges can be
deleted, see Colombo et al. (2012).  Because of these addiitonal
tests, we need to give <code>suffStat</code>, <code>indepTest</code>, and
<code>alpha</code> as inputs. Since edges can be deleted, the input
adjacency matrix <code>apag</code> and the input separating sets
<code>sepset</code> can change in this algorithm.
</p>
<p>If <code>unfVect = NULL</code> (no ambiguous triples), the orientation rules
are applied to each eligible structure until no more edges can be
oriented.  On the other hand, hand, if one uses conservative or
majority rule FCI and ambiguous triples have been found in
<code>pc.cons.intern</code>, <code>unfVect</code> contains the numbers of
all ambiguous triples in the graph.  In this case, the orientation
rules take this information into account.  For example, if a *-&gt; b o-*
c and &lt;a,b,c&gt; is an unambigous unshielded triple and not a
v-structure, then we obtain b -* c (otherwise we would create an
additional v-structure).  On the other hand, if a *-&gt; b o-* c but
&lt;a,b,c&gt; is an ambiguous unshielded triple, then the circle mark at b
is not oriented.
</p>
<p>Note that the algorithm works with columns' position of the adjacency
matrix and not with the names of the variables.
</p>
<p>Note that this function does not resolve possible order-dependence in
the application of the orientation rules, see Colombo and Maathuis (2014).
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>apag</code></td>
<td>
<p>Final adjacency matrix of type amat.pag</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sepset</code></td>
<td>
<p>Updated list of separating sets</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Diego Colombo and Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782.
</p>
<p>D. Colombo, M. H. Maathuis, M. Kalisch, T. S. Richardson (2012).
Learning high-dimensional directed acyclic graphs with latent
and selection variables. <em>Ann. Statist.</em> <b>40</b>, 294–321.
</p>
<p>J. Zhang (2008). On the completeness of orientation rules for causal
discovery in the presence of latent confounders and selection bias.
<em>Artificial Intelligence</em> <b>172</b>, 1873–1896.
</p>


<h3>See Also</h3>

<p><code>rfci</code>, <code>udag2pag</code>,
<code>dag2pag</code>, <code>udag2pdag</code>,
<code>udag2pdagSpecial</code>, <code>udag2pdagRelaxed</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##################################################%  --------       -----------
## Example with hidden variables
## Zhang (2008), Fig. 6, p.1882
##################################################

## create the DAG :
amat &lt;- t(matrix(c(0,1,0,0,1, 0,0,1,0,0, 0,0,0,1,0, 0,0,0,0,0, 0,0,0,1,0),5,5))
V &lt;- LETTERS[1:5]
colnames(amat) &lt;- rownames(amat) &lt;- V
edL &lt;- setNames(vector("list",length=5), V) 
edL[[1]] &lt;- list(edges= c(2,4),weights=c(1,1))
edL[[2]] &lt;- list(edges= 3,     weights=c(1))
edL[[3]] &lt;- list(edges= 5,     weights=c(1))
edL[[4]] &lt;- list(edges= 5,     weights=c(1))
## and leave  edL[[ 5 ]] empty
g &lt;- new("graphNEL", nodes=V, edgeL=edL, edgemode="directed")
if (require(Rgraphviz))
  plot(g)

## define the latent variable
L &lt;- 1

## compute the true covariance matrix of g
cov.mat &lt;- trueCov(g)

## delete rows and columns belonging to latent variable L
true.cov &lt;- cov.mat[-L,-L]

## transform covariance matrix into a correlation matrix
true.corr &lt;- cov2cor(true.cov)


n &lt;- 100000
alpha &lt;- 0.01
p &lt;- ncol(true.corr)

if (require("MASS")) {
  ## generate 100000 samples of DAG using standard normal error distribution
  set.seed(289)
  d.mat &lt;- mvrnorm(n, mu = rep(0, p), Sigma = true.cov)

  ## estimate the skeleton of given data
  suffStat &lt;- list(C = cor(d.mat), n = n)
  indepTest &lt;- gaussCItest
  resD &lt;- skeleton(suffStat, indepTest, alpha = alpha, labels=colnames(true.corr))

  ## estimate all ordered unshielded triples
  amat.resD &lt;- as(resD@graph, "matrix")
  print(u.t &lt;- find.unsh.triple(amat.resD)) # four of them

  ## check and orient v-structures
  vstrucs &lt;- rfci.vStruc(suffStat, indepTest, alpha=alpha,
			 sepset = resD@sepset, g.amat = amat.resD,
			 unshTripl= u.t$unshTripl, unshVect = u.t$unshVect,
			 verbose = TRUE)

  ## Estimate the final skeleton and extend it into a PAG
  ## (using all 10 rules, as per default):
  resP &lt;- udag2apag(vstrucs$amat, suffStat, indepTest=indepTest, alpha=alpha,
		    sepset=vstrucs$sepset, verbose = TRUE)
  print(Amat &lt;- resP$graph)
} # only if "MASS" is there

</code></pre>


</div>
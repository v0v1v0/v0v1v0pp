<div class="container">

<table style="width: 100%;"><tr>
<td>pcarma_solve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Functions to compute various characteristics of a PCARMA model
</h2>

<h3>Description</h3>

<p>Given a PCARMA model, create a function for computing autocovariances
or coefficients of the corresponding infinite moving average
representation or prepare the linear system whose solution provides
the first few autocovariances of the model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pcarma_acvf_lazy(phi, theta, sigma2, p, q, period, maxlag = 100)
pcarma_h_lazy(phi, theta, p, q, period, maxlag = 200)
pcarma_acvf_system(phi, theta, sigma2, p, q, period)
pcarma_param_system(acf, h, sigma2, p, q, period)
pcarma_h(h, na = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>

<p>the autoregression parameters, an object of class <code>"slMatrix"</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>

<p>the moving average parameters, an object of class <code>"slMatrix"</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p>the innovation variances, an object of class
<code>"PeriodicVector"</code> or  a vector of size <code>period</code>, Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>

<p>the (maximal) autoregression order or the autoregression orders.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>

<p>the (maximal) moving average order or the moving average orders.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p> number of seasons in an epoch </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxlag</code></td>
<td>

<p>maximal lag for which the result is stored internally.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acf</code></td>
<td>
<p> the autocovariance function, an object of class pcAcvf,
slMatrix, or similar </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
  <p><code>pcarma_param_system</code>,
<code>h(t,k)</code>  is expected to return the coefficient
<code class="reqn">h_{t,k}</code>. <code>h</code> is usually created by
<code>pcarma_h_lazy</code>.
For <code>pcarma_h</code>,  a matrix of h(t,i) coefficients.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na</code></td>
<td>

<p>not used currently, controls what to do for large lags.
</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Compute acvf from parameters</h4>

<p><code>pcarma_acvf_lazy</code> creates a function that will compute (on
demand) values of the acf by a recursive formula. Computed values
are stored internally for lags up to <code>maxlag</code>.
</p>



<h4>System for acvf from parameters</h4>

<p><code>pcarma_acvf_system</code> forms a linear system for the calculation
of autocovariances from the parameters of a pc-arma model.  The
argument <code>theta</code> is not used if <code class="reqn">q=0</code> and <code>phi</code> is not
used if <code class="reqn">p=0</code>.
</p>



<h4>System for parameters from acvf</h4>

<p><code>pcarma_param_system</code> takes
the periodic autocovariances of a pc-arma model and computes a
matrix and a vector representing the linear system whose solution
provides the parameters of the model.
</p>
<p>Scalar <code>p</code> specifies the same autoregression order for each
season, similarly for <code>q</code>.  <code>p</code> and <code>q</code> may be
vectors of length <code>period</code> specifying the order for each season
individually. In the latter case the solution of the system may not
be a proper model or, if it is, its autocovariances may not be the
ones used here! See the references for details.
</p>
<p>The class of <code>acf</code> is not required to be one of those
explicitly listed above, but it should understand their indexing
conventions, similarly for <code>sigma2</code>.
</p>
<p>For pure autoregression, <code class="reqn">q=0</code>, the arguments <code>h</code> and
<code>sigma2</code> are ignored. <strong>TODO: add sigma2 (if supplied) to
the returned list?</strong>
</p>



<h4>Compute h from parameters</h4>

<p><code>pcarma_h_lazy</code>: h(t,i) are the coefficients in infinite the
moving average representation of the pc.arma model. The calculations
use formula (4.4) from my paper (or elsewhere) with internal storage
(in an slMatrix) of calculated results (for i&lt;maxlag) and recursive
calls to itself. So, it is not necessary to compute h(t,i) in any
particular order.
</p>



<h4>Infinite MA coefficients(h)</h4>

<p><code>pcarma_h</code> Function to create a function for lazy computation
of h(t,i) in pc.arma models
</p>
<p>Takes a matrix of h(t,i) coefficeints and returns a function that
calculates h(t,i) from my paper xxx. The returned value can be used
in the same way as that of <code>pcarma_h_lazy</code>.
</p>



<h3>Value</h3>



<h4>for pcarma_acvf_lazy</h4>

<p>a function taking two arguments <code>t</code> and <code>k</code> such that for
scalar <code>t</code> and <code>k</code> the call <code>f(t,k)</code> will return
EX(t)X(t-k). If either of the arguments is a vector, then
<code>f(t,k)</code> returns a matrix of size (<code>length(t),length(k)</code>)
containing the respective autocovariances.
</p>



<h4>for pcarma_h_lazy</h4>

<p>a function, say <code>h</code>. In calls to <code>h</code>, if both arguments
are scalars <code>h(t,i)</code> returns <code class="reqn">h_{t,i}</code>. If at least one of the
arguments is a vector a matrix of values of <code class="reqn">h</code> is returned.
</p>



<h4>for pcarma_acvf_system</h4>

<p>a list with two components representing the linear system:
</p>

<dl>
<dt>A</dt>
<dd>
<p>The
<code class="reqn">(p+1)\mbox{period}\times(p+1)\mbox{period}</code>
matrix of the system, an object of class "matrix".
</p>
</dd>
<dt>b</dt>
<dd>
<p>The right-hand side of the system,  a vector of length
<code class="reqn">(p+1)\mbox{period}</code>, an object of class "vector".
</p>
</dd>
</dl>
<p><code class="reqn">A^{-1}b</code> can be used to get a vector of the
autocovariances in the following order (d is the period, p is the
maximal AR order):
</p>
<p style="text-align: center;"><code class="reqn">K(1,0),...,K(d,0), K(1,1),...,K(d,1),...,K(1,p),...,K(d,p).</code>
</p>




<h4>for pcarma_param_system</h4>

<p>A list with components representing the linear system and the AR and
MA orders:
</p>

<dl>
<dt>A</dt>
<dd>
<p>The matrix of the system</p>
</dd>
<dt>b</dt>
<dd>
<p>The right-hand side of the system</p>
</dd>
<dt>p</dt>
<dd>
<p>The AR order</p>
</dd>
<dt>q</dt>
<dd>
<p>The MA order</p>
</dd>
</dl>
<p><code class="reqn">A^{-1}b</code> will return a vector of the parameters of the
pc-arma model: all parameters for the first season, followed by all
parameters for the second seasons and so on. For each season the
parameters are in the following order (s is the current season, d is
the period, <code class="reqn">p[s]</code> and <code class="reqn">q[s]</code> are the corresponding AR and
MA orders):
</p>
<p style="text-align: center;"><code class="reqn">
      \sigma^2(s), \phi(s,1),...,\phi(s,p[s]),\theta(s,1),...,\theta(s,q[s]).
    </code>
</p>




<h4>for pcarma_h</h4>

<p>a function, say <code>h</code>. In calls to <code>h</code>, if both arguments
are scalars <code>h(t,i)</code> returns <code class="reqn">h_{t,i}</code>. If at least one of the
arguments is a vector a matrix of values of <code class="reqn">h</code> is returned.
Analogous to <code>pcarma_h_lazy</code>.
</p>



<h3>Note</h3>

<p>for <code>pcarma_acvf_lazy</code>: The recursion may become extremely slow for lags greater than
<code>maxlag</code>. If large lags are likely to be needed the argument
<code>maxlag</code> should be used to increase the internal storage. The
default for <code>maxlag</code> currently is 100.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN (1996).
“Recursive computation of the parameters of periodic autoregressive moving-average processes.”
<em>J. Time Ser. Anal.</em>, <b>17</b>(4), 333–349.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.1996.tb00281.x">doi:10.1111/j.1467-9892.1996.tb00281.x</a>.
</p>


<h3>See Also</h3>


<p><code>pcarma_h</code>,
<code>pcarma_param_system</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## periodic acf of Lambert-Lacroix
data(ex1f)
(pc3 &lt;- slMatrix(period = 2, maxlag = 5, f = ex1f, type = "tt"))
## find the parameters
s3 &lt;- pcarma_param_system(pc3, NULL, NULL, 2, 0, 2)
coef3 &lt;- solve(s3$A, s3$b)
pcarma_unvec(list(p = 2, q = 0, period = 2, param = coef3))

## actually, the model is PAR(1,2):
s3a &lt;- pcarma_param_system(pc3, NULL, NULL, c(1, 2), 0, 2)
coef3a &lt;- solve(s3a$A, s3a$b)
pcarma_unvec(list(p = c(1,2), q = 0, period = 2, param = coef3a))


## prepare test parameters for a PAR(2) model with period=2.
##   (rounded to 6 digits from the above example.
m1 &lt;- rbind(c(1, 0.81, 0), c(1, 0.4972376, 0.4972376) )
m2 &lt;- rbind(c(1, 0, 0), c(1, 0, 0) )
testphi &lt;- slMatrix(init = m1)
testtheta &lt;- slMatrix(init = m2)
si2 &lt;- PeriodicVector(c(0.3439000, 0.1049724)) #     # or si2 &lt;- c(1,1)

## acf from parameters
myf &lt;- pcarma_acvf_lazy(testphi, testtheta, si2, 2, 0, 2, maxlag = 110)
myf(1,4)        # compute a value
a1 &lt;- myf(1:2,0:9)    # get a matrix of values

## h from parameters
h &lt;- pcarma_h_lazy(testphi, testtheta, 2, 2, 2)
h(3, 2)           # a scalar
h1 &lt;- h(1:2, 1:4) # a matrix

## compute acvf from parameters
( acfsys &lt;- pcarma_acvf_system(testphi, testtheta, si2, 2, 0, 2) )
acfvec &lt;- solve(acfsys$A, acfsys$b)
acf1 &lt;- slMatrix(acfvec, period = 2)

## TODO: examples wirh q != 0
</code></pre>


</div>
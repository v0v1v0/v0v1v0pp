<div class="container">

<table style="width: 100%;"><tr>
<td>smmSAR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulated Method of Moments (SMM) Estimator of SAR model</h2>

<h3>Description</h3>

<p><code>smmSAR</code> implements the Simulated Method of Moments (SMM) estimator of the linear-in-mean SAR model when only the linking probabilities are available or can be estimated.
</p>


<h3>Usage</h3>

<pre><code class="language-R">smmSAR(
  formula,
  contextual = FALSE,
  fixed.effects = FALSE,
  dnetwork,
  W = "identity",
  smm.ctr = list(R = 30L, iv.power = 2L, opt.tol = 1e-04, smoother = FALSE, print =
    FALSE),
  cond.var = TRUE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>object of class formula: a symbolic description of the model. The <code>formula</code> should be as for example <code>y ~ x1 + x2 | gy | gx1 + gx2</code>
where <code>y</code> is the endogenous vector, the listed variables before the pipe, <code>x1</code>, <code>x2</code> are the individual exogenous variables, <code>gy</code> is the average of <code>y</code> among friends, and
<code>gx1</code>, <code>gx2</code> are the contextual observed variables. If <code>gy</code> is observed and <code>gx1</code>, <code>gx2</code> are not, the formula should be
<code>y ~ x1 + x2 | gy</code>. If <code>gy</code> is not observed and <code>gx1</code>, <code>gx2</code> are, the formula should be <code>y ~ x1 + x2 || gx1 + gx2</code>. If <code>gy</code>, <code>gx1</code>, and <code>gx2</code> are not observed, the
the formula should simply be <code>y ~ x1 + x2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contextual</code></td>
<td>
<p>logical; if true, this means that all individual variables will be set as contextual variables. In contrast <code>mcmcSAR</code>,
<code>formula</code> as <code>y ~ x1 + x2</code> and <code>contextual</code> as <code>TRUE</code> is not equivalent to set formula as <code>y ~ x1 + x2 || gx1 + gx2</code>. <code>formula = y ~ x1 + x2</code> means that <code>gy</code>, <code>gx1</code>, and <code>gx2</code>
are not observed and <code>contextual = TRUE</code> means that the estimated model includes contextual effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.effects</code></td>
<td>
<p>logical; if true, group heterogeneity is included as fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dnetwork</code></td>
<td>
<p>a list, where the m-th elements is the matrix of link probability in the m-th sub-network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>is the weighted-matrix in the objective function of the SMM.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smm.ctr</code></td>
<td>
<p>is the list of some control parameters (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond.var</code></td>
<td>
<p>logical; if true the estimator variance conditional on <code>dnetwork</code> will be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables
in the model. If missing, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>smmSAR</code> is called.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The parameter <code>smm.ctr</code> is the list of some control parameters such as:
</p>

<ul>
<li> <p><code>R</code> numbers of draws R (in the package, we assume S = 1 and T = 1);
</p>
</li>
<li> <p><code>iv.power</code> number of powers of the network matrix <code>G</code> to be used to construct instruments;
</p>
</li>
<li> <p><code>opt.tol</code> optimization tolerance that will be used in optimize;
</p>
</li>
<li> <p><code>smoother</code> (logical) which indicates if draws should be performed using the smoother simulator;
</p>
</li>
<li> <p><code>h</code> bandwith of the smoother (required if <code>smoother = TRUE</code>);
</p>
</li>
<li> <p><code>print</code> (logical) indicates if the optimization process should be printed step by step.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>n.group</code></td>
<td>
<p>number of groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>vector of each group size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>elapsed time to run the SMM in second.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimates</code></td>
<td>
<p>vector of estimated parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>input value of <code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contextual</code></td>
<td>
<p>input value of <code>contextual</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.effects</code></td>
<td>
<p>input value of <code>fixed.effects</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smm.ctr</code></td>
<td>
<p>input value of <code>smm.ctr</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>details</code></td>
<td>
<p>other details of the model.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">
# Number of groups
M        &lt;- 100
# size of each group
N        &lt;- rep(30,M)
# covariates
X        &lt;- cbind(rnorm(sum(N),0,5),rpois(sum(N),7))
# network formation model parameter
rho      &lt;- c(-0.8, 0.2, -0.1)
# individual effects
beta     &lt;- c(2, 1, 1.5, 5, -3)
# endogenous effects
alpha    &lt;- 0.4
# std-dev errors
se       &lt;- 1
# network
tmp      &lt;- c(0, cumsum(N))
X1l      &lt;- lapply(1:M, function(x) X[c(tmp[x] + 1):tmp[x+1],1])
X2l      &lt;- lapply(1:M, function(x) X[c(tmp[x] + 1):tmp[x+1],2])
dist.net &lt;- function(x, y) abs(x - y)
X1.mat   &lt;- lapply(1:M, function(m) {
  matrix(kronecker(X1l[[m]], X1l[[m]], FUN = dist.net), N[m])})
X2.mat   &lt;- lapply(1:M, function(m) {
  matrix(kronecker(X2l[[m]], X2l[[m]], FUN = dist.net), N[m])})
Xnet     &lt;- as.matrix(cbind("Const" = 1,
                            "dX1"   = mat.to.vec(X1.mat),
                            "dX2"   = mat.to.vec(X2.mat)))
ynet     &lt;- Xnet %*% rho
ynet     &lt;- c(1*((ynet + rlogis(length(ynet))) &gt; 0))
G0       &lt;- vec.to.mat(ynet, N, normalise = FALSE)
# normalise
G0norm   &lt;- norm.network(G0)
# Matrix GX
GX       &lt;- peer.avg(G0norm, X)
# simulate dependent variable use an external package
y        &lt;- CDatanet::simsar(~ X, contextual = TRUE, Glist = G0norm,
                             theta = c(alpha, beta, se))
Gy       &lt;- y$Gy
y        &lt;- y$y
# build dataset
dataset           &lt;- as.data.frame(cbind(y, X, Gy, GX))
colnames(dataset) &lt;- c("y","X1","X2", "Gy", "GX1", "GX2")
nNet      &lt;- nrow(Xnet) # network formation model sample size
Aobs      &lt;- sample(1:nNet, round(0.3*nNet)) # We observed 30%
# We can estimate rho using the gml function from the stats package
logestim  &lt;- glm(ynet[Aobs] ~ -1 + Xnet[Aobs,], family = binomial(link = "logit"))
slogestim &lt;- summary(logestim)
rho.est   &lt;- logestim$coefficients
rho.var   &lt;- slogestim$cov.unscaled # we also need the covariance of the estimator

d.logit     &lt;- lapply(1:M, function(x) {
  out       &lt;- 1/(1 + exp(-rho.est[1] - rho.est[2]*X1.mat[[x]] -
                            rho.est[3]*X2.mat[[x]]))
  diag(out) &lt;- 0
  out})
smm.logit   &lt;- smmSAR(y ~ X1 + X2, dnetwork = d.logit, contextual = TRUE,
                      smm.ctr  = list(R = 100L, print = TRUE), data = dataset)
summary(smm.logit, dnetwork = d.logit, data = dataset)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>SVDgen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SVD with metrics and smoothing approximation</h2>

<h3>Description</h3>

<p>Computes the generalised Singular Value Decomposition, <em>i.e.</em> with
non-identity metrics. A smooth approximation can be asked to constraint the
components (<code>u</code> and <code>v</code>) to be smooth.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  SVDgen(Y, D2 = 1, D1 = 1, smoothing = FALSE, nomb = NULL,
                  smoo = list(function(u)ksmooth( 1:length(u), u, kernel = "normal",
                           bandwidth = 3, x.points = (1:length(u)))$y)) </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>a matrix <code class="reqn">n \times p</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D2</code></td>
<td>
<p>metric in <code class="reqn">R^p</code> either a vector (<code class="reqn">p \times 1</code>) or a matrix (<code class="reqn">p \times p</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D1</code></td>
<td>
<p>metric in <code class="reqn">R^n</code> either a vector (<code class="reqn">n \times 1</code>) or a matrix (<code class="reqn">n \times n</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothing</code></td>
<td>
<p>logical if <code>TRUE</code>  the smoothing methods in
<code>smoo</code> are used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nomb</code></td>
<td>
<p>numeric number of components to extract (typically when
smoothing is used less components are used as the screeplot becomes
flatter faster)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoo</code></td>
<td>

<p>list of lists of smoothing functions on a vector of the approriate dimension; if on one dimension it is
<code>NA</code> no smoothing will be done for this one; if the length of a list is one the function is used
for all components. If only one list in the list it will be used for both dimensions. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function computes the decomposition <code class="reqn">X=UL^{1/2}V'</code> where <code class="reqn">U'D_1U=Id_p</code> and
<code class="reqn">V'D_2V=Id_p</code> and the diagonal matrix <code class="reqn">L</code> containing no zeros squared singular values. If
<code>smoothing</code> a <em>constraint</em>  on Least Squares solution  is used, then the
above decomposition becomes an approximation (unless <code>X</code> belongs to the space defined by the constraints). A <em>Power Method</em> algorithm to compute each
principal tensor is used wherein Alternated Least Squares are always followed by a <em>smoothed
version</em> of the updated vectors. If a Spline smoothing was used the algorithm would be equivalent
to use the traditional <em>penalised least squares</em> at each iteration and could be called
<em>Penalised Power Method</em> or Splined Alternated Least Squares Algorithm (SALSA is already  an
acronym used by Besse and Ferraty (1995) in where  a similar idea is developped: but smoothing
operates only on variables, and is<em> model based</em> as the Alternating operates on the whole
approximation <em>i.e.</em> given the choice of the dimension
reduction). </p>


<h3>Value</h3>

<p>a <code>PTAk</code> object</p>


<h3>Note</h3>

<p><code>SVDgen</code> makes use of a non-identity version <code>svd</code> (inbuilt) or
<code>svdksmooth</code> which outputs like the inbuilt <code>svd</code>. The smoothing
option is also implemented in PTA-kmodes, FCA-kmodes, PCAn and
CANDECOMP/PARAFAC. The use of metrics (diagonal or not) allows flexibility of
analysis like <em>e.g.</em> correspondence analysis, discriminant analysis,
robust analysis. Smoothing option extends the analysis towards functional data
analysis, and or outliers protection. 
</p>
<p>This smoothing penalising approach is theoretically valid for Principal Tensors (here order 2) belonging
to a tensor product of separable Hilbert spaces (<em>e.g.</em> Sobolev
spaces) see Leibovici and El Maach (1997), and in fact only valid for
projection onto this space : this includes polynomial fitting, spline
basis fitting ... As you are penalysing the alternating optimisation
criterion you also need the to get a <em>robust fit</em> at each iteration to be
able to reach stationarity and declare optimisation done. If the smoother is not linear one looses orthogonality of
the corresponding components but they are usually not too much correlated
and preserving one mode to be unsmoothed insured orthogonality of the
whole decomposition. Alternatively <code>keepOrtho</code> insures (as a third
step optimisation for each iteration) orthogonality with the previous
component (but then the solution is approximatively in the space of constraints).
</p>
<p>The flexibility of this function <code>smoothing</code> constraint should be carefully used. The
function offers also the choice to change of smoothing (method or parameters)
as the number of components grows as in Ramsay and Silverman (1997).</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici <a href="mailto:GeotRYcs@gmail.com">GeotRYcs@gmail.com</a></p>


<h3>References</h3>

<p>Leibovici D and El Maache H (1997) <em>Une décomposition en Valeurs Singulières d'un élément
d'un produit Tensoriel de k espaces de Hilbert Séparables</em>. Compte Rendus de l'Académie des
Sciences tome 325, série I, Statistiques (Statistics) &amp; Probabilités (Probability Theory):
779-782.
</p>
<p>Besse P and Ferraty F (1995) <em>Curvilinear fixed effect model</em>. Computational Statistics, 10:339-351.
</p>
<p>Leibovici  D (2008) <em>A Simple Penalised algorithm for SVD and Multiway
functional  methods</em>. (to be submitted)
</p>
<p>Ramsay J.O. and Silverman B.W.  (1997) <em>Functional Data
Analysis</em>. Springer Series in Statistics.
</p>


<h3>See Also</h3>

<p><code>PTAk</code>,<code>PCAn</code>, <code>CANDPARA</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">#library(stats)
 #library(tensor)

 # on smoothing

 data(longley)
 long &lt;- as.matrix(longley[,-6])

 long.svd &lt;- SVDgen(long,smoothing=FALSE)
  summary.PTAk(long.svd,testvar=0)
   # X11(width=4,height=4)
  plot.PTAk(long.svd,scree=TRUE,RiskJack=4,type="b",lty=3)

 long.svdo &lt;- SVDgen(long,smoothing=TRUE,
  smoo=list(function(u)ksmooth(1:length(u),
      u,kernel="normal",bandwidth=3,x.points=(1:length(u)))$y,NA))

  summary.PTAk(long.svdo,testvar=0)
  #  X11(width=4,height=4)
  plot.PTAk(long.svdo,scree=TRUE,type="b",lty=3)
 ###using polynomial fitting
   polyfit &lt;- function(u,deg=length(u)/5)
       {n &lt;- length(u);time &lt;- rep(1,n);
        for(e in 1:deg)time&lt;-cbind(time,(1:n)^e);return(lm.fit(time,u)$fitted.values)}
bsfit&lt;-function(u,deg=42)
       {n &lt;- length(u);time &lt;- rep(1,n);
        return(lm.fit(bs(time,df=deg),u)$fitted.values)}

###
 long.svdo2 &lt;- SVDgen(long,nomb=4,smoothing=TRUE,smoo=list(polyfit,NA))
  long.svdo2[[1]]$v[1:3,]
long.svdo[[1]]$v[1:3,]
# orthogonality may be lost with non-projective smoother

     ####
comtoplot &lt;- function(com=1,solua=long.svd,solub=long.svdo,openX11s=FALSE,...)
         {
  if(openX11s)X11(width=4,height=4)
 yla &lt;- c(round((100*(solua[[2]]$d[com])^2)/
     solua[[2]]$ssX[1],4),
     round((100*(solub[[2]]$d[com])^2)/solua[[2]]$ssX[1],4))

limi &lt;- range(c(solua[[1]]$v[com,],solub[[1]]$v[com,]))
  plot(solua,nb1=com, mod=1,type="b",lty=3,lengthlabels=4,cex=0.4,
   ylimit=limi,ylab="",...)
mtext(paste("vs",com,":",yla[1],"%"),2,col=2,line=2)
 par(new=TRUE)

  plot.PTAk(solub,nb1=com,mod=1,labels=FALSE,type="b",lty=1,
  lengthlabels=4,cex=0.6,ylimit=limi,ylab="",main=paste("smooth vs",com,":",yla[2],"%"),...)
  par(new=FALSE)
}   ####
 comtoplot(com=1)



#  on using non-diagonal metrics

 data(crimerate)
  crimerate.mat &lt;- sweep(crimerate,2,apply(crimerate,2,mean))
  crimerate.mat &lt;- sweep(crimerate.mat,2,sqrt(apply(crimerate.mat,2,var)),FUN="/")
   metW &lt;- Powmat(CauRuimet(crimerate.mat),(-1))
   # inverse of the within "group" (to play a bit more you could set m0 relating
   # the neighbourhood of states (see CauRuimet)

  cri.svd &lt;- SVDgen(crimerate.mat,D2=1,D1=1)
  summary(cri.svd,testvar=0)
   plot(cri.svd,scree=TRUE,RiskJack=4,type="b",lty=3)
  cri.svdo &lt;- SVDgen(crimerate.mat,D2=metW,D1=1)
   summary(cri.svdo,testvar=0)
   plot(cri.svdo,scree=TRUE,RiskJack=4,type="b",lty=3)
  # X11(width=8,height=4)
  par(mfrow=c(1,2))
   plot(cri.svd,nb1=1,nb2=2,mod=1,lengthlabels=3)
  plot(cri.svd,nb1=1,nb2=2,mod=2,lengthlabels=4,main="canonical")
  # X11(width=8,height=4)
  par(mfrow=c(1,2))
 plot(cri.svdo,nb1=1,nb2=2,mod=1,lengthlabels=3)
 plot(cri.svdo,nb1=1,nb2=2,mod=2,lengthlabels=4,
       main=expression(paste("metric ",Wg^{-1})))

###########
#  demo function
 # when ima is NULL it uses the dataset timage12 but you can put any array
 # demo.SVDgen(ima=NULL,snr=3,openX11s=TRUE)  

    </code></pre>


</div>
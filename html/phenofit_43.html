<div class="container">

<table style="width: 100%;"><tr>
<td>findpeaks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>findpeaks</h2>

<h3>Description</h3>

<p>Find peaks (maxima) in a time series. This function is modified from
<code>pracma::findpeaks</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">findpeaks(
  x,
  nups = 1,
  ndowns = nups,
  zero = "0",
  peakpat = NULL,
  minpeakheight = -Inf,
  minpeakdistance = 1,
  h_min = 0,
  h_max = 0,
  npeaks = 0,
  sortstr = FALSE,
  include_gregexpr = FALSE,
  IsPlot = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nups</code></td>
<td>
<p>minimum number of increasing steps before a peak is reached</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndowns</code></td>
<td>
<p>minimum number of decreasing steps after the peak</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero</code></td>
<td>
<p>can be <code>+</code>, <code>-</code>, or <code>0</code>; how to interprete succeeding steps
of the same value: increasing, decreasing, or special</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>peakpat</code></td>
<td>
<p>define a peak as a regular pattern, such as the default
pattern <code style="white-space: pre;">⁠[+]{1,}[-]{1,}⁠</code>; if a pattern is provided, the parameters
<code>nups</code> and <code>ndowns</code> are not taken into account</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minpeakheight</code></td>
<td>
<p>The minimum (absolute) height a peak has to have
to be recognized as such</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minpeakdistance</code></td>
<td>
<p>The minimum distance (in indices) peaks have to have
to be counted. If the distance of two maximum extreme value less than
<code>minpeakdistance</code>, only the real maximum value will be left.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h_min</code></td>
<td>
<p><code>h</code> is defined as the difference of peak value to the
adjacent left and right trough value (<code>h_left</code> and <code>h_right</code> respectively).
The real peaks should follow <code>min(h_left, h_right) &gt;= h_min</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h_max</code></td>
<td>
<p>Similar as <code>h_min</code>, the real peaks should follow
<code>max(h_left, h_right) &gt;= h_min</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npeaks</code></td>
<td>
<p>the number of peaks to return. If <code>sortstr</code> = true, the
largest npeaks maximum values will be returned; If <code>sortstr</code> = false,
just the first npeaks are returned in the order of index.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortstr</code></td>
<td>
<p>Boolean, Should the peaks be returned sorted in decreasing oreder of
their maximum value?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_gregexpr</code></td>
<td>
<p>Boolean (default <code>FALSE</code>), whether to include the
matched <code>gregexpr</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IsPlot</code></td>
<td>
<p>Boolean, whether to plot?</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>In versions before v0.3.4, <code>findpeaks(c(1, 2, 3, 4, 4, 3, 1))</code> failed to detect
peaks when a flat pattern exit in the middle.
</p>
<p>From version v0.3.4, the peak pattern was changed from <code style="white-space: pre;">⁠[+]{%d,}[-]{%d,}⁠</code> to
<code style="white-space: pre;">⁠[+]{%d,}[0]{0,}[-]{%d,}⁠</code>. The latter can escape the flat part successfully.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- seq(0, 1, len = 1024)
pos &lt;- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt &lt;- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wdt &lt;- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
pSignal &lt;- numeric(length(x))
for (i in seq(along=pos)) {
    pSignal &lt;- pSignal + hgt[i]/(1 + abs((x - pos[i])/wdt[i]))^4
}

plot(pSignal, type="l", col="navy"); grid()
x &lt;- findpeaks(pSignal, npeaks=3, h_min=4, sortstr=TRUE)
points(val~pos, x$X, pch=20, col="maroon")

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>landscape</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>landscape objects</h2>

<h3>Description</h3>

<p><code>landscape</code> objects represent sets of patches forming a
metapopulation, storing information (such as area, population and
environmental features) that may impact on the dynamic transitions
occurring in each component patch. <code>dynamic</code> objects all have a
<code>landscape</code> object (by default a single-patch landscape) as a an
attribute which can be accessed and set via the function <code>landscape</code>.
<code>as.landscape</code> is used to create landscape objects, and the functions
<code>population</code>, <code>area</code>, <code>distance</code> and <code>features</code>
access and set each of the elements of a landscape.
</p>


<h3>Usage</h3>

<pre><code class="language-R">landscape(dynamic)

landscape(dynamic) &lt;- value

as.landscape(patches)

is.landscape(x)

## S3 method for class 'landscape'
print(x, ...)

area(landscape)

area(landscape) &lt;- value

population(landscape)

population(landscape) &lt;- value

features(landscape)

features(landscape) &lt;- value

distance(landscape)

distance(landscape) &lt;- value

## S3 method for class 'landscape'
x[[i]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dynamic</code></td>
<td>
<p>an object of class <code>dynamic</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>an object of class <code>landscape</code> (for
<code>landscape(dynamic) &lt;- value</code>) or the value to assign to the
<code>distance</code>, <code>area</code>, <code>population</code>, or <code>features</code>
elements of a <code>landscape</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>patches</code></td>
<td>
<p>an object to turn into a <code>landscape</code> object. Currently
this can either be a dynamic, a list or <code>NULL</code> (see <code>details</code>),
though more approaches will be added in the future</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object to print or test as a landscape object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>landscape</code></td>
<td>
<p>an object of class <code>landscape</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>index specifying the patches to include in the subset
<code>landscape</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The accessor function <code>landscape</code> either returns or sets the
landscape structure of the dynamic, encoded as a <code>landscape</code>
object
</p>
<p><code>patches</code> can be a list containing the following elements:
<code>population</code>, a dataframe giving the number of individuals of each
stage (columns) within each patch (rows); <code>area</code>, a one-column
dataframe giving the areas of the patches in square kilometres;
<code>coordinates</code>, a dataframe giving the coordinates of the habitat
patches; and <code>features</code>, a dataframe containing miscellaneous features
(columns) of the patches (rows), such as measures of patch quality or
environmental variables. Alternatively, <code>patches = NULL</code>, will set up
a 'default' one-patch landscape with <code>area = data.frame(area =1)</code>,
<code>coordinates = data.frame(x = 0, y = 0)</code> and blank <code>population</code>
and <code>features</code> elements. The other option is to pass a <code>dynamic</code>
object as <code>patches</code>, in which case the set up will be the same as for
<code>patches = NULL</code> except that <code>population</code> will be a one-row
dataframe of 0s, with columns corresponding to the states in the dynamic.
This is what's used when analysing a <code>dynamic</code> object without
user-specified metapopulation structure.
</p>
<p>the accessor functions <code>distance</code>, <code>area</code>,
<code>population</code> and <code>features</code> either return or set corresponding
sub-dataframes of the <code>landscape</code> object
</p>


<h3>Value</h3>

<p>an object of class <code>landscape</code>, essentially a dataframe
containing the coordinates, area, population and features (as columns) for
each patch (rows)
</p>


<h3>Examples</h3>

<pre><code class="language-R"># create a default landscape
landscape &lt;- as.landscape(NULL)

# create a marginally more interesting one-patch landscape
landscape &lt;- as.landscape(list(coordinates = data.frame(x = c(10, 11),
                                                        y = c(11, 12)),
                               area = data.frame(area = 10),
                               population = data.frame(adult = 10,
                                                       larva = 3,
                                                       egg = 20),
                               features = data.frame(temperature = 10)))
# print method
print(landscape)

# get and set the area
area(landscape)
area(landscape) &lt;- area(landscape) * 2
area(landscape)

# get and set the population
population(landscape)
population(landscape) &lt;- population(landscape) * 2
population(landscape)

# get and set the features
features(landscape)
features(landscape) &lt;- cbind(features(landscape), rainfall = 100)
features(landscape)

# get and set the distance matrix
distance(landscape)
distance(landscape) &lt;- sqrt(distance(landscape))
distance(landscape)

# landscapes can be subsetted to get sub-landscapes of patches with double
# braces
landscape
landscape[[1]]
landscape[[1:2]]

</code></pre>


</div>
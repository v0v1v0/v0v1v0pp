<div class="container">

<table style="width: 100%;"><tr>
<td>pdag2allDags</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Enumerate All DAGs in a Markov Equivalence Class</h2>

<h3>Description</h3>

<p><code>pdag2allDags</code> computes all DAGs in the Markov Equivalence Class
Represented by a Given Partially Directed Acyclic Graph (PDAG).
</p>


<h3>Usage</h3>

<pre><code class="language-R">pdag2allDags(gm, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>gm</code></td>
<td>
<p>adjacency matrix of type amat.cpdag</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; if true, some output is produced during
computation</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All DAGs extending the given PDAG are computing while avoiding new
v-structures and cycles. If no DAG is found, the function returns <code>NULL</code>.
</p>


<h3>Value</h3>

<p>List with two elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>dags:</code></td>
<td>
<p>Matrix; every row corresponds to a DAG; every column
corresponds to an entry in the adjacency matrix of this DAG. Thus, the
adjacency matrix (of type amat.cpdag) contained in the i-th row
of matrix <code>dags</code> can be obtained by calling
<code>matrix(dags[i,],p,p, byrow = TRUE)</code> (assuming the input PDAG has
<code>p</code> nodes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodeNms</code></td>
<td>
<p>Node labels of the input PDAG.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example 1
gm &lt;- rbind(c(0,1),
            c(1,0))
colnames(gm) &lt;- rownames(gm) &lt;- LETTERS[1:2]
res1 &lt;- pdag2allDags(gm)
## adjacency matrix of first DAG in output
amat1 &lt;- matrix(res1$dags[1,],2,2, byrow = TRUE)
colnames(amat1) &lt;- rownames(amat1) &lt;- res1$nodeNms
amat1 ## A --&gt; B

## Example 2
gm &lt;- rbind(c(0,1,1),
            c(1,0,1),
            c(1,1,0))
colnames(gm) &lt;- rownames(gm) &lt;- LETTERS[1:ncol(gm)]
res2 &lt;- pdag2allDags(gm)
## adjacency matrix of first DAG in output
amat2 &lt;- matrix(res2$dags[1,],3,3, byrow = TRUE)
colnames(amat2) &lt;- rownames(amat2) &lt;- res2$nodeNms
amat2

## Example 3
gm &lt;- rbind(c(0,1,1,0,0),
            c(1,0,0,0,0),
            c(1,0,0,0,0),
            c(0,1,1,0,1),
            c(0,0,0,1,0))
colnames(gm) &lt;- rownames(gm) &lt;- LETTERS[1:ncol(gm)]
res3 &lt;- pdag2allDags(gm)
## adjacency matrix of first DAG in output
amat3 &lt;- matrix(res3$dags[1,],5,5, byrow = TRUE)
colnames(amat3) &lt;- rownames(amat3) &lt;- res3$nodeNms
amat3

if (require(Rgraphviz)) {
## for convenience a simple plotting function
## for the function output
plotAllDags &lt;- function(res) {
    require(graph)
    p &lt;- sqrt(ncol(res$dags))
    nDags &lt;- ceiling(sqrt(nrow(res$dags)))
    par(mfrow = c(nDags, nDags))
    for (i in 1:nrow(res$dags)) {
        tmp &lt;- matrix(res$dags[i,],p,p)
        colnames(tmp) &lt;- rownames(tmp) &lt;- res$nodeNms
        plot(as(tmp, "graphNEL"))
    }
}
plotAllDags(res1)
amat1 ## adj.matrix corresponding to the first plot for expl 1
plotAllDags(res2)
amat2 ## adj.matrix corresponding to the first plot for expl 2
plotAllDags(res3)
amat3 ## adj.matrix corresponding to the first plot for expl 3
}
</code></pre>


</div>
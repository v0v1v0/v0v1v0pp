<div class="container">

<table style="width: 100%;"><tr>
<td>popkin_af</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate coancestry from an allele frequency matrix and subpopulation assignments</h2>

<h3>Description</h3>

<p>Given the individual-specific allele frequencies of <code>n</code> individuals, this function returns the <code>n</code>-by-<code>n</code> coancestry matrix.
This function is the analog of <code>popkin()</code> for allele frequencies rather than genotypes, and as a consequence estimates coancestry instead of kinship.
These coancestry estimates are unbiased if the true allele frequencies are provided, but may be less accurate when the allele frequencies themselves are estimated.
This function is intended for cases where allele frequencies, but not individual genotypes, are available; otherwise it is best to use the individual genotypes and <code>popkin()</code>.
An application of interest is the allele frequency matrices from admixture models, in which case the columns correspond to subpopulations rather than individuals, and <code>subpops = NULL</code> is an acceptable choice.
</p>


<h3>Usage</h3>

<pre><code class="language-R">popkin_af(
  P,
  subpops = NULL,
  loci_on_cols = FALSE,
  mem_factor = 0.7,
  mem_lim = NA,
  want_M = FALSE,
  m_chunk_max = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p><code>m</code>-by-<code>n</code> matrix of individual-specific allele frequencies, which should have values between <code style="white-space: pre;">⁠[0, 1]⁠</code> (range is not strictly required) or <code>NA</code> for missing data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subpops</code></td>
<td>
<p>The length-<code>n</code> vector of subpopulation assignments for each individual.
If <code>NULL</code>, every individual is effectively treated as a different population.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loci_on_cols</code></td>
<td>
<p>If <code>TRUE</code>, <code>P</code> has loci on columns and individuals on rows; if <code>FALSE</code> (default), loci are on rows and individuals on columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mem_factor</code></td>
<td>
<p>Proportion of available memory to use loading and processing data.
Ignored if <code>mem_lim</code> is not <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mem_lim</code></td>
<td>
<p>Memory limit in GB, used to break up data into chunks for very large datasets.
Note memory usage is somewhat underestimated and is not controlled strictly.
Default in Linux is <code>mem_factor</code> times the free system memory, otherwise it is 1GB (Windows, OSX and other systems).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>want_M</code></td>
<td>
<p>If <code>TRUE</code>, includes the matrix <code>M</code> of non-missing pair counts in the return value, which are sample sizes that can be useful in modeling the variance of estimates.
Default <code>FALSE</code> is to return the relatedness matrix only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m_chunk_max</code></td>
<td>
<p>Sets the maximum number of loci to process at the time.
Actual number of loci loaded may be lower if memory is limiting.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>want_M = FALSE</code>, returns the estimated <code>n</code>-by-<code>n</code> coancestry matrix only.
If <code>P</code> has names for the individuals, they will be copied to the rows and columns of this coancestry matrix.
If <code>want_M = TRUE</code>, a named list is returned, containing:
</p>

<ul>
<li> <p><code>coancestry</code>: the estimated <code>n</code>-by-<code>n</code> coancestry matrix
</p>
</li>
<li> <p><code>M</code>: the <code>n</code>-by-<code>n</code> matrix of non-missing pair counts (see <code>want_M</code> option).
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>popkin()</code> for kinship estimation from genotype matrices.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># a matrix of random uniform allele frequencies
# (unstructured, unlike real data)
P &lt;- matrix( runif( 9 ), nrow = 3 )

coancestry &lt;- popkin_af( P )

</code></pre>


</div>
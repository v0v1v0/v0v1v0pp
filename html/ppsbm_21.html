<div class="container">

<table style="width: 100%;"><tr>
<td>mainVEM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Adaptative VEM algorithm</h2>

<h3>Description</h3>

<p>Principal adaptative VEM algorithm for histogram with model selection or for kernel method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mainVEM(data, n, Qmin, Qmax = Qmin, directed = TRUE, sparse = FALSE,
  method = c("hist", "kernel"), init.tau = NULL, cores = 1, d_part = 5,
  n_perturb = 10, perc_perturb = 0.2, n_random = 0, nb.iter = 50,
  fix.iter = 10, epsilon = 1e-06, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data format depends on the estimation method used!!
</p>

<ol>
<li>
<p> Data with <strong>hist</strong> method - list with 2 components:
</p>

<dl>
<dt>data$Time</dt>
<dd>
<p>[0,data$Time] is the total time interval of observation</p>
</dd>
<dt>data$Nijk</dt>
<dd>
<p>Data matrix with counts per process <code class="reqn">N_{ij}</code> and sub-intervals ; matrix of size <code class="reqn">N*Dmax</code>  where <code class="reqn">N = n(n-1)</code> or <code class="reqn">n(n-1)/2</code> is the number of possible node pairs in the graph and <code class="reqn">Dmax = 2^{dmax}</code> is the size of the finest partition in the  histrogram approach
</p>
<p>Counts are pre-computed - Obtained through function 'statistics' (auxiliary.R) on data with second format</p>
</dd>
</dl>
</li>
<li>
<p> Data with <strong>kernel</strong> method - list with 3 components:
</p>

<dl>
<dt>data$time.seq</dt>
<dd>
<p>Sequence of observed time points of the m-th event (M-vector)</p>
</dd>
<dt>data$type.seq</dt>
<dd>
<p>Sequence of observed values convertNodePair(i,j,n,directed) (auxiliary.R) of process that produced the mth event (M-vector).</p>
</dd>
<dt>data$Time</dt>
<dd>
<p>[0,data$Time] is the total time interval of observation</p>
</dd>
</dl>
</li>
</ol>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Total number of nodes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qmin</code></td>
<td>
<p>Minimum number of groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qmax</code></td>
<td>
<p>Maximum number of groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>List of string. Can be "hist" for histogram method or "kernel" for kernel method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.tau</code></td>
<td>
<p>List of initial values of <code class="reqn">\tau</code> - all tau's are matrices with size <code class="reqn">Q\times n</code> (might be with different values of Q)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Number of cores for parallel execution
</p>
<p>If set to 1 it does sequential execution
</p>
<p>Beware: parallelization with fork (multicore) : doesn't work on Windows!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d_part</code></td>
<td>
<p>Maximal level for finest partition of time interval [0,T] used for k-means initializations.
</p>

<ul>
<li>
<p> Algorithm takes partition up to depth <code class="reqn">2^d</code> with <code class="reqn">d=1,...,d_{part}</code>
</p>
</li>
<li>
<p> Explore partitions <code class="reqn">[0,T], [0,T/2], [T/2,T], ... [0,T/2^d], ...[(2^d-1)T/2^d,T]</code>
</p>
</li>
<li>
<p> Total number of partitions <code class="reqn">npart= 2^{(d_{part} +1)} -1</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_perturb</code></td>
<td>
<p>Number of different perturbations on k-means result
</p>
<p>When <code class="reqn">Qmin &lt; Qmax</code>, number of perturbations on the result with <code class="reqn">Q-1</code> or <code class="reqn">Q+1</code> groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perc_perturb</code></td>
<td>
<p>Percentage of labels that are to be perturbed (= randomly switched)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_random</code></td>
<td>
<p>Number of completely random initial points. The total number of initializations for the VEM is <code class="reqn">npart*(1+n_{perturb}) +n_{random}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb.iter</code></td>
<td>
<p>Number of iterations of the VEM algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix.iter</code></td>
<td>
<p>Maximum number of iterations of the fixed point into the VE step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Threshold for the stopping criterion of VEM and fixed point iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>Name of the file where to save the results along the computation (increasing steps for <code class="reqn">Q</code>, these are the longest).
</p>
<p>The file will contain a list of 'best' results.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The sparse version works only for the histogram approach.
</p>


<h3>References</h3>

<p>DAUDIN, J.-J., PICARD, F. &amp; ROBIN, S. (2008). A mixture model for random graphs. Statist. Comput. 18, 173–183.
</p>
<p>DEMPSTER, A. P., LAIRD, N. M. &amp; RUBIN, D. B. (1977). Maximum likelihood from incomplete data via the EM algorithm. J. Roy. Statist. Soc. Ser. B 39, 1–38.
</p>
<p>JORDAN, M., GHAHRAMANI, Z., JAAKKOLA, T. &amp; SAUL, L. (1999). An introduction to variational methods for graphical models. Mach. Learn. 37, 183–233.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika.
</p>
<p>MATIAS, C. &amp; ROBIN, S. (2014). Modeling heterogeneity in random graphs through latent space models: a selective review. Esaim Proc. &amp; Surveys 47, 55–74.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load data of a synthetic graph with 50 individuals and 3 clusters
n &lt;- 20
Q &lt;- 3

Time &lt;- generated_Q3_n20$data$Time
data &lt;- generated_Q3_n20$data
z &lt;- generated_Q3_n20$z

step &lt;- .001
x0 &lt;- seq(0,Time,by=step)
intens &lt;-  generated_Q3_n20$intens

# VEM-algo kernel
sol.kernel &lt;- mainVEM(data,n,Q,directed=FALSE,method='kernel', d_part=0,
    n_perturb=0)[[1]]
# compute smooth intensity estimators
sol.kernel.intensities &lt;- kernelIntensities(data,sol.kernel$tau,Q,n,directed=FALSE)
# eliminate label switching
intensities.kernel &lt;- sortIntensities(sol.kernel.intensities,z,sol.kernel$tau,
    directed=FALSE)

# VEM-algo hist
# compute data matrix with precision d_max=3
Dmax &lt;- 2^3
Nijk &lt;- statistics(data,n,Dmax,directed=FALSE)
sol.hist &lt;- mainVEM(list(Nijk=Nijk,Time=Time),n,Q,directed=FALSE, method='hist',
    d_part=0,n_perturb=0,n_random=0)[[1]]
log.intensities.hist &lt;- sortIntensities(sol.hist$logintensities.ql,z,sol.hist$tau,
     directed=FALSE)

# plot estimators
par(mfrow=c(2,3))
ind.ql &lt;- 0
for (q in 1:Q){
  for (l in q:Q){
    ind.ql &lt;- ind.ql + 1
    true.val &lt;- intens[[ind.ql]]$intens(x0)
    values &lt;- c(intensities.kernel[ind.ql,],exp(log.intensities.hist[ind.ql,]),true.val)
    plot(x0,true.val,type='l',xlab=paste0("(q,l)=(",q,",",l,")"),ylab='',
        ylim=c(0,max(values)+.1))
    lines(seq(0,1,by=1/Dmax),c(exp(log.intensities.hist[ind.ql,]),
        exp(log.intensities.hist[ind.ql,Dmax])),type='s',col=2,lty=2)
    lines(seq(0,1,by=.001),intensities.kernel[ind.ql,],col=4,lty=3)
  }
}

</code></pre>


</div>
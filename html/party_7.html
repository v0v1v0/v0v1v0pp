<div class="container">

<table style="width: 100%;"><tr>
<td>Conditional Inference Trees</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Conditional Inference Trees </h2>

<h3>Description</h3>

<p>Recursive partitioning for continuous, censored, ordered, nominal and
multivariate response variables in a conditional inference framework. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">ctree(formula, data, subset = NULL, weights = NULL, 
      controls = ctree_control(), xtrafo = ptrafo, ytrafo = ptrafo, 
      scores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p> a symbolic description of the model to be fit. Note
that symbols like <code>:</code> and <code>-</code> will not work
and the tree will make use of all variables listed on the
rhs of <code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> a data frame containing the variables in the model. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting
process. Only non-negative integer valued weights are
allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>controls</code></td>
<td>
<p>an object of class <code>TreeControl</code>, which can be
obtained using <code>ctree_control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xtrafo</code></td>
<td>
<p> a function to be applied to all input variables.
By default, the <code>ptrafo</code> function is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ytrafo</code></td>
<td>
<p> a function to be applied to all response variables. 
By default, the <code>ptrafo</code> function is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p> an optional named list of scores to be attached to ordered
factors.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Conditional inference trees estimate a regression relationship by binary recursive
partitioning in a conditional inference framework. Roughly, the algorithm
works as follows: 1) Test the global null hypothesis of independence between
any of the input variables and the response (which may be multivariate as well). 
Stop if this hypothesis cannot be rejected. Otherwise select the input
variable with strongest association to the resonse. This
association is measured by a p-value corresponding to a test for the
partial null hypothesis of a single input variable and the response.
2) Implement a binary split in the selected input variable. 
3) Recursively repeate steps 1) and 2). 
</p>
<p>The implementation utilizes a unified framework for conditional inference,
or permutation tests, developed by Strasser and Weber (1999). The stop
criterion in step 1) is either based on multiplicity adjusted p-values 
(<code>testtype == "Bonferroni"</code>
or <code>testtype == "MonteCarlo"</code> in <code>ctree_control</code>),
on the univariate p-values (<code>testtype == "Univariate"</code>),
or on values of the test statistic
(<code>testtype == "Teststatistic"</code>). In both cases, the
criterion is maximized, i.e., 1 - p-value is used. A split is implemented 
when the criterion exceeds the value given by <code>mincriterion</code> as
specified in <code>ctree_control</code>. For example, when 
<code>mincriterion = 0.95</code>, the p-value must be smaller than
$0.05$ in order to split this node. This statistical approach ensures that
the right sized tree is grown and no form of pruning or cross-validation
or whatsoever is needed. The selection of the input variable to split in
is based on the univariate p-values avoiding a variable selection bias
towards input variables with many possible cutpoints.
</p>
<p>Multiplicity-adjusted Monte-Carlo p-values are computed 
following a "min-p" approach. The univariate 
p-values based on the limiting distribution (chi-square
or normal) are computed for each of the random 
permutations of the data. This means that one should
use a quadratic test statistic when factors are in
play (because the evaluation of the corresponding
multivariate normal distribution is time-consuming).
</p>
<p>By default, the scores for each ordinal factor <code>x</code> are
<code>1:length(x)</code>, this may be changed using <code>scores = list(x =
  c(1,5,6))</code>, for example.
</p>
<p>Predictions can be computed using <code>predict</code> or
<code>treeresponse</code>.  The first function accepts arguments
<code>type = c("response", "node", "prob")</code> where <code>type = "response"</code>
returns predicted means, predicted classes or median predicted survival
times, <code>type = "node"</code> returns terminal node IDs (identical to
<code>where</code>) and <code>type = "prob"</code> gives more information about
the conditional distribution of the response, i.e., class probabilities or
predicted Kaplan-Meier curves and is identical to
<code>treeresponse</code>.  For observations with zero weights,
predictions are computed from the fitted tree when <code>newdata = NULL</code>.
</p>
<p>For a general description of the methodology see Hothorn, Hornik and
Zeileis (2006) and Hothorn, Hornik, van de Wiel and Zeileis (2006). 
Introductions for novices can be found in Strobl et al. (2009) and
at <a href="https://github.com/christophM/overview-ctrees">https://github.com/christophM/overview-ctrees</a>.
</p>


<h3>Value</h3>

<p>An object of class <code>BinaryTree-class</code>.
</p>


<h3>References</h3>

 
<p>Helmut Strasser and Christian Weber (1999). On the asymptotic theory of permutation
statistics. <em>Mathematical Methods of Statistics</em>, <b>8</b>, 220–250.
</p>
<p>Torsten Hothorn, Kurt Hornik, Mark A. van de Wiel and Achim Zeileis (2006).
A Lego System for Conditional Inference. <em>The American Statistician</em>,
<b>60</b>(3), 257–263.
</p>
<p>Torsten Hothorn, Kurt Hornik and Achim Zeileis (2006). Unbiased Recursive
Partitioning: A Conditional Inference Framework. <em>Journal of
Computational and Graphical Statistics</em>, <b>15</b>(3), 651–674. 
Preprint available
from <a href="https://www.zeileis.org/papers/Hothorn+Hornik+Zeileis-2006.pdf">https://www.zeileis.org/papers/Hothorn+Hornik+Zeileis-2006.pdf</a>
</p>
<p>Carolin Strobl, James Malley and Gerhard Tutz (2009).
An Introduction to Recursive Partitioning: Rationale, Application, and Characteristics of 
Classification and Regression Trees, Bagging, and Random forests.
<em>Psychological Methods</em>, <b>14</b>(4), 323–348. 
</p>


<h3>Examples</h3>

<pre><code class="language-R">
    set.seed(290875)

    ### regression
    airq &lt;- subset(airquality, !is.na(Ozone))
    airct &lt;- ctree(Ozone ~ ., data = airq, 
                   controls = ctree_control(maxsurrogate = 3))
    airct
    plot(airct)
    mean((airq$Ozone - predict(airct))^2)
    ### extract terminal node ID, two ways
    all.equal(predict(airct, type = "node"), where(airct))

    ### classification
    irisct &lt;- ctree(Species ~ .,data = iris)
    irisct
    plot(irisct)
    table(predict(irisct), iris$Species)

    ### estimated class probabilities, a list
    tr &lt;- treeresponse(irisct, newdata = iris[1:10,])

    ### ordinal regression
    data("mammoexp", package = "TH.data")
    mammoct &lt;- ctree(ME ~ ., data = mammoexp) 
    plot(mammoct)

    ### estimated class probabilities
    treeresponse(mammoct, newdata = mammoexp[1:10,])

    ### survival analysis
    if (require("TH.data") &amp;&amp; require("survival")) {
        data("GBSG2", package = "TH.data")
        GBSG2ct &lt;- ctree(Surv(time, cens) ~ .,data = GBSG2)
        plot(GBSG2ct)
        treeresponse(GBSG2ct, newdata = GBSG2[1:2,])        
    }

    ### if you are interested in the internals:
    ### generate doxygen documentation
    ## Not run: 

        ### download src package into temp dir
        tmpdir &lt;- tempdir()
        tgz &lt;- download.packages("party", destdir = tmpdir)[2]
        ### extract
        untar(tgz, exdir = tmpdir)
        wd &lt;- setwd(file.path(tmpdir, "party"))
        ### run doxygen (assuming it is there)
        system("doxygen inst/doxygen.cfg")
        setwd(wd)
        ### have fun
        browseURL(file.path(tmpdir, "party", "inst", 
                            "documentation", "html", "index.html")) 
    
## End(Not run)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>kwic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform keyword-in-context (KWIC) analysis.</h2>

<h3>Description</h3>

<p>Get concordances for the matches for a query / perform keyword-in-context
(kwic) analysis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kwic(.Object, ...)

## S4 method for signature 'context'
kwic(
  .Object,
  s_attributes = getOption("polmineR.meta"),
  cpos = TRUE,
  verbose = FALSE
)

## S4 method for signature 'slice'
kwic(
  .Object,
  query,
  cqp = is.cqp,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  s_attributes = getOption("polmineR.meta"),
  region = NULL,
  p_attribute = "word",
  boundary = NULL,
  cpos = TRUE,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'partition'
kwic(
  .Object,
  query,
  cqp = is.cqp,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  s_attributes = getOption("polmineR.meta"),
  p_attribute = "word",
  region = NULL,
  boundary = NULL,
  cpos = TRUE,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'subcorpus'
kwic(
  .Object,
  query,
  cqp = is.cqp,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  s_attributes = getOption("polmineR.meta"),
  p_attribute = "word",
  region = NULL,
  boundary = NULL,
  cpos = TRUE,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'corpus'
kwic(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  left = as.integer(getOption("polmineR.left")),
  right = as.integer(getOption("polmineR.right")),
  s_attributes = getOption("polmineR.meta"),
  p_attribute = "word",
  region = NULL,
  boundary = NULL,
  cpos = TRUE,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'character'
kwic(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  left = as.integer(getOption("polmineR.left")),
  right = as.integer(getOption("polmineR.right")),
  s_attributes = getOption("polmineR.meta"),
  p_attribute = "word",
  region = NULL,
  boundary = NULL,
  cpos = TRUE,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'remote_corpus'
kwic(.Object, ...)

## S4 method for signature 'remote_partition'
kwic(.Object, ...)

## S4 method for signature 'remote_subcorpus'
kwic(.Object, ...)

## S4 method for signature 'partition_bundle'
kwic(.Object, ..., verbose = FALSE)

## S4 method for signature 'subcorpus_bundle'
kwic(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.Object</code></td>
<td>
<p>A (length-one) <code>character</code> vector with the name of a CWB
corpus, a <code>partition</code> or <code>context</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments, used to ensure backwards compatibility. If
<code>.Object</code> is a <code>remote_corpus</code> of <code>remote_partition</code> object,
the three dots (<code>...</code>) are used to pass arguments. Hence, it is
necessary to state the names of all arguments to be passed explicity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s_attributes</code></td>
<td>
<p>Structural attributes (s-attributes) to include into
output table as metainformation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpos</code></td>
<td>
<p>Logical, if <code>TRUE</code>, a <code>data.table</code> with the corpus
positions ("cpos") of the hits and their surrounding context will be
assigned to the slot "cpos" of the <code>kwic</code>-object that is returned.
Defaults to <code>TRUE</code>, as the availability of the cpos-<code>data.table</code>
will often be a prerequisite for further operations on the <code>kwic</code>
object. Omitting the table may however be useful to minimize memory
consumption.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to print messages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p>A query, CQP-syntax can be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cqp</code></td>
<td>
<p>Either a logical value (<code>TRUE</code> if <code>query</code> is a CQP
query), or a function to check whether query is a CQP query or not
(defaults to auxiliary function <code>is.query</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>left</code></td>
<td>
<p>A single <code>integer</code> value defining the number of tokens to the
left of the query match to include in the context. Advanced usage: (a) If
<code>left</code> is a length-one <code>character</code> vector stating an s-attribute, the
context will be expanded to the (left) boundary of the region where the
match occurs. (b) If <code>left</code> is a named length-one <code>integer</code> vector, this
value is the number regions of the structural attribute referred to by the
vector's name  to the left of the query match that are included in the
context.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>right</code></td>
<td>
<p>A single <code>integer</code> value, a length-one <code>character</code> vector or a
named length-one <code>integer</code> value, with equivalent effects to argument
<code>left</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>region</code></td>
<td>
<p>An s-attribute, given by a length-one <code>character</code> vector.
The context of query matches will be expanded to the left and right
boundary of the region where the match is located. If arguments <code>left</code> and
<code>right</code> are &gt; 1, the left and right boundaries of the respective number of
regions will be identified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_attribute</code></td>
<td>
<p>The p-attribute, defaults to 'word'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p>If provided, a length-one character vector stating an
s-attribute that will be used to check the boundaries of the text.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stoplist</code></td>
<td>
<p>Terms or ids to prevent a concordance from occurring in
results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>positivelist</code></td>
<td>
<p>Terms or ids required for a concordance to occurr in
results</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regex</code></td>
<td>
<p>Logical, whether <code>stoplist</code>/<code>positivelist</code> is
interpreted as regular expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>A <code>logical</code> value, whether to check validity of CQP query
using <code>check_cqp_query</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The method works with a whole CWB corpus defined by a  character vector, and
can be applied on a <code>partition</code>- or a <code>context</code> object.
</p>
<p>If <code>query</code> produces a lot of matches, the <code>DT::datatable()</code> function used to
produce output in the Viewer pane of RStudio may issue a warning. Usually,
this warning is harmless and can be ignored. Use
<code>options("polmineR.warn.size" = FALSE)</code> for turning off this warning.
</p>
<p>If a <code>positivelist</code> is supplied, only those concordances will be kept that
have one of the terms from the <code>positivelist</code> occurr in the context of
the query match. Use argument <code>regex</code> if the positivelist should be
interpreted as regular expressions. Tokens from the positivelist will be
highlighted in the output table.
</p>
<p>If a <code>negativelist</code> is supplied, concordances are removed if any of the
tokens of the <code>negativelist</code> occurrs in the context of the query match.
</p>
<p>Applying the <code>kwic</code>-method on a <code>partition_bundle</code> or
<code>subcorpus_bundle</code> will return a single <code>kwic</code> object that
includes a column 'subcorpus_name' with the name of the <code>subcorpus</code>
(or <code>partition</code>) in the input object where the match for a concordance
occurs.
</p>


<h3>Value</h3>

<p>If there are no matches, or if all (initial) matches are dropped due to the
application of a positivelist, a <code>NULL</code> is returned.
</p>


<h3>References</h3>

<p>Baker, Paul (2006): <em>Using Corpora in Discourse Analysis</em>. London: continuum, pp. 71-93 (ch. 4).
</p>
<p>Jockers, Matthew L. (2014): <em>Text Analysis with R for Students of Literature</em>.
Cham et al: Springer, pp. 73-87 (chs. 8 &amp; 9).
</p>


<h3>See Also</h3>

<p>The return value is a <code>kwic-class</code> object; the
documentation for the class explains the standard generic methods
applicable to <code>kwic-class</code> objects. It is possible to read the
whole text where a query match occurs, see the <code>read</code>-method.
To highlight terms in the context of a query match, see the
<code>highlight</code>-method.
</p>


<h3>Examples</h3>

<pre><code class="language-R">use("polmineR")
use(pkg = "RcppCWB", corpus = "REUTERS")

# basic usage
K &lt;- kwic("GERMAPARLMINI", "Integration")
if (interactive()) show(K)
oil &lt;- corpus("REUTERS") %&gt;% kwic(query = "oil")
if (interactive()) show(oil)
oil &lt;- corpus("REUTERS") %&gt;%
  kwic(query = "oil") %&gt;%
  highlight(yellow = "crude")
if (interactive()) show(oil)

# increase left and right context and display metadata
K &lt;- kwic(
  "GERMAPARLMINI",
  "Integration", left = 20, right = 20,
  s_attributes = c("date", "speaker", "party")
)
if (interactive()) show(K)

# use CQP syntax for matching
K &lt;- kwic(
  "GERMAPARLMINI",
  '"Integration" [] "(Menschen|Migrant.*|Personen)"', cqp = TRUE,
  left = 20, right = 20,
  s_attributes = c("date", "speaker", "party")
)
if (interactive()) show(K)

# check that boundary of region is not transgressed
K &lt;- kwic(
  "GERMAPARLMINI",
  '"Sehr" "geehrte"', cqp = TRUE,
  left = 100, right = 100,
  boundary = "date"
)
if (interactive()) show(K)

# use positivelist and highlight matches in context
K &lt;- kwic("GERMAPARLMINI", query = "Integration", positivelist = "[Ee]urop.*", regex = TRUE)
K &lt;- highlight(K, yellow = "[Ee]urop.*", regex = TRUE)

# Apply kwic on partition_bundle/subcorpus_bundle
gparl_2009_11_10_speeches &lt;- corpus("GERMAPARLMINI") %&gt;%
  subset(date == "2009-11-10") %&gt;%
  as.speeches(
    s_attribute_name = "speaker", s_attribute_date = "date",
    progress = FALSE, verbose = FALSE
  )
k &lt;- kwic(gparl_2009_11_10_speeches, query = "Integration")
</code></pre>


</div>
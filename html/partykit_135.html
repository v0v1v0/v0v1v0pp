<div class="container">

<table style="width: 100%;"><tr>
<td>partynode-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Methods for Node Objects</h2>

<h3>Description</h3>

<p>Methods for computing on <code>partynode</code> objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">is.partynode(x)
as.partynode(x, ...)
## S3 method for class 'partynode'
as.partynode(x, from = NULL, recursive = TRUE, ...)
## S3 method for class 'list'
as.partynode(x, ...)
## S3 method for class 'partynode'
as.list(x, ...)
## S3 method for class 'partynode'
length(x)
## S3 method for class 'partynode'
x[i, ...]
## S3 method for class 'partynode'
x[[i, ...]]
is.terminal(x, ...)
## S3 method for class 'partynode'
is.terminal(x, ...)
## S3 method for class 'partynode'
depth(x, root = FALSE, ...)
width(x, ...)
## S3 method for class 'partynode'
width(x, ...)
## S3 method for class 'partynode'
print(x, data = NULL, names = NULL,
    inner_panel = function(node) "", 
    terminal_panel = function(node) " *",
    prefix = "", first = TRUE, digits = getOption("digits") - 2, 
    ...)
## S3 method for class 'partynode'
nodeprune(x, ids, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> an object of class <code>partynode</code> or <code>list</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p> an integer giving the identifier of the root node.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recursive</code></td>
<td>
<p> a logical, if <code>FALSE</code>, only the id of the root node
is checked against <code>from</code>. If 
<code>TRUE</code>, the ids of all nodes are checked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p> an integer specifying the kid to extract.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>root</code></td>
<td>
<p> a logical. Should the root count be counted in <code>depth</code>? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> an optional <code>data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p> a vector of names for nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminal_panel</code></td>
<td>
<p> a panel function for printing terminal nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inner_panel</code></td>
<td>
<p> a panel function for printing inner nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix</code></td>
<td>
<p> lines start with this symbol.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>first</code></td>
<td>
<p> a logical.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p> number of digits to be printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ids</code></td>
<td>
<p> a vector of node ids to be pruned-off.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>is.partynode</code> checks if the argument is a valid <code>partynode</code>
object. <code>is.terminal</code> is <code>TRUE</code> for terminal nodes
and <code>FALSE</code> for inner nodes. The subset methods
return the <code>partynode</code> object corresponding to the <code>i</code>th
kid.
</p>
<p>The <code>as.partynode</code> and <code>as.list</code> methods can be used
to convert flat list structures into recursive <code>partynode</code>
objects and vice versa. <code>as.partynode</code> applied to
<code>partynode</code> objects renumbers the recursive nodes
starting with root node identifier <code>from</code>.
</p>
<p><code>length</code> gives the number of kid nodes of the root node,
<code>depth</code> the depth of the tree and <code>width</code> 
the number of terminal nodes.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## a tree as flat list structure
nodelist &lt;- list(
  # root node
  list(id = 1L, split = partysplit(varid = 4L, breaks = 1.9), 
      kids = 2:3),
  # V4 &lt;= 1.9, terminal node
  list(id = 2L),
  # V4 &gt; 1.9
  list(id = 3L, split = partysplit(varid = 1L, breaks = 1.7), 
      kids = c(4L, 7L)),
  # V1 &lt;= 1.7
  list(id = 4L, split = partysplit(varid = 4L, breaks = 4.8), 
      kids = 5:6),
  # V4 &lt;= 4.8, terminal node
  list(id = 5L),
  # V4 &gt; 4.8, terminal node
  list(id = 6L),
  # V1 &gt; 1.7, terminal node
  list(id = 7L)
)

## convert to a recursive structure
node &lt;- as.partynode(nodelist)

## print raw recursive structure without data
print(node)

## print tree along with the associated iris data
data("iris", package = "datasets")
print(node, data = iris)

## print subtree
print(node[2], data = iris)

## print subtree, with root node number one
print(as.partynode(node[2], from = 1), data = iris)

## number of kids in root node
length(node)

## depth of tree
depth(node)

## number of terminal nodes
width(node)

## convert back to flat structure
as.list(node)
</code></pre>


</div>
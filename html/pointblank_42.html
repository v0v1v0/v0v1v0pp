<div class="container">

<table style="width: 100%;"><tr>
<td>create_multiagent</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a <strong>pointblank</strong> <em>multiagent</em> object</h2>

<h3>Description</h3>

<p>Multiple <em>agents</em> can be part of a single object called the <em>multiagent</em>.
This can be useful when gathering multiple agents that have performed
interrogations in the past (perhaps saved to disk with <code>x_write_disk()</code>).
When be part of a <em>multiagent</em>, we can get a report that shows how data
quality evolved over time. This can be of interest when it's important to
monitor data quality and even the evolution of the validation plan itself.
The reporting table, generated by printing a <code>ptblank_multiagent</code> object or
by using the <code>get_multiagent_report()</code> function, is, by default, organized by
the interrogation time and it automatically recognizes which validation steps
are equivalent across interrogations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">create_multiagent(..., lang = NULL, locale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p><em>Pointblank agents</em>
</p>
<p><code style="white-space: pre;">⁠&lt;series of obj:&lt;ptblank_agent&gt;&gt;⁠</code> // <strong>required</strong>
</p>
<p>One or more <strong>pointblank</strong> agent objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lang</code></td>
<td>
<p><em>Reporting language</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The language to use for any reporting that will be generated from the
<em>multiagent</em>. (e.g., individual <em>agent reports</em>, <em>multiagent reports</em>,
etc.). By default, <code>NULL</code> will create English (<code>"en"</code>) text. Other options
include French (<code>"fr"</code>), German (<code>"de"</code>), Italian (<code>"it"</code>), Spanish
(<code>"es"</code>), Portuguese (<code>"pt"</code>), Turkish (<code>"tr"</code>), Chinese (<code>"zh"</code>), Russian
(<code>"ru"</code>), Polish (<code>"pl"</code>), Danish (<code>"da"</code>), Swedish (<code>"sv"</code>), and Dutch
(<code>"nl"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locale</code></td>
<td>
<p><em>Locale for value formatting within reports</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional locale ID to use for formatting values in the reporting outputs
according the locale's rules. Examples include <code>"en_US"</code> for English
(United States) and <code>"fr_FR"</code> for French (France); more simply, this can be
a language identifier without a country designation, like "es" for Spanish
(Spain, same as <code>"es_ES"</code>).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>ptblank_multiagent</code> object.
</p>


<h3>Examples</h3>

<p>For the example below, we'll use two different, yet simple tables.
</p>
<p>First, <code>tbl_1</code>:
</p>
<div class="sourceCode r"><pre>tbl_1 &lt;-
  dplyr::tibble(
    a = c(5, 5, 5, 5, 5, 5),
    b = c(1, 1, 1, 2, 2, 2),
    c = c(1, 1, 1, 2, 3, 4),
    d = LETTERS[a],
    e = LETTERS[b],
    f = LETTERS[c]
  )
  
tbl_1
#&gt; # A tibble: 6 x 6
#&gt;       a     b     c d     e     f    
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     5     1     1 E     A     A    
#&gt; 2     5     1     1 E     A     A    
#&gt; 3     5     1     1 E     A     A    
#&gt; 4     5     2     2 E     B     B    
#&gt; 5     5     2     3 E     B     C    
#&gt; 6     5     2     4 E     B     D
</pre></div>
<p>And next, <code>tbl_2</code>:
</p>
<div class="sourceCode r"><pre>tbl_2 &lt;-
  dplyr::tibble(
    a = c(5, 7, 6, 5, 8, 7),
    b = LETTERS[1:6]
  )

tbl_2
#&gt; # A tibble: 6 x 2
#&gt;       a b    
#&gt;   &lt;dbl&gt; &lt;chr&gt;
#&gt; 1     5 A    
#&gt; 2     7 B    
#&gt; 3     6 C    
#&gt; 4     5 D    
#&gt; 5     8 E    
#&gt; 6     7 F
</pre></div>
<p>Next, we'll create two different agents, each interrogating a different
table.
</p>
<p>First up, is <code>agent_1</code>:
</p>
<div class="sourceCode r"><pre>agent_1 &lt;-
  create_agent(
    tbl = tbl_1,
    tbl_name = "tbl_1",
    label = "Example table 1."
  ) %&gt;%
  col_vals_gt(columns = a, value = 4) %&gt;%
  interrogate()
</pre></div>
<p>Then, <code>agent_2</code>:
</p>
<div class="sourceCode r"><pre>agent_2 &lt;-
  create_agent(
    tbl = tbl_2,
    tbl_name = "tbl_2",
    label = "Example table 2."
  ) %&gt;%
  col_is_character(columns = b) %&gt;%
  interrogate()
</pre></div>
<p>Now, we'll combine the two agents into a <em>multiagent</em> with the
<code>create_multiagent()</code> function. Printing the <code>"ptblank_multiagent"</code> object
displays the multiagent report with its default options (i.e., a 'long'
report view).
</p>
<div class="sourceCode r"><pre>multiagent &lt;- create_multiagent(agent_1, agent_2)
  
multiagent
</pre></div>


<img src="https://raw.githubusercontent.com/rstudio/pointblank/main/images/man_create_multiagent_1.png" alt="This image was generated from the first code example in the `create_multiagent()` help file." style="width:100%;"><p>To take advantage of more display options, we could use the
<code>get_multiagent_report()</code> function. The added functionality there allows for
a 'wide' view of the data (useful for monitoring validations of the same
table over repeated interrogations), the ability to modify the title of the
multiagent report, and a means to export the report to HTML (via
<code>export_report()</code>).
</p>


<h3>Function ID</h3>

<p>10-1
</p>


<h3>See Also</h3>

<p>Other The multiagent: 
<code>get_multiagent_report()</code>,
<code>read_disk_multiagent()</code>
</p>


</div>
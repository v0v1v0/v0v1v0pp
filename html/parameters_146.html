<div class="container">

<table style="width: 100%;"><tr>
<td>pool_parameters</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pool Model Parameters</h2>

<h3>Description</h3>

<p>This function "pools" (i.e. combines) model parameters in a similar fashion
as <code>mice::pool()</code>. However, this function pools parameters from
<code>parameters_model</code> objects, as returned by
<code>model_parameters()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pool_parameters(
  x,
  exponentiate = FALSE,
  effects = "fixed",
  component = "conditional",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A list of <code>parameters_model</code> objects, as returned by
<code>model_parameters()</code>, or a list of model-objects that is supported by
<code>model_parameters()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exponentiate</code></td>
<td>
<p>Logical, indicating whether or not to exponentiate the
coefficients (and related confidence intervals). This is typical for
logistic regression, or more generally speaking, for models with log or
logit links. It is also recommended to use <code>exponentiate = TRUE</code> for models
with log-transformed response values. <strong>Note:</strong> Delta-method standard
errors are also computed (by multiplying the standard errors by the
transformed coefficients). This is to mimic behaviour of other software
packages, such as Stata, but these standard errors poorly estimate
uncertainty for the transformed coefficient. The transformed confidence
interval more clearly captures this uncertainty. For <code>compare_parameters()</code>,
<code>exponentiate = "nongaussian"</code> will only exponentiate coefficients from
non-Gaussian families.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effects</code></td>
<td>
<p>Should parameters for fixed effects (<code>"fixed"</code>), random
effects (<code>"random"</code>), or both (<code>"all"</code>) be returned? Only applies
to mixed models. May be abbreviated. If the calculation of random effects
parameters takes too long, you may use <code>effects = "fixed"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>component</code></td>
<td>
<p>Should all parameters, parameters for the conditional model,
for the zero-inflation part of the model, or the dispersion model be returned?
Applies to models with zero-inflation and/or dispersion component. <code>component</code>
may be one of <code>"conditional"</code>, <code>"zi"</code>, <code>"zero-inflated"</code>, <code>"dispersion"</code> or
<code>"all"</code> (default). May be abbreviated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Toggle warnings and messages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed down to <code>model_parameters()</code>, if <code>x</code> is a list
of model-objects. Can be used, for instance, to specify arguments like
<code>ci</code> or <code>ci_method</code> etc.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Averaging of parameters follows Rubin's rules (<em>Rubin, 1987, p. 76</em>).
The pooled degrees of freedom is based on the Barnard-Rubin adjustment for
small samples (<em>Barnard and Rubin, 1999</em>).
</p>


<h3>Value</h3>

<p>A data frame of indices related to the model's parameters.
</p>


<h3>Note</h3>

<p>Models with multiple components, (for instance, models with zero-inflation,
where predictors appear in the count and zero-inflation part) may fail in
case of identical names for coefficients in the different model components,
since the coefficient table is grouped by coefficient names for pooling. In
such cases, coefficients of count and zero-inflation model parts would be
combined. Therefore, the <code>component</code> argument defaults to
<code>"conditional"</code> to avoid this.
</p>
<p>Some model objects do not return standard errors (e.g. objects of class
<code>htest</code>). For these models, no pooled confidence intervals nor p-values
are returned.
</p>


<h3>References</h3>

<p>Barnard, J. and Rubin, D.B. (1999). Small sample degrees of freedom with
multiple imputation. Biometrika, 86, 948-955. Rubin, D.B. (1987). Multiple
Imputation for Nonresponse in Surveys. New York: John Wiley and Sons.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# example for multiple imputed datasets
data("nhanes2", package = "mice")
imp &lt;- mice::mice(nhanes2, printFlag = FALSE)
models &lt;- lapply(1:5, function(i) {
  lm(bmi ~ age + hyp + chl, data = mice::complete(imp, action = i))
})
pool_parameters(models)

# should be identical to:
m &lt;- with(data = imp, exp = lm(bmi ~ age + hyp + chl))
summary(mice::pool(m))

# For glm, mice used residual df, while `pool_parameters()` uses `Inf`
nhanes2$hyp &lt;- datawizard::slide(as.numeric(nhanes2$hyp))
imp &lt;- mice::mice(nhanes2, printFlag = FALSE)
models &lt;- lapply(1:5, function(i) {
  glm(hyp ~ age + chl, family = binomial, data = mice::complete(imp, action = i))
})
m &lt;- with(data = imp, exp = glm(hyp ~ age + chl, family = binomial))
# residual df
summary(mice::pool(m))$df
# df = Inf
pool_parameters(models)$df_error
# use residual df instead
pool_parameters(models, ci_method = "residual")$df_error

</code></pre>


</div>
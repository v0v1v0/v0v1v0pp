<div class="container">

<table style="width: 100%;"><tr>
<td>mergePed</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Merge two pedigrees</h2>

<h3>Description</h3>

<p>This function merges two linkdat objects, joining them at the individuals
with equal ID labels. This is especially useful for building 'top-heavy'
pedigrees. Only linkdat objects without marker data are supported.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mergePed(x, y, quick = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p><code>linkdat</code> objects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quick</code></td>
<td>
<p>a single logical. If TRUE, no pedigree checks are performed, and
the individual ordering may be unfortunate.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>linkdat</code> object.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Creating a trio where each parent have first cousin parents.
# (Alternatively, this could be built using many calls to addParents().)

x = cousinPed(1)
x = addOffspring(x, father=7, mother=8, noffs=1, id=9)
x = addOffspring(x, father=9, mother=10, noffs=1, id=11)

y = relabel(cousinPed(1), 101:108)
y = addOffspring(y, father=107, mother=108, noffs=1, sex=2, id=10)
y = addOffspring(y, father=9, mother=10, noffs=1, id=11)

# Joining x and y at the common individuals 9,10,11:
z = mergePed(x,y)

# plot all three pedigrees
op = par(mfrow = c(1,3))
plot(x); plot(y); plot(z)
par(op)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>sim.irt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functions to simulate psychological/psychometric data.</h2>

<h3>Description</h3>

<p>A number of functions in the psych package will generate simulated data with particular structures.  These functions include
<code>sim</code> for a factor simplex, and <code>sim.simplex</code> for a data simplex, <code>sim.circ</code> for a circumplex structure, <code>sim.congeneric</code> for a one factor factor congeneric model, <code>sim.dichot</code> to simulate dichotomous items, <code>sim.hierarchical</code> to create a hierarchical factor model, <code>sim.item</code> a more general item simulation,
<code>sim.minor</code> to simulate major and minor factors,
<code>sim.omega</code> to test various examples of omega,
<code>sim.parallel</code> to compare the efficiency of various ways of deterimining the number of factors,
<code>sim.rasch</code> to create simulated rasch data, 
<code>sim.irt</code> to create general 1 to 4 parameter IRT data by calling 
<code>sim.npl</code> 1 to 4 parameter logistic IRT or 
<code>sim.npn</code> 1 to 4 paramater normal IRT,
<code>sim.poly</code> to create polytomous ideas by calling
<code>sim.poly.npn</code> 1-4 parameter polytomous normal theory items or
<code>sim.poly.npl</code> 1-4 parameter polytomous logistic items, and 
<code>sim.poly.ideal</code> which creates data following an ideal point or unfolding model by calling 
<code>sim.poly.ideal.npn</code> 1-4 parameter polytomous normal theory ideal point model or 
<code>sim.poly.ideal.npl</code> 1-4 parameter polytomous logistic ideal point model.
</p>
<p><code>sim.structural</code> a general simulation of structural models,  and <code>sim.anova</code> for ANOVA and lm simulations, and <code>sim.VSS</code>. Some of these functions are separately documented and are listed here for ease of the help function.  See each function for more detailed help.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
sim.rasch(nvar = 5,n = 500, low=-3,high=3,d=NULL, a=1,mu=0,sd=1)
sim.irt(nvar = 5, n = 500, low=-3, high=3, a=NULL,c=0, z=1,d=NULL, mu=0,sd=1,  
  mod="logistic",theta=NULL)
sim.npl(nvar = 5, n = 500, low=-3,high=3,a=NULL,c=0,z=1,d=NULL,mu=0,sd=1,theta=NULL)
sim.npn(nvar = 5, n = 500, low=-3,high=3,a=NULL,c=0,z=1,d=NULL,mu=0,sd=1,theta=NULL)
sim.poly(nvar = 5 ,n = 500,low=-2,high=2,a=NULL,c=0,z=1,d=NULL, 
    mu=0,sd=1,cat=5,mod="logistic",theta=NULL) 
sim.poly.npn(nvar = 5 ,n = 500,low=-2,high=2,a=NULL,c=0,z=1,d=NULL,   mu=0, sd=1, 
     cat=5,theta=NULL) 
sim.poly.npl(nvar = 5 ,n = 500,low=-2,high=2,a=NULL,c=0,z=1,d=NULL,  mu=0, sd=1, 
cat=5,theta=NULL) 
sim.poly.ideal(nvar = 5 ,n = 500,low=-2,high=2,a=NULL,c=0,z=1,d=NULL, 
   mu=0,sd=1,cat=5,mod="logistic") 
sim.poly.ideal.npn(nvar = 5,n = 500,low=-2,high=2,a=NULL,c=0,z=1,d=NULL, mu=0,sd=1,cat=5) 
sim.poly.ideal.npl(nvar = 5,n = 500,low=-2,high=2,a=NULL,c=0,z=1,d=NULL, 
      mu=0,sd=1,cat=5,theta=NULL)
sim.poly.mat(R,m,n) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of cases to simulate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>The means for the items (if not 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvar</code></td>
<td>
<p>Number of variables for a simplex structure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>low</code></td>
<td>
<p>lower difficulty for sim.rasch or sim.irt</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>high</code></td>
<td>
<p>higher difficulty for sim.rasch or sim.irt</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>if not specified as a vector, the descrimination parameter a = <code class="reqn">\alpha</code> will be set to 1.0 for all items</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p> if not specified as a vector, item difficulties (d = <code class="reqn">\delta</code>) will range from low to high</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c</code></td>
<td>
<p>the gamma parameter: if not specified as a vector, the guessing asymptote is set to 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>the zeta parameter: if not specified as a vector, set to 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd</code></td>
<td>
<p>the standard deviation for the underlying latent variable in the irt simulations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>
<p>which IRT model to use, mod="logistic" simulates a logistic function, otherwise, a normal function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cat</code></td>
<td>
<p>Number of categories to simulate in sim.poly.  If cat=2, then this is the same as simulating t/f items and sim.poly is functionally equivalent to sim.irt</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>The underlying latent trait value for each simulated subject</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>A correlation matrix to be simulated using the sim.poly.mat function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The matrix of marginals for all the items</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Simulation of data structures is a very useful tool in psychometric research and teaching.  By knowing “truth" it is possible to see how well various algorithms can capture it.  For a much longer discussion of the use of simulation in psychometrics, see the accompany vignettes.  
</p>
<p>The simulations documented here are a miscellaneous set of functions that will be documented in other help files eventually.
</p>
<p>The default values for <code>sim.structure</code> is to generate a 4 factor, 12 variable data set with a simplex structure between the factors. This, and the simplex of items (<code>sim.simplex</code>) can also be converted in a STARS model with an autoregressive component (alpha) and a stable trait component (lambda). 
</p>
<p>Two data structures that are particular challenges to exploratory factor analysis are the simplex structure and the presence of minor factors.  Simplex structures <code>sim.simplex</code> will typically occur in developmental or learning contexts and have a correlation structure of r between adjacent variables and r^n for variables n apart.  Although just one latent variable (r) needs to be estimated, the structure will have nvar-1 factors.  
</p>
<p>An alternative version of the simplex is the State-Trait-Auto Regressive Structure (STARS) which has both a simplex state structure, with autoregressive path alpha and a trait structure with path lambda. This simulated in  <code>sim.simplex</code> by specifying a non-zero lambda value.
</p>
<p>Many simulations of factor structures assume that except for the major factors, all residuals are normally distributed around 0.  An alternative, and perhaps more realistic situation, is that the there are a few major (big) factors and many minor (small) factors.  The challenge is thus to identify the major factors. <code>sim.minor</code> generates such structures.  The structures generated can be thought of as havinga a major factor structure with some small correlated residuals. To make these simulations complete, the possibility of a general factor is considered.  For simplicity, sim.minor allows one to specify a set of loadings to be sampled from for g, fmajor and fminor.  Alternatively, it is possible to specify the complete factor matrix.
</p>
<p>Another structure worth considering is direct modeling of a general factor with several group factors.  This is done using <code>sim.general</code>.
</p>
<p>Although coefficient <code class="reqn">\omega</code> is a very useful indicator of the general factor saturation of a unifactorial test (one with perhaps several sub factors), it has problems with the case of multiple, independent factors.  In this situation, one of the factors is labelled as “general” and  the omega estimate is too large.  This situation may be explored using the <code>sim.omega</code> function with general left as NULL.  If there is a general factor, then results from <code>sim.omega</code> suggests that omega estimated either from EFA or from SEM does a pretty good job of identifying it but that the EFA approach using Schmid-Leiman transformation is somewhat more robust than the SEM approach. 
</p>
<p>The four irt simulations, sim.rasch, sim.irt, sim.npl and sim.npn, simulate dichotomous items following the Item Response model.  sim.irt just calls either sim.npl (for logistic models) or sim.npn (for normal models) depending upon the specification of the model. 
</p>
<p>The logistic model is </p>
<p style="text-align: center;"><code class="reqn">P(i,j) = \gamma + \frac{\zeta-\gamma}{1+ e^{\alpha(\delta-\theta)}}</code>
</p>
<p> where <code class="reqn">\gamma</code> is the lower asymptote or guesssing parameter, <code class="reqn">\zeta</code> is the upper asymptote (normally 1), <code class="reqn">\alpha</code> is item discrimination and <code class="reqn">\delta</code> is item difficulty.  For the 1 Paramater Logistic (Rasch) model, gamma=0, zeta=1, alpha=1 and item difficulty is the only free parameter to specify.
</p>
<p>For the 2PL and 2PN models, a = <code class="reqn">\alpha</code> and  d = <code class="reqn">\delta</code> are specified. <br>
For the 3PL or 3PN models, items also differ in their guessing parameter c =<code class="reqn">\gamma</code>. <br>
For the 4PL and 4PN models, the upper asymptote, z= <code class="reqn">\zeta</code> is also specified.  <br>
(Graphics of these may be seen in the demonstrations for the <code>logistic</code> function.)
</p>
<p>The normal model (irt.npn calculates the probability using pnorm instead of the logistic function used in irt.npl, but the meaning of the parameters are otherwise the same.  With the a = <code class="reqn">\alpha</code> parameter = 1.702 in the logistic model the two models are practically identical.
</p>
<p>In parallel to the dichotomous IRT simulations are the poly versions which simulate polytomous item models.  They have the additional parameter of how many categories to simulate.  In addition, the <code>sim.poly.ideal</code> functions will simulate an ideal point or unfolding model in which the response probability varies by the distance from each subject's ideal point.  Some have claimed that this is a more appropriate model of the responses to personality questionnaires.  It will lead to simplex like structures which may be fit by a two factor model.  The middle items form one factor, the extreme a bipolar factor.
</p>
<p>By default, the theta parameter is created in each function as normally distributed with mean mu=0  and sd=1.  In the case where you want to specify the theta to be equivalent from another simulation or fixed for a particular experimental condition, either take the theta object from the output of a previous simulation, or create it using whatever properties are desired. 
</p>
<p>The previous functions all assume one latent trait.  Alternatively, we can simulate dichotomous or polytomous items with a particular structure using the sim.poly.mat function.  This takes as input the population correlation matrix, the population marginals, and the sample size.  It returns categorical items with the specified structure.
</p>
<p>Other simulation functions in psych are:
</p>
<p><code>sim.structure</code>  A function to combine a measurement and structural model into one data matrix.  Useful for understanding structural equation models.  Combined with <code>structure.diagram</code> to see the proposed structure.  
</p>
<p><code>sim.congeneric</code>   A function to create congeneric items/tests for demonstrating classical test theory. This is just a special case of sim.structure.
</p>
<p><code>sim.hierarchical</code>  A function to create data with a hierarchical (bifactor) structure.  
</p>
<p><code>sim.item</code>      A function to create items that either have a simple structure or a circumplex structure.
</p>
<p><code>sim.circ</code>    Create data with a circumplex structure.
</p>
<p><code>sim.dichot</code>    Create dichotomous item data with a simple or circumplex structure.
</p>
<p><code>sim.minor</code>   Create a factor structure for nvar variables defined by nfact major factors and nvar/2 “minor" factors for n observations.  
</p>
<p>Although the standard factor model assumes that K major factors (K &lt;&lt; nvar) will account for the correlations among the variables
</p>
<p style="text-align: center;"><code class="reqn">R = FF' + U^2</code>
</p>
 
<p>where R is of rank P and F is a P x K matrix of factor coefficients and U is a diagonal matrix of uniquenesses.  However, in many cases, particularly when working with items, there are many small factors (sometimes referred to as correlated residuals) that need to be considered as well.  This leads to a data structure such that 
</p>
<p style="text-align: center;"><code class="reqn">R = FF' + MM' + U^2</code>
</p>
 
<p>where R is a P x P matrix of correlations, F is a  P x K factor loading matrix,  M is a P x P/2 matrix of minor factor loadings, and U is a diagonal matrix (P x P) of uniquenesses.  
</p>
<p>Such a correlation matrix will have a poor <code class="reqn">\chi^2</code> value in terms of goodness of fit if just the K factors are extracted, even though for all intents and purposes, it is well fit.  
</p>
<p>sim.minor will generate such data sets with big factors with loadings of .6 to .8 and small factors with loadings of -.2 to .2.  These may both be adjusted.
</p>
<p><code>sim.parallel</code> Create a number of simulated data sets using sim.minor to show how parallel analysis works.  The general observation is that with the presence of minor factors, parallel analysis is probably best done with component eigen values rather than factor eigen values, even when using the factor model. 
</p>
<p><code>sim.anova</code>    Simulate a 3 way balanced ANOVA or linear model, with or without repeated measures. Useful for teaching research  methods and generating teaching examples. 
</p>
<p><code>sim.multilevel</code>  To understand some of the basic concepts of multilevel modeling, it is useful to create multilevel structures.  The correlations of aggregated data is sometimes called an 'ecological correlation'.  That group level and individual level correlations are independent makes such inferences problematic.  This simulation allows for demonstrations that correlations within groups do not imply, nor are implied by, correlations between group means. 
</p>


<h3>Author(s)</h3>

<p>William Revelle</p>


<h3>References</h3>

<p>Revelle, W. (in preparation) An Introduction to Psychometric Theory with applications in R. Springer. at <a href="https://personality-project.org/r/book/">https://personality-project.org/r/book/</a>  </p>


<h3>See Also</h3>

<p> See above</p>


<h3>Examples</h3>

<pre><code class="language-R">simplex &lt;- sim.simplex() #create the default simplex structure
lowerMat(simplex) #the correlation matrix
#create a congeneric matrix
congeneric &lt;- sim.congeneric()
lowerMat(congeneric)
R &lt;- sim.hierarchical()
lowerMat(R)
#now simulate categorical items with the hierarchical factor structure.  
#Let the items be dichotomous with varying item difficulties.
marginals = matrix(c(seq(.1,.9,.1),seq(.9,.1,-.1)),byrow=TRUE,nrow=2)
X &lt;- sim.poly.mat(R=R,m=marginals,n=1000)
lowerCor(X) #show the raw correlations
#lowerMat(tetrachoric(X)$rho) # show the tetrachoric correlations (not run)
#generate a structure 
fx &lt;- matrix(c(.9,.8,.7,rep(0,6),c(.8,.7,.6)),ncol=2)
fy &lt;- c(.6,.5,.4)
Phi &lt;- matrix(c(1,0,.5,0,1,.4,0,0,0),ncol=3)
R &lt;- sim.structure(fx,Phi,fy) 
cor.plot(R$model) #show it graphically

simp &lt;- sim.simplex()
#show the simplex structure using cor.plot
cor.plot(simp,colors=TRUE,main="A simplex structure")
#Show a STARS model 
simp &lt;- sim.simplex(alpha=.8,lambda=.4)
#show the simplex structure using cor.plot
cor.plot(simp,colors=TRUE,main="State Trait Auto Regressive Simplex" )

dichot.sim &lt;- sim.irt()  #simulate 5 dichotomous items
poly.sim &lt;- sim.poly(theta=dichot.sim$theta)  #simulate 5 polytomous items that correlate 
  #with the dichotomous items

</code></pre>


</div>
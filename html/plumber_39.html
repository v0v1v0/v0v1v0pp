<div class="container">

<table style="width: 100%;"><tr>
<td>Plumber</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Package Plumber Router</h2>

<h3>Description</h3>

<p>Package Plumber Router
</p>
<p>Package Plumber Router
</p>


<h3>Details</h3>

<p>Routers are the core request handler in <span class="pkg">plumber</span>. A router is responsible for
taking an incoming request, submitting it through the appropriate filters and
eventually to a corresponding endpoint, if one is found.
</p>
<p>See the <a href="https://www.rplumber.io/articles/programmatic-usage.html">Programmatic Usage</a> article for additional
details on the methods available on this object.
</p>


<h3>Super class</h3>

<p><code>plumber::Hookable</code> -&gt; <code>Plumber</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>flags</code></dt>
<dd>
<p>For internal use only</p>
</dd>
</dl>
</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>endpoints</code></dt>
<dd>
<p>Plumber router endpoints read-only</p>
</dd>
<dt><code>filters</code></dt>
<dd>
<p>Plumber router filters read-only</p>
</dd>
<dt><code>mounts</code></dt>
<dd>
<p>Plumber router mounts read-only</p>
</dd>
<dt><code>environment</code></dt>
<dd>
<p>Plumber router environment read-only</p>
</dd>
<dt><code>routes</code></dt>
<dd>
<p>Plumber router routes read-only</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Plumber-new"><code>Plumber$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-run"><code>Plumber$run()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-mount"><code>Plumber$mount()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-unmount"><code>Plumber$unmount()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-registerHook"><code>Plumber$registerHook()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-handle"><code>Plumber$handle()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-removeHandle"><code>Plumber$removeHandle()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-print"><code>Plumber$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-serve"><code>Plumber$serve()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-route"><code>Plumber$route()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-call"><code>Plumber$call()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-onHeaders"><code>Plumber$onHeaders()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-onWSOpen"><code>Plumber$onWSOpen()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setSerializer"><code>Plumber$setSerializer()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setParsers"><code>Plumber$setParsers()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-set404Handler"><code>Plumber$set404Handler()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setErrorHandler"><code>Plumber$setErrorHandler()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setDocs"><code>Plumber$setDocs()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setDocsCallback"><code>Plumber$setDocsCallback()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setDebug"><code>Plumber$setDebug()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-getDebug"><code>Plumber$getDebug()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-filter"><code>Plumber$filter()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setApiSpec"><code>Plumber$setApiSpec()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-getApiSpec"><code>Plumber$getApiSpec()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-addEndpoint"><code>Plumber$addEndpoint()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-addAssets"><code>Plumber$addAssets()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-addFilter"><code>Plumber$addFilter()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-addGlobalProcessor"><code>Plumber$addGlobalProcessor()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-openAPIFile"><code>Plumber$openAPIFile()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-swaggerFile"><code>Plumber$swaggerFile()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-clone"><code>Plumber$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Hookable" data-id="registerHooks"><a href="../../plumber/html/Hookable.html#method-Hookable-registerHooks"><code>plumber::Hookable$registerHooks()</code></a></span></li>
</ul></details><hr>
<a id="method-Plumber-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>Plumber</code> router
</p>
<p>See also <code>plumb()</code>, <code>pr()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$new(file = NULL, filters = defaultPlumberFilters, envir)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file</code></dt>
<dd>
<p>path to file to plumb</p>
</dd>
<dt><code>filters</code></dt>
<dd>
<p>a list of Plumber filters</p>
</dd>
<dt><code>envir</code></dt>
<dd>
<p>an environment to be used as the enclosure for the routers execution</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new <code>Plumber</code> router
</p>


<hr>
<a id="method-Plumber-run"></a>



<h4>Method <code>run()</code>
</h4>

<p>Start a server using <code>Plumber</code> object.
</p>
<p>See also: <code>pr_run()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$run(
  host = "127.0.0.1",
  port = get_option_or_env("plumber.port", NULL),
  swagger = deprecated(),
  debug = missing_arg(),
  swaggerCallback = missing_arg(),
  ...,
  docs = missing_arg(),
  quiet = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>host</code></dt>
<dd>
<p>a string that is a valid IPv4 or IPv6 address that is owned by
this server, which the application will listen on. "0.0.0.0" represents
all IPv4 addresses and "::/0" represents all IPv6 addresses.</p>
</dd>
<dt><code>port</code></dt>
<dd>
<p>a number or integer that indicates the server port that should
be listened on. Note that on most Unix-like systems including Linux and
Mac OS X, port numbers smaller than 1025 require root privileges.
</p>
<p>This value does not need to be explicitly assigned. To explicitly set it, see <code>options_plumber()</code>.</p>
</dd>
<dt><code>swagger</code></dt>
<dd>
<p>Deprecated. Please use <code>docs</code> instead. See <code style="white-space: pre;">⁠$setDocs(docs)⁠</code> or <code style="white-space: pre;">⁠$setApiSpec()⁠</code> for more customization.</p>
</dd>
<dt><code>debug</code></dt>
<dd>
<p>If <code>TRUE</code>, it will provide more insight into your API errors. Using this value will only last for the duration of the run. If a <code style="white-space: pre;">⁠$setDebug()⁠</code> has not been called, <code>debug</code> will default to <code>interactive()</code> at <code style="white-space: pre;">⁠$run()⁠</code> time. See <code style="white-space: pre;">⁠$setDebug()⁠</code> for more details.</p>
</dd>
<dt><code>swaggerCallback</code></dt>
<dd>
<p>An optional single-argument function that is
called back with the URL to an OpenAPI user interface when one becomes
ready. If missing, defaults to information previously set with <code style="white-space: pre;">⁠$setDocsCallback()⁠</code>.
This value will only be used while running the router.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Should be empty.</p>
</dd>
<dt><code>docs</code></dt>
<dd>
<p>Visual documentation value to use while running the API.
This value will only be used while running the router.
If missing, defaults to information previously set with <code>setDocs()</code>.
For more customization, see <code style="white-space: pre;">⁠$setDocs()⁠</code> or <code>pr_set_docs()</code> for examples.</p>
</dd>
<dt><code>quiet</code></dt>
<dd>
<p>If <code>TRUE</code>, don't print routine startup messages.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-mount"></a>



<h4>Method <code>mount()</code>
</h4>

<p>Mount a Plumber router
</p>
<p>Plumber routers can be “nested” by mounting one into another
using the <code>mount()</code> method. This allows you to compartmentalize your API
by paths which is a great technique for decomposing large APIs into smaller files.
</p>
<p>See also: <code>pr_mount()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$mount(path, router)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>a character string. Where to mount router.</p>
</dd>
<dt><code>router</code></dt>
<dd>
<p>a Plumber router. Router to be mounted.</p>
</dd>
</dl>
</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
root &lt;- pr()

users &lt;- Plumber$new("users.R")
root$mount("/users", users)

products &lt;- Plumber$new("products.R")
root$mount("/products", products)
}
</pre>
</div>


<hr>
<a id="method-Plumber-unmount"></a>



<h4>Method <code>unmount()</code>
</h4>

<p>Unmount a Plumber router
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$unmount(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>a character string. Where to unmount router.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-registerHook"></a>



<h4>Method <code>registerHook()</code>
</h4>

<p>Register a hook
</p>
<p>Plumber routers support the notion of "hooks" that can be registered
to execute some code at a particular point in the lifecycle of a request.
Plumber routers currently support four hooks:
</p>

<ol>
<li> <p><code>preroute(data, req, res)</code>
</p>
</li>
<li> <p><code>postroute(data, req, res, value)</code>
</p>
</li>
<li> <p><code>preserialize(data, req, res, value)</code>
</p>
</li>
<li> <p><code>postserialize(data, req, res, value)</code>
</p>
</li>
</ol>
<p>In all of the above you have access to a disposable environment in the <code>data</code>
parameter that is created as a temporary data store for each request. Hooks
can store temporary data in these hooks that can be reused by other hooks
processing this same request.
</p>
<p>One feature when defining hooks in Plumber routers is the ability to modify
the returned value. The convention for such hooks is: any function that accepts
a parameter named <code>value</code> is expected to return the new value. This could
be an unmodified version of the value that was passed in, or it could be a
mutated value. But in either case, if your hook accepts a parameter
named <code>value</code>, whatever your hook returns will be used as the new value
for the response.
</p>
<p>You can add hooks using the <code>registerHook</code> method, or you can add multiple
hooks at once using the <code>registerHooks</code> method which takes a name list in
which the names are the names of the hooks, and the values are the
handlers themselves.
</p>
<p>See also: <code>pr_hook()</code>, <code>pr_hooks()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$registerHook(
  stage = c("preroute", "postroute", "preserialize", "postserialize", "exit"),
  handler
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stage</code></dt>
<dd>
<p>a character string. Point in the lifecycle of a request.</p>
</dd>
<dt><code>handler</code></dt>
<dd>
<p>a hook function.</p>
</dd>
</dl>
</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
pr &lt;- pr()
pr$registerHook("preroute", function(req){
  cat("Routing a request for", req$PATH_INFO, "...\n")
})
pr$registerHooks(list(
  preserialize=function(req, value){
    print("About to serialize this value:")
    print(value)

    # Must return the value since we took one in. Here we're not choosing
    # to mutate it, but we could.
    value
  },
  postserialize=function(res){
    print("We serialized the value as:")
    print(res$body)
  }
))

pr$handle("GET", "/", function(){ 123 })
}
</pre>
</div>


<hr>
<a id="method-Plumber-handle"></a>



<h4>Method <code>handle()</code>
</h4>

<p>Define endpoints
</p>
<p>The “handler” functions that you define in these handle calls
are identical to the code you would have defined in your plumber.R file
if you were using annotations to define your API. The handle() method
takes additional arguments that allow you to control nuanced behavior
of the endpoint like which filter it might preempt or which serializer
it should use.
</p>
<p>See also: <code>pr_handle()</code>, <code>pr_get()</code>, <code>pr_post()</code>, <code>pr_put()</code>, <code>pr_delete()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$handle(
  methods,
  path,
  handler,
  preempt,
  serializer,
  parsers,
  endpoint,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>methods</code></dt>
<dd>
<p>a character string. http method.</p>
</dd>
<dt><code>path</code></dt>
<dd>
<p>a character string. Api endpoints</p>
</dd>
<dt><code>handler</code></dt>
<dd>
<p>a handler function.</p>
</dd>
<dt><code>preempt</code></dt>
<dd>
<p>a preempt function.</p>
</dd>
<dt><code>serializer</code></dt>
<dd>
<p>a serializer function.</p>
</dd>
<dt><code>parsers</code></dt>
<dd>
<p>a named list of parsers.</p>
</dd>
<dt><code>endpoint</code></dt>
<dd>
<p>a <code>PlumberEndpoint</code> object.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>additional arguments for PlumberEndpoint <code>new</code> method (namely <code>lines</code>, <code>params</code>, <code>comments</code>, <code>responses</code> and <code>tags</code>. Excludes <code>envir</code>).</p>
</dd>
</dl>
</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
pr &lt;- pr()
pr$handle("GET", "/", function(){
  "&lt;html&gt;&lt;h1&gt;Programmatic Plumber!&lt;/h1&gt;&lt;/html&gt;"
}, serializer=plumber::serializer_html())
}
</pre>
</div>


<hr>
<a id="method-Plumber-removeHandle"></a>



<h4>Method <code>removeHandle()</code>
</h4>

<p>Remove endpoints
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$removeHandle(methods, path, preempt = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>methods</code></dt>
<dd>
<p>a character string. http method.</p>
</dd>
<dt><code>path</code></dt>
<dd>
<p>a character string. Api endpoints</p>
</dd>
<dt><code>preempt</code></dt>
<dd>
<p>a preempt function.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Print representation of plumber router.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$print(prefix = "", topLevel = TRUE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prefix</code></dt>
<dd>
<p>a character string. Prefix to append to representation.</p>
</dd>
<dt><code>topLevel</code></dt>
<dd>
<p>a logical value. When method executed on top level
router, set to <code>TRUE</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>additional arguments for recursive calls</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A terminal friendly representation of a plumber router.
</p>


<hr>
<a id="method-Plumber-serve"></a>



<h4>Method <code>serve()</code>
</h4>

<p>Serve a request
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$serve(req, res)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req</code></dt>
<dd>
<p>request object</p>
</dd>
<dt><code>res</code></dt>
<dd>
<p>response object</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-route"></a>



<h4>Method <code>route()</code>
</h4>

<p>Route a request
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$route(req, res)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req</code></dt>
<dd>
<p>request object</p>
</dd>
<dt><code>res</code></dt>
<dd>
<p>response object</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-call"></a>



<h4>Method <code>call()</code>
</h4>

<p><span class="pkg">httpuv</span> interface call function. (Required for <span class="pkg">httpuv</span>)
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$call(req)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req</code></dt>
<dd>
<p>request object</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-onHeaders"></a>



<h4>Method <code>onHeaders()</code>
</h4>

<p>httpuv interface onHeaders function. (Required for <span class="pkg">httpuv</span>)
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$onHeaders(req)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req</code></dt>
<dd>
<p>request object</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-onWSOpen"></a>



<h4>Method <code>onWSOpen()</code>
</h4>

<p>httpuv interface onWSOpen function. (Required for <span class="pkg">httpuv</span>)
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$onWSOpen(ws)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ws</code></dt>
<dd>
<p>WebSocket object</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-setSerializer"></a>



<h4>Method <code>setSerializer()</code>
</h4>

<p>Sets the default serializer of the router.
</p>
<p>See also: <code>pr_set_serializer()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setSerializer(serializer)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>serializer</code></dt>
<dd>
<p>a serializer function</p>
</dd>
</dl>
</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
pr &lt;- pr()
pr$setSerializer(serializer_unboxed_json())
}
</pre>
</div>


<hr>
<a id="method-Plumber-setParsers"></a>



<h4>Method <code>setParsers()</code>
</h4>

<p>Sets the default parsers of the router. Initialized to <code>c("json", "form", "text", "octet", "multi")</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setParsers(parsers)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parsers</code></dt>
<dd>
<p>Can be one of:
</p>

<ul>
<li>
<p> A <code>NULL</code> value
</p>
</li>
<li>
<p> A character vector of parser names
</p>
</li>
<li>
<p> A named <code>list()</code> whose keys are parser names names and values are arguments to be applied with <code>do.call()</code>
</p>
</li>
<li>
<p> A <code>TRUE</code> value, which will default to combining all parsers. This is great for seeing what is possible, but not great for security purposes
</p>
</li>
</ul>
<p>If the parser name <code>"all"</code> is found in any character value or list name, all remaining parsers will be added.
When using a list, parser information already defined will maintain their existing argument values.  All remaining parsers will use their default arguments.
</p>
<p>Example:
</p>
<div class="sourceCode"><pre># provide a character string
parsers = "json"

# provide a named list with no arguments
parsers = list(json = list())

# provide a named list with arguments; include `rds`
parsers = list(json = list(simplifyVector = FALSE), rds = list())

# default plumber parsers
parsers = c("json", "form", "text", "octet", "multi")
</pre></div>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-set404Handler"></a>



<h4>Method <code>set404Handler()</code>
</h4>

<p>Sets the handler that gets called if an
incoming request can’t be served by any filter, endpoint, or sub-router.
</p>
<p>See also: <code>pr_set_404()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$set404Handler(fun)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fun</code></dt>
<dd>
<p>a handler function.</p>
</dd>
</dl>
</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
pr &lt;- pr()
pr$set404Handler(function(req, res) {cat(req$PATH_INFO)})
}
</pre>
</div>


<hr>
<a id="method-Plumber-setErrorHandler"></a>



<h4>Method <code>setErrorHandler()</code>
</h4>

<p>Sets the error handler which gets invoked if any filter or
endpoint generates an error.
</p>
<p>See also: <code>pr_set_404()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setErrorHandler(fun)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fun</code></dt>
<dd>
<p>a handler function.</p>
</dd>
</dl>
</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
pr &lt;- pr()
pr$setErrorHandler(function(req, res, err) {
  message("Found error: ")
  str(err)
})
}
</pre>
</div>


<hr>
<a id="method-Plumber-setDocs"></a>



<h4>Method <code>setDocs()</code>
</h4>

<p>Set visual documentation to use for API
</p>
<p>See also: <code>pr_set_docs()</code>, <code>register_docs()</code>, <code>registered_docs()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setDocs(docs = get_option_or_env("plumber.docs", TRUE), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>docs</code></dt>
<dd>
<p>a character value or a logical value. See <code>pr_set_docs()</code> for examples.
If using <code>options_plumber()</code>, the value must be set before initializing your Plumber router.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Arguments for the visual documentation. See each visual documentation package for further details.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-setDocsCallback"></a>



<h4>Method <code>setDocsCallback()</code>
</h4>

<p>Set a callback to notify where the API's visual documentation is located.
</p>
<p>When set, it will be called with a character string corresponding
to the API docs url. This allows RStudio to locate visual documentation.
</p>
<p>If using <code>options_plumber()</code>, the value must be set before initializing your Plumber router.
</p>
<p>See also: <code>pr_set_docs_callback()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setDocsCallback(
  callback = get_option_or_env("plumber.docs.callback", NULL)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>callback</code></dt>
<dd>
<p>a callback function for taking action on the docs url. (Also accepts <code>NULL</code> values to disable the <code>callback</code>.)</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-setDebug"></a>



<h4>Method <code>setDebug()</code>
</h4>

<p>Set debug value to include error messages.
</p>
<p>See also: <code style="white-space: pre;">⁠$getDebug()⁠</code> and <code>pr_set_debug()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setDebug(debug = interactive())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>debug</code></dt>
<dd>
<p><code>TRUE</code> provides more insight into your API errors.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-getDebug"></a>



<h4>Method <code>getDebug()</code>
</h4>

<p>Retrieve the <code>debug</code> value. If it has never been set, the result of <code>interactive()</code> will be used.
</p>
<p>See also: <code style="white-space: pre;">⁠$getDebug()⁠</code> and <code>pr_set_debug()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$getDebug()</pre></div>


<hr>
<a id="method-Plumber-filter"></a>



<h4>Method <code>filter()</code>
</h4>

<p>Add a filter to plumber router
</p>
<p>See also: <code>pr_filter()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$filter(name, expr, serializer)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>a character string. Name of filter</p>
</dd>
<dt><code>expr</code></dt>
<dd>
<p>an expr that resolve to a filter function or a filter function</p>
</dd>
<dt><code>serializer</code></dt>
<dd>
<p>a serializer function</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-setApiSpec"></a>



<h4>Method <code>setApiSpec()</code>
</h4>

<p>Allows to modify router autogenerated OpenAPI Specification
</p>
<p>Note, the returned value will be sent through <code>serializer_unboxed_json()</code> which will turn all length 1 vectors into atomic values.
To force a vector to serialize to an array of size 1, be sure to call <code>as.list()</code> on your value. <code>list()</code> objects are always serialized to an array value.
</p>
<p>See also: <code>pr_set_api_spec()</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setApiSpec(api = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api</code></dt>
<dd>
<p>This can be
</p>

<ul>
<li>
<p> an OpenAPI Specification formatted list object
</p>
</li>
<li>
<p> a function that accepts the OpenAPI Specification autogenerated by <code>plumber</code> and returns a OpenAPI Specification formatted list object.
</p>
</li>
<li>
<p> a path to an OpenAPI Specification
</p>
</li>
</ul>
<p>The value returned will not be validated for OAS compatibility.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-getApiSpec"></a>



<h4>Method <code>getApiSpec()</code>
</h4>

<p>Retrieve OpenAPI file
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$getApiSpec()</pre></div>


<hr>
<a id="method-Plumber-addEndpoint"></a>



<h4>Method <code>addEndpoint()</code>
</h4>

<p>addEndpoint has been deprecated in v0.4.0 and will be removed in a coming release. Please use <code>handle()</code> instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$addEndpoint(
  verbs,
  path,
  expr,
  serializer,
  processors,
  preempt = NULL,
  params = NULL,
  comments
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbs</code></dt>
<dd>
<p>verbs</p>
</dd>
<dt><code>path</code></dt>
<dd>
<p>path</p>
</dd>
<dt><code>expr</code></dt>
<dd>
<p>expr</p>
</dd>
<dt><code>serializer</code></dt>
<dd>
<p>serializer</p>
</dd>
<dt><code>processors</code></dt>
<dd>
<p>processors</p>
</dd>
<dt><code>preempt</code></dt>
<dd>
<p>preempt</p>
</dd>
<dt><code>params</code></dt>
<dd>
<p>params</p>
</dd>
<dt><code>comments</code></dt>
<dd>
<p>comments</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-addAssets"></a>



<h4>Method <code>addAssets()</code>
</h4>

<p>addAssets has been deprecated in v0.4.0 and will be removed in a coming release. Please use <code>mount</code> and <code>PlumberStatic$new()</code> instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$addAssets(dir, path = "/public", options = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir</code></dt>
<dd>
<p>dir</p>
</dd>
<dt><code>path</code></dt>
<dd>
<p>path</p>
</dd>
<dt><code>options</code></dt>
<dd>
<p>options</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-addFilter"></a>



<h4>Method <code>addFilter()</code>
</h4>

<p><code style="white-space: pre;">⁠$addFilter()⁠</code> has been deprecated in v0.4.0 and will be removed in a coming release. Please use <code style="white-space: pre;">⁠$filter()⁠</code> instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$addFilter(name, expr, serializer, processors)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>name</p>
</dd>
<dt><code>expr</code></dt>
<dd>
<p>expr</p>
</dd>
<dt><code>serializer</code></dt>
<dd>
<p>serializer</p>
</dd>
<dt><code>processors</code></dt>
<dd>
<p>processors</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-addGlobalProcessor"></a>



<h4>Method <code>addGlobalProcessor()</code>
</h4>

<p><code style="white-space: pre;">⁠$addGlobalProcessor()⁠</code> has been deprecated in v0.4.0 and will be removed in a coming release. Please use <code style="white-space: pre;">⁠$registerHook⁠</code>(s) instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$addGlobalProcessor(proc)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>proc</code></dt>
<dd>
<p>proc</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Plumber-openAPIFile"></a>



<h4>Method <code>openAPIFile()</code>
</h4>

<p>Deprecated. Retrieve OpenAPI file
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$openAPIFile()</pre></div>


<hr>
<a id="method-Plumber-swaggerFile"></a>



<h4>Method <code>swaggerFile()</code>
</h4>

<p>Deprecated. Retrieve OpenAPI file
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$swaggerFile()</pre></div>


<hr>
<a id="method-Plumber-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p><code>pr()</code>,
<code>pr_run()</code>,
<code>pr_get()</code>, <code>pr_post()</code>,
<code>pr_mount()</code>,
<code>pr_hook()</code>, <code>pr_hooks()</code>, <code>pr_cookie()</code>,
<code>pr_filter()</code>,
<code>pr_set_api_spec()</code>, <code>pr_set_docs()</code>,
<code>pr_set_serializer()</code>, <code>pr_set_parsers()</code>,
<code>pr_set_404()</code>, <code>pr_set_error()</code>,
<code>pr_set_debug()</code>,
<code>pr_set_docs_callback()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## ------------------------------------------------
## Method `Plumber$mount`
## ------------------------------------------------

## Not run: 
root &lt;- pr()

users &lt;- Plumber$new("users.R")
root$mount("/users", users)

products &lt;- Plumber$new("products.R")
root$mount("/products", products)

## End(Not run)

## ------------------------------------------------
## Method `Plumber$registerHook`
## ------------------------------------------------

## Not run: 
pr &lt;- pr()
pr$registerHook("preroute", function(req){
  cat("Routing a request for", req$PATH_INFO, "...\n")
})
pr$registerHooks(list(
  preserialize=function(req, value){
    print("About to serialize this value:")
    print(value)

    # Must return the value since we took one in. Here we're not choosing
    # to mutate it, but we could.
    value
  },
  postserialize=function(res){
    print("We serialized the value as:")
    print(res$body)
  }
))

pr$handle("GET", "/", function(){ 123 })

## End(Not run)

## ------------------------------------------------
## Method `Plumber$handle`
## ------------------------------------------------

## Not run: 
pr &lt;- pr()
pr$handle("GET", "/", function(){
  "&lt;html&gt;&lt;h1&gt;Programmatic Plumber!&lt;/h1&gt;&lt;/html&gt;"
}, serializer=plumber::serializer_html())

## End(Not run)

## ------------------------------------------------
## Method `Plumber$setSerializer`
## ------------------------------------------------

## Not run: 
pr &lt;- pr()
pr$setSerializer(serializer_unboxed_json())

## End(Not run)

## ------------------------------------------------
## Method `Plumber$set404Handler`
## ------------------------------------------------

## Not run: 
pr &lt;- pr()
pr$set404Handler(function(req, res) {cat(req$PATH_INFO)})

## End(Not run)

## ------------------------------------------------
## Method `Plumber$setErrorHandler`
## ------------------------------------------------

## Not run: 
pr &lt;- pr()
pr$setErrorHandler(function(req, res, err) {
  message("Found error: ")
  str(err)
})

## End(Not run)
</code></pre>


</div>
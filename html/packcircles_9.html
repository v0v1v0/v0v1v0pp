<div class="container">

<table style="width: 100%;"><tr>
<td>circleRepelLayout</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Arranges circles by iterative pair-wise repulsion within a bounding rectangle</h2>

<h3>Description</h3>

<p>This function takes a set of circles, defined by a data frame of initial 
centre positions and radii, and uses iterative pair-wise repulsion to try to 
find a non-overlapping arrangement where all circle centres lie inside a 
bounding rectangle. If no such arrangement can be found within the specified 
maximum number of iterations, the last attempt is returned.
</p>


<h3>Usage</h3>

<pre><code class="language-R">circleRepelLayout(
  x,
  xlim,
  ylim,
  xysizecols = c(1, 2, 3),
  sizetype = c("area", "radius"),
  maxiter = 1000,
  wrap = TRUE,
  weights = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Either a vector of circle sizes (areas or radii) or a matrix or 
data frame with a column of sizes and, optionally, columns for initial
x-y coordinates of circle centres.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>The bounds in the X direction; either a vector for [xmin, xmax) 
or a single value interpreted as [0, xmax). Alternatively, omitting this 
argument or passing any of <code>NULL</code>, a vector of <code>NA</code> or an empty
vector will result in unbounded movement in the X direction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>The bounds in the Y direction; either a vector for [ymin, ymax) 
or a single value interpreted as [0, ymax). Alternatively, omitting this 
argument or passing any of <code>NULL</code>, a vector of <code>NA</code> or an empty
vector will result in unbounded movement in the Y direction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xysizecols</code></td>
<td>
<p>The integer indices or names of the columns in <code>x</code> 
for the centre x-y coordinates and sizes of circles. This argument is
ignored if <code>x</code> is a vector.  If <code>x</code> is a matrix or data frame
but does not contain initial x-y coordinates, this can be indicated as
<code>xysizecols = c(NA, NA, 1)</code> for example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sizetype</code></td>
<td>
<p>The type of size values: either <code>"area"</code> or <code>"radius"</code>.
May be abbreviated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrap</code></td>
<td>
<p>Whether to treat the bounding rectangle as a toroid (default 
<code>TRUE</code>). When this is in effect, a circle leaving the bounds on one 
side re-enters on the opposite side.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>An optional vector of numeric weights (0 to 1 inclusive) to 
apply to the distance each circle moves during pair-repulsion. A weight of 
0 prevents any movement. A weight of 1 gives the default movement distance.
A single value can be supplied for uniform weights. A vector with length 
less than the number of circles will be silently extended by repeating the 
final value. Any values outside the range [0, 1] will be clamped to 0 or 1.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm is adapted from a demo written in the Processing language by 
Sean McCullough (this no longer seems to be available online).
Each circle in the input data is compared to those following it. If two 
circles overlap, they are moved apart such that the distance moved by each is
proportional to the radius of the other, loosely simulating inertia. So when 
a small circle is overlapped by a larger circle, the small circle moves 
furthest. This process is repeated until no more movement takes place 
(acceptable layout) or the maximum number of iterations is reached (layout 
failure).
</p>
<p>To avoid edge effects, the bounding rectangle can be treated as a toroid by 
setting the <code>wrap</code> argument to <code>TRUE</code>. With this option, a circle 
moving outside the bounds re-enters at the opposite side.
</p>


<h3>Value</h3>

<p>A list with components: </p>
 <dl>
<dt>layout</dt>
<dd>
<p>A 3-column matrix or
data frame (centre x, centre y, radius).</p>
</dd> <dt>niter</dt>
<dd>
<p>Number of iterations
performed.</p>
</dd> </dl>
</div>
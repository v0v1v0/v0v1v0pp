<div class="container">

<table style="width: 100%;"><tr>
<td>phate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run PHATE on an input data matrix</h2>

<h3>Description</h3>

<p>PHATE is a data reduction method specifically designed for visualizing
<strong>high</strong> dimensional data in <strong>low</strong> dimensional spaces.
</p>


<h3>Usage</h3>

<pre><code class="language-R">phate(
  data,
  ndim = 2,
  knn = 5,
  decay = 40,
  n.landmark = 2000,
  gamma = 1,
  t = "auto",
  mds.solver = "sgd",
  knn.dist.method = "euclidean",
  knn.max = NULL,
  init = NULL,
  mds.method = "metric",
  mds.dist.method = "euclidean",
  t.max = 100,
  npca = 100,
  plot.optimal.t = FALSE,
  verbose = 1,
  n.jobs = 1,
  seed = NULL,
  potential.method = NULL,
  k = NULL,
  alpha = NULL,
  use.alpha = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>matrix (n_samples, n_dimensions)
2 dimensional input data array with
n_samples samples and n_dimensions dimensions.
If <code>knn.dist.method</code> is 'precomputed', <code>data</code> is treated as a
(n_samples, n_samples) distance or affinity matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndim</code></td>
<td>
<p>int, optional, default: 2
number of dimensions in which the data will be embedded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knn</code></td>
<td>
<p>int, optional, default: 5
number of nearest neighbors on which to build kernel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decay</code></td>
<td>
<p>int, optional, default: 40
sets decay rate of kernel tails.
If NULL, alpha decaying kernel is not used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.landmark</code></td>
<td>
<p>int, optional, default: 2000
number of landmarks to use in fast PHATE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>float, optional, default: 1
Informational distance constant between -1 and 1.
<code>gamma=1</code> gives the PHATE log potential, <code>gamma=0</code> gives
a square root potential.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>int, optional, default: 'auto'
power to which the diffusion operator is powered
sets the level of diffusion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mds.solver</code></td>
<td>
<p>'sgd', 'smacof', optional, default: 'sgd'
which solver to use for metric MDS. SGD is substantially faster,
but produces slightly less optimal results. Note that SMACOF was used
for all figures in the PHATE paper.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knn.dist.method</code></td>
<td>
<p>string, optional, default: 'euclidean'.
recommended values: 'euclidean', 'cosine', 'precomputed'
Any metric from <code>scipy.spatial.distance</code> can be used
distance metric for building kNN graph. If 'precomputed',
<code>data</code> should be an n_samples x n_samples distance or
affinity matrix. Distance matrices are assumed to have zeros
down the diagonal, while affinity matrices are assumed to have
non-zero values down the diagonal. This is detected automatically using
<code>data[0,0]</code>. You can override this detection with
<code>knn.dist.method='precomputed_distance'</code> or
<code>knn.dist.method='precomputed_affinity'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knn.max</code></td>
<td>
<p>int, optional, default: NULL
Maximum number of neighbors for which alpha decaying kernel
is computed for each point. For very large datasets, setting <code>knn.max</code>
to a small multiple of <code>knn</code> can speed up computation significantly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>phate object, optional
object to use for initialization. Avoids recomputing
intermediate steps if parameters are the same.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mds.method</code></td>
<td>
<p>string, optional, default: 'metric'
choose from 'classic', 'metric', and 'nonmetric'
which MDS algorithm is used for dimensionality reduction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mds.dist.method</code></td>
<td>
<p>string, optional, default: 'euclidean'
recommended values: 'euclidean' and 'cosine'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.max</code></td>
<td>
<p>int, optional, default: 100.
Maximum value of t to test for automatic t selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npca</code></td>
<td>
<p>int, optional, default: 100
Number of principal components to use for calculating
neighborhoods. For extremely large datasets, using
n_pca &lt; 20 allows neighborhoods to be calculated in
log(n_samples) time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.optimal.t</code></td>
<td>
<p>boolean, optional, default: FALSE
If TRUE, produce a plot showing the Von Neumann Entropy
curve for automatic t selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>int</code> or <code>boolean</code>, optional (default : 1)
If <code>TRUE</code> or <code style="white-space: pre;">⁠&gt; 0⁠</code>, print verbose updates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.jobs</code></td>
<td>
<p><code>int</code>, optional (default: 1)
The number of jobs to use for the computation.
If -1 all CPUs are used. If 1 is given, no parallel computing code is
used at all, which is useful for debugging.
For n_jobs below -1, (n.cpus + 1 + n.jobs) are used. Thus for
n_jobs = -2, all CPUs but one are used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>int or <code>NULL</code>, random state (default: <code>NULL</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>potential.method</code></td>
<td>
<p>Deprecated.
For log potential, use <code>gamma=1</code>. For sqrt potential, use <code>gamma=0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Deprecated. Use <code>knn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Deprecated. Use <code>decay</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.alpha</code></td>
<td>
<p>Deprecated
To disable alpha decay, use <code>alpha=NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments for <code>graphtools.Graph</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>"phate" object containing:
</p>

<ul>
<li> <p><strong>embedding</strong>: the PHATE embedding
</p>
</li>
<li> <p><strong>operator</strong>: The PHATE operator (python phate.PHATE object)
</p>
</li>
<li> <p><strong>params</strong>: Parameters passed to phate
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">if (reticulate::py_module_available("phate")) {

# Load data
# data(tree.data)
# We use a smaller tree to make examples run faster
data(tree.data.small)

# Run PHATE
phate.tree &lt;- phate(tree.data.small$data)
summary(phate.tree)
## PHATE embedding
## knn = 5, decay = 40, t = 58
## Data: (3000, 100)
## Embedding: (3000, 2)

library(graphics)
# Plot the result with base graphics
plot(phate.tree, col=tree.data.small$branches)
# Plot the result with ggplot2
if (require(ggplot2)) {
  ggplot(phate.tree) +
    geom_point(aes(x=PHATE1, y=PHATE2, color=tree.data.small$branches))
}

# Run PHATE again with different parameters
# We use the last run as initialization
phate.tree2 &lt;- phate(tree.data.small$data, t=150, init=phate.tree)
# Extract the embedding matrix to use in downstream analysis
embedding &lt;- as.matrix(phate.tree2)

}
</code></pre>


</div>
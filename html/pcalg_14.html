<div class="container">

<table style="width: 100%;"><tr>
<td>checkTriple</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Check Consistency of Conditional Independence for a Triple of Nodes</h2>

<h3>Description</h3>

<p>For each subset of <code>nbrsA</code> and <code>nbrsC</code> where <code>a</code> and
<code>c</code> are conditionally independent, it is checked if <code>b</code> is in the
conditioning set.
</p>


<h3>Usage</h3>

<pre><code class="language-R">checkTriple(a, b, c, nbrsA, nbrsC,
            sepsetA, sepsetC,
            suffStat, indepTest, alpha, version.unf = c(NA, NA),
            maj.rule = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a, b, c</code></td>
<td>
<p>(integer) positions in adjacency matrix for nodes
<code class="reqn">a</code>, <code class="reqn">b</code>, and <code class="reqn">c</code>, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbrsA, nbrsC</code></td>
<td>
<p>(integer) position in adjacency matrix for
neighbors of <code class="reqn">a</code> and <code class="reqn">c</code>, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sepsetA</code></td>
<td>
<p>vector containing <code class="reqn">Sepset(a,c)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sepsetC</code></td>
<td>
<p>vector containing <code class="reqn">Sepset(c,a)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffStat</code></td>
<td>
<p>a <code>list</code> of sufficient statistics for
independent tests; see, e.g., <code>pc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indepTest</code></td>
<td>
<p>a <code>function</code> for the independence test,
see, e.g., <code>pc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>significance level of test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>version.unf</code></td>
<td>
<p>(integer) vector of length two: </p>

<dl>
<dt>
<code>version.unf[1]</code>:</dt>
<dd>
<p>1 - check for all separating subsets of
<code>nbrsA</code> and <code>nbrsC</code> if <code>b</code> is in that set,<br>
2 - it also checks if there at all exists any sepset which is a
subset of the neighbours (there might be none, although <code>b</code>
is in the sepset, which indicates an ambiguous situation);</p>
</dd>
<dt>
<code>version.unf[2]</code>:</dt>
<dd>
<p>1 - do not consider the initial sepsets
<code>sepsetA</code> and <code>sepsetC</code> (same as Tetrad),<br>
2 - consider if <code>b</code> is in <code>sepsetA</code> or
<code>sepsetC</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maj.rule</code></td>
<td>
<p>logical indicating that the following majority rule
is applied: if <code>b</code> is in less than
50% of the checked sepsets, we say that <code>b</code> is in <b>no</b> sepset.  If
<code>b</code> is in more than 50% of the checked sepsets, we say that 
<code>b</code> is in <b>all</b> sepsets.  If <code>b</code> is in exactly 50% of the
checked sepsets, the triple is considered ‘ambiguous’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical asking for detailed output of intermediate steps.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is used in the conservative versions of structure
learning algorithms.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>decision</code></td>
<td>
<p>Decision on possibly ambiguous triple, an integer code,
</p>

<dl>
<dt>1</dt>
<dd>
<p><code>b</code> is in NO sepset (make v-structure);</p>
</dd>
<dt>2</dt>
<dd>
<p><code>b</code> is in ALL sepsets (make no v-structure);</p>
</dd>
<dt>3</dt>
<dd>
<p><code>b</code> is in SOME but not all sepsets (ambiguous triple)</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vers</code></td>
<td>
<p>Version (1 or 2) of the ambiguous triple
(1=normal ambiguous triple that is <code>b</code> is in some sepsets;
2=triple coming from <code>version.unf[1]==2</code>, that is, <code>a</code> and
<code>c</code> are indep given the initial sepset but there doesn't exist a
subset of the neighbours that d-separates them.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sepsetA</code></td>
<td>
<p>Updated version of <code>sepsetA</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sepsetC</code></td>
<td>
<p>Updated version of <code>sepsetC</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Diego Colombo.
</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782. 
</p>


<h3>Examples</h3>

<pre><code class="language-R">##################################################
## Using Gaussian Data
##################################################
## Load predefined data
data(gmG)
n &lt;- nrow    (gmG8$x)
V &lt;- colnames(gmG8$x)


## define independence test (partial correlations), and test level
indepTest &lt;- gaussCItest
alpha &lt;- 0.01
## define sufficient statistics
suffStat &lt;- list(C = cor(gmG8$x), n = n)

## estimate CPDAG
pc.fit &lt;- pc(suffStat, indepTest, alpha=alpha, labels = V, verbose = TRUE)

if (require(Rgraphviz)) {
  ## show estimated CPDAG
  par(mfrow=c(1,2))
  plot(pc.fit, main = "Estimated CPDAG")
  plot(gmG8$g, main = "True DAG")
}

a &lt;- 6
b &lt;- 1
c &lt;- 8
checkTriple(a, b, c,
            nbrsA = c(1,5,7),
            nbrsC = c(1,5),
            sepsetA = pc.fit@sepset[[a]][[c]],
            sepsetC = pc.fit@sepset[[c]][[a]],
            suffStat=suffStat, indepTest=indepTest, alpha=alpha,
            version.unf = c(2,2),
            verbose = TRUE) -&gt; ct
str(ct)
## List of 4
## $ decision: int 2
## $ version : int 1
## $ SepsetA : int [1:2] 1 5
## $ SepsetC : int 1

checkTriple(a, b, c,
            nbrsA = c(1,5,7),
            nbrsC = c(1,5),
            sepsetA = pc.fit@sepset[[a]][[c]],
            sepsetC = pc.fit@sepset[[c]][[a]],
            version.unf = c(1,1),
            suffStat=suffStat, indepTest=indepTest, alpha=alpha) -&gt; c2
stopifnot(identical(ct, c2)) ## in this case,  'version.unf' had no effect
</code></pre>


</div>
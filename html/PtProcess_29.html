<div class="container">

<table style="width: 100%;"><tr>
<td>simple_gif</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Non-Homogeneous Poisson Processes
</h2>

<h3>Description</h3>

<p>The functions listed here are intensity functions that are not conditional on the history of the process. Each has exactly the same “Usage” and calling format (see section “Value”) as the function <code>simple_gif</code>. They are: <code>expfourier_gif</code>, <code>exppoly_gif</code>, <code>fourier_gif</code>, <code>poly_gif</code>, and <code>simple_gif</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simple_gif(data, evalpts, params, TT=NA, tplus=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p><code>NULL</code> or a data frame. The contents of this object are not used by these functions, though they retain this argument for consistency with other <code>gif</code> functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evalpts</code></td>
<td>

<p>a <code>vector</code>, <code>matrix</code> or <code>data.frame</code>. If a vector, the elements will be assumed to represent the required evaluation times. Other objects must include a column named <code>"time"</code> that can be referred to as <code>evalpts[,"time"]</code>, at which the intensity function will be evaluated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>

<p>vector of parameter values as required by the particular intensity function, see Details below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TT</code></td>
<td>

<p>vector of length 2, being the time interval over which the integral of the intensity function is to be evaluated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tplus</code></td>
<td>
<p>logical, <code class="reqn">\lambda_g(t|{\cal H}_t)</code> is evaluated as <code class="reqn">\lambda_g(t^+|{\cal H}_t)</code> if <code>TRUE</code>, else <code class="reqn">\lambda_g(t^-|{\cal H}_t)</code>. Included for compatibility with others conditional intensity functions.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The models are parameterised as follows.
</p>

<dl>
<dt><code>expfourier_gif</code></dt>
<dd>
<p>The vector of parameters is
</p>
<p style="text-align: center;"><code class="reqn">
(p, a_0, a_1, a_2, \cdots, a_n, b_1, b_2, \cdots, b_n)
</code>
</p>

<p>and the intensity function is
</p>
<p style="text-align: center;"><code class="reqn">
\lambda_g(t) = \exp\left\{a_0 + \sum_{j=1}^n a_j\cos\left(\frac{2j\pi t}{p}\right) + \sum_{j=1}^n b_j\sin\left(\frac{2j\pi t}{p}\right)\right\}.
</code>
</p>

<p>The length of <code>params</code> is <code class="reqn">2n + 2</code>, and determines the order of the fitted Fourier series. The numbers of specified sine and cosine coefficients must be the same. The integral is evaluated using numerical integration, using the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>integrate</code>.
</p>
</dd>
<dt><code>exppoly_gif</code></dt>
<dd>
<p>The vector of parameters is
<code class="reqn">
(b_0, b_1, b_2, \cdots, b_n)
</code>
and the intensity function is
</p>
<p style="text-align: center;"><code class="reqn">
\lambda_g(t) = \exp\left\{b_0 + \sum_{j=1}^n b_j t^j \right\}.
</code>
</p>

<p>The length of <code>params</code> determines the order of the fitted polynomial. The integral is evaluated using numerical integration, using the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>integrate</code>.
</p>
</dd>
<dt><code>fourier_gif</code></dt>
<dd>
<p>The Fourier intensity function is the same as <code>expfourier_gif</code>, except the intensity function omits the exponential, and the integration is performed explicitly.
</p>
</dd>
<dt><code>poly_gif</code></dt>
<dd>
<p>The polynomial intensity function is the same as <code>exppoly_gif</code>, except the intensity function omits the exponential, and the integration is performed explicitly.
</p>
</dd>
<dt><code>simple_gif</code></dt>
<dd>
<p>The intensity function is <code class="reqn">\lambda_g(t) = a + b t^g</code> and the vector of parameters is <code class="reqn">(a, b, g)</code>.
</p>
</dd>
</dl>
<h3>Value</h3>

<p>Two usages are as follows.
</p>
<pre>
simple_gif(data, evalpts, params, tplus=FALSE)
simple_gif(data, evalpts=NULL, params, TT=NA)
</pre>
<p>The first usage returns a vector containing the values of <code class="reqn">\lambda_g(t)</code> evaluated at the specified points. In the second usage, it returns the value of the integral.
</p>


<h3>Function Attributes</h3>


<dl>
<dt><code>rate</code></dt>
<dd>
<p>is <code>"bounded"</code>.</p>
</dd>
</dl>
<h3>See Also</h3>

<p>General details about the structure of conditional intensity functions are given in the topic <code>gif</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">expfourier_gif(NULL, c(1.1,1.2,1.3), c(2,3,1,2,3,4), TT=NA)
#  Evaluates:  lambda_g(t) = exp(3 + 1*cos(2*pi*t/2) + 2*cos(4*pi*t/2) +
#                                3*sin(2*pi*t/2) + 4*sin(4*pi*t/2))
#  lambda_g(1.1) = 162.56331
#  lambda_g(1.2) = 127.72599
#  lambda_g(1.3) =  23.83979

expfourier_gif(NULL, NULL, c(2,3,1,2,3,4), TT=c(3,4))
#  Let:  lambda_g(t) = exp(3 + 1*cos(2*pi*t/2) + 2*cos(4*pi*t/2) +
#                              3*sin(2*pi*t/2) + 4*sin(4*pi*t/2))
#  Evaluates: integral_3^4 lambda_g(t) dt = 46.21920


#--------------------------------------------------------
#   Plot intensity function: lambda(t) = 3 + 3*sin(t)
#   on interval (0, 6*pi), no marks

params &lt;- c(2*pi, 3, 0, 3)
TT &lt;- c(0, 6*pi)
x &lt;- seq(TT[1], TT[2], length.out=500)

plot(x, fourier_gif(NULL, x, params, TT=NA),
     ylim=c(0, 6), type="l", axes=FALSE,
     xlab="t",
     ylab=expression(lambda(t) == 3 + 3*phantom(.)*plain(sin)*phantom(.)*t),
     main="Sinusoidal Intensity Function", font.main=1)
abline(h=params[2], lty=2, col="red")
box()
axis(2)
axis(1, at=0, labels=0)
axis(1, at=2*pi, labels=expression(2*pi))
axis(1, at=4*pi, labels=expression(4*pi))
axis(1, at=6*pi, labels=expression(6*pi))

#   Now define a model object
#   note NULL "marks" argument, see manual page for "mpp"
z &lt;- mpp(data=NULL,
         gif=fourier_gif,
         marks=list(NULL, NULL),
         params=params,
         gmap=expression(params),
         mmap=NULL,
         TT=TT)

#   Simulate event times
z &lt;- simulate(z, seed=3, max.rate=6)

#   Plot simulated times on sine curve
x &lt;- z$data$time
points(x, fourier_gif(NULL, x, params, TT=NA), col="blue", lwd=5)

#   Number of simulated events
print(nrow(z$data))

#   Estimate parameters based on simulated data
parmap &lt;- function(y, p){
    #    fix parameters 1 and 3
    y$params &lt;- c(2*pi, p[1], 0, p[2])
    return(y)
}

initial &lt;- c(3, 3)
y &lt;- nlm(neglogLik, initial, object=z, pmap=parmap,
         print.level=2, iterlim=20, stepmax=0.1)
print(y$estimate)
</code></pre>


</div>
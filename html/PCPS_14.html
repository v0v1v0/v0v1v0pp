<div class="container">

<table style="width: 100%;"><tr>
<td>matrix.p.sig</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Association between phylogeny-weighted species composition and environmental predictors</h2>

<h3>Description</h3>

<p>Analyses to relate an environmental gradient to the phylogenetic assembly of species 
across a metacommunity by means of phylogenetic fuzzy weighting.
</p>


<h3>Usage</h3>

<pre><code class="language-R">matrix.p.sig(
  comm,
  phylodist,
  envir,
  checkdata = TRUE,
  FUN,
  runs = 999,
  parallel = NULL,
  newname = "pcps",
  ...
)

pcps.sig(
  comm,
  phylodist,
  envir,
  checkdata = TRUE,
  method = "bray",
  squareroot = TRUE,
  FUN,
  choices,
  runs = 999,
  parallel = NULL,
  newname = "pcps",
  ...
)

FUN.ADONIS(x, envir, method.p, sqrt.p = TRUE, formula, return.model = FALSE)

FUN.GLM(x, envir, formula, ..., return.model = FALSE)

FUN.GLS.marginal(x, envir, formula, ..., return.model = FALSE)

FUN.GLS.sequential(x, envir, formula, ..., return.model = FALSE)

FUN.LME.marginal(x, envir, formula, ..., return.model = FALSE)

FUN.LME.sequential(x, envir, formula, ..., return.model = FALSE)

FUN.MANTEL(
  x,
  envir,
  method.p,
  method.envir,
  sqrt.p = TRUE,
  ...,
  return.model = FALSE
)

FUN.RDA(x, envir, return.model = FALSE)

## S3 method for class 'pcpssig'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as rows. This matrix 
can contain either presence/absence or abundance data.
Alternatively comm can be an object of class metacommunity.data, an alternative
way to set all data.frames/matrices. When you use the class metacommunity.data the arguments
phylodist and envir must not be specified. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phylodist</code></td>
<td>
<p>Matrix containing phylogenetic distances between species.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>A matrix or data.frame with environmental variables for each community, with variables as columns and 
sampling units as rows. See Details and Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkdata</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to check if species
sequence in the community data follows the same order as the one in the phylodist matrix 
and if sampling units in the community data follows the same order as the one in the 
environmental data (Default checkdata = TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>An object of class function to perform the analysis. See Details and Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>runs</code></td>
<td>
<p>Number of permutations for assessing significance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Number of parallel processes or a predefined socket cluster done with parallel package. Tip: use detectCores() (Default parallel = NULL).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newname</code></td>
<td>
<p>New name to be replaced in object returned by <code>matrix.p.null</code> (Default newname = "pcps").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed to FUN function. See Details and Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Dissimilarity index, as accepted by <code>vegdist</code> (Default dist = "bray").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>squareroot</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if use square root of 
dissimilarity index (Default squareroot = TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choices</code></td>
<td>
<p>Numeric vector to choose the PCPS used in analysis. See Details and Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class pcpssig or other object to apply the function passed by FUN. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.p</code></td>
<td>
<p>Resemblance index between communities based on P matrix, as accepted by <code>vegdist</code>. 
Used in FUN.MANTEL, FUN.ADONIS, FUN.ADONIS2.global and FUN.ADONIS2.margin analysis. See Details and Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqrt.p</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if use square root of dissimilarity P matrix. Used in
FUN.MANTEL, FUN.ADONIS, FUN.ADONIS2.global and FUN.ADONIS2.margin analysis. See Details and Examples (Default sqrt.p = TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>An object of class <code>formula</code>. Used in FUN.GLM, FUN.ADONIS, 
FUN.ADONIS2.global, FUN.ADONIS2.margin, FUN.GLS.marginal, FUN.GLS.sequential, FUN.LME.marginal and FUN.LME.sequential analysis. See Details and Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.model</code></td>
<td>
<p>Must not be specified. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.envir</code></td>
<td>
<p>Resemblance index between communities based on environmental variables, as accepted by <code>vegdist</code>.
Used in FUN.MANTEL analysis. See Details and Examples.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Each metacommunity is submitted to phylogenetic fuzzy weighting, generating a matrix
that describing the phylogeny-weighted species composition of the communities
(<code>matrix.p</code>). The function matrix.p.sig test directly the association 
this matrix with the environmental predictors. The pairwise dissimilarities are 
submitted to Mantel test (<code>mantel</code>) or ADONIS test (<code>adonis</code> or <code>adonis2</code>)
to evaluate the influence of an environmental gradient on species dispersion across 
the communities. The function pcps.sig generates principal coordinates of phylogenetic
structure (<code>pcps</code>) and use a single axis for run a generalized linear 
model (GLM, <code>glm</code>), linear model using generalized least squares (GLS, <code>gls</code>),
linear mixed-effects models (LME, <code>lme</code>) or use set of axis for run a distance-based redundancy
analysis (db-RDA, <code>rda</code>).
</p>
<p>The sequence species show up in the community data matrix must be the 
same as they show up in the phylogenetic distance matrix and, similarly, 
the sequence of communities in the community data matrix must be the same as that in 
the environmental data. The function <code>organize.pcps</code> organizes the data, placing the matrices of 
community, phylogenetic distance and environmental data in the same order. The function use of function 
organize.pcps is not requered for run the functions, but is recommended. In this way 
the arguments comm and phylodist can be specified them as normal arguments or by passing
them with the object returned by the function <code>organize.pcps</code> using, in this
case only the argument comm. Using the object returned by organize.pcps, the comm argument 
is used as an alternative way of entering to set all data.frames/matrices, and therefore 
the arguments phylodist and envir must not be specified.
</p>
<p>The significance is obtained via two null models, one that shuffles sites across the
environmental gradient and another that shuffles terminal tips (taxa) across the phylogenetic
tree. The first null model (site shuffle) shuffles the site position across the environmental
gradient and rerun the same model, generating a null F value (or r value in Mantel test). The
second null model (taxa shuffle), shuffles terminal tips across the phylogenetic tree and 
generates a null matrix containing phylogeny-weighted species composition and rerun the same
model, generating another null F value. In the pcps.sig function are generate set of null PCPS
and each null PCPS (or set of PCPS in RDA) is submitted to a procrustean adjustment 
(see <code>procrustes</code>), and the fitted values between observed PCPS and null PCPS is 
obtained. The adjusted null PCPS is used to rerun the model, generating another null F value. 
The observed F value (or r value) is compared independently with both null sets of F values 
(or r value) to generate a probability value of the original F value being generated merely by
chance according to each null model.
</p>
<p><strong>The argument FUN</strong>
</p>
<p>The type of analysis performed by this function is specified using the argument <em>FUN</em>. The current version 
of package includes ten predefined function, however additional small functions can be easy specify. All
this function uses the environmental variables to analyze the association between phylogeny-weighted species
composition and environmental predictors. For matrix P analysis, in <em>matrix.p.sig</em> function, the predefined 
functions available are <em>FUN.MANTEL</em>, <em>FUN.ADONIS</em>, <em>FUN.ADONIS2.global</em> and <em>FUN.ADONIS2.margin</em>. For PCPS 
analysis, in <em>pcps.sig</em> function, the predefined functions available are <em>FUN.GLM</em>, <em>FUN.RDA</em>, <em>FUN.GLS.marginal</em>, 
<em>FUN.GLS.sequential</em>, <em>FUN.LME.marginal</em> and <em>FUN.LME.sequential</em>. The significance 
for each null model is performed as described here, NOT using p value of basic functions.
</p>
<p><strong>FUN.MANTEL</strong>
</p>
<p>Mantel test that can be used in matrix P analysis. The arguments <em>method.p</em> and <em>sqrt.p</em> are specified for determine resemblance 
index between communities based on P matrix. The argument <em>method.envir</em> is specified to determine resemblance 
index between communities based on environmental variables. The significance is assess using r value, see more in <code>mantel</code>.
</p>
<p><strong>FUN.ADONIS</strong>
</p>
<p>Multivariate analysis of variance that can be used in matrix P analysis. The arguments <em>method.p</em> and <em>sqrt.p</em> are specified for determine resemblance 
index between communities based on P matrix. The argument <em>formula</em> is specified, where the left hand side gives 
the resemblance data, right hand side gives the variables. The resemblance data is internally named <em>p.dist</em>, 
thus formula is an expression of the form <em>p.dist ~ model</em> (see Examples). The significance is assess using overall F value, 
see more in <code>adonis</code>.
</p>
<p><strong>FUN.ADONIS2.global and FUN.ADONIS2.margin</strong>
</p>
<p>Multivariate analysis of variance that can be used in matrix P analysis. The arguments <em>method.p</em> and <em>sqrt.p</em> are specified for determine resemblance 
index between communities based on P matrix. The argument <em>formula</em> is specified, where the left hand side gives 
the resemblance data, right hand side gives the variables. The resemblance data is internally named <em>p.dist</em>, 
thus formula is an expression of the form <em>p.dist ~ model</em> (see Examples). The significance is assess using F value 
and the difference between function is due to the argument <em>by</em> in <code>adonis2</code>. The function 
<em>FUN.ADONIS2.global</em> use as default <em>by = NULL</em> to assess the overall significance of all terms together
whereas the function <em>FUN.ADONIS2.margin</em> use as default <em>by = margin</em> to assess the marginal effects of 
the terms and return F and p value for each term. See more in <code>adonis2</code>.
</p>
<p>The function <code>adonis2</code> evaluate the formula argument in the global environment, however CRAN 
do not allow assignments to the global environment. As a temporary workaround, copy and run the lines below to make 
the functions FUN.ADONIS2.global and FUN.ADONIS2.margin available.
</p>
<pre>

FUN.ADONIS2.global &lt;- function(x, envir, method.p, formula, sqrt.p = TRUE, return.model = FALSE){
p.dist &lt;- vegan::vegdist(x, method = method.p)
if(sqrt.p){
  p.dist &lt;- sqrt(p.dist)
}
assign("p.dist", p.dist, envir = globalenv())
mod.obs &lt;- vegan::adonis2(formula, data = data.frame(envir), permutations = 0, by = NULL, parallel = NULL)
rm(p.dist, envir = globalenv())
statistic.obs &lt;- mod.obs$F[1]
if(return.model){
  res &lt;- list()
  res$mod.obs &lt;- mod.obs
  res$statistic.obs &lt;- statistic.obs
} else{
  res &lt;- statistic.obs
}
return(res)
}

FUN.ADONIS2.margin &lt;- function(x, envir, method.p, formula, sqrt.p = TRUE, return.model = FALSE){
p.dist &lt;- vegan::vegdist(x, method = method.p)
if(sqrt.p){
  p.dist &lt;- sqrt(p.dist)
}
assign("p.dist", p.dist, envir = globalenv())
mod.obs &lt;- vegan::adonis2(formula, data = data.frame(envir), permutations = 2, by = "margin", parallel = NULL)
rm(p.dist, envir = globalenv())
nf &lt;- length(mod.obs$F)-2
statistic.obs &lt;- mod.obs$F[seq_len(nf)]
if(return.model){
  res &lt;- list()
  res$mod.obs &lt;- mod.obs
  res$statistic.obs &lt;- statistic.obs
} else{
  res &lt;- statistic.obs
}
return(res)
}

</pre>
<p><strong>FUN.GLM</strong>
</p>
<p>Generalized linear models that can be used in PCPS analysis. The argument <em>formula</em> is specified, where the left hand side gives the PCPS used, 
right hand side gives the variables. The PCPS are internally named sequentially <em>pcps.1</em>, <em>pcps.2</em>, <em>pcps.3</em> and so 
on. Thus, formula is an expression of the form <em>pcps.1 ~ model</em> (see Examples). The type of environmental variables are 
extracted directly from <em>envir</em> argument, thus variables of class <code>factor</code> can be already
specified in <em>envir</em> <code>data.frame</code> or through <em>formula</em> argument. The significance is assess using overall 
F value, see more in <code>glm</code>.
</p>
<p><strong>FUN.RDA</strong>
</p>
<p>Redundancy analysis that can be used in PCPS analysis. The RDA analysis is performed using all PCPS specified with choices argument and 
all environmental variables specified by envir argument. The significance is assess using overall 
F value, see more in <code>rda</code>.
</p>
<p><strong>FUN.GLS.marginal and FUN.GLS.sequential</strong>
</p>
<p>Linear model using generalized least squares that can be used in PCPS analysis. The argument <em>formula</em> is specified, where the left hand side gives the PCPS used, 
right hand side gives the variables. The PCPS are internally named sequentially <em>pcps.1</em>, <em>pcps.2</em>, <em>pcps.3</em> and so 
on. Thus, formula is an expression of the form <em>pcps.1 ~ model</em> (see Examples). The type of environmental variables are 
extracted directly from <em>envir</em> argument, thus variables of class <code>factor</code> can be already
specified in <em>envir</em> <code>data.frame</code> or through <em>formula</em> argument. The significance is assess using F value 
and the difference between function is due to the argument <em>type</em> in <code>anova.gls</code>. The function 
<em>FUN.GLS.marginal</em> use as default <em>type = marginal</em> to assess the marginal significance of all terms
whereas the function <em>FUN.GSL.sequential</em> use as default <em>type = sequential</em> to assess the sequential effects of 
the terms. Those funcitons return all F values calculed by <code>anova.gls</code>, including the intercept if it is in the model. 
Additional arguments as <em>correlation</em> can be passed by <em>...</em> argument. See more in <code>gls</code> and <code>anova.gls</code>.
</p>
<p><strong>FUN.LME.marginal and FUN.LME.sequential</strong>
</p>
<p>Linear mixed-effects models that can be used in PCPS analysis. The argument <em>formula</em> is specified, where the left hand side gives the PCPS used, 
right hand side gives the variables. The PCPS are internally named sequentially <em>pcps.1</em>, <em>pcps.2</em>, <em>pcps.3</em> and so 
on. Thus, formula is an expression of the form <em>pcps.1 ~ model</em> (see Examples). The type of environmental variables are 
extracted directly from <em>envir</em> argument, thus variables of class <code>factor</code> can be already
specified in <em>envir</em> <code>data.frame</code> or through <em>formula</em> argument. The significance is assess using F value 
and the difference between function is due to the argument <em>type</em> in <code>anova.lme</code>. The function 
<em>FUN.LME.marginal</em> use as default <em>type = marginal</em> to assess the marginal significance of all terms
whereas the function <em>FUN.LME.sequential</em> use as default <em>type = sequential</em> to assess the sequential effects of 
the terms. Those funcitons return all F values calculed by <code>anova.lme</code>, including the intercept if it is in the model. 
Additional arguments as <em>correlation</em> and <em>random</em> can be passed by <em>...</em> argument. See more in <code>lme</code> and <code>anova.lme</code>.
</p>
<p><strong>Additional function</strong>
</p>
<p>The functions <em>matrix.p.sig</em> and <em>pcps.sig</em> only perform permutation following null models and apply the functions in all 
permuted matrices. Additional functions can be easy specify and passed via <em>FUN</em> argument. A skeleton of this function is slowed 
below. In this function the argument <em>x</em> will be always the matrix P or one matrix with PCPS choose, when additional arguments
as <em>envir</em> will specify statistical analysis performed in matrix P ou PCPS. This function must return the observed statistical in addition the
<em>return.model</em> argument must not be specified because it specify the return options used for observed and null statistics.
</p>
<pre>FUN.X &lt;- function(x, envir, ..., return.model = FALSE){
  mod.obs &lt;- # Function to perform analysis using x, envir and any additional argument
  statistic.obs &lt;- # Extract only the numeric values of observed statistical
  # Next lines are mandatory
   if(return.model){
      res &lt;- list()
      res$mod.obs &lt;- mod.obs
      res$statistic.obs &lt;- statistic.obs
    } else{
      res &lt;- statistic.obs
    }
  return(res) 
}</pre>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The arguments used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P.obs</code></td>
<td>
<p>Phylogeny-weighted species composition matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PCPS.obs</code></td>
<td>
<p>The principal coordinates of phylogenetic structure (PCPS)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>The observed model returned by FUN, an object of class glm, gls, lme, rda, adonis, adonis2 or mantel to predefined function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>The funtion used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic.null.site</code></td>
<td>
<p>A matrix with null statistic for site shuffle null model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic.null.taxa</code></td>
<td>
<p>A matrix with null statistic for taxa shuffle null model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.statistic</code></td>
<td>
<p>Observed statistic, F value or r value to predefined function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.site.shuffle</code></td>
<td>
<p>The p value for the site shuffle null model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.taxa.shuffle</code></td>
<td>
<p>The p value for the taxa shuffle null model.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p><strong>IMPORTANT</strong>: The sequence of species in the community data matrix
MUST be the same as that in the phylogenetic distance matrix and, similarly, 
the sequence of communities in the community data matrix MUST be the same as that in 
the environmental data. See details and <code>organize.pcps</code>.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Duarte, L.S. (2011). Phylogenetic habitat filtering influences forest 
nucleation in grasslands. Oikos, 120, 208:215.
</p>
<p>Duarte, L.S. (2016). Dissecting phylogenetic fuzzy weighting: theory and application 
in metacommunity phylogenetics. Methods in Ecology and Evolution, 7(8), 937:946.
</p>


<h3>See Also</h3>

<p><code>matrix.p</code>, <code>pcps</code>, <code>procrustes</code>, 
<code>glm</code>, <code>rda</code>, <code>adonis</code>, <code>adonis2</code>, 
<code>mantel</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
data(flona)

# MANTEL
res &lt;- matrix.p.sig(flona$community,flona$phylo, FUN = FUN.MANTEL, method.p = "bray", 
             method.envir = "euclidean", envir = flona$environment[, 2, drop = FALSE], runs = 99)
res

# ADONIS
res &lt;- matrix.p.sig(flona$community,flona$phylo, FUN = FUN.ADONIS, method.p = "bray", 
             formula = p.dist~temp, envir = flona$environment[, 2, drop = FALSE], runs = 99)
res

# ADONIS2
res &lt;- matrix.p.sig(flona$community,flona$phylo, FUN = FUN.ADONIS2.global, 
             envir = flona$environment, formula = p.dist~temp+alt, 
             method.p = "bray", runs = 99)
res            
res &lt;- matrix.p.sig(flona$community,flona$phylo, FUN = FUN.ADONIS2.margin, 
              envir = flona$environment, formula = p.dist~temp+alt, 
              method.p = "bray", runs = 99)
res            

# GLM
res &lt;- pcps.sig(flona$community, flona$phylo, FUN = FUN.GLM, method = "bray", 
         formula = pcps.1~temp, envir = flona$environment, choices = 1, runs = 99)
res
summary.lm(res$model)

# RDA
res &lt;- pcps.sig(flona$community, flona$phylo, FUN = FUN.RDA, envir = flona$environment, 
         choices = 1:2, runs = 99)
res

# GLS
res &lt;- pcps.sig(flona$community, flona$phylo, FUN = FUN.GLS.marginal, 
         formula = pcps.1~temp, envir = flona$environment, choices = 1, runs = 99)
res
anova(res$model, type = "marginal")

res &lt;- pcps.sig(flona$community, flona$phylo, FUN = FUN.GLS.marginal, 
         formula = pcps.1~temp, envir = flona$environment, 
         correlation = nlme::corCAR1(form = ~1:39), choices = 1, runs = 99)
res
anova(res$model, type = "marginal")

# LME
res &lt;- pcps.sig(flona$community, flona$phylo, FUN = FUN.LME.marginal, formula = pcps.1~alt, 
         envir = flona$environment, random = ~1|temp, choices = 1, runs = 99)
res
anova(res$model, type = "marginal")

res &lt;- pcps.sig(flona$community, flona$phylo, FUN = FUN.LME.sequential, formula = pcps.1~alt,
         envir = flona$environment, random = ~1|temp, choices = 1, runs = 99)
res
anova(res$model, type = "sequential")

## End(Not run)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>polygauss</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate 2D Nodes and Weights of the Product Gauss Cubature</h2>

<h3>Description</h3>

<p>Calculate 2D Nodes and Weights of the Product Gauss Cubature
</p>


<h3>Usage</h3>

<pre><code class="language-R">polygauss(xy, nw_MN, alpha = NULL, rotation = FALSE, engine = "C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xy</code></td>
<td>
<p>list with elements <code>"x"</code> and <code>"y"</code> containing the
polygon vertices in <em>anticlockwise</em> order (otherwise the result of the
cubature will have a negative sign) with first vertex not repeated at the
end (like <code>owin.object$bdry</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nw_MN</code></td>
<td>
<p>unnamed list of nodes and weights of one-dimensional Gauss
quadrature rules of degrees <code class="reqn">N</code> and <code class="reqn">M=N+1</code> (as returned by
<code>gauss.quad</code>): <code>list(s_M, w_M, s_N, w_N)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>base-line of the (rotated) polygon at <code class="reqn">x = \alpha</code> (see
Sommariva and Vianello (2007) for an explication). If <code>NULL</code> (default),
the midpoint of the x-range of each polygon is chosen if no <code>rotation</code>
is performed, and otherwise the <code class="reqn">x</code>-coordinate of the rotated point
<code>"P"</code> (see <code>rotation</code>). If <code>f</code> has its maximum value at the
origin <code class="reqn">(0,0)</code>, e.g., the bivariate Gaussian density with zero mean,
<code>alpha = 0</code> is a reasonable choice.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotation</code></td>
<td>
<p>logical (default: <code>FALSE</code>) or a list of points
<code>"P"</code> and <code>"Q"</code> describing the preferred direction. If
<code>TRUE</code>, the polygon is rotated according to the vertices <code>"P"</code> and
<code>"Q"</code>, which are farthest apart (see Sommariva and Vianello, 2007). For
convex polygons, this rotation guarantees that all nodes fall inside the
polygon.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>engine</code></td>
<td>
<p>character string specifying the implementation to use.
Up to <span class="pkg">polyCub</span> version 0.4-3, the two-dimensional nodes and weights
were computed by <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> functions and these are still available by setting
<code>engine = "R"</code>.
The new C-implementation is now the default (<code>engine = "C"</code>) and
requires approximately 30% less computation time.<br>
The special setting <code>engine = "C+reduce"</code> will discard redundant nodes
at (0,0) with zero weight resulting from edges on the base-line
<code class="reqn">x = \alpha</code> or orthogonal to it.
This extra cleaning is only worth its cost for computationally intensive
functions <code>f</code> over polygons which really have some edges on the
baseline or parallel to the x-axis.  Note that the old <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
implementation does not have such unset zero nodes and weights.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Sommariva, A. and Vianello, M. (2007):
Product Gauss cubature over polygons based on Green's integration formula.
<em>BIT Numerical Mathematics</em>, <b>47</b> (2), 441-453.
<a href="https://doi.org/10.1007/s10543-007-0131-2">doi:10.1007/s10543-007-0131-2</a>
</p>


</div>
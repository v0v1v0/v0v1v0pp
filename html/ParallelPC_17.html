<div class="container">

<table style="width: 100%;"><tr>
<td>rfci_parallel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate a PAG fast using the RFCI_parallel Algorithm</h2>

<h3>Description</h3>

<p>This is the parallelised version of the RFCI algorithm in the pcalg package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rfci_parallel(suffStat, indepTest, alpha, labels, p,
  skel.method = c("parallel"), mem.efficient = FALSE, fixedGaps = NULL,
  fixedEdges = NULL, NAdelete = TRUE, m.max = Inf, rules = rep(TRUE,
  10), conservative = FALSE, maj.rule = FALSE, verbose = FALSE,
  num.cores = detectCores())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>suffStat</code></td>
<td>
<p>Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indepTest</code></td>
<td>
<p>Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Significance level for the individual conditional independence tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>(optional) character vector of variable (or "node") names. Typically preferred to specifying p.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>(optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skel.method</code></td>
<td>
<p>Character string specifying method; the default, "parallel" provides an efficient skeleton, see skeleton_parallel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mem.efficient</code></td>
<td>
<p>Uses less amount of memory at any time point while running the algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedGaps</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NAdelete</code></td>
<td>
<p>If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.max</code></td>
<td>
<p>Maximum size of the conditioning sets that are considered in the conditional independence tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rules</code></td>
<td>
<p>Logical vector of length 10 indicating which rules should be used when directing edges. See the pcalg package for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conservative</code></td>
<td>
<p>Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined. For more information, see pcalg.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maj.rule</code></td>
<td>
<p>Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined using a majority rule idea, which is less strict than the standard conservative. For more information, see pcalg.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If true, more detailed output is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.cores</code></td>
<td>
<p>The numbers of cores CPU to run the algorithm</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class fciAlgo (see fciAlgo in the pcalg package) containing the estimated graph (in the form of an adjacency matrix with various possible edge marks), the conditioning sets that lead to edge removals (sepset) and several other parameters.
</p>


<h3>References</h3>

<p>1. Diego Colombo, Marloes H Maathuis, Markus Kalisch, Thomas S Richardson, et al. Learning high-dimensional directed acyclic graphs with latent and selection variables. The Annals of Statistics, 40(1):294-321, 2012.
</p>
<p>2. Markus Kalisch, Martin Machler, Diego Colombo, Marloes H Maathuis, and Peter Buhlmann. Causal inference using graphical models with the r package pcalg.
Journal of Statistical Software, 47(11):1-26, 2012.
</p>


<h3>Examples</h3>

<pre><code class="language-R">##########################################
## Using rfci_parallel without mem.efficeient
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
rfci_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method="parallel", alpha=0.01, num.cores=2)

##########################################
## Using rfci_parallel with mem.efficeient
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
rfci_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method="parallel",
alpha=0.01, num.cores=2, mem.efficient=TRUE)

#################################################
## Using fci_parallel with mutual information test
#################################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)

# The first parameter is the dataset
rfci_parallel(gmG$x, indepTest=mig, p=p, skel.method="parallel",
alpha=0.01, num.cores=2, mem.efficient=TRUE)
</code></pre>


</div>
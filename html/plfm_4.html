<div class="container">

<table style="width: 100%;"><tr>
<td>bayesplfm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian analysis of probabilistic latent feature models for two-way two-mode frequency data</h2>

<h3>Description</h3>

<p>Computation of a sample of the posterior distribution for disjunctive or conjunctive probabilistic latent feature models with <em>F</em> features.</p>


<h3>Usage</h3>

<pre><code class="language-R">bayesplfm(data,object,attribute,rating,freq1,freqtot,F,
          Nchains=2,Nburnin=0,maxNiter=4000,
          Nstep=1000,Rhatcrit=1.2,maprule="disj",datatype="freq",
          start.bayes="best",fitted.plfm=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> A data frame that consists of three components: the variables 
<code>object</code>, <code>attribute</code> and <code>rating</code>. Each row of the data frame describes the outcome of a binary rater judgement
about the association between a certain object and a certain attribute.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>The name of the <code>object</code> component in the data frame <code>data</code>. The values of the vector <code>data$object</code> should be (non-missing) numeric or character values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attribute</code></td>
<td>
<p>The name of the <code>attribute</code> component in the data frame <code>data</code>. The values of the vector <code>data$attribute</code> should be (non-missing) numeric or character values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rating</code></td>
<td>
<p>The name of the <code>rating</code> component in the data frame <code>data</code>. The elements of the vector <code>data$rating</code> should be the numeric values 0 (no association) or 1 (association), 
or should be specified as missing (NA).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq1</code></td>
<td>
<p>A <em>J X K</em> matrix of observed association frequencies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freqtot</code></td>
<td>
<p>A <em>J X K</em> matrix with the total number of binary ratings in each cell <em>(j,k)</em>. If the total number of ratings is the same for all cells of the matrix 
it is sufficient to enter a single numeric value rather than a matrix. For instance, if <em>N</em> raters have judged <em>J X K</em> associations, one may specify <code>freqtot</code><em>=N</em></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>F</code></td>
<td>
<p>The number of latent features included in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nchains</code></td>
<td>
<p>The number of Markov-chains that are simulated using a data-augmented Gibbs sampling algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nburnin</code></td>
<td>
<p>The number of burn-in iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxNiter</code></td>
<td>
<p>The maximum number of iterations that will be computed for each chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nstep</code></td>
<td>
<p>The convergence of the chains to the true posterior will be checked for each parameter after c*<code>Nstep</code> iterations with c=1,2,...
The convergence will only be checked when <code>Nchains</code>&gt;1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rhatcrit</code></td>
<td>
<p>The estimation procedure will be stopped if the Rhat convergence diagnostic is smaller than <code>Rhatcrit</code> 
for each object- and attribute parameter. By default <code>Rhatcrit</code>=1.2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maprule</code></td>
<td>
<p>Disjunctive (<em>maprule="disj"</em>) or conjunctive (<em>maprule="conj"</em>) mapping rule of the probabilistic latent feature model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>datatype</code></td>
<td>
<p>The type of data used as input. When <code>datatype</code>="freq" one should specify frequency data <code>freq1</code> and <code>freqtot</code>, and when <code>datatype</code>="dataframe" one should 
specify the name of the data frame <code>data</code>, and its components, <code>object</code>, <code>attribute</code> and <code>rating</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.bayes</code></td>
<td>
<p>This argument can be used to define the type of starting point for the Bayesian analysis. If <code>start.bayes</code>="best" the best solution of a <code>plfm</code> analysis 
is used as the starting point for the Bayesian analysis, and if <code>start.bayes</code> = "fitted.plfm", the
starting point is read from the (<code>plfm</code>) object assigned to the argument 
<code>fitted.plfm</code>. If <code>start.bayes</code>="random", a random starting point is used for the Bayesian analysis.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.plfm</code></td>
<td>
<p>The name of the <code>plfm</code> object that contains posterior mode estimates for the specified model.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>bayesplfm</code> can be used to compute a sample of the posterior 
distribution of disjunctive or conjunctive probabilistic latent feature models with a particular number of features 
using a data-augmented Gibbs sampling algorithm 
(Meulders, De Boeck, Van Mechelen, Gelman, and Maris, 2001; Meulders, De Boeck, Van Mechelen, and Gelman, 2005; Meulders, 2013).
</p>
<p>By specifying the parameter <code>Nchains</code> the function can be used to compute one single chain, or multiple chains. 
When only one chain is computed, no convergence measure is reported. When more than one chain is computed, for each parameter, 
convergence to the true posterior distribution is assessed using the Rhat convergence diagnostic proposed by Gelman and Rubin (1992).
</p>
<p>When using <code>bayesplfm</code> for Bayesian analysis the same starting point will be used for each simulated chain. The reason for using the same
starting point for each of the chains is that the posterior distribution of probabilistic feature models with <em>F&gt;2</em> is always multimodal 
(local maxima may exist, and one may switch feature labels), so that the aim of the Bayesian analysis is to compute a sample in the neigbourhood 
of one specific posterior mode.  It is recommended to use the best posterior mode obtained
with the <code>plfm</code> function as a starting point for the Bayesian analysis (use <code>start.bayes</code>="best", or specify <code>start.bayes</code>="fitted.plfm" and 
<code>fitted.plfm</code>=object) with "object" being a <code>plfm</code> object that contains posterior mode estimates for the specified model. As an alternative to using the <code>plfm()</code>, 
function one may use random  starting points for the Bayesian analysis (<code>start.bayes</code>="random") to explore the posterior distribution.
</p>
<p>The function <code>bayesplfm()</code> will converge well if the  distinct posterior modes are well-separated and if the different chains only visit the same mode during the estimation process. 
However, if the posterior distribution is multimodal, it may fail to converge  if the Gibbs sampler starts visiting different posterior modes within
one chain, or if different chains sample from distinct posterior modes. 
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>Parameters used to call the function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.objpar</code></td>
<td>
<p>A <em>J X F X Niter X Nchains</em> array with parameter values for the object parameters. 
The matrix <code>sample.objpar[,,i,c]</code> contains the draw of the object parameters 
in iteration <em>i</em> of chain <em>c</em>. Note: when <code>Nchains</code>=1 the chain length <em>Niter</em> equals <code>maxNiter</code>, 
and when <code>Nchains</code>&gt;1 the chain length <em>Niter</em> equals the number of iterations required to obtain convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.attpar</code></td>
<td>
<p>A <em>K X F X Niter X Nchains</em> array with parameter values for the attribute parameters. 
The matrix <code>sample.attpar[,,i,c]</code> contains the draw of the attribute parameters 
in iteration <em>i</em> of chain <em>c</em>. Note: when <code>Nchains</code>=1 the chain length <em>Niter</em> equals <code>maxNiter</code>, 
and when <code>Nchains</code>&gt;1 the chain length <em>Niter</em> equals the number of iterations required to obtain convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmean.objpar</code></td>
<td>
<p>A <em>J X F</em> matrix with the posterior mean of the object parameters computed on all iterations and chains in the sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmean.attpar</code></td>
<td>
<p>A <em>K X F</em> matrix with the posterior mean of the attribute parameters computed on all iterations and chains in the sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p95.objpar</code></td>
<td>
<p>A <em>3 X J X F</em> array which contains for each object parameter the percentiles 2.5, 50 and 97.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p95.attpar</code></td>
<td>
<p>A <em>3 X K X F</em> array which contains for each attribute parameter the percentiles 2.5, 50 and 97.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rhat.objpar</code></td>
<td>
<p>A <em>J X F</em> matrix with Rhat convergence values for the object parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rhat.attpar</code></td>
<td>
<p>A <em>K X F</em> matrix with Rhat convergence values for the attribute parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitmeasures</code></td>
<td>
<p>A list with two measures of descriptive fit on the <em>J X K</em> table: (1) the correlation between observed and expected frequencies, 
and (2) the proportion of the variance in the observed frequencies accounted for by the model. 
The association probabilities and corresponding expected frequencies are computed using the posterior mean of the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convstat</code></td>
<td>
<p>The number of object-and attribute parameters that do not meet the convergence criterion.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Michel Meulders
</p>


<h3>References</h3>

<p>Gelman, A., and Rubin, D. B. (1992). Inference from iterative simulation using multiple
sequences. <em>Statistical Science, 7</em> , 457-472.
</p>
<p>Meulders, M., De Boeck, P., Van Mechelen, I., Gelman, A., and Maris, E. (2001). Bayesian inference with probability matrix decomposition models. 
<em>Journal of Educational and Behavioral Statistics, 26</em>, 153-179.
</p>
<p>Meulders, M., De Boeck, P., Van Mechelen, I., and Gelman, A. (2005). Probabilistic feature analysis of facial perception of emotions. 
<em>Applied Statistics, 54</em>, 781-793.
</p>
<p>Meulders, M. and De Bruecker, P. (2018). Latent class probabilistic latent feature analysis of three-way three-mode binary data. 
<em>Journal of Statistical Software, 87(1)</em>, 1-45.
</p>
<p>Meulders, M. (2013). An R Package for Probabilistic Latent Feature Analysis of Two-Way Two-Mode Frequencies. <em>Journal of Statistical Software, 54(14)</em>, 1-29. 
URL http://www.jstatsoft.org/v54/i14/.
</p>


<h3>See Also</h3>

<p><code>plfm</code>, <code>summary.bayesplfm</code>,<code>print.summary.bayesplfm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
## example 1: Bayesian analysis using data generated under the model

## define number of objects
J&lt;-10
## define number of attributes
K&lt;-10
## define number of features
F&lt;-2

## generate true parameters
set.seed(43565)
objectparameters&lt;-matrix(runif(J*F),nrow=J)
attributeparameters&lt;-matrix(runif(K*F),nrow=K)

## generate data for conjunctive model using N=100 replications
gdat&lt;-gendat(maprule="conj",N=100,
              objpar=objectparameters,attpar=attributeparameters)

## Use stepplfm to compute posterior mode(s) for 1 up to 3 features 

conj.lst&lt;-stepplfm(minF=1,maxF=3,maprule="conj",freq1=gdat$freq1,freqtot=100,M=5)


## Compute a sample of the posterior distribution 
## for the conjunctive model with two features
## use the posterior mode obtained with stepplfm as starting point
conjbayes2&lt;-bayesplfm(maprule="conj",freq1=gdat$freq1,freqtot=100,F=2,
                      maxNiter=3000,Nburnin=0,Nstep=1000,Nchains=2,
                      start.bayes="fitted.plfm",fitted.plfm=conj.lst[[2]])


## End(Not run)

## Not run: 
## example 2: Bayesian analysis of situational determinants of anger-related behavior

## load data
data(anger)

## Compute one chain of 500 iterations (including 250 burn-in iterations) 
## for the disjunctive model with two features
## use a random starting point

bayesangerdisj2a&lt;-bayesplfm(maprule="disj",freq1=anger$freq1,freqtot=anger$freqtot,F=2,
                      maxNiter=500,Nstep=500,Nburnin=250,Nchains=1,start.bayes="random")

##print a summary of the output 
summary(bayesangerdisj2a)


## Compute a sample of the posterior distribution 
## for the disjunctive model with two features
## compute starting points with plfm
## run 2 chains with a maximum length of 10000 iterations
## compute convergence after each 1000 iterations

bayesangerdisj2b&lt;-bayesplfm(maprule="disj",freq1=anger$freq1,freqtot=anger$freqtot,F=2,
                      maxNiter=10000,Nburnin=0,Nstep=1000,Nchains=2,start.bayes="best")


## print the output of the disjunctive 2-feature model for the anger data
print(bayesangerdisj2b)


## print a summary of the output of the disjunctive 2-feature model 
##for the anger data
summary(bayesangerdisj2b)

## End(Not run)


</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>psqn_bfgs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>BFGS Implementation Used Internally in the psqn Package</h2>

<h3>Description</h3>

<p>The method seems to mainly differ from <code>optim</code> by the line search
method. This version uses the interpolation method with a zoom phase
using cubic interpolation as described by Nocedal and Wright (2006).
</p>


<h3>Usage</h3>

<pre><code class="language-R">psqn_bfgs(
  par,
  fn,
  gr,
  rel_eps = 1e-08,
  max_it = 100L,
  c1 = 1e-04,
  c2 = 0.9,
  trace = 0L,
  env = NULL,
  gr_tol = -1,
  abs_eps = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>Initial values for the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>Function to evaluate the function to be minimized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gr</code></td>
<td>
<p>Gradient of <code>fn</code>. Should return the function value as an
attribute called <code>"value"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel_eps</code></td>
<td>
<p>Relative convergence threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_it</code></td>
<td>
<p>Maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c1</code></td>
<td>
<p>Thresholds for the Wolfe condition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c2</code></td>
<td>
<p>Thresholds for the Wolfe condition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Integer where larger values gives more information during the
optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>Environment to evaluate <code>fn</code> and <code>gr</code> in.
<code>NULL</code> yields the global environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gr_tol</code></td>
<td>
<p>Convergence tolerance for the Euclidean norm of the gradient. A negative
value yields no check.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abs_eps</code></td>
<td>
<p>Absolute convergence threshold. A negative values yields no
check.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object like the object returned by <code>psqn</code>.
</p>


<h3>References</h3>

<p>Nocedal, J. and Wright, S. J. (2006). <em>Numerical Optimization</em>
(2nd ed.). Springer.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># declare function and gradient from the example from help(optim)
fn &lt;- function(x) {
  x1 &lt;- x[1]
  x2 &lt;- x[2]
  100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
gr &lt;- function(x) {
  x1 &lt;- x[1]
  x2 &lt;- x[2]
  c(-400 * x1 * (x2 - x1 * x1) - 2 * (1 - x1),
     200 *      (x2 - x1 * x1))
}

# we need a different function for the method in this package
gr_psqn &lt;- function(x) {
  x1 &lt;- x[1]
  x2 &lt;- x[2]
  out &lt;- c(-400 * x1 * (x2 - x1 * x1) - 2 * (1 - x1),
            200 *      (x2 - x1 * x1))
  attr(out, "value") &lt;- 100 * (x2 - x1 * x1)^2 + (1 - x1)^2
  out
}

# we get the same
optim    (c(-1.2, 1), fn, gr, method = "BFGS")
psqn_bfgs(c(-1.2, 1), fn, gr_psqn)

# compare the computation time
system.time(replicate(1000,
                      optim    (c(-1.2, 1), fn, gr, method = "BFGS")))
system.time(replicate(1000,
                      psqn_bfgs(c(-1.2, 1), fn, gr_psqn)))

# we can use an alternative convergence criterion
org &lt;- psqn_bfgs(c(-1.2, 1), fn, gr_psqn, rel_eps = 1e-4)
sqrt(sum(gr_psqn(org$par)^2))

new_res &lt;- psqn_bfgs(c(-1.2, 1), fn, gr_psqn, rel_eps = 1e-4, gr_tol = 1e-8)
sqrt(sum(gr_psqn(new_res$par)^2))

new_res &lt;- psqn_bfgs(c(-1.2, 1), fn, gr_psqn, rel_eps = 1, abs_eps = 1e-2)
new_res$value - org$value # ~ there (but this is not guaranteed)
</code></pre>


</div>
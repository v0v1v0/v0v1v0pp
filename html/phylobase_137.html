<div class="container">

<table style="width: 100%;"><tr>
<td>phylo4d-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Combine a phylogenetic tree with data</h2>

<h3>Description</h3>

<p><code>phylo4d</code> is a generic constructor which merges a
phylogenetic tree with data frames to create a combined object of
class <code>phylo4d</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">phylo4d(x, ...)

## S4 method for signature 'phylo4'
phylo4d(
  x,
  tip.data = NULL,
  node.data = NULL,
  all.data = NULL,
  merge.data = TRUE,
  metadata = list(),
  ...
)

## S4 method for signature 'matrix'
phylo4d(
  x,
  tip.data = NULL,
  node.data = NULL,
  all.data = NULL,
  merge.data = TRUE,
  metadata = list(),
  edge.length = NULL,
  tip.label = NULL,
  node.label = NULL,
  edge.label = NULL,
  order = "unknown",
  annote = list(),
  ...
)

## S4 method for signature 'phylo'
phylo4d(
  x,
  tip.data = NULL,
  node.data = NULL,
  all.data = NULL,
  check.node.labels = c("keep", "drop", "asdata"),
  annote = list(),
  metadata = list(),
  ...
)

## S4 method for signature 'phylo4d'
phylo4d(x, ...)

## S4 method for signature 'nexml'
phylo4d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>phylo4</code>, <code>phylo</code>,
<code>nexml</code> or a matrix of edges (see above)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to control the behavior of the
constructor in the case of missing/extra data and where to look
for labels in the case of non-unique labels that cannot be stored
as row names in a data frame (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tip.data</code></td>
<td>
<p>a data frame (or object to be coerced to one)
containing only tip data (Optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node.data</code></td>
<td>
<p>a data frame (or object to be coerced to one)
containing only node data (Optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.data</code></td>
<td>
<p>a data frame (or object to be coerced to one)
containing both tip and node data (Optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merge.data</code></td>
<td>
<p>if both <code>tip.data</code> and <code>node.data</code> are
provided, should columns with common names will be merged together
(default TRUE) or not (FALSE)? See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metadata</code></td>
<td>
<p>any additional metadata to be passed to the new object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge.length</code></td>
<td>
<p>Edge (branch) length. (Optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tip.label</code></td>
<td>
<p>A character vector of species names (names of
"tip" nodes).  (Optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node.label</code></td>
<td>
<p>A character vector of internal node
names. (Optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge.label</code></td>
<td>
<p>A character vector of edge (branch)
names. (Optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>character: tree ordering (allowable values are listed
in <code>phylo4_orderings</code>, currently "unknown", "preorder"
(="cladewise" in <code>ape</code>), and "postorder", with "cladewise"
and "pruningwise" also allowed for compatibility with <code>ape</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>annote</code></td>
<td>
<p>any additional annotation data to be passed to the
new object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.node.labels</code></td>
<td>
<p>if <code>x</code> is of class <code>phylo</code>, use
either “keep” (the default) to retain internal node labels,
“drop” to drop them, or “asdata” to convert them to
numeric tree data. This argument is useful if the <code>phylo</code>
object has non-unique node labels or node labels with informative
data (e.g., posterior probabilities).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>You can provide several data frames to define traits associated
with tip and/or internal nodes. By default, data row names are
used to link data to nodes in the tree, with any number-like names
(e.g., “10”) matched against node ID numbers, and any
non-number-like names (e.g., “n10”) matched against node
labels. Alternative matching rules can be specified by passing
additional arguments (listed in the Details section); these
include positional matching, matching exclusively on node labels,
and matching based on a column of data rather than on row
names.
</p>
<p>Matching rules will apply the same way to all supplied data
frames.  This means that you need to be consistent with the row
names of your data frames.  It is good practice to use tip and
node labels (or node numbers if you use duplicated labels) when
you combine data with a tree.
</p>
<p>If you provide both <code>tip.data</code> and <code>node.data</code>, the
treatment of columns with common names will depend on the
<code>merge.data</code> argument. If TRUE, columns with the same name in
both data frames will be merged; when merging columns of different
data types, coercion to a common type will follow standard R
rules. If <code>merge.data</code> is FALSE, columns with common names
will be preserved independently, with “.tip” and
“.node” appended to the names. This argument has no effect
if <code>tip.data</code> and <code>node.data</code> have no column names in
common.
</p>
<p>If you provide <code>all.data</code> along with either of
<code>tip.data</code> and <code>node.data</code>, it must have distinct column
names, otherwise an error will result. Additionally, although
supplying columns with the same names <em>within</em> data frames is
not illegal, automatic renaming for uniqeness may lead to
surprising results, so this practice should be avoided.
</p>
<p>This is the list of additional arguments that can be used
to control matching between the tree and the data:
</p>

<dl>
<dt>match.data</dt>
<dd>
<p>(logical) should the rownames of the data frame
be used to be matched against tip and internal node identifiers?</p>
</dd>
<dt>rownamesAsLabels</dt>
<dd>
<p>(logical), should the row names of the
data provided be matched only to labels (TRUE), or should any
number-like row names be matched to node numbers (FALSE and
default)</p>
</dd>
<dt>label.type</dt>
<dd>
<p>character, <code>rownames</code> or <code>column</code>:
should the labels be taken from the row names of <code>dt</code> or from
the <code>label.column</code> column of <code>dt</code>?</p>
</dd>
<dt>label.column</dt>
<dd>
<p>iff <code>label.type=="column"</code>, column
specifier (number or name) of the column containing tip labels</p>
</dd>
<dt>missing.data</dt>
<dd>
<p>action to take if there are missing data or if
there are data labels that don't match</p>
</dd>
<dt>extra.data</dt>
<dd>
<p>action to take if there are extra data or if
there are labels that don't match</p>
</dd>
<dt>keep.all</dt>
<dd>
<p>(logical), should the returned data have rows for
all nodes (with NA values for internal rows when type='tip', and
vice versa) (TRUE and default) or only rows corresponding to the
type argument</p>
</dd>
</dl>
<p>Rules for matching rows of data to tree nodes are determined
jointly by the <code>match.data</code> and <code>rownamesAsLabels</code>
arguments. If <code>match.data</code> is TRUE, data frame rows will be
matched exclusively against tip and node labels if
<code>rownamesAsLabels</code> is also TRUE, whereas any all-digit row
names will be matched against tip and node numbers if
<code>rownamesAsLabels</code> is FALSE (the default). If
<code>match.data</code> is FALSE, <code>rownamesAsLabels</code> has no effect,
and row matching is purely positional with respect to the order
returned by <code>nodeId(phy, type)</code>.
</p>


<h3>Value</h3>

<p>An object of class phylo4d.
</p>


<h3>Methods</h3>

 <dl>
<dt>x = "phylo4"</dt>
<dd>
<p>merges a tree of
class <code>phylo4</code> with a data.frame into a <code>phylo4d</code>
object</p>
</dd> <dt>x = "matrix"</dt>
<dd>
<p>merges a matrix of tree edges similar
to the edge slot of a <code>phylo4</code> object (or to <code>$edge</code> of a
<code>phylo</code> object) with a data.frame into a <code>phylo4d</code>
object</p>
</dd> <dt>x = "phylo"</dt>
<dd>
<p>merges a tree of class <code>phylo</code>
with a data.frame into a <code>phylo4d</code> object </p>
</dd> </dl>
<h3>Note</h3>

<p>Checking on matches between the tree and the data will be
done by the validity checker (label matches between data and tree
tips, number of rows of data vs. number of nodes/tips/etc.)
</p>


<h3>Author(s)</h3>

<p>Ben Bolker, Thibaut Jombart, Steve Kembel, Francois
Michonneau, Jim Regetz
</p>


<h3>See Also</h3>

<p><code>coerce-methods</code> for translation
functions. The phylo4d class; phylo4
class and phylo4 constructor.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
treeOwls &lt;- "((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3);"
tree.owls.bis &lt;- ape::read.tree(text=treeOwls)
try(phylo4d(as(tree.owls.bis,"phylo4"),data.frame(wing=1:3)), silent=TRUE)
obj &lt;- phylo4d(as(tree.owls.bis,"phylo4"),data.frame(wing=1:3), match.data=FALSE)
obj
print(obj)

####

data(geospiza_raw)
geoTree &lt;- geospiza_raw$tree
geoData &lt;- geospiza_raw$data

## fix differences in tip names between the tree and the data
geoData &lt;- rbind(geoData, array(, dim = c(1,ncol(geoData)),
                  dimnames = list("olivacea", colnames(geoData))))

### Example using a tree of class 'phylo'
exGeo1 &lt;- phylo4d(geoTree, tip.data = geoData)

### Example using a tree of class 'phylo4'
geoTree &lt;- as(geoTree, "phylo4")

## some random node data
rNodeData &lt;- data.frame(randomTrait = rnorm(nNodes(geoTree)),
                        row.names = nodeId(geoTree, "internal"))

exGeo2 &lt;- phylo4d(geoTree, tip.data = geoData, node.data = rNodeData)

### Example using 'merge.data'
data(geospiza)
trGeo &lt;- extractTree(geospiza)
tDt &lt;- data.frame(a=rnorm(nTips(trGeo)), row.names=nodeId(trGeo, "tip"))
nDt &lt;- data.frame(a=rnorm(nNodes(trGeo)), row.names=nodeId(trGeo, "internal"))

(matchData1 &lt;- phylo4d(trGeo, tip.data=tDt, node.data=nDt, merge.data=FALSE))
(matchData2 &lt;- phylo4d(trGeo, tip.data=tDt, node.data=nDt, merge.data=TRUE))

## Example with 'all.data'
nodeLabels(geoTree) &lt;- as.character(nodeId(geoTree, "internal"))
rAllData &lt;- data.frame(randomTrait = rnorm(nTips(geoTree) + nNodes(geoTree)),
row.names = labels(geoTree, 'all'))

exGeo5 &lt;- phylo4d(geoTree, all.data = rAllData)

## Examples using 'rownamesAsLabels' and comparing with match.data=FALSE
tDt &lt;- data.frame(x=letters[1:nTips(trGeo)],
                  row.names=sample(nodeId(trGeo, "tip")))
tipLabels(trGeo) &lt;- as.character(sample(1:nTips(trGeo)))
(exGeo6 &lt;- phylo4d(trGeo, tip.data=tDt, rownamesAsLabels=TRUE))
(exGeo7 &lt;- phylo4d(trGeo, tip.data=tDt, rownamesAsLabels=FALSE))
(exGeo8 &lt;- phylo4d(trGeo, tip.data=tDt, match.data=FALSE))

## generate a tree and some data
set.seed(1)
p3 &lt;- ape::rcoal(5)
dat &lt;- data.frame(a = rnorm(5), b = rnorm(5), row.names = p3$tip.label)
dat.defaultnames &lt;- dat
row.names(dat.defaultnames) &lt;- NULL
dat.superset &lt;- rbind(dat, rnorm(2))
dat.subset &lt;- dat[-1, ]

## create a phylo4 object from a phylo object
p4 &lt;- as(p3, "phylo4")

## create phylo4d objects with tip data
p4d &lt;- phylo4d(p4, dat)
###checkData(p4d)
p4d.sorted &lt;- phylo4d(p4, dat[5:1, ])
try(p4d.nonames &lt;- phylo4d(p4, dat.defaultnames))
p4d.nonames &lt;- phylo4d(p4, dat.defaultnames, match.data=FALSE)

## Not run: 
p4d.subset &lt;- phylo4d(p4, dat.subset)
p4d.subset &lt;- phylo4d(p4, dat.subset)
try(p4d.superset &lt;- phylo4d(p4, dat.superset))
p4d.superset &lt;- phylo4d(p4, dat.superset)

## End(Not run)

## create phylo4d objects with node data
nod.dat &lt;- data.frame(a = rnorm(4), b = rnorm(4))
p4d.nod &lt;- phylo4d(p4, node.data = nod.dat, match.data=FALSE)


## create phylo4 objects with node and tip data
p4d.all1 &lt;- phylo4d(p4, node.data = nod.dat, tip.data = dat, match.data=FALSE)
nodeLabels(p4) &lt;- as.character(nodeId(p4, "internal"))
p4d.all2 &lt;- phylo4d(p4, all.data = rbind(dat, nod.dat), match.data=FALSE)
</code></pre>


</div>
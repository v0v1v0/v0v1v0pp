<div class="container">

<table style="width: 100%;"><tr>
<td>partDSA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>partDSA</h2>

<h3>Description</h3>

<p><em>partDSA</em> is a novel tool for generating a piecewise constant
estimation sieve of candidate estimators based on an intensive and
comprehensive search over the entire covariate space. The strength of
this algorithm is that it builds <em>'and'</em> and <em>'or'</em>
statements. This allows combinations and substitutions of regions for
the purpose of discovering intricate correlations patterns and
interactions in addition to main effects. Depending on the application,
this approach will supersede methods such as CART by being not only
more aggressive but also more flexible. As such, <em>partDSA</em> provides
the user an additional tool for their statistical toolbox.
</p>


<h3>Usage</h3>

<pre><code class="language-R">	
partDSA(x, y, wt=rep(1, nrow(x)), x.test=x, y.test=y, wt.test,
        control=DSA.control(), sleigh)
DSA.control(vfold=10, minsplit = 20, minbuck=round(minsplit/3), 
                        cut.off.growth=10, MPD=0.1, missing="impute.at.split", 
                        loss.function="default", wt.method="KM", brier.vec=NULL,
                        leafy=0, leafy.random.num.variables.per.split=4,
                        leafy.num.trees=50, leafy.subsample=0, save.input=FALSE, 
                        boost=0, boost.rounds=100, cox.vec=NULL,IBS.wt=NULL, partial=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The matrix or data frame of predictor variables for the training set,
used to build the model.
Each row corresponds to an observation, and each column corresponds to
a variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The outcome (response) vector, either continuous or categorical,
representing the true response values for observations in <code>x</code>.
The length of this vector should equal the number of rows in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt</code></td>
<td>
<p>Optional vector  of training weights with length equal to the
number of observations in <code>x</code>.
Default is a vector of ones with length equal to the number of training
set observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.test</code></td>
<td>
<p>The matrix or data frame of predictor variables used to
build the model.
The number of columns (variables) of <code>x.test</code> should equal the number
of columns as <code>x</code>.
The default is <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.test</code></td>
<td>
<p>The outcome (response) vector, either continuous or categorical,
representing the true response values for observations in <code>x.test</code>.
The length of this vector should equal the number of rows in <code>x.test</code>.
The default value is <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt.test</code></td>
<td>
<p>Optional vector of test weights with length equal to the
number of test set observations.
Default value is <code>wt</code> if <code>x.test</code> wasn't specified, otherwise
it is a vector of ones with length  equal to the number of test
set observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list object used to specify additional control parameters.
This is normally created by calling the <code>DSA.control</code> function.
Default value is the result of calling <code>DSA.control</code> with no arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sleigh</code></td>
<td>
<p>Optional <code>sleigh</code> object to allow the cross-validation
to be performed in parallel using the <code>nws</code> package.
If not specified, the cross-validation will be executed sequentially.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vfold</code></td>
<td>
<p>The number of folds of cross-validation for the model
building process.
The default value is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minsplit</code></td>
<td>
<p>The minimum number of observations in order to split a partition into two paritions. 
The default value is 20.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minbuck</code></td>
<td>
<p>The minimum number of observations in any terminal partition.
The default value is round(minsplit/3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cut.off.growth</code></td>
<td>
<p>The maximum number of terminal partitions to be
considered when building the model.
The default value is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MPD</code></td>
<td>
<p>Minimum Percent Difference.
The model fit must improve by this percentage in order to be considered.
This saves time in the model building process.
The default value is 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing</code></td>
<td>
<p>Character string specifying how missing data should be
handled.  The default value is "no." See the details section from more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss.function</code></td>
<td>
<p>The function to be minimized when building the model.
For categorical outcomes, "entropy" (default) or "gini" can be specified.
For continuous outcomes, the L2 loss function is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt.method</code></td>
<td>
<p>Not documented yet.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>brier.vec</code></td>
<td>
<p>Not documented yet.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cox.vec</code></td>
<td>
<p>Not documented yet.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IBS.wt</code></td>
<td>
<p>Not documented yet.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leafy</code></td>
<td>
<p>Set to 1 to run Bagged partDSA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leafy.random.num.variables.per.split</code></td>
<td>
<p>Number of variables to use
if utilizing random variable selection in Bagged partDSA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leafy.num.trees</code></td>
<td>
<p>Numbed in trees in Bagged partDSA.  Default is 50.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leafy.subsample</code></td>
<td>
<p>Numeric value between 0 and 1.  The value 0 is
used for bootstrap sampling (sampling witht replacement).  If the
value is greater than 0, it corresponds to the proportion of samples
used to build the model, such as 0.632.  The default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.input</code></td>
<td>
<p>Indicates if <code>x</code> and <code>y</code> should be saved
in the object returned by partDSA.  If <code>FALSE</code>, <code>x</code> and <code>y</code>
are set to <code>NULL</code>.  The default value is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boost</code></td>
<td>
<p>Set to 1 to run Boosted partDSA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boost.rounds</code></td>
<td>
<p>Maximum number of rounds of boosting.  Default is
100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partial</code></td>
<td>
<p>If set to "deciles," step partial importance is computed
on deciles of data rather than actual data.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>missing</code> set to "no" indicates that there is no missing data and
will create an error if missing data is found in the dataset. Setting missing="impute.at.split" will use a data
imputation method similar to that in CRUISE (Kim and Loh, 2001). At each
split, the non-missing observations for a given variable will be used
to find the best split, and the missing observations will be imputed
based on the mean or mode (depending on whether the variable is
categorical or continuous) of the non-missing observations in that node.
Once the node assignment of these missing observations is determined
using the imputed values, the imputed values are returned to their
missing status. For missing values in the test set, the grand mean or
mode from the corresponding variables in the training set are used.
Including variables which are entirely missing will result in an error.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(MASS)
set.seed(6442)

n &lt;- nrow(Boston)
tr.n &lt;- floor(n / 2)
train.index &lt;- sample(1:n, tr.n, replace=FALSE)
test.index &lt;- (1:n)[-train.index]

x &lt;- Boston[train.index, -14]
y &lt;- Boston[train.index, 14]
x.test &lt;- Boston[test.index, -14]
y.test &lt;- Boston[test.index, 14]

control &lt;- DSA.control(vfold=1)  # no cross-validation
partDSA(x, y, x.test=x.test, y.test=y.test, control=control)
</code></pre>


</div>
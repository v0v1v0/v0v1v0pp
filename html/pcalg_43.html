<div class="container">

<table style="width: 100%;"><tr>
<td>GaussParDAG-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class <code>"GaussParDAG"</code> of Gaussian Causal Models</h2>

<h3>Description</h3>

<p>The <code>"GaussParDAG"</code> class represents a Gaussian causal model.
</p>


<h3>Details</h3>

<p>The class <code>"GaussParDAG"</code> is used to simulate observational
and/or interventional data from Gaussian causal models as well as for parameter
estimation (maximum-likelihood estimation) for a given DAG structure in the
presence of a data set with jointly observational and interventional data.
</p>
<p>A Gaussian causal model can be represented as a set of <code class="reqn">p</code> linear
structural equations with Gaussian noise variables.  Those equations are
fully specified by indicating the regression parameters, the intercept
and the variance of the noise or error terms.  More details can be found e.g.
in Kalisch and Bühlmann (2007) or Hauser and Bühlmann (2012).
</p>


<h3>Extends</h3>

<p>Class <code>"ParDAG"</code>, directly.
</p>
<p>All reference classes extend and inherit methods from
<code>"envRefClass"</code>.
</p>


<h3>Constructor</h3>

<p><code>new("GaussParDAG", nodes, in.edges, params)</code>
</p>

<dl>
<dt><code>nodes</code></dt>
<dd>
<p>Vector of node names; cf. also field <code>.nodes</code>.</p>
</dd>
<dt><code>in.edges</code></dt>
<dd>
<p>A list of length <code>p</code> consisting of index
vectors indicating the edges pointing into the nodes of the DAG.</p>
</dd>
<dt><code>params</code></dt>
<dd>
<p>A list of length <code>p</code> consisting of parameter
vectors modeling the conditional distribution of a node given its
parents; cf. also field <code>.params</code> for the meaning of the
parameters.</p>
</dd>
</dl>
<h3>Fields</h3>


<dl>
<dt>
<code>.nodes</code>:</dt>
<dd>
<p>Vector of node names; defaults to <code>as.character(1:p)</code>,
where <code>p</code> denotes the number of nodes (variables) of the model.</p>
</dd>
<dt>
<code>.in.edges</code>:</dt>
<dd>
<p>A list of length <code>p</code> consisting of index
vectors indicating the edges pointing into the nodes of the DAG.  The
<code class="reqn">i</code>-th entry lists the indices of the parents of the <code class="reqn">i</code>-th node.</p>
</dd>
<dt>
<code>.params</code>:</dt>
<dd>
<p>A list of length <code>p</code> consisting of parameter
vectors modeling the conditional distribution of a node given its
parents.  The <code class="reqn">i</code>-th entry models the conditional (normal)
distribution of the <code class="reqn">i</code>-th variable in the model given its parents.
It is a vector of length <code class="reqn">k + 2</code>, where <code class="reqn">k</code> is the number of
parents of node <code class="reqn">i</code>; the first entry encodes the error variance of
node <code class="reqn">i</code>, the second entry the intercept, and the remaining entries
the regression coefficients (see above).  In most cases, it is easier
to access the parameters via the wrapper functions <code>err.var</code>,
<code>intercept</code> and <code>weight.mat</code>.</p>
</dd>
</dl>
<h3>Class-Based Methods</h3>


<dl>
<dt>
<code>set.err.var(value)</code>:</dt>
<dd>
<p>Sets the error variances.  The argument
must be a vector of length <code class="reqn">p</code>, where <code class="reqn">p</code> denotes the number
of nodes in the model.</p>
</dd>
<dt>
<code>err.var()</code>:</dt>
<dd>
<p>Yields the vector of error variances.</p>
</dd>
<dt>
<code>intercept()</code>:</dt>
<dd>
<p>Yields the vector of intercepts.</p>
</dd>
<dt>
<code>set.intercept(value)</code>:</dt>
<dd>
<p>Sets the intercepts.  The argument
must be a vector of length <code class="reqn">p</code>, where <code class="reqn">p</code> denotes the number
of nodes in the model.</p>
</dd>
<dt>
<code>weight.mat(target)</code>:</dt>
<dd>
<p>Yields the (observational or
interventional) weight matrix of the model. The weight matrix is an
<code class="reqn">p \times p</code> matrix whose <code class="reqn">i</code>-th columns contains the
regression coefficients of the <code class="reqn">i</code>-th structural equation, if node
<code class="reqn">i</code> is not intervened (i.e., if <code>i</code> is not contained in the
vector <code>target</code>), and is empty otherwise.</p>
</dd>
<dt>
<code>cov.mat(target, ivent.var)</code>:</dt>
<dd>
<p>Yields the covariance matrix
of the observational or an interventional distribution of the causal
model.  If <code>target</code> has length 0, the covariance matrix of the
observational distribution is returned; otherwise <code>target</code> is a
vector of the intervened nodes, and <code>ivent.var</code> is a vector of the
same length indicating the variances of the intervention levels.
Deterministic interventions with fix intervention levels would correspond
to vanishing intervention variances; with non-zero intervention variances,
stochastic interventions are considered in which intervention values are
realizations of Gaussian variables (Korb et al., 2004).</p>
</dd>
</dl>
<p>The following methods are inherited (from the corresponding class):
<code>node.count</code> ("ParDAG"), <code>edge.count</code> ("ParDAG"), <code>simulate</code> ("ParDAG")
</p>


<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>References</h3>

<p>A. Hauser and P. Bühlmann (2012).  Characterization and greedy learning of
interventional Markov equivalence classes of directed acyclic graphs.
<em>Journal of Machine Learning Research</em> <b>13</b>, 2409–2464.
</p>
<p>M. Kalisch and P. Buehlmann (2007).  Estimating high-dimensional directed
acyclic graphs with the PC-algorithm. <em>Journal of Machine Learning
Research</em> <b>8</b>, 613–636.
</p>
<p>K.B. Korb, L.R. Hope, A.E. Nicholson, and K. Axnick (2004).  Varieties of
causal intervention.  <em>Proc. of the Pacific Rim International Conference
on Artificial Intelligence (PRICAI 2004)</em>, 322–331
</p>


<h3>See Also</h3>

<p><code>ParDAG</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(307)
myDAG &lt;- r.gauss.pardag(p = 5, prob = 0.4)
(wm &lt;- myDAG$weight.mat())
m &lt;- as(myDAG, "matrix") # TRUE/FALSE adjacency matrix
symnum(m)
stopifnot(identical(unname( m ),
                    unname(wm != 0)))
myDAG$err.var()
myDAG$intercept()
myDAG$set.intercept(runif(5, min=3, max=4))
myDAG$intercept()
if (require(Rgraphviz)) plot(myDAG)
</code></pre>


</div>
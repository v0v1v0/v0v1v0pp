<div class="container">

<table style="width: 100%;"><tr>
<td>ekm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
K-Means Clustering Using Different Seeding Techniques
</h2>

<h3>Description</h3>

<p>The function <code>ekm</code> partitions a numeric data set by using the K-means clustering algorithm. It is a wrapper function of the standard <code>kmeans</code> function with more initialization (seeding) techniques and output values obtained in the multiple starts of the algorithm. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">ekm(x, centers, dmetric="euclidean", alginitv="hartiganwong",  
    nstart=1, iter.max=1000, stand=FALSE, numseed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector, data frame or matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centers</code></td>
<td>
<p>an integer specifying the number of clusters or a numeric matrix containing the initial cluster centers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dmetric</code></td>
<td>
<p>a string for the distance calculation method. The default is <span class="option">euclidean</span> for the Euclidean distances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alginitv</code></td>
<td>
<p>a string for the initialization of cluster prototypes matrix. The default is <span class="option">hartiganwong</span> for Hartigan-Wong seeding method. See <code>get.algorithms</code> for the alternative options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart</code></td>
<td>
<p>an integer for the number of starts for clustering. The default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max</code></td>
<td>
<p>an integer for the maximum number of iterations allowed. The default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stand</code></td>
<td>
<p>a logical flag to standardize data. Its default value is <code>FALSE</code>. If its value is <code>TRUE</code>, the data matrix <code>x</code> is standardized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numseed</code></td>
<td>
<p>a seeding number to set the seed of R's random number generator.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>K-Means (KM) clustering algorithm partitions a data set of <code class="reqn">n</code> objects into <code class="reqn">k</code>, a pre-defined number of clusters. It is an iterative relocation algorithm, and in each iteration step the objects are assigned to the nearest cluster by using the Euclidean distances. The objective of KM is to minimize total intra-cluster variance (or the sum of squared errors):
</p>
<p><code class="reqn">J_{KM}(\mathbf{X}; \mathbf{V})=\sum\limits_{i=1}^n d^2(\vec{x}_i, \vec{v}_j)</code>
</p>
<p>In the above equation for <code class="reqn">J_{KM}</code>:
</p>
<p><code class="reqn">d^2(\vec{x}_i, \vec{v}_j)</code> is the distance measure between the object <code class="reqn">\vec{x}_j</code> and cluster prototype <code class="reqn">\vec{v}_i</code>.The Euclidean distance metric is usually employed with the implementations of K-means.
</p>
<p>See <code>kmeans</code> and <code>ppclust-package</code> for more details about the terms of the objective function <code class="reqn">J_{KM}</code>.
</p>
<p>The update equation of the cluster prototypes:
</p>
<p><code class="reqn">\vec{v}_{j} =\frac{1}{n_j} \sum\limits_{i=1}^{n_j} x_{ij} \;;\; 1 \leq j \leq k</code>
</p>


<h3>Value</h3>

<p>an object of class ‘ppclust’, which is a list consists of the following items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric matrix containing the processed data set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>a numeric matrix containing the final cluster prototypes (centers of clusters).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>a numeric matrix containing the crisp membership degrees of the data objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>a numeric matrix containing the distances of objects to the final cluster prototypes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>an integer for the number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>a numeric vector containing the cluster labels found by defuzzying the fuzzy membership degrees of the objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>csize</code></td>
<td>
<p>a numeric vector containing the number of objects in the clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>an integer vector for the number of iterations in each start of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.start</code></td>
<td>
<p>an integer for the index of start with the minimum objective functional.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func.val</code></td>
<td>
<p>a numeric vector for the objective function values in each start of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comp.time</code></td>
<td>
<p>a numeric vector for the execution time in each start of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stand</code></td>
<td>
<p>a logical value, <code>TRUE</code> shows that <code>x</code> data set contains the standardized values of raw data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wss</code></td>
<td>
<p>a number for the within-cluster sum of squares for each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bwss</code></td>
<td>
<p>a number for the between-cluster sum of squares.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tss</code></td>
<td>
<p>a number for the total within-cluster sum of squares.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>twss</code></td>
<td>
<p>a number for the total sum of squares.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>a string for the name of partitioning algorithm. It is ‘KM’ with this function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>a string for the matched function call generating this ‘ppclust’ object.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Zeynel Cebeci, Figen Yildiz &amp; Hasan Onder
</p>


<h3>References</h3>

<p>MacQueen, J.B. (1967). Some methods for classification and analysis of multivariate observations. 
In <em>Proc. of 5th Berkeley Symp. on Mathematical Statistics and Probability</em>, Berkeley, University of California Press, 1: 281-297. &lt;<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.308.8619&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.308.8619&amp;rep=rep1&amp;type=pdf</a>&gt;
</p>


<h3>See Also</h3>

<p><code>kmeans</code>,
<code>fcm</code>,
<code>fcm2</code>,
<code>fpcm</code>,
<code>fpppcm</code>,
<code>gg</code>,
<code>gk</code>,
<code>gkpfcm</code>,
<code>hcm</code>,
<code>pca</code>,
<code>pcm</code>,
<code>pcmr</code>,
<code>pfcm</code>,
<code>upfc</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load dataset iris 
data(iris)
x &lt;- iris[,-5]

# Run EKM for 3 clusters
res.ekm &lt;- ekm(x, centers=3)

# Print and plot the clustering result
print(res.ekm$cluster)
plot(x, col=res.ekm$cluster, pch=16)
</code></pre>


</div>
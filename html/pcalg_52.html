<div class="container">

<table style="width: 100%;"><tr>
<td>getNextSet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Iteration through a list of all combinations of choose(n,k)</h2>

<h3>Description</h3>

<p>Given a combination of <code class="reqn">k</code> elements out of the elements
<code class="reqn">1,\dots,n</code>, the next 
set of size <code>k</code> in a specified sequence is computed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getNextSet(n,k,set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of elements to choose from (integer)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Size of chosen set (integer)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set</code></td>
<td>
<p>Previous set in list (numeric vector)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The initial set is <code>1:k</code>.  Last index varies quickest.  Using the
dynamic creation of sets reduces the memory demands dramatically for
large sets.  If complete lists of combination sets have to be produced
and memory is no problem, the function <code>combn</code>
from package <span class="pkg">combinat</span> is an alternative.
</p>


<h3>Value</h3>

<p>List with two elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>nextSet</code></td>
<td>
<p>Next set in list (numeric vector)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wasLast</code></td>
<td>
<p>Logical indicating whether the end of the specified sequence is reached.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Markus Kalisch <a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a> and Martin Maechler
</p>


<h3>See Also</h3>

<p>This function is used in <code>skeleton</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">## start from first set (1,2) and get the next set of size 2 out of 1:5
## notice that res$wasLast is FALSE :
str(r &lt;- getNextSet(5,2,c(1,2)))

## input is the last set; notice that res$wasLast now is TRUE:
str(r2 &lt;- getNextSet(5,2,c(4,5)))

## Show all sets of size k out of 1:n :
## {if you really want this in practice, use something like combn() !}
n &lt;- 5
k &lt;- 3
currentSet &lt;- 1:k
(res &lt;- rbind(currentSet, deparse.level = 0))
repeat {
  newEl &lt;- getNextSet(n,k,currentSet)
  if (newEl$wasLast)
     break
  ## otherwise continue:
  currentSet &lt;- newEl$nextSet
  res &lt;- rbind(res, currentSet, deparse.level = 0)
}
res
stopifnot(choose(n,k) == nrow(res)) ## must be identical
</code></pre>


</div>
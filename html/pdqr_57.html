<div class="container">

<table style="width: 100%;"><tr>
<td>region</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Work with regions</h2>

<h3>Description</h3>

<p>These functions provide ways of working with a <strong>region</strong>: a data frame with
numeric "left" and "right" columns, each row of which represents a unique
finite interval (open, either type of half-open, or closed). Values of "left"
and "right" columns should create an "ordered" set of intervals:
<code style="white-space: pre;">⁠left[1] &lt;= right[1] &lt;= left[2] &lt;= right[2] &lt;= ...⁠</code> (intervals with zero
width are accepted). Originally, <code style="white-space: pre;">⁠region_*()⁠</code> functions were designed to work
with output of <code>summ_hdr()</code> and <code>summ_interval()</code>, but can be used for any
data frame which satisfies the definition of a region.
</p>


<h3>Usage</h3>

<pre><code class="language-R">region_is_in(region, x, left_closed = TRUE, right_closed = TRUE)

region_prob(region, f, left_closed = TRUE, right_closed = TRUE)

region_height(region, f, left_closed = TRUE, right_closed = TRUE)

region_width(region)

region_distance(region, region2, method = "Jaccard")

region_draw(region, col = "blue", alpha = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>region</code></td>
<td>
<p>A data frame representing region.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric vector to be tested for being inside region.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>left_closed</code></td>
<td>
<p>A single logical value representing whether to treat left
ends of intervals as their parts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>right_closed</code></td>
<td>
<p>A single logical value representing whether to treat
right ends of intervals as their parts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A pdqr-function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>region2</code></td>
<td>
<p>A data frame representing region.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method for computing distance between regions in
<code>region_distance()</code>. Should be one of "Jaccard" or methods of
<code>summ_distance()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>Single color of rectangles to be used. Should be appropriate for
<code>col</code> argument of col2rgb().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Single number representing factor modifying the opacity alpha;
typically in [0; 1].</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>region_is_in()</code> tests each value of <code>x</code> for being inside interval.
In other words, if there is a row for which element of <code>x</code> is between "left"
and "right" value (respecting <code>left_closed</code> and <code>right_closed</code> options),
output for that element will be <code>TRUE</code>. <strong>Note</strong> that for zero-width
intervals one of <code>left_closed</code> or <code>right_closed</code> being <code>TRUE</code> is enough to
accept that point as "in region".
</p>
<p><code>region_prob()</code> computes total probability of region according to
pdqr-function <code>f</code>. If <code>f</code> has "discrete" type, output is
computed as sum of probabilities for all "x" values from "x_tbl" metadata which lie inside a region (respecting <code>left_closed</code>
and <code>right_closed</code> options while using <code>region_is_in()</code>). If <code>f</code> has
"continuous" type, output is computed as integral of density over a region
(<code style="white-space: pre;">⁠*_closed⁠</code> options having any effect).
</p>
<p><code>region_height()</code> computes "height" of a region (with respect to <code>f</code>):
minimum value of corresponding to <code>f</code> d-function can return based on relevant
points inside a region. If <code>f</code> has "discrete" type, those relevant points are
computed as "x" values from "x_tbl" metadata which lie inside a region (if
there are no such points, output is 0). If <code>f</code> has "continuous" type, the
whole intervals are used as relevant points. The notion of "height" comes
from <code>summ_hdr()</code> function: if <code>region</code> is <code>summ_hdr(f, level)</code> for some
<code>level</code>, then <code>region_height(region, f)</code> is what is called in <code>summ_hdr()</code>'s
docs as "target height" of HDR. That is, a maximum value of d-function for
which a set consisting from points at which d-function has values not less
than target height and total probability of the set being not less than
<code>level</code>.
</p>
<p><code>region_width()</code> computes total width of a region, i.e. sum of differences
between "right" and "left" columns.
</p>
<p><code>region_distance()</code> computes distance between a pair of regions. As in
<code>summ_distance()</code>, it is a single non-negative number representing how much
two regions differ from one another (bigger values indicate bigger
difference). Argument <code>method</code> represents method of computing distance.
Method "Jaccard" computes Jaccard distance: one minus ratio of intersection
width and union width. Other methods come from <code>summ_distance()</code> and
represent distance between regions as probability distributions:
</p>

<ul>
<li>
<p> If total width of region is zero (i.e. it consists only from points),
distribution is a uniform discrete one based on points from region.
</p>
</li>
<li>
<p> If total width is positive, then distribution is a uniform continuous one
based on intervals with positive width.
</p>
</li>
</ul>
<p><code>region_draw()</code> draws (on current plot) intervals stored in <code>region</code> as
colored rectangles vertically starting from zero and ending in the top of the
plot (technically, at "y" value of <code>2e8</code>).
</p>


<h3>Value</h3>

<p><code>region_is_in()</code> returns a logical vector (with length equal to
length of <code>x</code>) representing whether certain element of <code>x</code> is inside a
region.
</p>
<p><code>region_prob()</code> returns a single number between 0 and 1 representing total
probability of region.
</p>
<p><code>region_height()</code> returns a single number representing a height of a region
with respect to <code>f</code>, i.e. minimum value that corresponding d-function can
return based on relevant points inside a region.
</p>
<p><code>region_width()</code> returns a single number representing total width of a
region.
</p>
<p><code>region_draw()</code> draws colored rectangles filling <code>region</code> intervals.
</p>


<h3>See Also</h3>

<p><code>summ_hdr()</code> for computing of Highest Density Region.
</p>
<p><code>summ_interval()</code> for computing of single interval summary of distribution.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Type "discrete"
d_binom &lt;- as_d(dbinom, size = 10, prob = 0.7)
hdr_dis &lt;- summ_hdr(d_binom, level = 0.6)
region_is_in(hdr_dis, 0:10)
## This should be not less than 0.6
region_prob(hdr_dis, d_binom)
region_height(hdr_dis, d_binom)
region_width(hdr_dis)

# Type "continuous"
d_norm &lt;- as_d(dnorm)
hdr_con &lt;- summ_hdr(d_norm, level = 0.95)
region_is_in(hdr_con, c(-Inf, -2, 0, 2, Inf))
## This should be approximately equal to 0.95
region_prob(hdr_con, d_norm)
## This should be equal to `d_norm(hdr_con[["left"]][1])`
region_height(hdr_con, d_norm)
region_width(hdr_con)

# Usage of `*_closed` options
region &lt;- data.frame(left = 1, right = 3)
## Closed intervals
region_is_in(region, 1:3)
## Open from left, closed from right
region_is_in(region, 1:3, left_closed = FALSE)
## Closed from left, open from right
region_is_in(region, 1:3, right_closed = FALSE)
## Open intervals
region_is_in(region, 1:3, left_closed = FALSE, right_closed = FALSE)

# Handling of intervals with zero width
region &lt;- data.frame(left = 1, right = 1)
## If at least one of `*_closed` options is `TRUE`, 1 will be considered as
## "in a region"
region_is_in(region, 1)
region_is_in(region, 1, left_closed = FALSE)
region_is_in(region, 1, right_closed = FALSE)
## Only this will return `FALSE`
region_is_in(region, 1, left_closed = FALSE, right_closed = FALSE)

# Distance between regions
region1 &lt;- data.frame(left = c(0, 2), right = c(1, 2))
region2 &lt;- data.frame(left = 0.5, right = 1.5)
region_distance(region1, region2, method = "Jaccard")
region_distance(region1, region2, method = "KS")

# Drawing
d_mix &lt;- form_mix(list(as_d(dnorm), as_d(dnorm, mean = 5)))
plot(d_mix)
region_draw(summ_hdr(d_mix, 0.95))
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>JKpp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run a jackknife</h2>

<h3>Description</h3>

<p>This function uses a jackknife approach to compute person parameters. The jackknife ability measure is based on primarily estimated models (<code>PP_4pl()</code>, <code>PP_gpcm()</code> or <code>PPall()</code>) - so the function is applied on the estimation objects, and jackknifed ability measures are returned.
</p>


<h3>Usage</h3>

<pre><code class="language-R">JKpp(estobj, ...)

## S3 method for class 'fourpl'
JKpp(
  estobj,
  cmeth = "mean",
  maxsteps = 500,
  exac = 0.001,
  fullmat = FALSE,
  ctrl = list(),
  ...
)

## S3 method for class 'gpcm'
JKpp(
  estobj,
  cmeth = "mean",
  maxsteps = 500,
  exac = 0.001,
  fullmat = FALSE,
  ctrl = list(),
  ...
)

## S3 method for class 'gpcm4pl'
JKpp(
  estobj,
  cmeth = "mean",
  maxsteps = 500,
  exac = 0.001,
  fullmat = FALSE,
  ctrl = list(),
  ...
)

## S3 method for class 'jk'
print(x, ...)

## S3 method for class 'jk'
summary(object, nrowmax = 15, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>estobj</code></td>
<td>
<p>An object which originates from using <code>PP_gpcm()</code>, <code>PP_4pl()</code> or <code>PPall()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>More input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cmeth</code></td>
<td>
<p>Choose the centering method, to summarize the n jackknife results to one single ability estimate. There are three valid entries: "mean", "median" and "AMT" (see Details for further description).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxsteps</code></td>
<td>
<p>The maximum number of steps the NR Algorithm will take.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exac</code></td>
<td>
<p>How accurate are the estimates supposed to be? Default is 0.001.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fullmat</code></td>
<td>
<p>Default = FALSE. If TRUE, the function returns the whole jackknife matrix, which is the basis for the jackknife estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctrl</code></td>
<td>
<p>More controls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>jk</code> which is the result of using the <code>JKpp()</code> function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>jk</code> which is the result of using the <code>JKpp()</code> function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrowmax</code></td>
<td>
<p>When printing the matrix of estimates - how many rows should be shown? Default = 15.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Please use the Jackknife <b>Standard-Error</b> output with <b>caution</b>! It is implemented as suggested in Wainer and Wright (1980), but the results seem a bit strange, because the JK-SE is supposed to overestimate the SE compared to the MLE-SE. Actually, in all examples an underestimation of the SE was observed compared to the MLE/WLE-SE! 
</p>
<p><b>AMT-robustified jackknife:</b> When choosing <code>cmeth = AMT</code>, the jackknife ability subsample estimates and the original supplied ability estimate are combined to a single jackknife-ability value by the Sine M-estimator. The AMT (or Sine M-estimator) is one of the winners in the Princeton Robustness Study of 1972. To get a better idea how the estimation process works, take a closer look to the paper which is mentioned below (Wainer &amp; Wright, 1980).
</p>


<h3>Author(s)</h3>

<p>Manuel Reif
</p>


<h3>References</h3>

<p>Wainer, H., &amp; Wright, B. D. (1980). Robust estimation of ability in the Rasch model. Psychometrika, 45(3), 373-391.
</p>


<h3>See Also</h3>

<p>PP_gpcm, PP_4pl, PPall
</p>


<h3>Examples</h3>

<pre><code class="language-R">################# Jackknife ###################################################

### 4 PL model ######

### data creation ##########

set.seed(1623)
# intercepts
diffpar &lt;- seq(-3,3,length=12)
# slope parameters
sl     &lt;- round(runif(12,0.5,1.5),2)
la     &lt;- round(runif(12,0,0.25),2)
ua     &lt;- round(runif(12,0.8,1),2)

# response matrix
abpar &lt;- rnorm(10,0,1.7)
awm &lt;- sim_4pl(beta = diffpar,alpha = sl,lowerA = la,upperA=ua,theta = abpar)

## 1PL model ##### 

# MLE
res1plmle &lt;- PP_4pl(respm = awm,thres = diffpar,type = "mle")
# WLE
res1plwle &lt;- PP_4pl(respm = awm,thres = diffpar,type = "wle")
# MAP estimation
res1plmap &lt;- PP_4pl(respm = awm,thres = diffpar,type = "map")
# EAP estimation
res1pleap &lt;- PP_4pl(respm = awm,thres = diffpar,type = "eap")
# robust estimation
res1plrob &lt;- PP_4pl(respm = awm,thres = diffpar,type = "robust")

## centering method = mean
res_jk1 &lt;- JKpp(res1plmle)
res_jk2 &lt;- JKpp(res1plwle)
res_jk3 &lt;- JKpp(res1plmap)
res_jk4 &lt;- JKpp(res1plrob)
res_jk5 &lt;- JKpp(res1pleap)

summary(res_jk1)

## centering method = median
res_jk1a &lt;- JKpp(res1plmle,cmeth = "median")
res_jk2a &lt;- JKpp(res1plwle,cmeth = "median")
res_jk3a &lt;- JKpp(res1plmap,cmeth = "median")

summary(res_jk2a)

## centering method = AMT
res_jk1b &lt;- JKpp(res1plmle,cmeth = "AMT")
res_jk2b &lt;- JKpp(res1plwle,cmeth = "AMT")
res_jk3b &lt;- JKpp(res1plmap,cmeth = "AMT")

summary(res_jk3b)


## 2PL model ##### 

# MLE
res2plmle &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "mle")
# WLE
res2plwle &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "wle")
# MAP estimation
res2plmap &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "map")
# EAP estimation
res2pleap &lt;- PP_4pl(respm = awm,thres = diffpar,slopes = sl,type = "eap")
# robust estimation
res2plrob &lt;- PP_4pl(respm = awm,thres = diffpar,slopes = sl,type = "robust")

res_jk6 &lt;- JKpp(res2plmle)
res_jk7 &lt;- JKpp(res2plwle)
res_jk8 &lt;- JKpp(res2plmap)
res_jk9 &lt;- JKpp(res2pleap)
res_jk10 &lt;- JKpp(res2plrob)

### GPCM model ######

# some threshold parameters
THRES  &lt;- matrix(c(-2,-1.23,1.11,3.48,1
                   ,2,-1,-0.2,0.5,1.3,-0.8,1.5),nrow=2)
# slopes
sl     &lt;- c(0.5,1,1.5,1.1,1,0.98)
awmatrix &lt;- matrix(c(1,0,2,0,1,1,1,0,0,1,2,0,0,0,0,0,0,0,0,1,
                     1,2,2,1,1,1,1,0,0,1),byrow=TRUE,nrow=5)


### PCM model ######

# MLE
respcmlmle &lt;- PP_gpcm(respm = awmatrix,thres = THRES,
                      slopes = rep(1,ncol(THRES)),type = "mle")
# WLE
respcmwle &lt;- PP_gpcm(respm = awmatrix,thres = THRES,
                     slopes = rep(1,ncol(THRES)),type = "wle")
# MAP estimation
respcmmap &lt;- PP_gpcm(respm = awmatrix,thres = THRES,
                     slopes = rep(1,ncol(THRES)),type = "map")


res_jk11 &lt;- JKpp(respcmlmle)
res_jk12 &lt;- JKpp(respcmwle)
res_jk13 &lt;- JKpp(respcmmap)

### GPCM/4-PL mixed model ######

THRES  &lt;- matrix(c(-2,-1.23,1.11,3.48,1
                   ,2,-1,-0.2,0.5,1.3,-0.8,1.5),nrow=2)

sl     &lt;- c(0.5,1,1.5,1.1,1,0.98)

THRESx &lt;- THRES
THRESx[2,1:3] &lt;- NA

# for the 4PL item the estimated parameters are submitted, 
# for the GPCM items the lower asymptote = 0 
# and the upper asymptote = 1.
la     &lt;- c(0.02,0.1,0,0,0,0)
ua     &lt;- c(0.97,0.91,1,1,1,1)

awmatrix &lt;- matrix(c(1,0,1,0,1,1,1,0,0,1
                     ,2,0,0,0,1,0,0,0,0,1
                     ,0,2,2,1,1,1,1,0,0,1),byrow=TRUE,nrow=5)

# create model2est
# this function tries to help finding the appropriate 
# model by inspecting the THRESx.
model2est &lt;- findmodel(THRESx)


# MLE estimation
respmixed_mle &lt;- PPall(respm = awmatrix,
                       thres = THRESx, 
                       slopes = sl,
                       lowerA = la,
                       upperA=ua,
                       type = "mle",
                       model2est=model2est)
# WLE estimation
respmixed_wle &lt;- PPall(respm = awmatrix,
                       thres = THRESx, 
                       slopes = sl,
                       lowerA = la,
                       upperA=ua,
                       type = "wle",
                       model2est=model2est)


res_jk114 &lt;- JKpp(respmixed_mle)
res_jk115 &lt;- JKpp(respmixed_wle)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>krig</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Simple and ordinary kriging.
</h2>

<h3>Description</h3>

<p>Computes simple or ordinary kringing using a list of sampled locations.
The interpolation is executed to the table of coordinates given.
</p>


<h3>Usage</h3>

<pre><code class="language-R">krig(values, coords, grid, gv, distFUN = geo.dist, ..., m=NA, cv=FALSE,
     neg.weights = TRUE, clamp = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>

<p>A vector of values per sampled location.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>A table containing longitude and latitude of sample locations for each
value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>

<p>A table containing the coordinates of locations to interpolate
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gv</code></td>
<td>

<p>A fitted model to variogram as given by 'gv.model' function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distFUN</code></td>
<td>

<p>Distance function used to calculate distances between locations.
The default is 'geo.dist' which calculates simple euclidean
distances between the locations. This function must have a 'from'
and a 'to' arguments to specify, respectively, the source and
destination localities. Other functions can be given to include,
for instance, a landscape resistance (see examples and vignette).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Other arguments to be passed to distFUN.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>

<p>A value for the mean. When the mean is known and given, a simple kriging
is used for the interpolation. If m = NA (default) then the mean is
estimated using ordinary kriging.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv</code></td>
<td>

<p>A logical value to perform cross validation of the interpolation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neg.weights</code></td>
<td>

<p>A logical value indicating if negative weights are allowed in the
calculation. If FALSE, negative weights are corrected and eliminating the
need for clamping. See details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clamp</code></td>
<td>

<p>A logical value indicating if Z values will be adjusted to the interval
[0,1].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>A logical indicating if the function should be verbose.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function interpolates the probability of lineage occurrence to all
locations given in 'coords'. Usually 'coords' stores coordinates of
pixel centroids representing the study area with a user-defined spatial
resolution. The variogram with a fitted model describes the
autocorrelation structure of the genetic data. This is used by kriging
to determine the weight of the sampled points on the location to
predict a value.
</p>
<p>The most usual kriging is performed with geographical distances
between localities (samples and grid). The default function is the
'geo.dist' that calculate simple euclidean distances. However, the
'krig' function allows to provide user-defined distance functions to
calculate other kind of distances. A landscape resistance, for
instance, may be used to calculate cost distances between points and
to be used in the interpolation process. The same distance function
provided here has to be used before, to produce the variogram. The
function 'distFUN' has to have the arguments 'from' and 'to' to
use as source and destination coordinates, respectively. It may have
other arguments that can be passed to the function. See the vignette
for a exhaustive example on how to use this functionality.
</p>
<p>The kriging algorithm often produce negative weights for the interpolation.
This results in predictions outside the original range between zero and one.
Correcting negative weights allows to maintain predictions in this range and
to preserve kriging proprieties. Correction of negative weights is done
following Deutsch (1996): negative weights and small positive weights
(within the variation of the negative weights) are set to zero and the sum
of the resulting weights rescaled to one.
</p>
<p>Cross-validation is computed by leaving each of the observation in 'values'
out of kriging and predict for the same location. A mean squared error
(MSE) is computed using the original observation and the predicted value.
</p>


<h3>Value</h3>

<p>Returns a vector of interpolated values and respective variance for each
location in 'coords'.
</p>
<p>If cross-validation is performed (cv=TRUE) than a list of interpolation
and variance values is given with a cross-validation matrix (original
observation and predicted value) and a mean squared error (MSE).
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>References</h3>

<p>Deutsch C. V. (1996) <em>Correcting for negative weights in ordinary kriging</em>. Computers and Geosciences, 22(7), 765-773.
</p>
<p>Fortin, M. -J. and Dale, M. (2006) <em>Spatial Analysis: A guide for Ecologists</em>. Cambridge: Cambridge University Press.
</p>
<p>Isaaks, E. H. and Srivastava, R. M. (1989) <em>An Introduction to applied geostatistics</em>. New York: Oxford University Press.
</p>
<p>Legendre, P. and Legendre, L. (1998) <em>Numerical ecology</em>. 2nd english edition. Amesterdam: Elsevier
</p>


<h3>See Also</h3>

<p><code>gen.variogram</code>
<code>plot.gv</code>
<code>predict.gv</code>
<code>idw</code>
<code>intgen.idw</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(vipers)
data(d.gen)
data(grid)

# In this example we want to create the probable distribution of a
# lineage based on the genetic distance. We need a vector defining if
# each sample belongs or not to the lineage
lin &lt;- as.integer(vipers$lin == 1)

# create a distance matrix between samples
r.dist &lt;- dist(vipers[,1:2])

# fit a model with defaults (spherical model) and estimation of range
gv &lt;- gen.variogram(r.dist, d.gen)
gv &lt;- gv.model(gv)

# perform interpolation with ordinary kriging
int.krig &lt;- krig(lin, vipers[,1:2], grid, gv)

#plot the interpolation results
grid.image(int.krig, grid, main='Kriging with genetic distances',
           xlab='Longitude', ylab='Latitude',
           sclab='Lineage interpolation')
points(vipers[,1:2], pch=lin+1)

# plot the interpolation standard variance
grid.image(int.krig, grid, ic='sd',
           main='Kriging with genetic distances',
           xlab='Longitude', ylab='Latitude',
           sclab='Standard deviation')
points(vipers[,1:2], pch=lin+1)

#plot only pixels higher than 0.95
lin.krig &lt;- as.integer(int.krig$Z&gt;0.95)
grid.image(lin.krig, grid, main='Kriging with genetic distances',
           xlab='Longitude', ylab='Latitude', sclab='Lineage')
points(vipers[,1:2], pch=lin+1)

## Not run: 
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# The following code is an example to combine the possible clusters   #
#  of a tree in a single map. It samples the tree at different length #
# and combines the probabilities.                                     #
#                                                                     #
#                NOTE: it may take some time to run!                  #
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#

# A phylogenetic tree is sampled at different lengths. An appropriate
# package (e.g. ape) should be used to process the tree. To avoid extra
# dependencies we convert the genetic distances to an hclust.

hc &lt;- hclust(as.dist(d.gen))
hs = seq(0.01, 0.08, 0.005) # tree length sampling

# Another options for tree sampling can be using the nodes position,
# avoiding the root and tip levels:
# hs &lt;- hc$height[hc$height &gt; 0.0 &amp; hc$height &lt; max(hc$height)]
#
# Or a single threshold:
# hs &lt;- 0.06

contact = rep(0, nrow(grid)) # Sums all probabilities
for (h in hs) {
    lins &lt;- cutree(hc, h=h)
    print(paste("height =", h, ":", max(lins), "lineages")) #keep track
    ct = rep(1, nrow(grid)) # Product of individual cluster/lineage map
    for (i in unique(lins)) {
        lin &lt;- as.integer(lins == i)
        krg &lt;- krig(lin, vipers[,1:2], grid, gv,
                    clamp = TRUE, verbose=FALSE)
        # Probability of NOT belonging to a cluster.
        ct &lt;- ct * (1 - krg$Z) # Probab. of NOT belonging to a cluster
    }
    contact = contact + ct
}
krg$Z &lt;- contact / length(hs) # Recycle krg with contact zones

#plot the interpolation results
grid.image(krg, grid, xlab='Longitude', ylab='Latitude',
           main='Uncertainty in cluster classification / contact zones')
points(vipers[,1:2], pch=16, cex=0.5)

## End(Not run)
</code></pre>


</div>
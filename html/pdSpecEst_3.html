<div class="container">

<table style="width: 100%;"><tr>
<td>H.coeff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Orthonormal basis expansion of a Hermitian matrix</h2>

<h3>Description</h3>

<p><code>H.coeff</code> expands a <code class="reqn">(d,d)</code>-dimensional Hermitian matrix <code>H</code>  with respect to
an orthonormal (in terms of the Frobenius inner product) basis of the space of Hermitian matrices.
That is, <code>H.coeff</code> transforms <code>H</code> into a numeric vector of <code class="reqn">d^2</code> real-valued basis coefficients,
which is possible as the space of Hermitian matrices is a real vector space. Let <code class="reqn">E_{nm}</code> be a
<code class="reqn">(d,d)</code>-dimensional zero matrix with a 1 at location <code class="reqn">(1, 1) \leq (n,m) \leq (d,d)</code>.
The orthonormal basis contains the following matrix elements; let  <code class="reqn">1 \le n \le d</code> and
<code class="reqn">1 \le m \le d</code>,
</p>

<dl>
<dt>If <code>n == m</code>
</dt>
<dd>
<p> the real matrix element <code class="reqn">E_{nn}</code></p>
</dd>
<dt>If <code>n &lt; m</code>
</dt>
<dd>
<p> the complex matrix element <code class="reqn">2i/\sqrt 2 E_{nm}</code></p>
</dd>
<dt>If <code>n &gt; m</code>
</dt>
<dd>
<p> the real matrix element <code class="reqn">2/\sqrt 2 E_{nm}</code></p>
</dd>
</dl>
<p>The orthonormal basis coefficients are ordered by scanning through the matrix <code>H</code> in a row-by-row
fashion.
</p>


<h3>Usage</h3>

<pre><code class="language-R">H.coeff(H, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>if <code>inverse = FALSE</code>, a <code class="reqn">(d,d)</code>-dimensional Hermitian matrix; if <code>inverse = TRUE</code>, a numeric
vector of length <code class="reqn">d^2</code> with <code class="reqn">d</code> an integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inverse</code></td>
<td>
<p>a logical value that determines whether the forward basis transform (<code>inverse = FALSE</code>) or the inverse
basis transform (<code>inverse = TRUE</code>) should be applied.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>inverse = FALSE</code> takes as input a <code class="reqn">(d,d)</code>-dimensional Hermitian matrix and outputs a numeric
vector of length <code class="reqn">d^2</code> containing the real-valued basis coefficients. If <code>inverse = TRUE</code> takes as input a
<code class="reqn">d^2</code>-dimensional numeric vector of basis coefficients and outputs the corresponding <code class="reqn">(d,d)</code>-dimensional
Hermitian matrix.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## random Hermitian matrix
H &lt;- matrix(complex(real = rnorm(9), imaginary = rnorm(9)), nrow = 3)
diag(H) &lt;- rnorm(3)
H[lower.tri(H)] &lt;- t(Conj(H))[lower.tri(H)]

## orthonormal basis expansion
h &lt;- H.coeff(H)
H1 &lt;- H.coeff(h, inverse = TRUE) ## reconstructed Hermitian matrix
all.equal(H, H1)

</code></pre>


</div>
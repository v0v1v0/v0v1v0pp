<div class="container">

<table style="width: 100%;"><tr>
<td>%then%</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Applying parsers in sequence</h2>

<h3>Description</h3>

<p><code>(p1 %then% p2)</code> recognizes anything that <code>p1</code> and <code>p2</code> would if applied in
succession.
</p>


<h3>Usage</h3>

<pre><code class="language-R">p1 %then% p2
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>p1, p2</code></td>
<td>
<p>two parsers.</p>
</td>
</tr></table>
<h3>Value</h3>

<p>A parser.
</p>


<h3>Pseudocode</h3>

<pre>
(p1 %then% p2)(x):
  if p1(x)==[] or x==null then fail()(x)
  else
    if p2(x[-1])==[] then fail()(x)
    else succeed([p1(x)$L, p2(x[-1])$L])(x[-2])
</pre>
<p>where <code>null</code> is the empty vector, <code>x[-1]</code> and <code>x[-2]</code> are the vector <code>x</code>
without the first element and without the first two elements, respectively.
</p>


<h3>See Also</h3>

<p>The discarding versions %xthen% and %thenx%
</p>


<h3>Examples</h3>

<pre><code class="language-R">starts_with_a &lt;- function(x) grepl("^a",x[1])
starts_with_b &lt;- function(x) grepl("^b",x[1])
(satisfy(starts_with_a) %then% satisfy(starts_with_b)) (c("ab", "bc", "de")) # success
(satisfy(starts_with_a) %then% satisfy(starts_with_b)) (c("bb", "bc", "de")) # failure
(satisfy(starts_with_a) %then% satisfy(starts_with_b)) (c("ab", "ac", "de")) # failure

</code></pre>


</div>
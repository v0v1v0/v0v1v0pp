<div class="container">

<table style="width: 100%;"><tr>
<td>mjn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Median-Joining Network</h2>

<h3>Description</h3>

<p>This function computes the median-joining network (MJN) as described
by Bandelt et al. (1999).
</p>


<h3>Usage</h3>

<pre><code class="language-R">mjn(x, epsilon = 0, max.n.cost = 10000, prefix = "median.vector_",
    quiet = FALSE)
## S3 method for class 'mjn'
plot(x, shape = c("circles", "diamonds"),
      bg = c("green", "slategrey"), labels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix (or data frame) of DNA sequences or binary 0/1
data; an object of class <code>"mjn"</code> for <code>plot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>tolerance parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.n.cost</code></td>
<td>
<p>the maximum number of costs to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix</code></td>
<td>
<p>the prefix used to label the median vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>a logical value; by default, the progress of the
calculatins is printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape, bg</code></td>
<td>
<p>the default shapes and colours for observed
haplotypes and median vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>by default, the labels of the haplotypes are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed to <code>plot.haploNet</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>MJN is a network method where unobserved sequences (the median
vectors) are reconstructed and included in the final network. Unlike
<code>mst</code>, <code>rmst</code>, and <code>msn</code>, <code>mjn</code> works with
the original sequences, the distances being calculated internally
using a Hamming distance method (with <code>dist(x, "manhattan")</code> for
binary data or <code>dist.dna(x, "N")</code> for DNA sequences).
</p>
<p>The parameter <code>epsilon</code> controls how the search for new median
vectors is performed: the larger this parameter, the wider the search
(see the example with binary data).
</p>
<p>If the sequences are very divergent, the search for new median vectors
can take a very long time. The argument <code>max.n.cost</code> controls how
many such vectors are added to the network (the default value should
avoid the function to run endlessly).
</p>
<p>The arguments <code>shape</code> and <code>bg</code> must be of length two (unlike
in <code>plot.haploNet</code>). It is possible to have more
flexibility when plotting the MJN by changing its class, for instance
with the output in the examples below: <code>class(nt0) &lt;- "haplotNet"</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>c("mjn", "haploNet")</code> with an extra attribute
(data) containing the original data together with the median vectors.
</p>


<h3>Note</h3>

<p>Since <span class="pkg">pegas</span> 1.0, <code>mjn</code> is expected to run in reasonable
times (less than 15 sec with 100 sequences). Bandelt et al. (1999)
reported long computing times because of the need to compute a lot of
median vectors. Running times also depend on the level of polymorphism
in the data (see above).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Bandelt, H. J., Forster, P. and Rohl, A. (1999) Median-joining networks
for inferring intraspecific phylogenies. <em>Molecular Biology and
Evolution</em>, <b>16</b>, 37â€“48.
</p>


<h3>See Also</h3>

<p><code>haploNet</code>, <code>mst</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## data in Table 1 of Bandelt et al. (1999):
x &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0,
       1, 1, 1, 1, 0, 0, 0, 0, 0,
       1, 0, 0, 0, 1, 1, 1, 0, 0,
       0, 1, 1, 1, 1, 1, 0, 1, 1)
x &lt;- matrix(x, 4, 9, byrow = TRUE)
rownames(x) &lt;- LETTERS[1:4]
(nt0 &lt;- mjn(x))
(nt1 &lt;- mjn(x, 1))
(nt2 &lt;- mjn(x, 2))
plot(nt0)

## Not run: 
## same like in Fig. 4 of Bandelt et al. (1999):
plotNetMDS(nt2, dist(attr(nt2, "data"), "manhattan"), 3)

## End(Not run)

## data in Table 2 of Bandelt et al. (1999):
z &lt;- list(c("g", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a"),
          c("a", "g", "g", "a", "a", "a", "a", "a", "a", "a", "a", "a"),
          c("a", "a", "a", "g", "a", "a", "a", "a", "a", "a", "g", "g"),
          c("a", "a", "a", "a", "g", "g", "a", "a", "a", "a", "g", "g"),
          c("a", "a", "a", "a", "a", "a", "a", "a", "g", "g", "c", "c"),
          c("a", "a", "a", "a", "a", "a", "g", "g", "g", "g", "a", "a"))
names(z) &lt;- c("A1", "A2", "B1", "B2", "C", "D")
z &lt;- as.matrix(as.DNAbin(z))
(ntz &lt;- mjn(z, 2))

## Not run: 
## same like in Fig. 5 of Bandelt et al. (1999):
plotNetMDS(ntz, dist.dna(attr(ntz, "data"), "N"), 3)

## End(Not run)
</code></pre>


</div>
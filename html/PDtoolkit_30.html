<div class="container">

<table style="width: 100%;"><tr>
<td>pp.testing</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Testing the predictive power of PD rating model</h2>

<h3>Description</h3>

<p><code>pp.testing</code> performs testing of predictive power of the PD rating model. This procedure should be applied
on the level of the rating scale.
Four tests are implemented: the binomial, Jeffreys, z-score and Hosmer-Lemeshow test.
Only the Hosmer-Lemeshow test refers to complete rating scale, while the remaining three are implemented on the
rating grade level. The null hypothesis for the binomial, Jeffreys, and z-score tests is that the observed default rate
<code class="reqn">\frac{n_b}{n_o}</code> is less or equal to the calibrated PD (<code>pdc</code>) while for the Hosmer-Lemeshow test is that
the calibrated PD (<code>pdc</code>) is the true one.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pp.testing(rating.label, pdc, no, nb, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>rating.label</code></td>
<td>
<p>Vector of rating labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdc</code></td>
<td>
<p>Vector of calibrated probabilities of default (PD).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no</code></td>
<td>
<p>Number of observations per rating grade.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb</code></td>
<td>
<p>Number of defaults (bad cases) per rating grade.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Significance level of p-value for implemented tests. Default is 0.05.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Due to the fact that test of predictive power is usually implemented on the application portfolio,
certain prerequisites are needed to be fulfilled. In the first place model should be developed
and rating scale should be formed. In order to reflect appropriate role and right moment of
tests application, presented simplified example covers all steps before test implementation.
</p>


<h3>Value</h3>

<p>The command <code>pp.testing</code> returns a data frame with input parameters along with
p-value for each implemented test and the accepted hypothesis. Due to the fact that
Hosmer-Lemeshow test is applied to complete rating scale, returned p-values are all equal between
the rating grades as well as the test results.
</p>


<h3>References</h3>

<p>Tasche, D. (2008). Validation of internal rating systems and PD estimates,
The Analytics of Risk Model Validation, Quantitative Finance,
Elsevier B.V., .<br>
Oesterreichische Nationalbank (2004). Rating Models and Validation,
Oesterreichische Nationalbank (OeNB).
</p>


<h3>Examples</h3>

<pre><code class="language-R">suppressMessages(library(PDtoolkit))
data(loans)
#estimate some dummy model
mod.frm &lt;- `Creditability` ~ `Account Balance` + `Duration of Credit (month)` +
				`Age (years)`
lr.mod &lt;- glm(mod.frm, family = "binomial", data = loans)
summary(lr.mod)$coefficients
#model predictions
loans$pred &lt;-  unname(predict(lr.mod, type = "response", newdata = loans))
#scale probabilities
loans$score &lt;- scaled.score(probs = loans$pred, score = 600, odd = 50/1, pdo = 20)
#group scores into rating
loans$rating &lt;- sts.bin(x = round(loans$score), y = loans$Creditability, y.type = "bina")[[2]]
#create rating scale
rs &lt;- loans %&gt;%
group_by(rating) %&gt;%
summarise(no = n(),
	    nb = sum(Creditability),
	    ng = sum(1 - Creditability)) %&gt;%
mutate(dr = nb / no)
rs
#calcualte portfolio default rate
sum(rs$dr * rs$no / sum(rs$no))
#calibrate rating scale to central tendency of 27% with minimum PD of 5%
ct &lt;- 0.33
min.pd &lt;- 0.05
rs$pd &lt;- rs.calibration(rs = rs, 
			dr = "dr", 
			w = "no", 
			ct = ct, 
			min.pd = min.pd,
			method = "log.odds.ab")[[1]]
#checks
rs
sum(rs$pd * rs$no / sum(rs$no))
#simulate some dummy application portfolio
set.seed(11)
app.port &lt;- loans[sample(1:nrow(loans), 400), ]
#summarise application portfolio on rating level
ap.summary &lt;- app.port %&gt;%
	  group_by(rating) %&gt;%
	  summarise(no = n(),
			nb = sum(Creditability),
			ng = sum(1 - Creditability)) %&gt;%
	  mutate(dr = nb / no)
#bring calibrated pd as a based for predictive power testing
ap.summary &lt;- merge(rs[, c("rating", "pd")], ap.summary, by = "rating", all.x = TRUE)
ap.summary
#perform predictive power testing
pp.res &lt;- pp.testing(rating.label = ap.summary$rating,
		     pdc = ap.summary$pd,
		     no = ap.summary$no,
		     nb = ap.summary$nb, 
		     alpha = 0.05)
pp.res
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>expDistMeasure</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute expected distance in measure of approximate excursion set</h2>

<h3>Description</h3>

<p>Computes expected distance in measure between the excursion set of the approximated process and the true excursion set.
</p>


<h3>Usage</h3>

<pre><code class="language-R">expDistMeasure(
  simupoints,
  model,
  threshold,
  batchsize,
  integration.param = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>simupoints</code></td>
<td>
<p>a numeric array of size <code>batchsize*d</code> containing the simulation points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a km model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>threshold value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batchsize</code></td>
<td>
<p>number of simulations points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integration.param</code></td>
<td>
<p>a list containing parameters for the integration of the criterion A, see max_sur_parallel for more details.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A positive value indicating the expected distance in measure.
</p>


<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850â€“874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Compute optimal simulation points in a 2d example
if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
if (!requireNamespace("DiceDesign", quietly = TRUE)) {
stop("DiceDesign needed for this example to work. Please install it.",
     call. = FALSE)
}
# Define the function
g=function(x){
  return(-DiceKriging::branin(x))
}
d=2
# Fit OK km model
design&lt;-DiceDesign::maximinESE_LHS(design = DiceDesign::lhsDesign(n=20,
                                                                  dimension = 2,
                                                                  seed=42)$design)$design
colnames(design)&lt;-c("x1","x2")
observations&lt;-apply(X = design,MARGIN = 1,FUN = g)
kmModel&lt;-DiceKriging::km(formula = ~1,design = design,response = observations,
                         covtype = "matern3_2",control=list(trace=FALSE))


threshold &lt;- -10

# Obtain simulation point sampling from maximin LHS design
batchsize &lt;- 50
set.seed(1)
mmLHS_simu_points &lt;-  DiceDesign::maximinSA_LHS(DiceDesign::lhsDesign(n=batchsize,
                                                                     dimension = d,
                                                                     seed=1)$design)$design


# Compute expected distance in measure for approximation obtain from random simulation points
EDM_mmLHS &lt;- rep(NA,batchsize)
integcontrol &lt;- list(distrib="sobol",n.points=1000)
integration.param &lt;- KrigInv::integration_design(integcontrol,d=d,
                                        lower=c(0,0),upper=c(1,1),
                                        model=kmModel,T=threshold)
integration.param$alpha &lt;- 0.5
for(i in seq(1,batchsize)){
EDM_mmLHS[i]&lt;-expDistMeasure( mmLHS_simu_points[1:i,],model = kmModel,
                             threshold = threshold,batchsize = i,
                             integration.param = integration.param  )
}

plot(EDM_mmLHS,type='l',main="Expected distance in measure",xlab="batchsize")


## Not run: 
# Get optimized simulation points with algorithm B
simu_points &lt;- optim_dist_measure(model=kmModel,threshold = threshold,
                                  lower = c(0,0),upper = c(1,1),
                                  batchsize = batchsize,algorithm = "B")
# plot the criterion value
plot(1:batchsize,simu_points$value,type='l',main="Criterion value")

# Compute expected distance in measure for approximation obtained from optimized simulation points
EDM_optB &lt;- rep(NA,batchsize)
for(i in seq(1,batchsize)){
  EDM_optB[i]&lt;-expDistMeasure( simu_points$par[1:i,],model = kmModel,threshold = threshold,
                                 batchsize = i,integration.param = integration.param  )
}
plot(EDM_mmLHS,type='l',main="Expected distance in measure",
     xlab="batchsize",ylab="EDM",
     ylim=range(EDM_mmLHS,EDM_optB))
lines(EDM_optB,col=2,lty=2)
legend("topright",c("Maximin LHS","B"),lty=c(1,2),col=c(1,2))

# Get optimized simulation points with algorithm A
simu_pointsA &lt;- optim_dist_measure(model=kmModel,threshold = threshold,
                                   lower = c(0,0),upper = c(1,1),
                                   batchsize = batchsize,algorithm = "A")
# plot the criterion value
plot(1:batchsize,simu_pointsA$value,type='l',main="Criterion value")

# Compute expected distance in measure for approximation obtained from optimized simulation points
EDM_optA &lt;- rep(NA,batchsize)
for(i in seq(1,batchsize)){
  EDM_optA[i]&lt;-expDistMeasure( simu_pointsA$par[1:i,],model = kmModel,threshold = threshold,
                                 batchsize = i,integration.param = integration.param  )
}
plot(EDM_mmLHS,type='l',main="Expected distance in measure",
     xlab="batchsize",ylab="EDM",
     ylim=range(EDM_mmLHS,EDM_optB,EDM_optA))
lines(EDM_optB,col=2,lty=2)
lines(EDM_optA,col=3,lty=3)
legend("topright",c("Maximin LHS","A","B"),lty=c(1,3,2),col=c(1,3,2))


## End(Not run)
</code></pre>


</div>
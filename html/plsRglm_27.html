<div class="container">

<table style="width: 100%;"><tr>
<td>cv.plsR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Partial least squares regression models with k-fold cross-validation</h2>

<h3>Description</h3>

<p>This function implements k-fold cross-validation on complete or incomplete datasets for partial least squares regression models
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.plsR(object, ...)
## Default S3 method:
cv.plsRmodel(object,dataX,nt=2,limQ2set=.0975,modele="pls", 
K=5, NK=1, grouplist=NULL, random=TRUE, scaleX=TRUE, 
scaleY=NULL, keepcoeffs=FALSE, keepfolds=FALSE, keepdataY=TRUE, 
keepMclassed=FALSE, tol_Xi=10^(-12), weights, verbose=TRUE,...)
## S3 method for class 'formula'
cv.plsRmodel(object,data=NULL,nt=2,limQ2set=.0975,modele="pls", 
K=5, NK=1, grouplist=NULL, random=TRUE, scaleX=TRUE, 
scaleY=NULL, keepcoeffs=FALSE, keepfolds=FALSE, keepdataY=TRUE, 
keepMclassed=FALSE, tol_Xi=10^(-12), weights,subset,contrasts=NULL, verbose=TRUE,...)
PLS_lm_kfoldcv(dataY, dataX, nt = 2, limQ2set = 0.0975, modele = "pls", 
K = 5, NK = 1, grouplist = NULL, random = TRUE, scaleX = TRUE, 
scaleY = NULL, keepcoeffs = FALSE, keepfolds = FALSE, keepdataY = TRUE, 
keepMclassed=FALSE, tol_Xi = 10^(-12), weights, verbose=TRUE)
PLS_lm_kfoldcv_formula(formula,data=NULL,nt=2,limQ2set=.0975,modele="pls", 
K=5, NK=1, grouplist=NULL, random=TRUE, scaleX=TRUE, 
scaleY=NULL, keepcoeffs=FALSE, keepfolds=FALSE, keepdataY=TRUE, 
keepMclassed=FALSE, tol_Xi=10^(-12), weights,subset,contrasts=NULL,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>response (training) dataset or an object of class "<code>formula</code>" (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataY</code></td>
<td>
<p>response (training) dataset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataX</code></td>
<td>
<p>predictor(s) (training) dataset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class "<code>formula</code>" (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code>as.data.frame</code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>plsRglm</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nt</code></td>
<td>
<p>number of components to be extracted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limQ2set</code></td>
<td>
<p>limit value for the Q2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modele</code></td>
<td>
<p>name of the PLS model to be fitted, only (<code>"pls"</code> available for this fonction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>number of groups. Defaults to 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NK</code></td>
<td>
<p>number of times the group division is made</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grouplist</code></td>
<td>
<p>to specify the members of the <code>K</code> groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>should the <code>K</code> groups be made randomly. Defaults to <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for <code>modele="pls"</code> and should be for glms pls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since non always possible for glm responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepcoeffs</code></td>
<td>
<p>shall the coefficients for each model be returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepfolds</code></td>
<td>
<p>shall the groups' composition be returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepdataY</code></td>
<td>
<p>shall the observed value of the response for each one of the predicted value be returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepMclassed</code></td>
<td>
<p>shall the number of miss classed be returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times pp)</code> if there is any missing value in the <code>dataX</code>. It defaults to <code class="reqn">10^{-12}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments to pass to <code>cv.plsRmodel.default</code> or to <code>cv.plsRmodel.formula</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Predicts 1 group with the <code>K-1</code> other groups. Leave one out cross validation is thus obtained for <code>K==nrow(dataX)</code>.
</p>
<p>A typical predictor has the form response ~ terms where response is the (numeric) response vector and terms is a series of terms which specifies a linear predictor for response. A terms specification of the form first + second indicates all the terms in first together with all the terms in second with any duplicates removed. 
</p>
<p>A specification of the form first:second indicates the the set of terms obtained by taking the interactions of all terms in first with all terms in second. The specification first*second indicates the cross of first and second. This is the same as first + second + first:second. 
</p>
<p>The terms in the formula will be re-ordered so that main effects come first, followed by the interactions, all second-order, all third-order and so on: to avoid this pass a terms object as the formula. 
</p>
<p>Non-NULL weights can be used to indicate that different observations have different dispersions (with the values in weights being inversely proportional to the dispersions); or equivalently, when the elements of weights are positive integers w_i, that each response y_i is the mean of w_i unit-weight observations. 
</p>


<h3>Value</h3>

<p>An object of class <code>"cv.plsRmodel"</code>.<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>results_kfolds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the results for a group division:
</p>

<dl>
<dt>list</dt>
<dd>
<p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * nt</code> with the predicted values for a growing number of components</p>
</dd>
<dt>...</dt>
<dd>
<p>...</p>
</dd>
<dt>list</dt>
<dd>
<p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * nt</code> with the predicted values for a growing number of components</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>folds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the results for a group division:
</p>

<dl>
<dt>list</dt>
<dd>
<p> of <code>K</code> vectors of length about <code>nrow(dataX)</code> with the numbers of the rows of <code>dataX</code> that were used as a training set</p>
</dd>
<dt>...</dt>
<dd>
<p>...</p>
</dd>
<dt>list</dt>
<dd>
<p> of <code>K</code> vectors of length about <code>nrow(dataX)</code> with the numbers of the rows of <code>dataX</code> that were used as a training set</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataY_kfolds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the results for a group division:
</p>

<dl>
<dt>list</dt>
<dd>
<p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * 1</code> with the observed values of the response</p>
</dd>
<dt>...</dt>
<dd>
<p>...</p>
</dd>
<dt>list</dt>
<dd>
<p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * 1</code> with the observed values of the response</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call of the function</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Work for complete and incomplete datasets.</p>


<h3>Author(s)</h3>

<p>Frederic Bertrand<br><a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br><a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et Frederic Bertrand (2010). Comparing the linear and the logistic PLS regression with qualitative predictors: application to allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>, 151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p>Summary method <code>summary.cv.plsRmodel</code>. <code>kfolds2coeff</code>, <code>kfolds2Pressind</code>, <code>kfolds2Press</code>, <code>kfolds2Mclassedind</code>, <code>kfolds2Mclassed</code> and <code>kfolds2CVinfos_lm</code> to extract and transform results from k-fold cross-validation.</p>


<h3>Examples</h3>

<pre><code class="language-R">data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

#Leave one out CV (K=nrow(Cornell)) one time (NK=1)
bbb &lt;- cv.plsR(object=yCornell,dataX=XCornell,nt=6,K=nrow(Cornell),NK=1)
bbb2 &lt;- cv.plsR(Y~.,data=Cornell,nt=6,K=12,NK=1,verbose=FALSE)
(sum1&lt;-summary(bbb2))

#6-fold CV (K=6) two times (NK=2)
#use random=TRUE to randomly create folds for repeated CV
bbb3 &lt;- cv.plsR(object=yCornell,dataX=XCornell,nt=6,K=6,NK=2)
bbb4 &lt;- cv.plsR(Y~.,data=Cornell,nt=6,K=6,NK=2,verbose=FALSE)
(sum3&lt;-summary(bbb4))

cvtable(sum1)
cvtable(sum3)
rm(list=c("XCornell","yCornell","bbb","bbb2","bbb3","bbb4"))
</code></pre>


</div>
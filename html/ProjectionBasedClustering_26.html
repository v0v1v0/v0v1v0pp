<div class="container">

<table style="width: 100%;"><tr>
<td>tSNE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>T-distributed Stochastic Neighbor Embedding (t-SNE)</h2>

<h3>Description</h3>

<p>T-distributed Stochastic Neighbor Embedding   res = tSNE(Data, KNN=30,OutputDimension=2) 
</p>


<h3>Usage</h3>

<pre><code class="language-R">tSNE(DataOrDistances,k,OutputDimension=2,Algorithm='tsne_cpp',

method="euclidean",Whitening=FALSE, Iterations=1000,PlotIt=FALSE,Cls,num_threads=1,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>DataOrDistances</code></td>
<td>

<p>Numerical matrix defined as either 
</p>
<p><code>Data</code>, i.e., [1:n,1:d], nonsymmetric, and consists of n cases of d-dimensional data points with every case having d attributes, variables or features,
</p>
<p>or
</p>
<p><code>Distances</code>, i.e.,[1:n,1:n], symmetric and consists of n cases, e.g., <code>as.matrix(dist(Data,method))</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of k nearest neighbors=number of effective nearest neighbors("perplexity"); Important parameter. If not given, settings of packages of t-SNE will be used depending <code>Algorithm</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OutputDimension</code></td>
<td>
<p>Number of dimensions in the Outputspace, default=2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Algorithm</code></td>
<td>

<p>'tsne_cpp': T-Distributed Stochastic Neighbor Embedding using a Barnes-HutImplementation in C++ of <span class="pkg">Rtsne</span>. Requires Version &gt;= 0.15 of <span class="pkg">Rtsne</span> for multicore parallelisation.
</p>
<p>'tsne_opt_cpp': T-Distributed Stochastic Neighbor Embedding with automated optimized parameters using a Barnes-HutImplementation in C++ of [Ulyanov, 2016].
</p>
<p>'tsne_r': pure R implementation of the t-SNE algorithm of of <span class="pkg">tsne</span>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>	                    method specified by distance string: 
'euclidean','cityblock=manhatten','cosine','chebychev','jaccard','minkowski','manhattan','binary' 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Whitening</code></td>
<td>
<p>A boolean value indicating whether the matrix data should be whitened (tsne_r) or if pca should be used priorly 
(tsne_cpp)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Iterations</code></td>
<td>
<p> maximum number of iterations to perform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PlotIt</code></td>
<td>

<p>Default: FALSE, If TRUE: Plots the projection as a 2d visualization. 
OutputDimension&gt;2: only the first two dimensions will be shown
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cls</code></td>
<td>
<p>[1:n,1] Optional,: only relevant if PlotIt=TRUE. Numeric vector, given Classification in numbers: every element is the cluster number of a certain corresponding element of data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_threads</code></td>
<td>

<p>Number of threads for parallel computation, only usable for Algorithm='tsne_cpp' or 'tsne_opt_cpp'
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments passed on to either 'Rtsne' or 'tsne' 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An short overview of different types of projection methods can be found in [Thrun, 2018, p.42, Fig. 4.1], <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>.
</p>


<h3>Value</h3>

<p>List of 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>ProjectedPoints</code></td>
<td>
<p>[1:n,OutputDimension], n by OutputDimension matrix containing coordinates of the Projection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ModelObject</code></td>
<td>
<p>NULL for tsne_r, further information if tsne_cpp is selected </p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>A wrapper for <code>Rtsne</code> (Algorithm='tsne_cpp'),
</p>
<p><a href="https://github.com/omiq-ai/Multicore-opt-SNE">Multicore-opt-tSNE</a> (Algorithm='tsne_opt_cpp'),
</p>
<p>or  for <code>tsne</code> (Algorithm='tsne_r')
</p>
<p>You can use the standard <code>ShepardScatterPlot</code> or the better approach through the <code>ShepardDensityPlot</code> of the CRAN package <code>DataVisualizations</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Thrun, Luca Brinkmann</p>


<h3>References</h3>

<p>Anna C. Belkina, Christopher O. Ciccolella, Rina Anno, Josef Spidlen, Richard Halpert, Jennifer Snyder-Cappione: Automated optimal parameters for T-distributed stochastic neighbor embedding improve visualization and allow analysis of large datasets, bioRxiv 451690, doi: https://doi.org/10.1101/451690, 2018.
</p>
<p>L.J.P van der Maaten: Accelerating t-SNE using tree-based algorithms, Journal of Machine Learning Research 15.1:3221-3245, 2014.
</p>
<p>Ulyanov, Dmitry: Multicore-TSNE, GitHub repository URL <a href="https://github.com/DmitryUlyanov/Multicore-TSNE">https://github.com/DmitryUlyanov/Multicore-TSNE</a>, 2016.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data('Hepta')
Data=Hepta$Data

## Not run: 
Proj=tSNE(Data,k=7)

PlotProjectedPoints(Proj$ProjectedPoints,Hepta$Cls)

## End(Not run)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>clean</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Clean (=replace) off-range values in a spectrum</h2>

<h3>Description</h3>

<p>These functions implement the equivalent of replace() but for spectral
objects instead of vectors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">clean(x, range, range.s.data, fill, ...)

## Default S3 method:
clean(x, range, range.s.data, fill, ...)

## S3 method for class 'source_spct'
clean(
  x,
  range = x,
  range.s.data = c(0, NA),
  fill = range.s.data,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'filter_spct'
clean(
  x,
  range = x,
  range.s.data = NULL,
  fill = range.s.data,
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  ...
)

## S3 method for class 'reflector_spct'
clean(x, range = x, range.s.data = c(0, 1), fill = range.s.data, ...)

## S3 method for class 'solute_spct'
clean(x, range = x, range.s.data = c(0, NA), fill = range.s.data, ...)

## S3 method for class 'object_spct'
clean(
  x,
  range = x,
  range.s.data = c(0, 1),
  fill = range.s.data,
  min.Afr = NULL,
  ...
)

## S3 method for class 'response_spct'
clean(
  x,
  range = x,
  range.s.data = c(0, NA),
  fill = range.s.data,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'cps_spct'
clean(x, range = x, range.s.data = c(0, NA), fill = range.s.data, ...)

## S3 method for class 'raw_spct'
clean(
  x,
  range = x,
  range.s.data = c(NA_real_, NA_real_),
  fill = range.s.data,
  ...
)

## S3 method for class 'generic_spct'
clean(
  x,
  range = x,
  range.s.data = c(NA_real_, NA_real_),
  fill = range.s.data,
  col.names,
  ...
)

## S3 method for class 'source_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, NA),
  fill = range.s.data,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'filter_mspct'
clean(
  x,
  range = NULL,
  range.s.data = NULL,
  fill = range.s.data,
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'reflector_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, 1),
  fill = range.s.data,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'object_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, 1),
  fill = range.s.data,
  min.Afr = NULL,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'solute_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, NA),
  fill = range.s.data,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'response_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, NA),
  fill = range.s.data,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'cps_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, NA),
  fill = range.s.data,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'raw_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, NA),
  fill = range.s.data,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'generic_mspct'
clean(
  x,
  range = x,
  range.s.data = c(NA_real_, NA_real_),
  fill = range.s.data,
  col.names,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an R object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p>numeric vector of wavelengths</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range.s.data</code></td>
<td>
<p>numeric vector of length two giving the allowable
range for the spectral data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>numeric vector of length 1 or 2, giving the replacement
values to use at each extreme of the range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit.out</code></td>
<td>
<p>character string with allowed values "energy", and "photon",
or its alias "quantum"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qty.out</code></td>
<td>
<p>character string with allowed values "energy", and "photon",
or its alias "quantum"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.Afr</code></td>
<td>
<p>numeric Gives the minimum value accepted for the computed
absorptance. The default <code>NULL</code> sets a valid value (Afr &gt;= 0) with
a warning. If an integer value is passed to <code>digits</code> values are
adjusted silently.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.names</code></td>
<td>
<p>character The name of the variable to clean</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A copy of <code>x</code>, possibly with some of the spectral data values
replaced by the value passed to <code>fill</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>clean(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>clean(source_spct)</code>: Replace off-range values in a source spectrum
</p>
</li>
<li> <p><code>clean(filter_spct)</code>: Replace off-range values in a filter spectrum
</p>
</li>
<li> <p><code>clean(reflector_spct)</code>: Replace off-range values in a reflector spectrum
</p>
</li>
<li> <p><code>clean(solute_spct)</code>: Replace off-range values in a solute spectrum
</p>
</li>
<li> <p><code>clean(object_spct)</code>: Replace off-range values in an object spectrum
</p>
</li>
<li> <p><code>clean(response_spct)</code>: Replace off-range values in a response spectrum
</p>
</li>
<li> <p><code>clean(cps_spct)</code>: Replace off-range values in a counts per second spectrum
</p>
</li>
<li> <p><code>clean(raw_spct)</code>: Replace off-range values in a raw counts spectrum
</p>
</li>
<li> <p><code>clean(generic_spct)</code>: Replace off-range values in a generic spectrum
</p>
</li>
<li> <p><code>clean(source_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(object_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(solute_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(response_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(raw_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(generic_mspct)</code>: 
</p>
</li>
</ul>
<h3>Note</h3>

<p>In the case of <code>object_spct</code> objects, cleaning is done first
on the Rfr and Tfr columns and subsequently Afr estimated and if needed
half of deviation of Afr from the expected minimum value subtracted from
each of Rfr and Tfr.
</p>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>season_mov</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Moving growing season division</h2>

<h3>Description</h3>

<p>Moving growing season division
</p>


<h3>Usage</h3>

<pre><code class="language-R">season_mov(INPUT, options = list(), ..., years.run = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>INPUT</code></td>
<td>
<p>A list object with the elements of <code>t</code>, <code>y</code>, <code>w</code>,
<code>Tn</code> (optional) and <code>ylu</code>, returned by <code>check_input()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>see the following section <code style="white-space: pre;">⁠options for season⁠</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>others parameter to <code>set_options()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>years.run</code></td>
<td>
<p>Numeric vector. Which years to run? If not specified, it is
all years.</p>
</td>
</tr>
</table>
<h3>options for season</h3>



<h4>(a) Parameters for rough fitting</h4>


<ul>
<li> <p><code>rFUN</code>              : character (default <code>smooth_wWHIT</code>), the name of rough
curve fitting function, can be one of <code>c("smooth_wSG", "smooth_wWHIT", "smooth_wHANTS")</code>, which are corresponding to <code>smooth_wSG()</code>,
<code>smooth_wWHIT()</code> and <code>smooth_wHANTS()</code>.
</p>
</li>
<li> <p><code>wFUN</code>              : character (default <code>wTSM</code>), the name of weights
updating functions, can be one of c("wTSM", "wChen", "wBisquare",
"wSELF"). See <code>wTSM()</code>, <code>wChen()</code>, <code>wBisquare()</code> and <code>wSELF()</code> for
details.
</p>
</li>
<li> <p><code>iters</code>             : integer (default 2), the number of rough fitting
iterations.
</p>
</li>
<li> <p><code>wmin</code>              : double, the minimum weight of bad points (i.e. snow,
ice and cloud).
</p>
</li>
<li> <p><code>verbose</code>           : logical (default <code>FALSE</code>). If <code>TRUE</code>,
<code>options$season</code> will be printed on the console.
</p>
</li>
<li> <p><code>lambda</code>            : double (default NULL), the smoothing parameter of
<code>smooth_wWHIT()</code>.
</p>

<ul><li>
<p> If <code>lambda = NULL</code>, V-curve theory will be employed to find the
optimal <code>lambda</code>. See <code>lambda_vcurve()</code> for details.
</p>
</li></ul>
</li>
<li> <p><code>frame</code>             : integer (default NULL), the parameter of
<code>smooth_wSG()</code>, moving window size.
</p>

<ul><li>
<p> If <code>frame = NULL</code>, <code>frame</code> will be reset as <code>floor(nptperyear/5)*2 +    1</code> (refered by TIMESAT).
</p>
</li></ul>
</li>
<li> <p><code>nf</code>                : integer (default 4), the number of frequencies in
<code>smooth_wHANTS()</code>.
</p>
</li>
<li> <p><code>maxExtendMonth</code>: integer (default 12), previous and subsequent
<code>maxExtendMonth</code> (in month) data were added to the current year for rough
fitting.
</p>
</li>
<li> <p><code>nextend</code>           : integer (default NULL), same as <code>maxExtendMonth</code>, but
in points.
</p>

<ul>
<li>
<p> If <code>nextend</code> provided, <code>maxExtendMonth</code> will be ignored.
</p>
</li>
<li>
<p> If <code>nextend = NULL</code>, <code>nextend</code> will be reset as
<code>ceiling(maxExtendMonth/12*nptperyear)</code>
</p>
</li>
</ul>
</li>
</ul>
<h4>(b) Parameters for growing season division</h4>


<ul>
<li> <p><code>minpeakdistance</code>   : double (default NULL), the minimum distance of two
peaks (in points). If the distance of two maximum extreme value less than
<code>minpeakdistance</code>, only the maximum one will be kept.
</p>

<ul><li>
<p> If <code>minpeakdistance = NULL</code>, it will be reset as <code>nptperyear/6</code>.
</p>
</li></ul>
</li>
<li> <p><code>r_max</code>             : double (default 0.2; in (0, 1)). <code>r_max</code> and <code>r_min</code>
are used to eliminate fake peaks and troughs.
</p>

<ul>
<li>
<p> The real peaks should satisfy:
</p>

<ol>
<li> <p><code class="reqn">max(h_{peak, L}, h_{peak, R}) &gt; r_{max} A</code>
</p>
</li>
<li> <p><code class="reqn">min(h_{peak, L}, h_{peak, R}) &gt; r_{min} A,</code> where <code class="reqn">h_{peak,
     L}, h_{peak, R}</code> are height difference from the peak to the left- and
right-hand troughs.
</p>
</li>
</ol>
</li>
<li>
<p> The troughs should satisfy:
</p>

<ol><li> <p><code class="reqn">max(h_{trough, L}, h_{trough, R}) &gt; r_{max} A,</code> where
<code class="reqn">h_{trough, L}, h_{trough, R}</code> are height difference from the trough
to the left- and right-hand peaks.
</p>
</li></ol>
</li>
</ul>
</li>
<li> <p><code>r_min</code>             : double (default 0.05; in (0, 1)), see above <code>r_max</code>
for details. <code>r_min</code> &lt; <code>r_max</code>.
</p>
</li>
<li> <p><code>rtrough_max</code>       : double (default 0.6, in (0, 1)), <code class="reqn">y_{peak} &lt;=
  rtrough_max * A + ylu[1]</code>.
</p>
</li>
<li> <p><code>ypeak_min</code>         : double 0.1 (in VI unit), <code class="reqn">y_{peak} &gt;= ypeak_min</code>.
</p>
</li>
<li> <p><code>.check_season</code>     : logical (default <code>TRUE</code>). check the growing season
length according to <code>len_min</code> and <code>len_max</code>. If <code>FALSE</code>, <code>len_min</code> and
<code>len_max</code> will lose their effect.
</p>
</li>
<li> <p><code>len_min</code>           : integer (default 45), the minimum length (in days) of
growing season
</p>
</li>
<li> <p><code>len_max</code>           : integer (default 650), the minimum length (in days)
of growing season
</p>
</li>
<li> <p><code>adj.param</code>         : logical. If <code>TRUE</code> (default), if there are too many
or too less peaks and troughs, <code>phenofit</code> will automatically adjust rough
curve fitting function parameters. See <code>MaxPeaksPerYear</code> and
<code>MaxTroughsPerYear</code> for details.
</p>
</li>
<li> <p><code>MaxPeaksPerYear</code> (optional)   : integer (default 2), the max number of
peaks per year. If <code>PeaksPerYear</code> &gt; <code>MaxPeaksPerYear</code>, then <code>lambda = lambda*2</code>.
</p>
</li>
<li> <p><code>MaxTroughsPerYear</code> (optional) : integer (default 3), the max number of
troughs per year. If <code>TroughsPerYear</code> &gt; <code>MaxTroughsPerYear</code>, then <code>lambda = lambda*2</code>.
</p>
</li>
<li> <p><code>calendarYear</code>      : logical (default <code>FALSE</code>). If <code>TRUE</code>, the start and
end of a calendar year will be regarded as growing season division (North
Hemisphere is from 01 Jan to 31 Dec; South Hemisphere is from 01 Jul to 30
Jun).
</p>
</li>
<li> <p><code>rm.closed</code>         : logical (default <code>TRUE</code>). If <code>TRUE</code>, closed peaks (or troughs)
will be further tidied. Only the maximum
</p>
</li>
<li> <p><code>is.continuous</code> (not used): logical (default <code>TRUE</code>). This parameter is for
<code>fluxnet2015</code> fluxsite data, where the input might be not continuous.
</p>
</li>
</ul>
<h3>References</h3>


<ol>
<li>
<p> Kong, D., Zhang, Y., Wang, D., Chen, J., &amp; Gu, X. (2020). Photoperiod
Explains the Asynchronization Between Vegetation Carbon Phenology and
Vegetation Greenness Phenology. Journal of Geophysical Research:
Biogeosciences, 125(8), e2020JG005636.
https://doi.org/10.1029/2020JG005636
</p>
</li>
<li>
<p> Kong, D., Zhang, Y., Gu, X., &amp; Wang, D. (2019). A robust method for
reconstructing global MODIS EVI time series on the Google Earth Engine.
ISPRS Journal of Photogrammetry and Remote Sensing, 155, 13-24.
</p>
</li>
</ol>
<h3>See Also</h3>

<p><code>season()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("CA_NS6")
d &lt;- CA_NS6

nptperyear &lt;- 23
INPUT &lt;- check_input(d$t, d$y, d$w,
    QC_flag = d$QC_flag,
    nptperyear = nptperyear, south = FALSE,
    maxgap = nptperyear / 4, alpha = 0.02, wmin = 0.2
)

# curve fitting by year
brks_mov &lt;- season_mov(INPUT,
    options = list(
        rFUN = "smooth_wWHIT", wFUN = "wTSM",
        lambda = 10,
        r_min = 0.05, ypeak_min = 0.05,
        verbose = TRUE
    )
)
plot_season(INPUT, brks_mov)

rfit &lt;- brks2rfit(brks_mov)
# Phenological Metrics from rough fitting
r &lt;- get_pheno(rfit)
</code></pre>


</div>
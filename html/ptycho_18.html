<div class="container">

<table style="width: 100%;"><tr>
<td>ptycho</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sample From Posterior Distributions</h2>

<h3>Description</h3>

<p>Generate MCMC samples from posterior distribution.  Two interfaces are
provided: <code>ptycho</code> generates samples for one design matrix and response
matrix while <code>ptycho.all</code> runs in batch an object generated by
<code>createData</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ptycho(X, y, initStates, groups = NULL,
       tau.min = 0.01, tau.max = 10, tau.sd = (tau.max - tau.min)/4,
       doGPrior = TRUE, doDetPrior = FALSE, prob.varadd = 0.5,
       isOmegaFixed = FALSE, omega = NULL, omega.grp = NULL,
       probs.grp = NULL, rho.alpha = 10, rho.lambda = rho.alpha,
       only.means = FALSE, nburn = 0, nthin = 1, nSavePerChain,
       parallel.chains=FALSE, random.seed=NULL)
ptycho.all(data, across=c("none","traits","sites"), doGrpIndicator,
           dir.out, nreplicates=NULL, parallel.replicates=FALSE,
           doSetSeed=TRUE, ncolumns=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code class="reqn">n</code>-by-<code class="reqn">p</code> design matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p><code class="reqn">n</code>-by-<code class="reqn">q</code> matrix containing response(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initStates</code></td>
<td>
<p>List containing initial states for chains.  Each state is a
list with components:
</p>

<dl>
<dt><code>indic.var</code></dt>
<dd>
<p><code class="reqn">p</code>-by-<code class="reqn">q</code> logical matrix.  If <code class="reqn">(j,k)</code>
entry is <code>TRUE</code>, then covariate <code class="reqn">j</code> is initially in the model
for response <code class="reqn">k</code>.</p>
</dd>
<dt><code>tau</code></dt>
<dd>
<p>Scalar</p>
</dd>
<dt><code>indic.grp</code></dt>
<dd>
<p>Logical vector of length equal to the number of
groups; analogous to <code>indic.var</code>; <code>NULL</code> to use priors that do
not incorporate a second-level indicator variable
</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>To combine information across variants, list containing
</p>

<dl>
<dt><code>var2group</code></dt>
<dd>
<p>Integer vector of length <code class="reqn">p</code>, with entry
<code class="reqn">j</code> being the index of the group containing covariate <code class="reqn">j</code></p>
</dd>
<dt><code>group2var</code></dt>
<dd>
<p>List of length <code class="reqn">G</code>, each entry of which is an
integer vector containing the indices of the covariates belonging to
that group</p>
</dd>
<dt><code>sizes</code></dt>
<dd>
<p>Vector of length <code class="reqn">G</code> containing the number of
covariates in each group</p>
</dd>
</dl>
<p>Otherwise, <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.min, tau.max</code></td>
<td>
<p>Endpoints of uniform prior distribution on <code>tau</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.sd</code></td>
<td>
<p>Standard deviation of the Metropolis-Hastings proposal
distribution for <code>tau</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doGPrior</code></td>
<td>
<p>Logical indicating whether to use the g-prior for effect
sizes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doDetPrior</code></td>
<td>
<p>Unsupported; use default value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob.varadd</code></td>
<td>
<p>If <code>initStates[[1]]]$indic.grp</code> is <code>NULL</code>, the
probability that the Metropolis-Hastings proposal changes one entry of
<code>indic.var</code> from <code>FALSE</code> to <code>TRUE</code>.  Otherwise, the
probability of this event given that the proposal does not change
<code>indic.grp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isOmegaFixed</code></td>
<td>
<p>Logical indicating whether <code>omega</code> is known</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>If <code>isOmegaFixed</code> is <code>TRUE</code>, a <code class="reqn">p</code>-by-<code class="reqn">q</code>
matrix containing the known probabilities.  Otherwise, a matrix containing
the parameters for the Beta prior distribution on <code>omega</code>.  Such a
matrix has columns “A” and “B”; the number of rows should be:
</p>

<ul>
<li>
<p> 1 if <code class="reqn">q=1</code> and <code>initStates[[1]]$indic.grp</code> is <code>NULL</code>,
</p>
</li>
<li> <p><code>length(groups$group2var)</code> if that is nonzero, or
</p>
</li>
<li> <p><code class="reqn">p</code> otherwise.
</p>
</li>
</ul>
<p>If <code>omega</code> is <code>NULL</code> and <code>isOmegaFixed</code> is <code>FALSE</code>,
defaults to uniform priors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega.grp</code></td>
<td>
<p>If <code>isOmegaFixed</code> is <code>TRUE</code>, the known probability
that entries in <code>indic.grp</code> are <code>TRUE</code>.  Otherwise, a vector with
names “A” and “B” containing the parameters for the Beta prior
distribution on <code>omega.grp</code>.  If <code>NULL</code>, defaults to uniform
priors.  Unused if <code>initStates[[1]]$indic.grp</code> is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs.grp</code></td>
<td>
<p>Vector containing the probabilities that the
Metropolis-Hastings proposal will add, leave unchanged, or remove,
respectively, a group.  If <code>NULL</code>, defaults to <code>c(0.25,0.5,0.25)</code>.
Unused if <code>initStates[[1]]$indic.grp</code> is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho.alpha, rho.lambda</code></td>
<td>
<p>Parameters for the Gamma prior distribution on
<code class="reqn">\rho</code>, which is the precision of the noise.  Here, the
Gamma<code class="reqn">(\alpha,\lambda)</code> distribution has density function proportional
to <code class="reqn">x^\alpha e^{-\lambda x}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.means</code></td>
<td>
<p>If logical, specifies whether to return samples or the
running means of the samples.  Can also be a vector containing the
iterations (after the burn-in interval) at which to save the means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nburn</code></td>
<td>
<p>Number of MCMC samples to make before starting to save samples or
to compute means</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthin</code></td>
<td>
<p>Interval between saved samples; default value 1 saves all
samples.  Unused if <code>only.means</code> is <code>TRUE</code> or a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nSavePerChain</code></td>
<td>
<p>If <code>only.means</code> is <code>FALSE</code>, number of MCMC
samples to return from each chain, which means a total of
<code>nthin * nSavePerChain + nburn</code> samples are drawn per chain.  If
<code>only.means</code> is <code>TRUE</code>, then <code>nSavePerChain + nburn</code> samples
are drawn, and only the averages of the last <code>nSavePerChain</code> samples
are returned.  Unused if <code>only.means</code> is not a logical.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.chains</code></td>
<td>
<p>Logical indicating whether to run chains in parallel;
see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.seed</code></td>
<td>
<p>Random seed to pass to chain iterator; if <code>NULL</code>, the
random seed is not set.  See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data in format output by <code>createData</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>across</code></td>
<td>
<p>Whether to combine information across traits, sites, or
neither</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doGrpIndicator</code></td>
<td>
<p>Whether to use priors that incorporate <code>indic.grp</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dir.out</code></td>
<td>
<p>Directory to which to <code>save</code> samples or means</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nreplicates</code></td>
<td>
<p>Vector of replicates to run; if <code>NULL</code>, all will be run</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.replicates</code></td>
<td>
<p>Logical indicating whether to run replicates in
parallel; see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doSetSeed</code></td>
<td>
<p>If <code>TRUE</code>, call <code>set.seed(n.repl)</code> before running
samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncolumns</code></td>
<td>
<p>Scalar. If <code>across</code> is “none” or
“sites”, each of the first <code>ncolumns</code> of <code>repl$y</code> will
be used in turn, running all columns by default.  Ignored if <code>across</code>
is “sites”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to <code>ptycho</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions run MCMC sampling from the posterior of the linear regression
models using hierarchical priors described in Stell and Sabatti (2015).  The
function <code>ptycho.all</code> is a wrapper of <code>ptycho</code> to simplify running
the simulation experiments over many replicates.  These functions determine
which priors to use as follows:
</p>

<ul>
<li>
<p> Standard spike and slab priors that do not combine information
(basic)<br>
For <code>ptycho.all</code>, argument <code>across</code> is “none” and
<code>doGrpIndicator</code> is <code>FALSE</code>.<br>
For <code>ptycho</code>, argument <code>y</code> has one column, <code>groups</code> is
<code>NULL</code>, and <code>indic.grp</code> is <code>NULL</code> or missing in each entry of
<code>initStates</code>.
</p>
</li>
<li>
<p> Combine information across traits (<em>Across Traits</em>)<br>
For <code>ptycho.all</code>, argument <code>across</code> is “traits” and
<code>doGrpIndicator</code> is <code>TRUE</code>.<br>
For <code>ptycho</code>, argument <code>y</code> has <code class="reqn">p &gt; 1</code> columns, <code>groups</code>
is <code>NULL</code>, and <code>indic.grp</code> is a logical vector of length <code class="reqn">p</code>
in each entry of <code>initStates</code>.
</p>
</li>
<li>
<p> Combine information across variants (<em>Across Sites</em>)<br>
For <code>ptycho.all</code>, argument <code>across</code> is “sites” and
<code>doGrpIndicator</code> is <code>TRUE</code>.<br>
For <code>ptycho</code>, argument <code>y</code> has one column, <code>groups</code> specifies
how to combine information, and <code>indic.grp</code> in each entry of
<code>initStates</code> is a logical vector of the same length as
<code>groups$group2var</code>.
</p>
</li>
<li>
<p> Combine information across traits <em>incorrectly</em>
(<em>Unadjusted</em>)<br>
For <code>ptycho.all</code>, argument <code>across</code> is “traits” and
<code>doGrpIndicator</code> is <code>FALSE</code>.<br>
For <code>ptycho</code>, argument <code>y</code> has <code class="reqn">p &gt; 1</code> columns, <code>groups</code>
is <code>NULL</code>, and <code>indic.grp</code> is <code>NULL</code> in each entry of
<code>initStates</code>.<br>
This prior does not properly correct for multiple hypothesis testing and is
only included because it is needed to reproduce results in Stell and Sabatti
(2015).
</p>
</li>
</ul>
<p>Combining information across both phenotypes and variants is planned for a
future release.  These functions perform some checks for compatibility of
<code>X</code>, <code>y</code>, <code>groups</code>, and <code>initStates</code>; but invalid input
could lead to unpredictable behavior.  Singular <code class="reqn">X</code> can result in an error;
even strongly correlated covariates can cause difficulties as described by Stell
and Sabatti (2015).
</p>
<p>The simplest way to run the simulations in Stell and Sabatti (2015) is, for
example,
</p>
<pre>
  data &lt;- createPubData("pleiotropy")
  ptycho.all(data=data, across="traits", doGrpIndicator=TRUE,
             dir.out="/path/to/output/dir/",
             only.means=50000*(1:10), nburn=10000)
  ptycho.all(data=data, across="sites", doGrpIndicator=TRUE,
             dir.out="/path/to/another/dir/",
             groups=createGroupsSim(G=10, ncol(data$X)),
             only.means=50000*(1:10), nburn=10000)
</pre>
<p>With these calls, the replicates run sequentially and so do the chains of the
MCMC sampler; the results will be reproducible because the random seed is set
for each replicate.
</p>
<p>Parallelization is implemented via the <span class="pkg">foreach</span> package.  The user must not
only have it installed but also an appropriate parallel backend, which must be
registered.  To run chains in parallel using the <span class="pkg">doMC</span>, for example,
</p>
<pre>
  data(ptychoIn)
  G &lt;- 2; p &lt;- ncol(ptychoIn$X)
  groups &lt;- createGroupsSim(G, p)
  state &lt;- list(list(indic.grp=rep(FALSE,G),
                     indic.var=matrix(FALSE,nrow=p,ncol=1), tau=1),
                list(indic.grp=rep(TRUE,G),
                     indic.var=matrix(TRUE,nrow=p,ncol=1), tau=1))
  require(doMC)
  registerDoMC(length(state))
  ptychoOut &lt;- ptycho(X=ptychoIn$X, y=ptychoIn$replicates[[1]]$y,
                      groups=groups, initStates=state,
                      only.means=100*seq_len(5), parallel.chains=TRUE)
</pre>
<p>The results would not be reproducible, however, even if one set the random seed
before calling <code>ptycho</code>.  For reproducible results, pass the random seed
in the call to <code>ptycho</code>, which requires that the <span class="pkg">doRNG</span> package is
also installed.  Running the chains in parallel when calling <code>ptycho.all</code>
also requires the option <code>parallel.chains=TRUE</code>, which uses <span class="pkg">doRNG</span>
unless <code>doSetSeed=FALSE</code>.  By default, one of the chains starts with all
variants in the model, so that chain takes much longer to run than do the other
chains.  Consequently, when running multiple replicates via <code>ptycho.all</code>,
much greater time savings can be achieved by running the replicates in parallel
with, for example,
</p>
<pre>
  data &lt;- createPubData("pleiotropy")
  require(doMC)
  registerDoMC(8)
  ptycho.all(data=data, across="traits", doGrpIndicator=TRUE,
             dir.out="/path/to/output/dir/",
             only.means=50000*(1:10), nburn=10000)
</pre>
<p>In this case, the default behavior of reproducible results does <em>not</em>
require <span class="pkg">doRNG</span> because the seed is set after each parallel worker is
created.
</p>
<p>We conclude this description with a discussion of the running time of the MCMC
sampler.  Our actual data has 5335 subjects, 764 variants and three traits.  An
<code>mcmc.list</code> containing 50,000 samples for each of four chains can take
about 5~GB.  Running chains in parallel, it takes less than an hour (on a Linux
computer with 2.6 GHz processors) to perform 510,000 samples per chain.  The run
time depends primarily on the number of entries that are <code>TRUE</code> in the
sampled <code>indic.var</code> matrices; increasing this will increase run times.  A
chain that initially has all entries of <code>indic.var</code> set to <code>TRUE</code> will
take longer than one where the model is initially empty.  Priors that inflate
the posterior expectation of <code>indic.var[j,k]</code> (such as combining
information across responses without using <code>indic.grp</code>) will also take
longer.
</p>


<h3>Value</h3>

<p>The results of <code>ptycho.all</code> are written to files by <code>save</code>.
For priors that use only one response, the output for replicate <code class="reqn">r</code> and
column <code class="reqn">c</code> will be written to ‘<span class="file">rpl&lt;r&gt;col&lt;c&gt;.Rdata</span>’ in the directory
specified by <code>dir.out</code>.  For priors that use multiple responses,
<code>ptycho</code> is called only once for each replicate, and the file name will
be ‘<span class="file">rpl&lt;r&gt;col1.Rdata</span>’.  The object in each such file has the name
<code>smpl</code> and is the value of a call to <code>ptycho</code>.  The format of these
objects depends upon the argument <code>only.means</code>.  In all cases, however,
it has attribute <code>params</code> set to a list containing most of the arguments
in the call to <code>ptycho</code>.
</p>
<p>If <code>only.means</code> is <code>FALSE</code>, then <code>ptycho</code> returns an
<code>mcmc.list</code> whose length is the same as the length of
<code>initStates</code>.  Each entry in this list is an <code>mcmc</code> object
with <code>nSavePerChain</code> rows and a column for each entry of <code>indic.var</code>
and <code>indic.grp</code> plus a column for <code>tau</code>.
</p>
<p>Otherwise, <code>ptycho</code> returns an object of class <code>ptycho</code>, which is
actually a matrix.  The matrix has a column for each sampled indicator
variable, for <code>tau</code> and its square (so that its variance can be
computed), and for the chain and iteration numbers.  If <code>only.means</code> is
<code>TRUE</code>, then each row contains the means of the samples in one chain and
there will be <code>length(initStates) * nSavePerChain</code> rows.
If
<code>only.means</code> is a vector, then there will be
<code>length(initStates) * length(only.means)</code> rows.
</p>


<h3>Author(s)</h3>

<p>Laurel Stell and Chiara Sabatti<br>
Maintainer: Laurel Stell &lt;lstell@stanford.edu&gt;
</p>


<h3>References</h3>

<p>Stell, L. and Sabatti, C. (2015) Genetic variant selection: learning across
traits and sites, arXiv:1504.00946.
</p>


<h3>See Also</h3>

<p><code>createData</code> for simulating input data.
</p>
<p><code>checkConvergence</code> and PosteriorStatistics for analyzing
output of <code>ptycho</code>.
</p>
<p>Data describes <code>tinysim</code> in example below as well as an object
created with <code>ptycho</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(tinysim)
# Use replicate 4.
X &lt;- tinysim$X; p &lt;- ncol(X); nr &lt;- 4
# COMBINE INFORMATION ACROSS RESPONSES
Y &lt;- tinysim$replicates[[nr]]$y; q &lt;- ncol(Y)
# Run 2 chains.
state &lt;- list(list(indic.grp=rep(FALSE,p),
                   indic.var=matrix(FALSE,nrow=p,ncol=q), tau=1),
              list(indic.grp=rep(TRUE,p),
                   indic.var=matrix(TRUE,nrow=p,ncol=q), tau=1))
# In each chain, discard first 10 burn-in samples, then generate
# 100 samples and save running means after every 20 samples.
smpl.ph &lt;- ptycho(X=X, y=Y, initStates=state, only.means=20*(1:5),
                  nburn=10)
# COMBINE INFORMATION ACROSS VARIANTS
# Use two groups of variants.
G &lt;- 2; groups &lt;- createGroupsSim(G, p)
# Run 2 chains.
state &lt;- list(list(indic.grp=rep(FALSE,G),
                   indic.var=matrix(FALSE,nrow=p,ncol=1), tau=1),
              list(indic.grp=rep(TRUE,G),
                   indic.var=matrix(TRUE,nrow=p,ncol=1), tau=1))
# Use response 3.
y &lt;- tinysim$replicates[[nr]]$y[,3,drop=FALSE]
smpl.var &lt;- ptycho(X=X, y=y, groups=groups, initStates=state,
                   only.means=c(20*(1:5)), nburn=10, nthin=1)
</code></pre>


</div>
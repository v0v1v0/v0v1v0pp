<div class="container">

<table style="width: 100%;"><tr>
<td>compute_offset</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute offsets from a count data using one of several normalization schemes</h2>

<h3>Description</h3>

<p>Computes offsets from the count table using one of several normalization schemes (TSS, CSS, RLE, GMPR, Wrench, TMM, etc) described in the literature.
</p>


<h3>Usage</h3>

<pre><code class="language-R">compute_offset(
  counts,
  offset = c("TSS", "GMPR", "RLE", "CSS", "Wrench", "TMM", "none"),
  scale = c("none", "count"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>counts</code></td>
<td>
<p>Required. An abundance count table, preferably with dimensions names and species as columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Optional. Normalization scheme used to compute scaling factors used as offset during PLN inference. Available schemes are "TSS" (Total Sum Scaling, default), "CSS" (Cumulative Sum Scaling, used in metagenomeSeq), "RLE" (Relative Log Expression, used in DESeq2), "GMPR" (Geometric Mean of Pairwise Ratio, introduced in Chen et al., 2018), Wrench (introduced in Kumar et al., 2018) or "none". Alternatively the user can supply its own vector or matrix of offsets (see note for specification of the user-supplied offsets).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Either <code>"none"</code> (default) or <code>"count"</code>. Should the offset be normalized to be on the same scale as the counts ?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters passed on to specific methods (for now CSS and RLE)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>RLE has additional <code>pseudocounts</code> and <code>type</code> arguments to add pseudocounts to the observed counts (defaults to 0L) and to compute offsets using only positive counts (if <code>type == "poscounts"</code>). This mimics the behavior of <code>DESeq2::DESeq()</code> when using <code>sfType == "poscounts"</code>. CSS has an additional <code>reference</code> argument to choose the location function used to compute the reference quantiles (defaults to <code>median</code> as in the Nature publication but can be set to <code>mean</code> to reproduce behavior of functions cumNormStat* from metagenomeSeq). Wrench has two additional parameters: <code>groups</code> to specify sample groups and <code>type</code> to either reproduce exactly the default <code>Wrench::wrench()</code> behavior (<code>type = "wrench"</code>, default) or to use simpler heuristics (<code>type = "simple"</code>). Note that (i) CSS normalization fails when the median absolute deviation around quantiles does not become instable for high quantiles (limited count variations both within and across samples) and/or one sample has less than two positive counts, (ii) RLE fails when there are no common species across all samples (unless <code>type == "poscounts"</code> has been specified) and (iii) GMPR fails if a sample does not share any species with all other samples.
TMM code between two libraries is simplified and adapted from M. Robinson (edgeR:::.calcFactorTMM).
The final output is however different from the one produced by edgeR:::.calcFactorTMM as they are intended
to be used as such in the model (whereas they need to be multiplied by sequencing depths in edgeR)
</p>


<h3>Value</h3>

<p>If <code>offset = "none"</code>, <code>NULL</code> else a vector of length <code>nrow(counts)</code> with one offset per sample.
</p>


<h3>References</h3>

<p>Chen, L., Reeve, J., Zhang, L., Huang, S., Wang, X. and Chen, J. (2018) GMPR: A robust normalization method for zero-inflated count data with application to microbiome sequencing data. PeerJ, 6, e4600 <a href="https://doi.org/10.7717/peerj.4600">doi:10.7717/peerj.4600</a>
</p>
<p>Paulson, J. N., Colin Stine, O., Bravo, H. C. and Pop, M. (2013) Differential abundance analysis for microbial marker-gene surveys. Nature Methods, 10, 1200-1202 <a href="https://doi.org/10.1038/nmeth.2658">doi:10.1038/nmeth.2658</a>
</p>
<p>Anders, S. and Huber, W. (2010) Differential expression analysis for sequence count data. Genome Biology, 11, R106 <a href="https://doi.org/10.1186/gb-2010-11-10-r106">doi:10.1186/gb-2010-11-10-r106</a>
</p>
<p>Kumar, M., Slud, E., Okrah, K. et al. (2018) Analysis and correction of compositional bias in sparse sequencing count data. BMC Genomics 19, 799 <a href="https://doi.org/10.1186/s12864-018-5160-5">doi:10.1186/s12864-018-5160-5</a>
</p>
<p>Robinson, M.D., Oshlack, A. (2010) A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biol 11, R25 <a href="https://doi.org/10.1186/gb-2010-11-3-r25">doi:10.1186/gb-2010-11-3-r25</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(trichoptera)
counts &lt;- trichoptera$Abundance
compute_offset(counts)
## Other normalization schemes
compute_offset(counts, offset = "RLE", pseudocounts = 1)
compute_offset(counts, offset = "Wrench", groups = trichoptera$Covariate$Group)
compute_offset(counts, offset = "GMPR")
compute_offset(counts, offset = "TMM")
## User supplied offsets
my_offset &lt;- setNames(rep(1, nrow(counts)), rownames(counts))
compute_offset(counts, offset = my_offset)
</code></pre>


</div>
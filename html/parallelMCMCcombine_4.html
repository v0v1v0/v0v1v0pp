<div class="container">

<table style="width: 100%;"><tr>
<td>sampleAvg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Sample Averaging Method </h2>

<h3>Description</h3>

<p>The function combines the independent subset posterior samples subchains into  the set of samples that estimate the posterior density given the full data set, by averaging the samples across subsets. Individual model
parameters are assumed to be independent.</p>


<h3>Usage</h3>

<pre><code class="language-R">sampleAvg(subchain, shuff = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>subchain</code></td>
<td>

<p>array of subset posterior samples of the dimension <span class="option">c(d,sampT,M).</span> Here <span class="option">d</span> is the dimension of the parameter space, <span class="option">sampT</span> is the number of samples, and <span class="option">M</span> is the number of subposterior datasets.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shuff</code></td>
<td>
<p>shuff: logical; if TRUE, each of the <span class="option">M</span> subsets of <span class="option">d</span> dimensional parameters  in <span class="option">subchain</span> is shuffled.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> The array <span class="option">subchain</span> must have dimension <span class="option">c(d,sampT,M)</span>. Here <span class="option">d</span> is the dimension of the parameter space, <span class="option">sampT</span> is the number of samples, and <span class="option">M</span> is the number of subposterior datasets.
</p>


<h3>Value</h3>

<p>Returns an array of samples of dimension dim=c(d,sampT) representing an estimated (combined) full posterior density.</p>


<h3>Examples</h3>

<pre><code class="language-R">d      &lt;- 2     # dimension of the parameter space  
sampT  &lt;- 1000  # number of subset posterior samples
M      &lt;- 3     # total number of subsets

## simulate Gaussian subposterior samples

theta &lt;- array(NA,c(d,sampT,M)) 

norm.mean &lt;- c(1.0, 2.0)
norm.sd   &lt;- c(0.5, 1.0)

for (i in 1:d)
  for (s in 1:M)        
    theta[i,,s] &lt;- rnorm(sampT, mean=norm.mean[i]+runif(1,-0.01,0.01), sd=norm.sd[i])

## combine samples:

full.theta &lt;- sampleAvg(subchain=theta, shuff=FALSE)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>estimate_belief_for_nodes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate the Belief for Policy Graph Nodes</h2>

<h3>Description</h3>

<p>Estimate a belief for each alpha vector (segment of the value function) which represents
a node in the policy graph.
</p>


<h3>Usage</h3>

<pre><code class="language-R">estimate_belief_for_nodes(
  x,
  method = "auto",
  belief = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class POMDP containing a solved and converged POMDP problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character string specifying the estimation method. Methods include
<code>"auto"</code>, reuse <code>"solver_points"</code>, follow <code>"trajectories"</code>, sample <code>"random_sample"</code>
or <code>"regular_sample"</code>. Auto uses
solver points if available and follows trajectories otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>belief</code></td>
<td>
<p>start belief used for method trajectories. <code>NULL</code> uses the start belief specified in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; show which method is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>parameters are passed on to <code>sample_belief_space()</code> or the code that follows trajectories.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>estimate_belief_for_nodes()</code> can estimate the belief in several ways:
</p>

<ol>
<li> <p><strong>Use belief points explored by the solver.</strong> Some solvers return explored belief points.
We assign the belief points to the nodes and average each nodes belief.
</p>
</li>
<li> <p><strong>Follow trajectories</strong> (breadth first) till all policy graph nodes have been visited and
return the encountered belief. This implementation returns the first (i.e., shallowest) belief point
that is encountered is used and no averaging is performed. parameter <code>n</code> can be used to
limit the number of nodes searched.
</p>
</li>
<li> <p><strong>Sample a large set</strong> of possible belief points, assigning them to the nodes and then averaging
the belief over the points assigned to each node. This will return a central belief for the node.
Additional parameters like <code>method</code> and the sample size <code>n</code> are passed on to <code>sample_belief_space()</code>.
If no belief point is generated for a segment, then a
warning is produced. In this case, the number of sampled points can be increased.
</p>
</li>
</ol>
<p><strong>Notes:</strong>
</p>

<ul>
<li>
<p> Each method may return a different answer. The only thing that is guaranteed is that the returned belief falls
in the range where the value function segment is maximal.
</p>
</li>
<li>
<p> If some nodes not belief points are sampled, or the node is not reachable from the initial belief,
then a vector with all <code>NaN</code>s will be returned with a warning.
</p>
</li>
</ul>
<h3>Value</h3>

<p>returns a list with matrices with a belief for each policy graph node. The list elements are the epochs and converged solutions
only have a single element.
</p>


<h3>See Also</h3>

<p>Other policy: 
<code>optimal_action()</code>,
<code>plot_belief_space()</code>,
<code>plot_policy_graph()</code>,
<code>policy()</code>,
<code>policy_graph()</code>,
<code>projection()</code>,
<code>reward()</code>,
<code>solve_POMDP()</code>,
<code>solve_SARSOP()</code>,
<code>value_function()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("Tiger")

# Infinite horizon case with converged solution
sol &lt;- solve_POMDP(model = Tiger, method = "grid")
sol

# default method auto uses the belief points used in the algorithm (if available).
estimate_belief_for_nodes(sol, verbose = TRUE)

# use belief points obtained from trajectories  
estimate_belief_for_nodes(sol, method = "trajectories", verbose = TRUE)

# use a random uniform sample 
estimate_belief_for_nodes(sol, method = "random", verbose = TRUE)

# Finite horizon example with three epochs. 
sol &lt;- solve_POMDP(model = Tiger, horizon = 3)
sol
estimate_belief_for_nodes(sol)
</code></pre>


</div>
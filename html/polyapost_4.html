<div class="container">

<table style="width: 100%;"><tr>
<td>hitrun</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hit and Run Algorithm for Constrained Dirichlet Distribution</h2>

<h3>Description</h3>

<p>Markov chain Monte Carlo for equality and inequality constrained
Dirichlet distribution using a hit and run algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hitrun(alpha, ...)

## Default S3 method:
hitrun(alpha, a1 = NULL, b1 = NULL, a2 = NULL, b2 = NULL,
     nbatch = 1, blen = 1, nspac = 1, outmat = NULL, debug = FALSE,
     stop.if.implied.equalities = FALSE, ...)

## S3 method for class 'hitrun'
hitrun(alpha, nbatch, blen, nspac, outmat, debug, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>parameter vector for Dirichlet distribution.  Alternatively,
an object of class <code>"hitrun"</code> that is the result of a previous
invocation of this function, in which case this run continues where
the other left off.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbatch</code></td>
<td>
<p>the number of batches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blen</code></td>
<td>
<p>the length of batches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nspac</code></td>
<td>
<p>the spacing of iterations that contribute to batches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a1</code></td>
<td>
<p>a numeric or character matrix or <code>NULL</code>.  See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b1</code></td>
<td>
<p>a numeric or character vector or <code>NULL</code>.  See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a2</code></td>
<td>
<p>a numeric or character matrix or <code>NULL</code>.  See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b2</code></td>
<td>
<p>a numeric or character vector or <code>NULL</code>.  See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outmat</code></td>
<td>
<p>a numeric matrix, which controls the output.  If <code>p</code>
is the constrained Dirichlet random vector being simulated, then
<code>outmat %*% p</code> is the functional of the state that is averaged.
May be <code>NULL</code>, in which case the identity matrix is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>if <code>TRUE</code>, then additional output useful for debugging
is produced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop.if.implied.equalities</code></td>
<td>
<p>If <code>TRUE</code> stop if there
are any implied equalities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>ignored arguments.  Allows the two methods to have different
arguments.  You cannot change the Dirichlet parameter or the constraints
(hence cannot change the target distribution) when using the method
for class <code>"hitrun"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Runs a hit and run algorithm (for which see the references)
producing a Markov chain with equilibrium distribution having a Dirichlet
distribution with parameter vector <code>alpha</code> constrained to lie in the
subset of the unit simplex consisting of <code>x</code> satisfying
</p>
<pre>
    a1 %*% x &lt;= b1
    a2 %*% x == b2
</pre>
<p>Hence if <code>a1</code> is <code>NULL</code> then so must be <code>b1</code>, and vice versa,
and similarly for <code>a2</code> and <code>b2</code>.
</p>
<p>If any of <code>a1</code>, <code>b1</code>, <code>a2</code>, <code>b2</code> are of type
<code>"character"</code>, then they must be valid GMP (GNU multiple precision)
rational, that is, if run through <code>q2q</code>, they do not
give an error.  This allows constraints to be represented exactly
(using infinite precision rational arithmetic) if so desired.
See also the section on this subject below.
</p>


<h3>Value</h3>

<p>an object of class <code>"hitrun"</code>,
which is a list containing at least the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>batch</code></td>
<td>
<p><code>nbatch</code> by <code>p</code> matrix, the batch means, where
<code>p</code> is the row dimension of <code>outmat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>initial state of Markov chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>final</code></td>
<td>
<p>final state of Markov chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.seed</code></td>
<td>
<p>value of <code>.Random.seed</code> before the run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>final.seed</code></td>
<td>
<p>value of <code>.Random.seed</code> after the run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>running time from <code>system.time()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>the Dirichlet parameter vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbatch</code></td>
<td>
<p>the argument <code>nbatch</code> or <code>obj$nbatch</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blen</code></td>
<td>
<p>the argument <code>blen</code> or <code>obj$blen</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nspac</code></td>
<td>
<p>the argument <code>nspac</code> or <code>obj$nspac</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outmat</code></td>
<td>
<p>the argument <code>outmat</code> or <code>obj$outmat</code>.</p>
</td>
</tr>
</table>
<h3>GMP Rational Arithmetic</h3>

<p>The arguments <code>a1</code>, <code>b1</code>, <code>a2</code>, and <code>b2</code> can and should be
given as GMP (GNU multiple precision) rational values.  This allows the
computational geometry calculations for the constraint set to be done exactly,
without error.  For example, if <code>a1</code> has elements that have been rounded
to two decimal places one should do
</p>
<pre>
a1 &lt;- z2q(round(100 * a1), rep(100, length(a1)))
</pre>
<p>and similarly for <code>b1</code>, <code>a2</code>, and <code>b2</code> to make them exact.
For all the conversion functions between ordinary computer numbers and
GMP rational numbers see ConvertGMP.  For all the functions that
do arithmetic on GMP rational numbers, see ArithmeticGMP.
</p>


<h3>Warning About Implied Equality Constraints</h3>

<p>If any constraints supplied as inequality constraints (specified by rows
of <code>a1</code> and the corresponding components of <code>b1</code>) actually hold
with equality for all points in the constraint set, this is called an
implied equality constraint.  The program must establish that none of these
exist (which is a fast operation) or, otherwise, find out which constraints
supplied as inequality constraints are actually implied equality constraints,
and this operation is very slow when the state is high dimensional.  One
example with 1000 variables took 3 days of computing time when there were
implied equality constraints in the specification.  The same example takes
9 minutes when the same constraint set is specified in a different way so
that there are no  implied equality constraints.
</p>
<p>This issue is not a big deal if there are only in the low hundreds of
variables, because the algorithm to find implied equality constraints is not
that slow.  The same example that takes 3 days of computing time with 1000
variables takes only 15 seconds with 100 variables, 3 and 1/2 minutes with 200
variables, and 23 minutes with 300 variables.  As one can see, this issue
does become a big deal as the number of variables increases.  Thus users
should avoid implied inequality constraints, if possible,
when there are many variables.  Admittedly, there
is no sure way users can identify and eliminate implied equality constraints.
(The sure way to do that is precisely the time consuming step we are trying
to avoid.)  The argument <code>stop.if.implied.equalities</code> can be used to
quickly test for the presence of implied equalities.
</p>


<h3>Philosophy of MCMC</h3>

<p>This function follows the philosophy of MCMC used in the CRAN package
<code>mcmc</code> and the introductory chapter of the
<em>Handbook of Markov Chain Monte Carlo</em> (Geyer, 2011).
</p>
<p>The <code>hitrun</code> function automatically does batch means in order to reduce
the size of output and to enable easy calculation of Monte Carlo standard
errors (MCSE), which measure error due to the Monte Carlo sampling (not
error due to statistical sampling — MCSE gets smaller when you run the
computer longer, but statistical sampling variability only gets smaller
when you get a larger data set).  All of this is explained in the package
vignette for the <code>mcmc</code> package (<code>vignette("demo", "mcmc")</code>)
and in Section 1.10 of Geyer (2011).
</p>
<p>The <code>hitrun</code> function does not apparently
do “burn-in” because this concept does not actually help with MCMC
(Geyer, 2011, Section 1.11.4) but the re-entrant property of the hitrun
function does allow one to do “burn-in” if one wants.
Assuming <code>alpha</code>, <code>a1</code>, <code>b1</code>, <code>a2</code>, and <code>b2</code>
have been already defined
</p>
<pre>
out &lt;- hitrun(alpha, a1, b1, a2, b2, nbatch = 1, blen = 1e5)
out &lt;- hitrun(out, nbatch = 100, blen = 1000)
</pre>
<p>throws away a run of 100 thousand iterations before doing another run of
100 thousand iterations that is actually useful for analysis, for example,
</p>
<pre>
apply(out$batch, 2, mean)
apply(out$batch, 2, sd)
</pre>
<p>gives estimates of posterior means and their MCSE assuming the batch length
(here 1000) was long enough to contain almost all of the signifcant
autocorrelation (see Geyer, 2011, Section 1.10, for more on MCSE).
The re-entrant property of the <code>hitrun</code> function (the second run starts
where the first one stops) assures that this is really “burn-in”.
</p>
<p>The re-entrant property allows one to do very long runs without having to
do them in one invocation of the <code>hitrun</code> function.
</p>
<pre>
out2 &lt;- hitrun(out)
out3 &lt;- hitrun(out2)
batch &lt;- rbind(out$batch, out2$batch, out3$batch)
</pre>
<p>produces a result as if the first run had been three times as long.
</p>


<h3>References</h3>

<p>Belisle, C. J. P., Romeijn, H. E. and Smith, R. L. (1993)
Hit-and-run algorithms for generating multivariate distributions.
<em>Mathematics of Operations Research</em>, <b>18</b>, 255–266.
<a href="https://doi.org/10.1287/moor.18.2.255">doi:10.1287/moor.18.2.255</a>.
</p>
<p>Chen, M. H. and Schmeiser, B. (1993)
Performance of the Gibbs, hit-and-run, and Metropolis samplers.
<em>Journal of Computational and Graphical Statistics</em>, <b>2</b>, 251–272.
</p>
<p>Geyer, C. J. (2011)
Introduction to MCMC.
In <em>Handbook of Markov Chain Monte Carlo</em>. Edited by S. P. Brooks,
A. E. Gelman, G. L. Jones, and X. L. Meng.
Chapman &amp; Hall/CRC, Boca Raton, FL, pp. 3–48.
</p>


<h3>See Also</h3>

<p><code>ConvertGMP</code> and <code>ArithmeticGMP</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># Bayesian inference for discrete probability distribution on {1, ..., d}
# state is probability vector p of length d
d &lt;- 10
x &lt;- 1:d
# equality constraints
#     mean equal to (d + 1) / 2, that is, sum(x * p) = (d + 1) / 2
# inequality constraints
#     median less than or equal to (d + 1) / 2, that is,
#         sum(p[x &lt;= (d + 1) / 2]) &lt;= 1 / 2
a2 &lt;- rbind(x)
b2 &lt;- (d + 1) / 2
a1 &lt;- rbind(as.numeric(x &lt;= (d + 1) / 2))
b1 &lt;- 1 / 2
# simulate prior, which Dirichlet(alpha)
# posterior would be another Dirichlet with n + alpha - 1,
#    where n is count of IID data for each value
alpha &lt;- rep(2.3, d)
out &lt;- hitrun(alpha, nbatch = 30, blen = 250,
    a1 = a1, b1 = b1, a2 = a2, b2 = b2)
# prior means
round(colMeans(out$batch), 3)
# Monte Carlo standard errors
round(apply(out$batch, 2, sd) / sqrt(out$nbatch), 3)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>itemresp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Data Structure for Item Response Data</h2>

<h3>Description</h3>

<p>A class for representing data from questionnaires
along with methods for many generic functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  itemresp(data, mscale = NULL, labels = NULL, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>matrix or data frame. A matrix or data frame with integer
values or factors where the rows correspond to subjects and the
columns to items. See below for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mscale</code></td>
<td>
<p>integer or character. A list of vectors (either integer
or character) giving the measurement scale.
See below for details. By default guessed from <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>character. A vector of character labels for the items.
By default, the column names of <code>data</code> are used or, if these are
not available, the string <code>"item"</code> along with numbers 1, 2, ...
is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>character. A vector of names (or IDs) for the subjects. By default,
no subject names are used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>itemresp</code> is designed for item response data of
<code class="reqn">n</code> subjects for <code class="reqn">k</code> items.
</p>
<p>The item responses should be coded in a matrix <code>data</code>
with <code class="reqn">n</code> rows (subjects) and <code class="reqn">k</code> columns (items). Alternatively,
<code>data</code> can be a data frame with <code class="reqn">n</code> rows (subjects) and
<code class="reqn">k</code> variables (items), which can be either factors or integer
valued vectors.
</p>
<p><code>mscale</code> provides the underlying measurement scale either as
integer or character vector(s). If all items are measured on the same
scale, <code>mscale</code> can be a vector. Alternatively, it can be
provided as a named list of vectors for each item. If the list
contains one unnamed element, this element will be used as the
measurement scale for items that have not been named. Integers or
characters not present in <code>mscale</code> but in <code>data</code> will be
replaced by <code>NA</code>. All items must be measured with at least 2
categories. By default, <code>mscale</code> is set to the full range of
observed values for all integer items (see example below) and the
corresponding levels for all factor items in <code>data</code>.
</p>
<p>Methods to standard generic functions include: <code>str</code>,
<code>length</code> (number of subjects), <code>dim</code> (number of subjects and
items), <code>is.na</code> (only <code>TRUE</code> if all item responses are
<code>NA</code> for a subject), <code>print</code> (see
<code>print.itemresp</code> for details), <code>summary</code> and
<code>plot</code> (see <code>summary.itemresp</code> for details),
subsetting via <code>[</code> and <code>subset</code> (see
<code>subset.itemresp</code> for details), <code>is.itemresp</code> and
various coercion functions to other classes (see
<code>as.list.itemresp</code> for details).
</p>
<p>Extracting/replacing properties is available through: <code>labels</code> for the item labels,
<code>mscale</code> for the measurement scale, <code>names</code> for subject names/IDs.
</p>


<h3>Value</h3>

<p><code>itemresp</code> returns an object of class <code>"itemresp"</code> which is
a matrix (<code>data</code> transformed to integers 0, 1, ...) plus an
attribute <code>"mscale"</code> as a named list for each item
(after being checked and potentially suitably coerced or transformed
to all integer or all character).
</p>


<h3>See Also</h3>

<p><code>print.itemresp</code>, <code>summary.itemresp</code>,
<code>as.list.itemresp</code>, <code>subset.itemresp</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## binary responses to three items, coded as matrix
x &lt;- cbind(c(1, 0, 1, 0), c(1, 0, 0, 0), c(0, 1, 1, 1))
## transformed to itemresp object
xi &lt;- itemresp(x)

## printing (see also ?print.itemresp)
print(xi)
print(xi, labels = TRUE)

## subsetting/indexing (see also ?subset.itemresp)
xi[2]
xi[c(TRUE, TRUE, FALSE, FALSE)]
subset(xi, items = 1:2)
dim(xi)
length(xi)

## summary/visualization (see also ?summary.itemresp)
summary(xi)
plot(xi)

## query/set measurement scale labels
## extract mscale (tries to collapse to vector)
mscale(xi)
## extract as list
mscale(xi, simplify = FALSE)
## replacement by list
mscale(xi) &lt;- list(item1 = c("no", "yes"),
  item2 = c("nay", "yae"), item3 = c("-", "+"))
xi
mscale(xi)
## replacement with partially named list plus default
mscale(xi) &lt;- list(item1 = c("n", "y"), 0:1)
mscale(xi)
## replacement by vector (if number of categories constant)
mscale(xi) &lt;- c("-", "+")
mscale(xi, simplify = FALSE)

## query/set item labels and subject names
labels(xi)
labels(xi) &lt;- c("i1", "i2", "i3")
names(xi)
names(xi) &lt;- c("John", "Joan", "Jen", "Jim")
print(xi, labels = TRUE)

## coercion (see also ?as.list.itemresp)
## to integer matrix
as.matrix(xi)
## to data frame with single itemresp column
as.data.frame(xi)
## to list of factors
as.list(xi)
## to data frame with factors
as.list(xi, df = TRUE)


## polytomous responses with missing values and unequal number of
## categories in a data frame
d &lt;- data.frame(
  q1 = c(-2, 1, -1, 0, NA, 1, NA),
  q2 = c(3, 5, 2, 5, NA, 2, 3),
  q3 = factor(c(1, 2, 1, 2, NA, 3, 2), levels = 1:3,
    labels = c("disagree", "neutral", "agree")))
di &lt;- itemresp(d)
di

## auto-completion of mscale: full range (-2, ..., 2) for q1, starting
## from smallest observed (negative) value (-2) to the same (positive)
## value (2), full (positive) range for q2, starting from smallest
## observed value (2) to largest observed value (5), missing category of
## 4 is detected, for q3 given factor levels are used
mscale(di)

## set mscale for q2 and add category 1, q1 and q3 are auto-completed:
di &lt;- itemresp(d, mscale = list(q2 = 1:5))

## is.na.itemresp - only true for observation 5 (all missing)
is.na(di)

## illustration for larger data set
data("VerbalAggression", package = "psychotools")
r &lt;- itemresp(VerbalAggression$resp[, 1:12])
str(r)
head(r)
plot(r)
summary(r)
prop.table(summary(r), 1)

## dichotomize response
r2 &lt;- r
mscale(r2) &lt;- c(0, 1, 1)
plot(r2)

## transform to "likert" package
if(require("likert")) {
lik &lt;- likert(as.data.frame(as.list(r)))
lik
plot(lik)
}
</code></pre>


</div>
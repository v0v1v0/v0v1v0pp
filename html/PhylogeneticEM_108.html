<div class="container">

<table style="width: 100%;"><tr>
<td>PhyloEM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model Estimation with Detection of Shifts</h2>

<h3>Description</h3>

<p><code>PhyloEM</code> is the main function of the package. It uses maximum likelihood
methods to fit a BM or an OU process for several traits evolving along a
phylogenetic tree, with automatic shift detection on the branches of the tree.
This function can handle missing data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">PhyloEM(
  phylo,
  Y_data,
  process = c("BM", "OU", "scOU", "rBM"),
  check_postorder = TRUE,
  independent = FALSE,
  K_max = max(floor(sqrt(length(phylo$tip.label))), 10),
  use_previous = FALSE,
  order = TRUE,
  method.selection = c("LINselect", "DDSE", "Djump"),
  C.BM1 = 0.1,
  C.BM2 = 2.5,
  C.LINselect = 1.1,
  method.variance = c("upward_downward", "simple"),
  method.init = "lasso",
  method.init.alpha = "estimation",
  method.init.alpha.estimation = c("regression", "regression.MM", "median"),
  methods.segmentation = c("lasso", "best_single_move"),
  alpha_grid = TRUE,
  nbr_alpha = 10,
  random.root = TRUE,
  stationary.root = random.root,
  alpha = NULL,
  check.tips.names = TRUE,
  progress.bar = TRUE,
  estimates = NULL,
  save_step = FALSE,
  rescale_OU = TRUE,
  parallel_alpha = FALSE,
  Ncores = 3,
  K_lag_init = 5,
  light_result = TRUE,
  tol_tree = .Machine$double.eps^0.5,
  allow_negative = FALSE,
  option_is.ultrametric = 1,
  trait_correlation_threshold = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>phylo</code></td>
<td>
<p>A phylogenetic tree of class <code>phylo</code> 
(from package <code>ape</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y_data</code></td>
<td>
<p>Matrix of data at the tips, size p x ntaxa. Each line is a
trait, and each column is a tip. The column names are checked against the
tip names of the tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>process</code></td>
<td>
<p>The model used for the fit. One of "BM" (for a full BM model, 
univariate or multivariate); "OU" (for an OU with independent traits, 
univariate or multivariate); or "scOU" (for a "scalar OU" model, see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_postorder</code></td>
<td>
<p>Re-order the tree in post-order. If the Upward-Downward
algorithm is used, the tree need to be in post-order. Default to TRUE if the
upward-downward is used, otherwise automatically set to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>independent</code></td>
<td>
<p>Are the trait assumed to be independent from one another?
Default to FALSE. OU in a multivariate setting only works if TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K_max</code></td>
<td>
<p>The maximum number of shifts to be considered. Default to 
<code class="reqn">max(|\sqrt ntaxa|, 10)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_previous</code></td>
<td>
<p>Should the initialization for K+1 shifts use the 
estimation for $K$ shifts already obtained? Default to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>Should the estimations be done for K increasing (TRUE) or K
decreasing (FALSE)? If use_previous=FALSE, this has no influence, except if one
initialization fails. Default to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.selection</code></td>
<td>
<p>Method selection to be used. Several ones can be
used at the same time. One of "LINselect" for the Baraud Giraud Huet LINselect 
method; "DDSE" for the Slope Heuristic or "Djump" for the Jump Heuristic, last
two based the Birg√© Massart method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.BM1</code></td>
<td>
<p>Multiplying constant to be used for the BigeMassart1 method.
Need to be positive. Default to 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.BM2</code></td>
<td>
<p>Multiplying constant to be used for the BigeMassart2 method.
Default to 2.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.LINselect</code></td>
<td>
<p>Multiplying constant to be used for the LINselect method.
Need to be greater than 1. Default to 1.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.variance</code></td>
<td>
<p>Algorithm to be used for the moments computations at the
E step. One of "simple" for the naive method; of "upward_downward" for the 
Upward Downward method (usually faster). Default to "upward_downward".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.init</code></td>
<td>
<p>The initialization method. One of "lasso" for the LASSO
base initialization method; or "default" for user-specified initialization
values. Default to "lasso".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.init.alpha</code></td>
<td>
<p>For OU model, initialization method for the selection
strength alpha. One of "estimation" for a cherry-based initialization, using
<code>nlrob</code>; or "default" for user-specified 
initialization values. Default to "estimation".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.init.alpha.estimation</code></td>
<td>
<p>If method.init.alpha="estimation",
choice of the estimation(s) methods to be used. Choices among "regression",
(method="M" is passed to <code>nlrob</code>); "regression.MM"
(method="MM" is passed to <code>nlrob</code>) or "median"
(<code>nlrob</code> is not used, a simple median is taken).
Default to all of them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methods.segmentation</code></td>
<td>
<p>For OU, method(s) used at the M step to find new
candidate shifts positions. Choices among "lasso" for a LASSO-based algorithm;
and "best_single_move" for a one-move at a time based heuristic. Default to 
both of them. Using only "lasso" might speed up the function a lot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha_grid</code></td>
<td>
<p>whether to use a grid for alpha values. Default to TRUE. This
is the only available method for scOU. This method is not available for OU with
multivariate traits. OU with univariate traits can take both TRUE or FALSE. If
TRUE, a grid based on the branch length of the tree is automatically computed,
using function <code>find_grid_alpha</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbr_alpha</code></td>
<td>
<p>If <code>alpha_grid=TRUE</code>, the number of alpha values on the
grid. Default to 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.root</code></td>
<td>
<p>whether the root is assumed to be random (TRUE) of fixed
(FALSE). Default to TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stationary.root</code></td>
<td>
<p>whether the root is assumed to be in the stationary 
state. Default to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>If the estimation is done with a fixed alpha (either known, or
on a grid), the possible value for alpha. Default to NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.tips.names</code></td>
<td>
<p>whether to check the tips names of the tree against
the column names of the data. Default to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress.bar</code></td>
<td>
<p>whether to display a progress bar of the computations.
Default to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimates</code></td>
<td>
<p>The result of a previous run of this same function. This
function can be re-run for other model election method. Default to NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save_step</code></td>
<td>
<p>If alpha_grid=TRUE, whether to save the intermediate results
for each value of alpha (in a temporary file). Useful for long computations.
Default to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_OU</code></td>
<td>
<p>For the Univariate OU, should the tree be re-scaled to use a BM ? 
This can speed up the computations a lot. However, it can make it harder for the EM to 
explore the space of parameters, and hence lead to a sub-optimal solution.
Default to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel_alpha</code></td>
<td>
<p>If alpha_grid=TRUE, whether to run the 
estimations with different values of alpha on separate cores. Default to 
FALSE. If TRUE, the log is written as a temporary file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ncores</code></td>
<td>
<p>If parallel_alpha=TRUE, number of cores to be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K_lag_init</code></td>
<td>
<p>Number of extra shifts to be considered at the initialization
step. Increases the accuracy, but can make computations quite slow of taken
too high. Default to 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>light_result</code></td>
<td>
<p>if TRUE (the default), the object returned is made light,
without easily computable quantities. If FALSE, the object can be very heavy, but
its subsequent manipulations can be faster (especially for plotting).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_tree</code></td>
<td>
<p>tolerance to consider a branch length significantly greater than zero, or
two lineages lengths to be different, when checking for ultrametry. 
(Default to .Machine$double.eps^0.5). See <code>is.ultrametric</code> and <code>di2multi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow_negative</code></td>
<td>
<p>whether to allow negative values for alpha (Early Burst).
See details. Default to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>option_is.ultrametric</code></td>
<td>
<p>option for <code>is.ultrametric</code> check. Default to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trait_correlation_threshold</code></td>
<td>
<p>the trait correlation threshold to stop the analysis. Default to 0.9.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to <code>estimateEM</code>, including
tolerance parameters for stopping criteria, maximal number of iterations, etc.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Several models can be used:
</p>

<ul>
<li>
<p> BM with fixed root, univariate or multivariate.
</p>
</li>
<li>
<p> OU with fixed or stationary root, univariate or multivariate.
</p>
</li>
</ul>
<p>For the OU in the multivariate setting, two assumptions can be made:
</p>

<ul>
<li>
<p> Independent traits. This amounts to diagonal rate and selection matrices.
</p>
</li>
<li>
<p> "Scalar OU" (scOU): the rate matrix can be full, but the selection 
strength matrix is assumed to be scalar, i.e. all the traits are supposed to
go to their optimum values with the same speed.
</p>
</li>
</ul>
<p>Note that the "scalar OU" model can also be seen as a re-scaling of the tree.
The selection strength parameter alpha can then be interpreted as a measure
of the "phylogenetic signal":
</p>

<ul>
<li>
<p> If alpha is close to 0, then the process is similar to a BM on the original tree,
and the signal is strong.
</p>
</li>
<li>
<p> If alpha is large, then the re-scaled tree is similar to a star-tree,
and the signal is weak.
</p>
</li>
</ul>
<p>When there are no shifts, and the root is taken to be constant, this
model is actually equivalent to an AC model (Uyeda et al. 2015).
With this interpretation in mind, one might want to explore 
negative values of alpha, in order to fit a DC (or Early Burst) model.
With no shift and a fixed root, the same proof shows that the scOU
with alpha negative is equivalent to the DC model. There are two
strong caveats in doing that.
</p>

<ul>
<li>
<p> The interpretation of the OU as modeling the dynamic of a trait
undergoing stabilizing selection is lost. In this case, the scOU can only
be seen as a re-scaling of the tree, similar to Pagel's delta.
</p>
</li>
<li>
<p> The values of the "optimal values", and of the shifts on them, cannot
be interpreted as such (the process is actually going away from this values,
instead of being attracted). When looking at these values, one should only use
the un-normalized values happening of the underlying BM. You can extract those
using the <code>params_process</code> function with <code>rBM = TRUE</code>.
</p>
</li>
</ul>
<h3>Value</h3>

<p>An object of class <code>PhyloEM</code>. Relevant quantities can be extracted from it 
using helper functions <code>params_process.PhyloEM</code>,
<code>imputed_traits.PhyloEM</code>
</p>


<h3>See Also</h3>

<p><code>plot.PhyloEM</code>, <code>params_process.PhyloEM</code>,
<code>imputed_traits.PhyloEM</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Load Data
data(monkeys)
## Run method
# Note: use more alpha values for better results.
res &lt;- PhyloEM(Y_data = monkeys$dat,        ## data
               phylo = monkeys$phy,         ## phylogeny
               process = "scOU",            ## scalar OU
               random.root = TRUE,          ## root is stationary
               stationary.root = TRUE,
               K_max = 10,                  ## maximal number of shifts
               nbr_alpha = 4,               ## number of alpha values
               parallel_alpha = TRUE,       ## parallelize on alpha values
               Ncores = 2)
## Plot selected solution (LINselect)
plot(res) # three shifts
## Plot selected solution (DDSE)
plot(res, method.selection = "DDSE") # no shift
## Extract and solution with 5 shifts
params_5 &lt;- params_process(res, K = 5)
plot(res, params = params_5)
## Show all equivalent solutions
eq_sol &lt;- equivalent_shifts(monkeys$phy, params_5)
plot(eq_sol)

## End(Not run)

</code></pre>


</div>
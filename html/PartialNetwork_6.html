<div class="container">

<table style="width: 100%;"><tr>
<td>mcmcARD</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate network model using ARD</h2>

<h3>Description</h3>

<p><code>mcmcARD</code> estimates the network model proposed by Breza et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class="language-R">mcmcARD(
  Y,
  traitARD,
  start,
  fixv,
  consb,
  iteration = 2000L,
  sim.d = TRUE,
  sim.zeta = TRUE,
  hyperparms = NULL,
  ctrl.mcmc = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>is a matrix of ARD. The entry (i, k) is the number of i's friends having the trait k.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>traitARD</code></td>
<td>
<p>is the matrix of traits for individuals with ARD. The entry (i, k) is equal to 1 if i has the trait k and 0 otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>is a list containing starting values of <code>z</code> (matrix of dimension <code class="reqn">N \times p</code>), <code>v</code> (matrix of dimension <code class="reqn">K \times p</code>),
<code>d</code> (vector of dimension <code class="reqn">N</code>), <code>b</code> (vector of dimension <code class="reqn">K</code>), <code>eta</code> (vector of dimension <code class="reqn">K</code>) and <code>zeta</code> (scalar).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixv</code></td>
<td>
<p>is a vector setting which location parameters are fixed for identifiability.
These fixed positions are used to rotate the latent surface back to a common orientation at each iteration using
a Procrustes transformation (see Section Identification in Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>consb</code></td>
<td>
<p>is a vector of the subset of <code class="reqn">\beta_k</code> constrained to the total size (see Section Identification in Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iteration</code></td>
<td>
<p>is the number of MCMC steps to be performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim.d</code></td>
<td>
<p>is logical indicating whether the degree <code>d</code> will be updated in the MCMC. If <code>sim.d = FALSE</code>,
the starting value of <code>d</code> in the argument <code>start</code> is set fixed along the MCMC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim.zeta</code></td>
<td>
<p>is logical indicating whether the degree <code>zeta</code> will be updated in the MCMC. If <code>sim.zeta = FALSE</code>,
the starting value of <code>zeta</code> in the argument <code>start</code> is set fixed along the MCMC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hyperparms</code></td>
<td>
<p>is an 8-dimensional vector of hyperparameters (in this order) <code class="reqn">\mu_d</code>,  <code class="reqn">\sigma_d</code>,
<code class="reqn">\mu_b</code>, <code class="reqn">\sigma_b</code>, <code class="reqn">\alpha_{\eta}</code>, <code class="reqn">\beta_{\eta}</code>,
<code class="reqn">\alpha_{\zeta}</code> and <code class="reqn">\beta_{\zeta}</code> (see Section Model in Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctrl.mcmc</code></td>
<td>
<p>is a list of MCMC controls (see Section MCMC control in Details).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The linking probability is given by
</p>


<h4>Model</h4>

<p style="text-align: center;"><code class="reqn">P_{ij} \propto \exp(\nu_i + \nu_j + \zeta\mathbf{z}_i\mathbf{z}_j).</code>
</p>

<p>McCormick and Zheng (2015) write the likelihood of the model with respect to the spherical coordinate <code class="reqn">\mathbf{z}_i</code>,
the trait locations <code class="reqn">\mathbf{v}_k</code>, the degree <code class="reqn">d_i</code>, the fraction of ties in the network that are
made with members of group k <code class="reqn">b_k</code>, the trait intensity parameter <code class="reqn">\eta_k</code> and <code class="reqn">\zeta</code>.
The following
prior distributions are defined.
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{z}_i \sim Uniform ~ von ~ Mises-Fisher</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{v}_k \sim Uniform ~ von ~ Mises-Fisher</code>
</p>

<p style="text-align: center;"><code class="reqn">d_i \sim log-\mathcal{N}(\mu_d, \sigma_d)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_k \sim log-\mathcal{N}(\mu_b, \sigma_b)</code>
</p>

<p style="text-align: center;"><code class="reqn">\eta_k \sim Gamma(\alpha_{\eta}, \beta_{\eta})</code>
</p>

<p style="text-align: center;"><code class="reqn">\zeta \sim Gamma(\alpha_{\zeta}, \beta_{\zeta})</code>
</p>




<h4>Identification</h4>

<p>For identification, some <code class="reqn">\mathbf{v}_k</code> and <code class="reqn">b_k</code> need to be exogenously fixed around their given starting value
(see McCormick and Zheng, 2015 for more details). The parameter <code>fixv</code> can be used
to set the desired value for <code class="reqn">\mathbf{v}_k</code> while <code>fixb</code> can be used to set the desired values for <code class="reqn">b_k</code>.<br></p>



<h4>MCMC control</h4>

<p>During the MCMC, the jumping scales are updated following Atchade and Rosenthal (2005) in order to target the acceptance rate of each parameter to the <code>target</code> values. This
requires to set minimal and maximal jumping scales through the parameter <code>ctrl.mcmc</code>. The parameter <code>ctrl.mcmc</code> is a list which can contain the following named components.
</p>

<ul>
<li>
<p><code>target</code>: The default value is <code>rep(0.44, 5)</code>.
The target of every <code class="reqn">\mathbf{z}_i</code>, <code class="reqn">d_i</code>, <code class="reqn">b_k</code>, <code class="reqn">\eta_k</code> and <code class="reqn">\zeta</code> is  0.44.
</p>
</li>
<li>
<p><code>jumpmin</code>: The default value is <code>c(0,1,1e-7,1e-7,1e-7)*1e-5</code>.
The minimal jumping of every <code class="reqn">\mathbf{z}_i</code> is 0, every <code class="reqn">d_i</code> is <code class="reqn">10^{-5}</code>, and every <code class="reqn">b_k</code>, <code class="reqn">\eta_k</code> and <code class="reqn">\zeta</code> is <code class="reqn">10^{-12}</code>.
</p>
</li>
<li>
<p><code>jumpmax</code>: The default value is <code>c(100,1,1,1,1)*20</code>. The maximal jumping scale is 20 except for <code class="reqn">\mathbf{z}_i</code> which is set to 2000.
</p>
</li>
<li>
<p><code>print</code>: A logical value which indicates if the MCMC progression should be printed in the console. The default value is <code>TRUE</code>.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>dimension of the sample with ARD.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>number of traits.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>hypersphere dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>elapsed time in second.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iteration</code></td>
<td>
<p>number of MCMC steps performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simulations</code></td>
<td>
<p>simulations from the posterior distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hyperparms</code></td>
<td>
<p>return value of hyperparameters (updated and non updated).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accept.rate</code></td>
<td>
<p>list of acceptance rates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>starting values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctrl.mcmc</code></td>
<td>
<p>return value of <code>ctrl.mcmc</code>.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">
  # Sample size
  N       &lt;- 500
  
  # ARD parameters
  genzeta &lt;- 1
  mu      &lt;- -1.35
  sigma   &lt;- 0.37
  K       &lt;- 12    # number of traits
  P       &lt;- 3     # Sphere dimension
  
  
  # Generate z (spherical coordinates)
  genz    &lt;- rvMF(N,rep(0,P))
  
  # Generate nu  from a Normal distribution with parameters mu and sigma (The gregariousness)
  gennu   &lt;- rnorm(N,mu,sigma)
  
  # compute degrees
  gend &lt;- N*exp(gennu)*exp(mu+0.5*sigma^2)*exp(logCpvMF(P,0) - logCpvMF(P,genzeta))
  
  # Link probabilities
  Probabilities &lt;- sim.dnetwork(gennu,gend,genzeta,genz)
  
  # Adjacency matrix
  G &lt;- sim.network(Probabilities)
  
  # Generate vk, the trait location
  genv &lt;- rvMF(K,rep(0,P))
  
  # set fixed some vk  distant
  genv[1,] &lt;- c(1,0,0)
  genv[2,] &lt;- c(0,1,0)
  genv[3,] &lt;- c(0,0,1)
  
  # eta, the intensity parameter
  geneta   &lt;-abs(rnorm(K,2,1))
  
  # Build traits matrix
  densityatz       &lt;- matrix(0,N,K)
  for(k in 1:K){
    densityatz[,k] &lt;- dvMF(genz,genv[k,]*geneta[k])
  }
  
  trait       &lt;- matrix(0,N,K)
  NK          &lt;- floor(runif(K, 0.8, 0.95)*colSums(densityatz)/apply(densityatz, 2, max))
  for (k in 1:K) {
    trait[,k]  &lt;- rbinom(N, 1, NK[k]*densityatz[,k]/sum(densityatz[,k]))
  }
  
  # print a percentage of people having a trait
  colSums(trait)*100/N
  
  # Build ARD
  ARD         &lt;- G %*% trait
  
  # generate b
  genb        &lt;- numeric(K)
  for(k in 1:K){
    genb[k]   &lt;- sum(G[,trait[,k]==1])/sum(G)
  }
  
  ############ ARD Posterior distribution ###################
  # initialization
  d0     &lt;- exp(rnorm(N)); b0 &lt;- exp(rnorm(K)); eta0 &lt;- rep(1,K);
  zeta0  &lt;- 05; z0 &lt;- matrix(rvMF(N,rep(0,P)),N); v0 &lt;- matrix(rvMF(K,rep(0,P)),K)
  
  # We need to fix some of the vk and bk for identification (see Breza et al. (2020) for details).
  vfixcolumn      &lt;- 1:6
  bfixcolumn      &lt;- c(3, 5)
  b0[bfixcolumn]  &lt;- genb[bfixcolumn]
  v0[vfixcolumn,] &lt;- genv[vfixcolumn,]
  start  &lt;- list("z" = z0, "v" = v0, "d" = d0, "b" = b0, "eta" = eta0, "zeta" = zeta0)
  
  # MCMC
  out   &lt;- mcmcARD(Y = ARD, traitARD = trait, start = start, fixv = vfixcolumn,
                   consb = bfixcolumn, iteration = 5000)
  
  # plot simulations
  # plot d
  plot(out$simulations$d[,100], type = "l", col = "blue", ylab = "")
  abline(h = gend[100], col = "red")
  
  # plot coordinates of individuals
  i &lt;- 123 # individual 123
  {
    lapply(1:3, function(x) {
      plot(out$simulations$z[i, x,] , type = "l", ylab = "", col = "blue", ylim = c(-1, 1))
      abline(h = genz[i, x], col = "red")
    })
  }
  
  # plot coordinates of traits
  k &lt;- 8
  {
    lapply(1:3, function(x) {
      plot(out$simulations$v[k, x,] , type = "l", ylab = "", col = "blue", ylim = c(-1, 1))
      abline(h = genv[k, x], col = "red")
    })
  }
</code></pre>


</div>
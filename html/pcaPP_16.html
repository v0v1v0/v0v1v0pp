<div class="container">

<table style="width: 100%;"><tr>
<td>PCAgrid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> (Sparse) Robust Principal Components using the Grid search algorithm </h2>

<h3>Description</h3>

<p>Computes a desired number of (sparse) (robust) principal components using 
the grid search algorithm in the plane.
The global optimum of the objective function is searched in planes, not in
the p-dimensional space, using regular grids in these planes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">PCAgrid (x, k = 2, method = c ("mad", "sd", "qn"),
         maxiter = 10, splitcircle = 25, scores = TRUE, zero.tol = 1e-16, 
	 center = l1median, scale, trace = 0, store.call = TRUE, control, ...)

sPCAgrid (x, k = 2, method = c ("mad", "sd", "qn"), lambda = 1,
          maxiter = 10, splitcircle = 25, scores = TRUE, zero.tol = 1e-16, 
	  center = l1median, scale, trace = 0, store.call = TRUE, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> a numerical matrix or data frame of dimension (<code>n x p</code>)which 
provides the data for the principal components analysis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p> the desired number of components to compute </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> the scale estimator used to detect the direction with the 
largest variance. Possible values are <code>"sd"</code>, <code>"mad"</code> and 
<code>"qn"</code>, the  latter can be called <code>"Qn"</code> too. <code>"mad"</code> is the 
default value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p> the sparseness constraint's strength(<code>sPCAgrid</code> only).
A single value for all components, or a vector of length <code>k</code> with 
different values for each component can be specified.
See <code>opt.TPO</code> for the choice of this argument. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splitcircle</code></td>
<td>
<p> the number of directions in which the algorithm should
search for the largest variance. The direction with the largest variance
is searched for in the directions defined by a number of equally spaced points
on the unit circle. This argument determines, how many such points are used to
split the unit circle. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p> A logical value indicating whether the scores of the
principal component should be calculated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.tol</code></td>
<td>
<p> the zero tolerance used internally for checking 
convergence, etc. </p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p> this argument indicates how the data is to be centered. It
can be a function like <code>mean</code> or <code>median</code> or a vector
of length <code>ncol(x)</code> containing the center value of each column. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p> this argument indicates how the data is to be rescaled. It
can be a function like <code>sd</code> or <code>mad</code> or a vector
of length <code>ncol(x)</code> containing the scale value of each column. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p> an integer value &gt;= 0, specifying the tracing level. </p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>store.call</code></td>
<td>
<p> a logical variable, specifying whether the function call
shall be stored in the result structure. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p> a list which elements must be the same as (or a subset of) 
the parameters above. If the control object is supplied, the parameters from 
it will be used and any other given parameters are overridden. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> further arguments passed to or from other functions. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In contrast to <code>PCAgrid</code>, the function <code>sPCAgrid</code> computes sparse
principal components. The strength of the applied sparseness constraint is
specified by argument <code>lambda</code>.


</p>
<p>Similar to the function <code>princomp</code>, there is a <code>print</code> method 
for the these objects that prints the results in a nice format and the 
<code>plot</code> method produces a scree plot (<code>screeplot</code>). There is 
also a <code>biplot</code> method.
</p>
<p>Angle halving is an extension of the original algorithm. In the original 
algorithm, the search directions are determined by a number of points on the
unit circle in the interval [-pi/2 ; pi/2). Angle halving means this angle is
halved in each iteration, eg. for the first approximation, the above mentioned
angle is used, for the second approximation, the angle is halved to 
[-pi/4 ; pi/4) and so on. This usually gives better results with less 
iterations needed. <br>
NOTE: in previous implementations angle halving could be suppressed by the 
former argument "<code>anglehalving</code>". This still can be done by setting 
argument <code>maxiter = 0</code>.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>"princomp"</code>, i.e. a list 
similar to the output of the function <code>princomp</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>sdev</code></td>
<td>
<p>the (robust) standard deviations of the principal components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>the matrix of variable loadings (i.e., a matrix whose columns
contain the eigenvectors).  This is of class <code>"loadings"</code>:
see <code>loadings</code> for its <code>print</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>the means that were subtracted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>the scalings applied to each variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.obs</code></td>
<td>
<p>the number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>if <code>scores = TRUE</code>, the scores of the supplied data on the
principal components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>A vector containing the objective functions values. For function
<code>PCAgrid</code> this is the same as <code>sdev</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The lambda each component has been calculated with 
(<code>sPCAgrid</code> only).</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>See the vignette "Compiling pcaPP for Matlab" which comes with this package to compile and use these functions in Matlab.</p>


<h3>Author(s)</h3>

<p>Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, M. Oliveira, (2007).
Algorithms for Projection-Pursuit Robust Principal Component Analysis,
<em>Chemometrics and Intelligent Laboratory Systems</em>, Vol. 87, pp. 218-225.
</p>
<p>C. Croux, P. Filzmoser, H. Fritz (2011).
Robust Sparse Principal Component Analysis Based on Projection-Pursuit,
<em>??</em> To appear.
</p>


<h3>See Also</h3>

 <p><code>PCAproj</code>, <code>princomp</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">  # multivariate data with outliers
  library(mvtnorm)
  x &lt;- rbind(rmvnorm(200, rep(0, 6), diag(c(5, rep(1,5)))),
             rmvnorm( 15, c(0, rep(20, 5)), diag(rep(1, 6))))
  # Here we calculate the principal components with PCAgrid
  pc &lt;- PCAgrid(x)
  # we could draw a biplot too:
  biplot(pc)
  # now we want to compare the results with the non-robust principal components
  pc &lt;- princomp(x)
  # again, a biplot for comparison:
  biplot(pc)

  ##  Sparse loadings
  set.seed (0)
  x &lt;- data.Zou ()

                   ##  applying PCA
  pc &lt;-  princomp (x)
                   ##  the corresponding non-sparse loadings
  unclass (pc$load[,1:3])
  pc$sdev[1:3]

                   ##  lambda as calculated in the opt.TPO - example
  lambda &lt;- c (0.23, 0.34, 0.005)
                   ##  applying sparse PCA
  spc &lt;- sPCAgrid (x, k = 3, lambda = lambda, method = "sd")
  unclass (spc$load)
  spc$sdev[1:3]

                   ## comparing the non-sparse and sparse biplot
  par (mfrow = 1:2)
  biplot (pc, main = "non-sparse PCs")
  biplot (spc, main = "sparse PCs")
</code></pre>


</div>
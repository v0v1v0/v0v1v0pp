<div class="container">

<table style="width: 100%;"><tr>
<td>fshift</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Shift the scale of a spectrum using a summary function</h2>

<h3>Description</h3>

<p>The <code>fshift()</code> methods return a spectral object of the same class as the
one supplied as argument but with the spectral data on a zero-shifted scale.
A range of wavelengths is taken as a zero reference and the summary
calculated with <code>f</code> for this waveband is substracted. This results in a
zero shift (= additive correction) to the values in the returned object.
Metadata attributes are retained unchanged.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fshift(x, ...)

## Default S3 method:
fshift(x, ...)

## S3 method for class 'source_spct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'response_spct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'filter_spct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  ...
)

## S3 method for class 'reflector_spct'
fshift(x, range = c(wl_min(x), wl_min(x) + 10), f = "min", qty.out = NULL, ...)

## S3 method for class 'source_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'raw_spct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  qty.out = NULL,
  ...
)

## S3 method for class 'cps_spct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  qty.out = NULL,
  ...
)

## S3 method for class 'generic_spct'
fshift(x, range = c(wl_min(x), wl_min(x) + 10), f = "mean", col.names, ...)

## S3 method for class 'response_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'filter_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'reflector_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  qty.out = NULL,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'raw_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'cps_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'generic_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  col.names,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An R object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional named arguments passed down to <code>f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p>An R object on which <code>range()</code> returns a numeric vector of
length 2 with the limits of a range of wavelengths in nm, with min and max
wavelengths (nm)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>character string "mean", "min" or "max" for scaling so that this
summary value becomes the origin of the spectral data scale in the returned
object, or the name of a function taking <code>x</code> as first argument and
returning a numeric value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit.out</code></td>
<td>
<p>character Allowed values "energy", and "photon", or its alias
"quantum"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qty.out</code></td>
<td>
<p>character Allowed values "transmittance", and "absorbance"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.names</code></td>
<td>
<p>character vector containing the names of columns or
variables to which to apply the scale shift.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A copy of <code>x</code> with the spectral data values replaced with values
zero-shifted.
</p>
<p>a new object of the same class as <code>x</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fshift(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>fshift(source_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(response_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(filter_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(reflector_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(source_mspct)</code>: 
</p>
</li>
<li> <p><code>fshift(raw_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(cps_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(generic_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(response_mspct)</code>: 
</p>
</li>
<li> <p><code>fshift(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>fshift(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>fshift(raw_mspct)</code>: 
</p>
</li>
<li> <p><code>fshift(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>fshift(generic_mspct)</code>: 
</p>
</li>
</ul>
<h3>Note</h3>

<p>Method <code>fshift</code> is not implemented for <code>solute_spct</code> objects
as the spectral data stored in them are a description of an intensive
property of a substance. To represent solutions of specific concentrations
of solutes, <code>filter_spct</code> objects can be used.
</p>


<h3>See Also</h3>

<p>Other rescaling functions: 
<code>fscale()</code>,
<code>getNormalized()</code>,
<code>getScaled()</code>,
<code>is_normalized()</code>,
<code>is_scaled()</code>,
<code>normalize()</code>,
<code>setNormalized()</code>,
<code>setScaled()</code>
</p>


</div>
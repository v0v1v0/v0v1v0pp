<div class="container">

<table style="width: 100%;"><tr>
<td>plrm.ancova</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Semiparametric analysis of covariance (based on PLR models)
</h2>

<h3>Description</h3>

<p>From samples <code class="reqn">{(Y_{ki}, X_{ki1}, ..., X_{kip}, t_i): i=1,...,n}</code>, <code class="reqn">k=1,...,L</code>, this routine tests the null hypotheses <code class="reqn">H0: \beta_1 = ... = \beta_L</code> and <code class="reqn">H0: m_1 = ... = m_L</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">\beta_k = (\beta_{k1},...,\beta_{kp})</code>
</p>

<p>is an unknown vector parameter;
</p>
<p style="text-align: center;"><code class="reqn">m_k(.)</code>
</p>

<p>is a smooth but unknown function and
</p>
<p style="text-align: center;"><code class="reqn">Y_{ki}= X_{ki1}*\beta_{k1} +...+ X_{kip}*\beta_{kp} + m(t_i) + \epsilon_{ki}.</code>
</p>

<p>Fixed equally spaced design is considered for the "nonparametric" explanatory variable, <code class="reqn">t</code>, and the random errors, <code class="reqn">\epsilon_{ki}</code>, are allowed to be time series. The test statistic used for testing <code class="reqn">H0: \beta_1 = ...= \beta_L</code> derives from the asymptotic normality of an estimator of <code class="reqn">\beta_k</code> (<code class="reqn">k=1,...,L</code>) based on both ordinary least squares and kernel smoothing (this result giving a <code class="reqn">\chi^2</code>-test). The test statistic used for testing <code class="reqn">H0: m_1 = ...= m_L</code> derives from a Cramer-von-Mises-type functional based on different distances between nonparametric estimators of <code class="reqn">m_k</code> (<code class="reqn">k=1,...,L</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">plrm.ancova(data = data, t = t, b.seq = NULL, h.seq = NULL, 
w = NULL, estimator = "NW", kernel = "quadratic", 
time.series = FALSE, Var.Cov.eps = NULL, Tau.eps = NULL, 
b0 = NULL, h0 = NULL, lag.max = 50, p.max = 3, q.max = 3,
ic = "BIC", num.lb = 10, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p><code>data[, 1, k]</code> contains the values of the response variable, <code class="reqn">Y_k</code>, for each model <code class="reqn">k</code> (<code class="reqn">k=1, ..., L</code>);
</p>
<p><code>data[, 2:(p+1), k]</code> contains the values of the "linear" explanatory variables, <code class="reqn">X_{k1}, ..., X_{kp}</code>, for each model k (<code class="reqn">k=1, ..., L</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>contains the values of the "nonparametric" explanatory (common) variable, <code class="reqn">t</code>, for each model <code class="reqn">k</code> (<code class="reqn">k=1, ..., L</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.seq</code></td>
<td>
<p>the statistic test for <code class="reqn">H0: \beta_1 = ... = \beta_L</code> is performed using each bandwidth in the vector <code>b.seq</code>. If <code>NULL</code> (the default) but <code>h.seq</code> is not <code>NULL</code>, it takes <code>b.seq=h.seq</code>. If both <code>b.seq</code> and <code>h.seq</code> are <code>NULL</code>, 10 equidistant values between zero and a quarter of the range of <code class="reqn">{t_i}</code> are considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h.seq</code></td>
<td>
<p>the statistic test for <code class="reqn">H0: m_1 = ... = m_L</code> is performed using each pair of bandwidths (<code>b.seq[j], h.seq[j]</code>). If <code>NULL</code> (the default) but <code>b.seq</code> is not <code>NULL</code>, it takes <code>h.seq=b.seq</code>. If both <code>b.seq</code> and <code>h.seq</code> are <code>NULL</code>, 10 equidistant values between zero and a quarter of the range of <code class="reqn">{t_i}</code> are considered for both <code>b.seq</code> and  <code>h.seq</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>support interval of the weigth function in the test statistic for <code class="reqn">H0: m_1 = ... = m_L</code>. If <code>NULL</code> (the default), <code class="reqn">(q_{0.1}, q_{0.9})</code> is considered, where <code class="reqn">q_p</code> denotes the quantile of order <code class="reqn">p</code> of <code class="reqn">{t_i}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimator</code></td>
<td>
<p>allows us the choice between “NW” (Nadaraya-Watson) or “LLP” (Local Linear Polynomial). The default is “NW”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>allows us the choice between “gaussian”, “quadratic” (Epanechnikov kernel), “triweight” or “uniform” kernel. The default is “quadratic”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.series</code></td>
<td>
<p>it denotes whether the data are independent (FALSE) or if data is a time series (TRUE). The default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Var.Cov.eps</code></td>
<td>
<p><code>Var.Cov.eps[, , k]</code> contains the <code>n x n</code> matrix of variances-covariances associated to the random errors of the regression model k (<code class="reqn">k=1, ..., L</code>). If NULL (the default), the function tries to estimate it: it fits an ARMA model (selected according to an information criterium) to the residuals from the fitted regression model and, then, it obtains the var-cov matrix of such ARMA model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tau.eps</code></td>
<td>
<p><code>Tau.eps[k]</code> contains the sum of autocovariances associated to the random errors of the regression model <code class="reqn">k</code> (<code class="reqn">k=1, ..., L</code>). If NULL (the default), the function tries to estimate it: it fits an ARMA model (selected according to an information criterium) to the residuals from the fitted regression model and, then, it obtains the sum of the autocovariances of such ARMA model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, <code>b0</code> contains the pilot bandwidth for the estimator of <code class="reqn">\beta_k</code> (<code class="reqn">k=1, ..., L</code>) used for obtaining the residuals to construct the default for <code>Var.Cov.eps</code> and/or <code>Tau.eps</code>. If <code>NULL</code> (the default) but <code>h0</code> is not <code>NULL</code>, it takes <code>b0=h0</code>. If both <code>b0</code> and <code>h0</code> are <code>NULL</code>, a quarter of the range of <code class="reqn">{t_i}</code> is considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h0</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, (<code>b0, h0</code>) contains the pair of pilot bandwidths  for the estimator of <code class="reqn">m_k</code> (<code class="reqn">k=1, ..., L</code>) used for obtaining the residuals to construct the default for <code>Var.Cov.eps</code> and/or <code>Tau.eps</code>. If <code>NULL</code> (the default) but <code>b0</code> is not <code>NULL</code>, it takes <code>h0=b0</code>. If both <code>b0</code> and <code>h0</code> are <code>NULL</code>, a quarter of the range of <code class="reqn">{t_i}</code> is considered for both <code>b0</code> and  <code>h0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag.max</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, <code>lag.max</code> contains the maximum delay used to construct the default for <code>Tau.eps</code>. The default is 50.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, the ARMA models are selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, the ARMA models are selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, <code>ic</code> contains the information criterion used to suggest the ARMA models. It allows us to choose between: "AIC", "AICC" or "BIC" (the default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.lb</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, it checks the suitability of the selected ARMA models according to the Ljung-Box test and the t-test. It uses up to <code>num.lb</code> delays in the Ljung-Box test. The default is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, <code>alpha</code> contains the significance level which the ARMA models are checked. The default is 0.05.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A weight function (specifically, the indicator function <b>1</b><code class="reqn">_{[w[1] , w[2]]}</code>) is introduced in the test statistic for testing <code class="reqn">H0: m_1 = ... = m_L</code> to allow elimination (or at least significant reduction) of boundary effects from the estimate of <code class="reqn">m_k(t_i)</code>.
</p>
<p>If <code>Var.Cov.eps=NULL</code> and the routine is not able to suggest an approximation for <code>Var.Cov.eps</code>, it warns the user with a message saying that the model could be not appropriate and then it shows the results. In order to construct <code>Var.Cov.eps</code>, the procedure suggested in Aneiros-Perez and Vieu (2013) can be followed.
</p>
<p>If <code>Tau.eps=NULL</code> and the routine is not able to suggest an approximation for <code>Tau.eps</code>, it warns the user with a message saying that the model could be not appropriate and then it shows the results. In order to construct <code>Tau.eps</code>, the procedures suggested in Aneiros-Perez (2008) can be followed.
</p>
<p>Expressions for the implemented statistic tests can be seen in (15) and (16) in Aneiros-Perez (2008).
</p>


<h3>Value</h3>

<p>A list with two dataframes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>parametric.test</code></td>
<td>
<p>a dataframe containing the bandwidths, the statistics and the p-values when one tests <code class="reqn">H0: \beta_1 = ...= \beta_L</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonparametric.test</code></td>
<td>
<p>a dataframe containing the bandwidths b and h, the statistics, the normalised statistics and the p-values when one tests <code class="reqn">H0: m_1 = ...= m_L</code>.</p>
</td>
</tr>
</table>
<p>Moreover, if <code>data</code> is a time series and <code>Tau.eps</code> or <code>Var.Cov.eps</code> are not especified:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>pv.Box.test</code></td>
<td>
<p>p-values of the Ljung-Box test for the model fitted to the residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pv.t.test</code></td>
<td>
<p>p-values of the t.test for the model fitted to the residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar.ma</code></td>
<td>
<p>ARMA orders for the model fitted to the residuals.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Aneiros-Perez, G. (2008) Semi-parametric analysis of covariance under dependence conditions within each group. <em>Aust. N. Z. J. Stat.</em> <b>50</b>, 97-123.
</p>
<p>Aneiros-Perez, G. and Vieu, P. (2013) Testing linearity in semi-parametric functional data analysis. <em>Comput. Stat.</em> <b>28</b>, 413-434. 
</p>


<h3>See Also</h3>

<p>Other related functions are <code>plrm.est</code>, <code>par.ancova</code> and <code>np.ancova</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data,1:nrow(data))

data(barnacles2)
data2 &lt;- as.matrix(barnacles2)
data2 &lt;- diff(data2, 12)
data2 &lt;- cbind(data2,1:nrow(data2))

data3 &lt;- array(0, c(nrow(data),ncol(data)-1,2))
data3[,,1] &lt;- data[,-4]
data3[,,2] &lt;- data2[,-4]
t &lt;- data[,4]

plrm.ancova(data=data3, t=t)



# EXAMPLE 2: SIMULATED DATA
## Example 2a: dependent data - true null hypotheses

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
beta &lt;- c(0.05, 0.01)

m1 &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m1(t)
x1 &lt;- matrix(rnorm(200,0,1), nrow=n)
sum1 &lt;- x1%*%beta
epsilon1 &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y1 &lt;-  sum1 + f + epsilon1
data1 &lt;- cbind(y1,x1)

x2 &lt;- matrix(rnorm(200,1,2), nrow=n)
sum2 &lt;- x2%*%beta
epsilon2 &lt;- arima.sim(list(order = c(0,0,1), ma=0.5), sd = 0.02, n = n)
y2 &lt;- sum2 + f + epsilon2
data2 &lt;- cbind(y2,x2)

data_eq &lt;- array(c(data1,data2), c(n,3,2))

# We apply the tests
plrm.ancova(data=data_eq, t=t, time.series=TRUE)


## Example 2b: dependent data - false null hypotheses

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
m3 &lt;- function(t) {0.25*t*(1-t)}
m4 &lt;- function(t) {0.25*t*(1-t)*0.75}
beta3 &lt;- c(0.05, 0.01)
beta4 &lt;- c(0.05, 0.02)

x3 &lt;- matrix(rnorm(200,0,1), nrow=n)
sum3 &lt;- x3%*%beta3
f3 &lt;- m3(t)
epsilon3 &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y3 &lt;-  sum3 + f3 + epsilon3
data3 &lt;- cbind(y3,x3)

x4 &lt;- matrix(rnorm(200,1,2), nrow=n)
sum4 &lt;- x4%*%beta4
f4 &lt;- m4(t)
epsilon4 &lt;- arima.sim(list(order = c(0,0,1), ma=0.5), sd = 0.02, n = n)
y4 &lt;-  sum4 + f4 + epsilon4
data4 &lt;- cbind(y4,x4)

data_neq &lt;- array(c(data3,data4), c(n,3,2))

# We apply the tests
plrm.ancova(data=data_neq, t=t, time.series=TRUE)

</code></pre>


</div>
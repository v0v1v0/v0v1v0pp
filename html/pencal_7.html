<div class="container">

<table style="width: 100%;"><tr>
<td>fit_prcmlpmm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Step 3 of PRC-MLPMM (estimation of the penalized Cox model(s))</h2>

<h3>Description</h3>

<p>This function performs the third step for the estimation
of the PRC-MLPMM model proposed in Signorelli et al. (2021)
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit_prcmlpmm(object, surv.data, baseline.covs = NULL, include.b0s = TRUE,
  penalty = "ridge", standardize = TRUE, pfac.base.covs = 0,
  cv.seed = 19920207, n.alpha.elnet = 11, n.folds.elnet = 5,
  n.cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>the output of step 2 of the PRC-MLPMM procedure, 
as produced by the <code>summarize_mlpmms</code> function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>surv.data</code></td>
<td>
<p>a data frame with the survival data and (if 
relevant) additional baseline covariates. <code>surv.data</code> should at least
contain a subject id (called <code>id</code>), the time to event outcome  
(<code>time</code>), and binary event variable (<code>event</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>baseline.covs</code></td>
<td>
<p>a formula specifying the variables 
(e.g., baseline age) in <code>surv.data</code> that should be included 
as baseline covariates in the penalized Cox model. Example:
<code>baseline.covs = '~ baseline.age'</code>. Default is <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.b0s</code></td>
<td>
<p>logical. If <code>TRUE</code>, the PRC-MLPMM(U+B) model
is estimated; if <code>FALSE</code>, the PRC-MLPMM(U) model is estimated. See
Signorelli et al. (2021) for details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>the type of penalty function used for regularization.
Default is <code>'ridge'</code>, other possible values are <code>'elasticnet'</code> 
and <code>'lasso'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>logical argument: should the predicted random effects
be standardized when included in the penalized Cox model? Default is <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pfac.base.covs</code></td>
<td>
<p>a single value, or a vector of values, indicating
whether the baseline covariates (if any) should be penalized (1) or not (0).
Default is <code>pfac.base.covs = 0</code> (no penalization of all baseline covariates)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.seed</code></td>
<td>
<p>value of the random seed to use for the cross-validation
done to select the optimal value of the tuning parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.alpha.elnet</code></td>
<td>
<p>number of alpha values for the two-dimensional 
grid of tuning parameteres in elasticnet.
Only relevant if <code>penalty = 'elasticnet'</code>. Default is 11,
so that the resulting alpha grid is c(1, 0.9, 0.8, ..., 0.1, 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.folds.elnet</code></td>
<td>
<p>number of folds to be used for the selection
of the tuning parameter in elasticnet. Only relevant if 
<code>penalty = 'elasticnet'</code>. Default is 5</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>number of cores to use to parallelize part of
the computations. If <code>ncores = 1</code> (default), no parallelization is done. 
Pro tip: you can use <code>parallel::detectCores()</code> to check 
how many cores are available on your computer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code> (default and recommended value), information
on the ongoing computations is printed in the console</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>call</code>: the function call
</p>
</li>
<li> <p><code>pcox.orig</code>: the penalized Cox model fitted on the
original dataset;
</p>
</li>
<li> <p><code>tuning</code>: the values of the tuning parameter(s) selected through 
cross-validation
</p>
</li>
<li> <p><code>surv.data</code>: the supplied survival data (ordered by
subject id)
</p>
</li>
<li> <p><code>n.boots</code>: number of bootstrap samples;
</p>
</li>
<li> <p><code>boot.ids</code>: a list with the ids of bootstrapped subjects 
(when <code>n.boots &gt; 0</code>);
</p>
</li>
<li> <p><code>pcox.boot</code>: a list where each element is a fitted penalized
Cox model for a given bootstrap sample (when <code>n.boots &gt; 0</code>).
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2024). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors. 
To appear in: The R Journal. Preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code>fit_mlpmms</code> (step 1), 
<code>summarize_mlpmms</code> (step 2),
<code>performance_prc</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# generate example data
set.seed(123)
n.items = c(4,2,2,3,4,2)
simdata = simulate_prcmlpmm_data(n = 100, p = length(n.items),  
             p.relev = 3, n.items = n.items, 
             type = 'u+b', seed = 1)
 
# specify options for cluster bootstrap optimism correction
# procedure and for parallel computing 
do.bootstrap = FALSE
# IMPORTANT: set do.bootstrap = TRUE to compute the optimism correction!
n.boots = ifelse(do.bootstrap, 100, 0)
more.cores = FALSE
# IMPORTANT: set more.cores = TRUE to speed computations up!
if (!more.cores) n.cores = 2
if (more.cores) {
   # identify number of available cores on your machine
   n.cores = parallel::detectCores()
   if (is.na(n.cores)) n.cores = 2
}

# step 1 of PRC-MLPMM: estimate the MLPMMs
y.names = vector('list', length(n.items))
for (i in 1:length(n.items)) {
  y.names[[i]] = paste('marker', i, '_', 1:n.items[i], sep = '')
}

step1 = fit_mlpmms(y.names, fixefs = ~ contrast(age),  
                 ranef.time = age, randint.items = TRUE, 
                 long.data = simdata$long.data, 
                 surv.data = simdata$surv.data,
                 t.from.base = t.from.base,
                 n.boots = n.boots, n.cores = n.cores)

# step 2 of PRC-MLPMM: compute the summaries 
step2 = summarize_mlpmms(object = step1, n.cores = n.cores)

# step 3 of PRC-LMM: fit the penalized Cox models
step3 = fit_prcmlpmm(object = step2, surv.data = simdata$surv.data,
                   baseline.covs = ~ baseline.age,
                   include.b0s = TRUE,
                   penalty = 'ridge', n.cores = n.cores)
summary(step3)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>Service</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Service</h2>

<h3>Description</h3>

<p>This is an interface that defines the operations available on a
<code>Backend</code> implementation. Backend implementations and the
<code>Context</code> class must implement this interface.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Service-new"><code>Service$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Service-start"><code>Service$start()</code></a>
</p>
</li>
<li> <p><a href="#method-Service-stop"><code>Service$stop()</code></a>
</p>
</li>
<li> <p><a href="#method-Service-clear"><code>Service$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-Service-peek"><code>Service$peek()</code></a>
</p>
</li>
<li> <p><a href="#method-Service-export"><code>Service$export()</code></a>
</p>
</li>
<li> <p><a href="#method-Service-evaluate"><code>Service$evaluate()</code></a>
</p>
</li>
<li> <p><a href="#method-Service-sapply"><code>Service$sapply()</code></a>
</p>
</li>
<li> <p><a href="#method-Service-lapply"><code>Service$lapply()</code></a>
</p>
</li>
<li> <p><a href="#method-Service-apply"><code>Service$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-Service-get_output"><code>Service$get_output()</code></a>
</p>
</li>
<li> <p><a href="#method-Service-clone"><code>Service$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-Service-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>Service</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Service$new()</pre></div>



<h5>Returns</h5>

<p>Instantiating this call will throw an error.
</p>


<hr>
<a id="method-Service-start"></a>



<h4>Method <code>start()</code>
</h4>

<p>Start the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Service$start(specification)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification</code></dt>
<dd>
<p>An object of class <code>Specification</code>
that contains the backend configuration.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The resulting backend must be stored in the
<code>.cluster</code> private field on the <code>Backend</code> abstract class,
and accessible to any concrete backend implementations via the active
binding <code>cluster</code>.
</p>


<hr>
<a id="method-Service-stop"></a>



<h4>Method <code>stop()</code>
</h4>

<p>Stop the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Service$stop()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-Service-clear"></a>



<h4>Method <code>clear()</code>
</h4>

<p>Remove all objects from the backend. This function is equivalent to
calling <code>rm(list = ls(all.names = TRUE))</code> on each node in the
backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Service$clear()</pre></div>



<h5>Details</h5>

<p>This method is ran by default when the backend is started.
</p>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-Service-peek"></a>



<h4>Method <code>peek()</code>
</h4>

<p>Inspect the backend for variables available in the <code>.GlobalEnv</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Service$peek()</pre></div>



<h5>Returns</h5>

<p>This method returns a list of character vectors, where each element
corresponds to a node in the backend. The character vectors contain
the names of the variables available in the <code>.GlobalEnv</code> on each
node.
</p>


<hr>
<a id="method-Service-export"></a>



<h4>Method <code>export()</code>
</h4>

<p>Export variables from a given environment to the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Service$export(variables, environment)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>variables</code></dt>
<dd>
<p>A character vector of variable names to export.</p>
</dd>
<dt><code>environment</code></dt>
<dd>
<p>An environment object from which to export the
variables.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-Service-evaluate"></a>



<h4>Method <code>evaluate()</code>
</h4>

<p>Evaluate an arbitrary expression on the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Service$evaluate(expression)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expression</code></dt>
<dd>
<p>An unquoted expression to evaluate on the backend.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns the result of the expression evaluation.
</p>


<hr>
<a id="method-Service-sapply"></a>



<h4>Method <code>sapply()</code>
</h4>

<p>Run a task on the backend akin to <code>parallel::parSapply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Service$sapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code>Backend</code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-Service-lapply"></a>



<h4>Method <code>lapply()</code>
</h4>

<p>Run a task on the backend akin to <code>parallel::parLapply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Service$lapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code>Backend</code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-Service-apply"></a>



<h4>Method <code>apply()</code>
</h4>

<p>Run a task on the backend akin to <code>parallel::parApply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Service$apply(x, margin, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>An array to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>margin</code></dt>
<dd>
<p>A numeric vector indicating the dimensions of <code>x</code> the
<code>fun</code> function should be applied over. For example, for a matrix,
<code>margin = 1</code> indicates applying <code>fun</code> rows-wise, <code>margin = 2</code>
indicates applying <code>fun</code> columns-wise, and <code>margin = c(1, 2)</code>
indicates applying <code>fun</code> element-wise. Named dimensions are also
possible depending on <code>x</code>. See <code>parallel::parApply()</code> and
<code>base::apply()</code> for more details.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to <code>x</code> according to the <code>margin</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code>Backend</code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-Service-get_output"></a>



<h4>Method <code>get_output()</code>
</h4>

<p>Get the output of the task execution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Service$get_output(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Additional optional arguments that may be used by concrete
implementations.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>This method fetches the output of the task execution after calling
the <code>sapply()</code> method. It returns the output and immediately removes
it from the backend. Therefore, subsequent calls to this method are
not advised. This method should be called after the execution of a
task.
</p>



<h5>Returns</h5>

<p>A vector, matrix, or list of the same length as <code>x</code>, containing the
results of the <code>fun</code>. The output format differs based on the specific
operation employed. Check out the documentation for the <code>apply</code>
operations of <code>parallel::parallel</code> for more information.
</p>


<hr>
<a id="method-Service-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Service$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p><code>Backend</code>, <code>SyncBackend</code>, <code>AsyncBackend</code>,
and <code>Context</code>.
</p>


</div>
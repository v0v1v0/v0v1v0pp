<div class="container">

<table style="width: 100%;"><tr>
<td>phipt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Distances between communities, auxiliary functions</h2>

<h3>Description</h3>

<p>Auxiliary functions for <code>communitydist</code>. <code>phipt</code>
computes phiPT/phiST (Peakall and Smouse, 2012, Meirmans,
2006) between two communities. <code>cfchord</code> computes the
chord-distance (Cavalli-Sforza and Edwards, 1967) between two lists or
locus-wise relative allele frequencies. <code>shared.problist</code>
computes a straightforward generalisation of the shared allele
distance (Bowcock et al., 1994) between
individuals for communities, namely the ‘overlap’, i.e., sum of the
minima of the
allele relative frequencies. <code>diploidcomlist</code> constructs the
input lists for <code>cfchord</code> and <code>shared.problist</code> from an
<code>alleleobject</code>. It provides relative frequencies for all
alles of all loci in all communities. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">
phipt(alleleobj,comvector,i,j)
cfchord(p1,p2)
shared.problist(p1,p2)
diploidcomlist(alleleobj,comvector,diploid=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>alleleobj</code></td>
<td>
<p>if <code>diploid=TRUE</code>, an object of class
<code>alleleobject</code> as produced by
function  <code>alleleinit</code>. This has the required
information on the individuals that are grouped into communities. In
case <code>diploid=FALSE</code>, a list that needs to have components
<code>n.variables</code> (number of loci), <code>alevels</code> (vector of
allele names, see <code>alleleinit</code>) and
<code>charmatrix</code> (matrix of characters with one row for every
individual and one column for every locus giving the alleles; see
examples below for how this can be constructed for a
<code>prabobject</code> with presence-absence data).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comvector</code></td>
<td>
<p>vector of integers indicating to which
community an individual belongs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>integer. Number of community.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>j</code></td>
<td>
<p>integer. Number of community. The phiPT-distance is computed
between the communities numbered <code>i</code> and <code>j</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p1</code></td>
<td>
<p>list. Every list entry refers to a locus and is a vector of
relative frequencies of the alleles present in that locus in a
community.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p2</code></td>
<td>
<p>list. Every list entry refers to a locus and is a vector of
relative frequencies of the alleles present in that locus in a
community. The chord or shared allele distance is computed between
the communities encoded by <code>p1</code> and <code>p2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diploid</code></td>
<td>
<p>logical, indicating whether loci are diploid, see
<code>alleleobj</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>cfchord</code> gives out the value of the chord
distance. <code>shared.problist</code> gives out the distance
value. <code>diploidcomlist</code> gives out a two-dimensional list. The
list has one entry for each community, which is itself a list. This
community list has one entry for each locus, which is a vector that
gives the relative frequencies of the different alleles in    
<code>phipt</code> gives out a list with components <code>phipt, vap, n0,
  sst, ssg, msa, msw</code>. These refer to the notation on p.2.12 and 2.15 of
Peakall and Smouse (2012).
</p>
<table>
<tr style="vertical-align: top;">
<td><code>phipt</code></td>
<td>
<p>value of phiPT.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vap</code></td>
<td>
<p>variance among (between) populations (communities).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n0</code></td>
<td>
<p>standardisation factor N0, see  p.2.12 of Peakall and Smouse (2012).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sst</code></td>
<td>
<p>total distances sum of squares.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssg</code></td>
<td>
<p>vector with two non-<code>NA</code> entriesm, within community
sums of squares for communities <code>i</code> and <code>j</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msa</code></td>
<td>
<p>mean square between communities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msw</code></td>
<td>
<p>mean square within communities.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Bowcock, A. M., Ruiz-Linares, A., Tomfohrde, J., Minch, E., Kidd, J. R.,
Cavalli-Sforza, L. L. (1994) High resolution of human evolutionary
trees with polymorphic microsatellites. <em>Nature</em> 368, 455-457.
</p>
<p>Cavalli-Sforza, L. L. and Edwards, A. W. F. (1967) Phylogenetic
Analysis - Models and Estimation Procedures. <em>The American Journal of
Human Genetics</em> 19, 233-257.
</p>
<p>Meirmans, P. G. (2006) Using the AMOVA framework to estimate a
standardized genetic differentiation measure. <em>Evolution</em> 60, 2399-2402.
</p>
<p>Peakall, R. and Smouse P.E. (2012) GenAlEx Tutorial 2.
<a href="https://biology-assets.anu.edu.au/GenAlEx/Tutorials.html">https://biology-assets.anu.edu.au/GenAlEx/Tutorials.html</a>
</p>


<h3>See Also</h3>

<p><code>communitydist</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  options(digits=4)
  data(tetragonula)
  tnb &lt;-
  coord2dist(coordmatrix=tetragonula.coord[83:120,],cut=50,file.format="decimal2",neighbors=TRUE)
  ta &lt;- alleleconvert(strmatrix=tetragonula[83:120,])
  tai &lt;- alleleinit(allelematrix=ta,neighborhood=tnb$nblist)
  tetracoms &lt;-
  c(rep(1:3,each=3),4,5,rep(6:11,each=2),12,rep(13:19,each=2))
  phipt(tai,tetracoms,4,6)
  tdip &lt;- diploidcomlist(tai,tetracoms,diploid=TRUE)
  cfchord(tdip[[4]],tdip[[6]])
  shared.problist(tdip[[4]],tdip[[6]])
  
</code></pre>


</div>
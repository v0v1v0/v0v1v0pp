<div class="container">

<table style="width: 100%;"><tr>
<td>equate-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>IRT True Score and Observed Score Equating</h2>

<h3>Description</h3>

<p>This function conducts IRT true score and observed score equating for unidimensional 
single-format or mixed-format item parameters for two or more groups.  This function
supports all item response models available in <code>plink</code> with the exception of 
the multiple-choice model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">equate(x, method=c("TSE", "OSE"), true.scores, ts.low, base.grp=1, score=1, 
  startval, weights1, weights2, syn.weights, exclude, max.tse.iter, ...) 

## S4 method for signature 'list'
equate(x, method, true.scores, ts.low, base.grp, score, startval, 
  weights1, weights2, syn.weights, exclude, max.tse.iter, ...)

## S4 method for signature 'irt.pars', 'ANY'
equate(x, method, true.scores, ts.low, base.grp, score, startval, 
  weights1, weights2, syn.weights, exclude, max.tse.iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>irt.pars</code> with one or more groups,
a list containing two or more <code>irt.pars</code> objects (e.g., when there
are no common items), or the output from <code>plink</code> containing rescaled item parameters. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character vector identifying the equating method(s) to use. 
Values can include <code>"TSE"</code> and <code>"OSE"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>true.scores</code></td>
<td>
<p>numeric vector of true score values to be equated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ts.low</code></td>
<td>
<p>logical value. If TRUE, interpolate values for the equated 
true scores in the range of observed scores from one to the value below 
the lowest estimated true score (a rounded sum of guessing parameters)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base.grp</code></td>
<td>
<p>integer identifying the group for the base scale</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>if <code>score</code> = 1, score responses for the true-score equating
method with zero for the lowest category and k-1 for the highest, k, category
for each item.  If <code>score</code> = 2, score responses with one for the
lowest category and k for the highest, k, category for each item.  A vector or
list of scoring weights for each response category can be supplied, but this is 
only recommended for advanced users.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startval</code></td>
<td>
<p>integer starting value for the first value of <code>true.score</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights1</code></td>
<td>
<p>list containing information about the theta values and weights
to be used in the observed score equating for population 1. See below for more 
details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights2</code></td>
<td>
<p>list containing information about the theta values and weights
to be used in the observed score equating for population 2. See below for more 
details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>syn.weights</code></td>
<td>
<p>vector of length two or a list containing vectors of length two
with synthetic population weights to be used for each pair of tests for populations 
1 and 2 respectively. If missing, weights of 0.5 will be used for both populations
for all groups.  If <code>syn.weights</code> is a list, there should be k-1 elements for
k groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>character vector or list identifying common items that should be
excluded when estimating the linking constants. See below for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.tse.iter</code></td>
<td>
<p>maximum number of iterations to identify the theta value associated
with each true score. The default is 50.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods. See below for details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>weights1</code> can be a list or a list of lists.  The purpose of this object is to specify
the theta values for population 1 to integrate over in the observed score equating as well as 
any weights associated with the theta values.  The function <code>as.weight</code> 
can be used to facilitate the creation of this object.  If <code>weights1</code> is missing, the 
default is to use equally spaced theta values ranging from -4 to 4 with an increment of 0.05 
and normal density weights for all groups.
</p>
<p>To better understand the elements of <code>weights1</code>, let us assume for a moment that <code>x</code>
has parameters for only two groups.  In this instance, <code>weights1</code> would be a single list 
with length two.  The first element should be a vector of theta values corresponding to points 
on the base scale.  The second list element should be a vector of weights corresponding the 
theta values.  If <code>x</code> contains more than two groups, a single <code>weights1</code> object can 
be supplied, and the same set of thetas and weights will be used for all adjacent groups.  
However, a separate list of theta values and weights for each adjacent group in <code>x</code> can be 
supplied.
</p>
<p>The specification of <code>weights2</code> is the same as that for <code>weights1</code>, although the 
theta values and weights for this object correspond to theta values for population 2.
This argument is only used when the synthetic weight associated with population 2 is greater
than zero. If <code>weights2</code> is missing, the same theta values and weights used for 
<code>weights1</code> will be used for <code>weights2</code>.
</p>
<p>For both equating methods, response probabilities are computed using the functions <code>drm</code>, 
<code>grm</code>, <code>gpcm</code>, and <code>nrm</code> for the associated models respectively. Various 
arguments from these functions can be passed to <code>equate</code>. Specifically, the argument 
<code>incorrect</code> can be passed to <code>drm</code> and <code>catprob</code> can be passed to <code>grm</code>. 
In the functions <code>drm</code>, <code>grm</code>, and <code>gpcm</code> there is an argument <code>D</code>
for the value of a scaling constant. In <code>plink</code>, a single argument <code>D</code> can be passed
that will be applied to all applicable models, or arguments <code>D.drm</code>, <code>D.grm</code>, and 
<code>D.gpcm</code> can be specified for each model respectively. If an argument is specified for <code>D</code>
and, say <code>D.drm</code>, the values for <code>D.grm</code> and <code>D.gpcm</code> (if applicable) will be
set equal to <code>D</code>. If only <code>D.drm</code> is specified, the values for <code>D.grm</code> and 
<code>D.gpcm</code> (if applicable) will be set to 1.
</p>
<p>There are instances where certain items should not be included in the computation of total scores
(e.g., when the common items correspond to an external anchor test or when using field test items)
The <code>exclude</code> argument can be used to remove these items prior to conducting the equationg. 
<code>exclude</code> can be specified as a character vector or a list. In the former case, a single value
"all.common" can be used to remove all common items or a vector of model names (i.e., "drm", "grm", 
"gpcm", "nrm", "mcm") can be supplied, indicating that any item on any test associated with the given 
model(s) would be excluded. If the argument is specified as a list, <code>exclude</code> should have as 
any elements as groups in <code>x</code>. Each list element can include model names and/or item numbers 
corresponding to the items on each test that should be excluded. If no items need to be excluded for 
a given group, the list element should be equal NA. For example, say we have two groups and we would 
like to exclude the GRM items and item 23 from the first group, we would specify <code>exclude</code> as 
<code>exclude &lt;- list(c("grm",23),NA)</code>.
</p>


<h3>Value</h3>

<p>Returns a matrix of equated true scores and/or a list of equated observed scores with associated
marginal distributions or a list combining these two objects. The output for the observed-score
equating also includes EAP scores and SDs for each of the observed scores (Thissen &amp; Orlando, 2001).
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

 
<p>Kolen, M. J. (1981). 
Comparison of traditional and item response theory methods for equating tests. 
<em>Journal of Educational Measurement</em>, <em>18</em>(1), 1-11.
</p>
<p>Kolen, M. J. &amp; Brennan, R. L. (2004)
<em>Test Equating, Scaling, and Linking</em> (2nd ed.).
New York: Springer
</p>
<p>Thissen, D. &amp; Orlando, M. (2001)
Item response theory for items scored in two categories.
In D. Thissen &amp; H. Wainer (Eds.)
<em>Test Scoring</em> (p. 23 - 72).
Hillsdale, NJ: Lawrence Erlbaum Associates.
</p>
<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1â€“33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># IRT true score and observed score examples from 
# Kolen &amp; Brennan (2004, ch. 6)
pm &lt;- as.poly.mod(36)
x &lt;- as.irt.pars(KB04$pars, KB04$common,
  cat=list(rep(2,36),rep(2,36)), poly.mod=list(pm,pm))
out &lt;- plink(x, rescale="MS", base.grp=2, D=1.7, exclude=list(27,NA))

# Create the quadrature points and weights
wt &lt;- as.weight(
  theta=c(-5.2086,-4.163,-3.1175,-2.072,-1.0269,0.0184,
    1.0635,2.109,3.1546,4.2001),
  weight=c(0.000101,0.00276,0.03021,0.142,0.3149,0.3158,
    0.1542,0.03596,0.003925,0.000186))

# Conduct the equating
equate(out,weights1=wt, synth.weights=c(1,0),D=1.7)

# Conduct true score equating for specific true scores
equate(out, true.scores=7:15, ts.low=FALSE, D=1.7)

# Exclude all common items (assume they correspond to an external anchor)
equate(out, D=1.7, exclude="all.common")


# Observed score equating for mixed-format tests
pm1 &lt;- as.poly.mod(55,c("drm","gpcm","nrm"),dgn$items$group1)
pm2 &lt;- as.poly.mod(55,c("drm","gpcm","nrm"),dgn$items$group2)
x &lt;- as.irt.pars(dgn$pars,dgn$common,dgn$cat,list(pm1,pm2))
out &lt;- plink(x, rescale="HB") 
OSE &lt;- equate(out, method="OSE", score=2)

# Display the equated scores
OSE[[1]]

# Multiple group equating
pars &lt;- TK07$pars
common &lt;- TK07$common
cat &lt;- list(rep(2,26),rep(2,34),rep(2,37),rep(2,40),rep(2,41),rep(2,43))
pm1 &lt;- as.poly.mod(26)
pm2 &lt;- as.poly.mod(34)
pm3 &lt;- as.poly.mod(37)
pm4 &lt;- as.poly.mod(40)
pm5 &lt;- as.poly.mod(41)
pm6 &lt;- as.poly.mod(43)
pm &lt;- list(pm1, pm2, pm3, pm4, pm5, pm6)
x &lt;- as.irt.pars(pars, common, cat, pm, grp.names=paste("grade",3:8,sep=""))
out &lt;- plink(x, rescale="SL")


# True score equating
equate(out, method="TSE")

# True score equating with the base group changed to 3
equate(out, method="TSE", base.grp=3)

# Observed score equating (These data are for non-equivalent groups, but
# this example is included to illustrate the multigroup capabilities)
OSE &lt;- equate(out, method="OSE", base.grp=3)

# Display the equated scores for each group
OSE[[1]]

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>x_read_disk</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Read an <em>agent</em>, <em>informant</em>, <em>multiagent</em>, or table scan from disk</h2>

<h3>Description</h3>

<p>An <em>agent</em>, <em>informant</em>, <em>multiagent</em>, or table scan that has been written to
disk (with <code>x_write_disk()</code>) can be read back into memory with the
<code>x_read_disk()</code> function. For an <em>agent</em> or an <em>informant</em> object that has
been generated in this way, it may not have a data table associated with it
(depending on whether the <code>keep_tbl</code> option was <code>TRUE</code> or <code>FALSE</code> when
writing to disk) but it should still be able to produce reporting (by
printing the <em>agent</em> or <em>informant</em> to the console or using
<code>get_agent_report()</code>/<code>get_informant_report()</code>). An <em>agent</em> will return an
x-list with <code>get_agent_x_list()</code> and yield any available data extracts with
<code>get_data_extracts()</code>. Furthermore, all of an <em>agent</em>'s validation steps will
still be present (along with results from the last interrogation).
</p>


<h3>Usage</h3>

<pre><code class="language-R">x_read_disk(filename, path = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p><em>File name</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <strong>required</strong>
</p>
<p>The name of a file that was previously written by <code>x_write_disk()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p><em>File path</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional path to the file (combined with <code>filename</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p><em>Inform (or not) upon file writing</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;logical&gt;⁠</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should the function <em>not</em> inform when the file is written?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Should a written-to-disk <em>agent</em> or <em>informant</em> possess a table-prep formula
or a specific in-memory tablewe could use the <code>interrogate()</code> or
<code>incorporate()</code> function again. For a <em>data quality reporting</em> workflow, it
is useful to <code>interrogate()</code> target tables that evolve over time. While the
same validation steps will be used, more can be added before calling
<code>interrogate()</code>. For an <em>information management</em> workflow with an <em>informant</em>
object, using <code>incorporate()</code> will update aspects of the reporting such as
table dimensions, and info snippets/text will be regenerated.
</p>


<h3>Value</h3>

<p>Either a <code>ptblank_agent</code>, <code>ptblank_informant</code>, or a
<code>ptblank_tbl_scan</code> object.
</p>


<h3>Examples</h3>



<h4>A: Reading an agent from disk</h4>

<p>The process of developing an agent and writing it to disk with the
<code>x_write_disk()</code> function is explained in that function's documentation.
Suppose we have such a written file that's named <code>"agent-small_table.rds"</code>,
we could read that to a new agent object with <code>x_read_disk()</code>.
</p>
<div class="sourceCode r"><pre>agent &lt;- x_read_disk("agent-small_table.rds")
</pre></div>



<h4>B: Reading an informant from disk</h4>

<p>If there is an informant written to disk via <code>x_write_disk()</code> and it's named
<code>"informant-small_table.rds"</code>. We could read that to a new informant object
with <code>x_read_disk()</code>.
</p>
<div class="sourceCode r"><pre>informant &lt;- x_read_disk("informant-small_table.rds")
</pre></div>



<h4>C: Reading a multiagent from disk</h4>

<p>The process of creating a multiagent and writing it to disk with the
<code>x_write_disk()</code> function is shown in that function's documentation. Should
we have such a written file called <code>"multiagent-small_table.rds"</code>, we could
read that to a new multiagent object with <code>x_read_disk()</code>.
</p>
<div class="sourceCode r"><pre>multiagent &lt;- x_read_disk("multiagent-small_table.rds")
</pre></div>



<h4>D: Reading a table scan from disk</h4>

<p>If there is a table scan written to disk via <code>x_write_disk()</code> and it's named
<code>"tbl_scan-storms.rds"</code>, we could read it back into R with <code>x_read_disk()</code>.
</p>
<div class="sourceCode r"><pre>tbl_scan &lt;- x_read_disk("tbl_scan-storms.rds")
</pre></div>



<h3>Function ID</h3>

<p>9-2
</p>


<h3>See Also</h3>

<p>Other Object Ops: 
<code>activate_steps()</code>,
<code>deactivate_steps()</code>,
<code>export_report()</code>,
<code>remove_steps()</code>,
<code>set_tbl()</code>,
<code>x_write_disk()</code>
</p>


</div>
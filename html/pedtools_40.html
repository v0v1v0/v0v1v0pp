<div class="container">

<table style="width: 100%;"><tr>
<td>ped_modify</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add/remove pedigree members</h2>

<h3>Description</h3>

<p>Functions for adding or removing individuals in a 'ped' object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">addChildren(
  x,
  father = NULL,
  mother = NULL,
  nch = NULL,
  sex = 1L,
  ids = NULL,
  verbose = TRUE
)

addChild(x, parents, id = NULL, sex = 1, verbose = TRUE)

addSon(x, parents, id = NULL, verbose = TRUE)

addDaughter(x, parents, id = NULL, verbose = TRUE)

addParents(x, id, father = NULL, mother = NULL, verbose = TRUE)

removeIndividuals(
  x,
  ids,
  remove = c("descendants", "ancestors"),
  returnLabs = FALSE,
  verbose = TRUE
)

branch(x, id)

## S3 method for class 'ped'
subset(x, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>ped</code> object, or a list of such.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>father, mother</code></td>
<td>
<p>Single ID labels. At least one of these must be an
existing member of <code>x</code>. The other may be (i) another existing member, (ii)
a new founder to be created, or (iii) missing (i.e., NULL), in which case
the other parent is created and given a suitable name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nch</code></td>
<td>
<p>A positive integer indicating the number of children to be
created. Default: 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sex</code></td>
<td>
<p>Gender codes of the created children (recycled if needed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ids</code></td>
<td>
<p>A vector of ID labels. In <code>addChildren()</code> these are the children
to be created. If NULL (default) given, automatic labels are generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical: Verbose output or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parents</code></td>
<td>
<p>A vector of 1 or 2 ID labels, of which at least one must be an
existing member of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>The ID label of a pedigree member.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove</code></td>
<td>
<p>Either "ancestors" or "descendants" (default), dictating the
method of removing pedigree members. Abbreviations are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnLabs</code></td>
<td>
<p>A logical, by default FALSE. If TRUE, <code>removeIndividuals()</code>
returns only the labels of all members to be removed, instead of actually
removing them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>A character vector (or coercible to such) with ID labels
forming a connected sub-pedigree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In <code>addChildren()</code> and <code>addParents()</code>, labels of added individuals are
generated automatically if they are not specified by the user. The automatic
labelling uses the smallest integers not already in use.
</p>
<p><code>addChild()</code>, <code>addSon()</code> and <code>addDaughter()</code> are convenient wrappers for the
most common use of <code>addChildren()</code>, namely adding a single child to a
pedigree. Note that the parents can be given in any order. If only one parent
is supplied, the other is created as a new individual.
</p>
<p><code>removeIndividuals()</code> removes the individuals indicated with <code>ids</code> along with
all of their ancestors OR descendants, depending on the <code>remove</code> argument.
Leftover spouses disconnected to the remaining pedigree are also removed. An
error is raised if result is a disconnected pedigree.
</p>
<p>The <code>branch()</code> function extracts the sub-pedigree formed by <code>id</code> and all
his/her spouses and descendants.
</p>
<p>Finally, <code>subset()</code> can be used to extract any connected sub-pedigree. (Note
that in the current implementation, the function does not actually check that
the indicated subset forms a connected pedigree; failing to comply with this
may lead to obscure errors.)
</p>


<h3>Value</h3>

<p>The modified <code>ped</code> object.
</p>


<h3>See Also</h3>

<p><code>ped()</code>, <code>relabel()</code>, <code>swapSex()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x = nuclearPed(1) |&gt;
  addSon(3) |&gt;
  addParents(4, father = 6, mother = 7) |&gt;
  addChildren(father = 6, mother = 7, nch = 3, sex = c(2,1,2))

# Remove 6 and 7 and their descendants
y1 = removeIndividuals(x, 6:7)

# Remove 8-10 and their parents
y2 = removeIndividuals(x, 8:10, remove = "ancestors")

# Adding a child across components
z = singletons(1:2, sex = 1:2) |&gt; addDaughter(1:2)


</code></pre>


</div>
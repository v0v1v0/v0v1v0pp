<div class="container">

<table style="width: 100%;"><tr>
<td>crossval</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation of PLSR and PCR models</h2>

<h3>Description</h3>

<p>A “stand alone” cross-validation function for <code>mvr</code> objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">crossval(
  object,
  segments = 10,
  segment.type = c("random", "consecutive", "interleaved"),
  length.seg,
  jackknife = FALSE,
  trace = 15,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an <code>mvr</code> object; the regression to cross-validate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segments</code></td>
<td>
<p>the number of segments to use, or a list with segments (see
below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segment.type</code></td>
<td>
<p>the type of segments to use.  Ignored if <code>segments</code>
is a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length.seg</code></td>
<td>
<p>Positive integer.  The length of the segments to use.  If
specified, it overrides <code>segments</code> unless <code>segments</code> is a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jackknife</code></td>
<td>
<p>logical.  Whether jackknifing of regression coefficients
should be performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>if <code>TRUE</code>, tracing is turned on.  If numeric, it denotes a
time limit (in seconds).  If the estimated total time of the
cross-validation exceeds this limit, tracing is turned on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments, sent to the underlying fit function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs cross-validation on a model fit by <code>mvr</code>.  It
can handle models such as <code>plsr(y ~ msc(X), ...{})</code> or other models
where the predictor variables need to be recalculated for each segment.
When recalculation is not needed, the result of
<code>crossval(mvr(...{}))</code> is identical to <code>mvr(...{}, validation
= "CV")</code>, but slower.
</p>
<p>Note that to use <code>crossval</code>, the data <em>must</em> be specified with a
<code>data</code> argument when fitting <code>object</code>.
</p>
<p>If <code>segments</code> is a list, the arguments <code>segment.type</code> and
<code>length.seg</code> are ignored.  The elements of the list should be integer
vectors specifying the indices of the segments.  See
<code>cvsegments</code> for details.
</p>
<p>Otherwise, segments of type <code>segment.type</code> are generated.  How many
segments to generate is selected by specifying the number of segments in
<code>segments</code>, or giving the segment length in <code>length.seg</code>.  If both
are specified, <code>segments</code> is ignored.
</p>
<p>If <code>jackknife</code> is <code>TRUE</code>, jackknifed regression coefficients are
returned, which can be used for for variance estimation
(<code>var.jack</code>) or hypothesis testing (<code>jack.test</code>).
</p>
<p>When tracing is turned on, the segment number is printed for each segment.
</p>
<p>By default, the cross-validation will be performed serially.  However, it
can be done in parallel using functionality in the <code>parallel</code>
package by setting the option <code>parallel</code> in <code>pls.options</code>.
See <code>pls.options</code> for the different ways to specify the
parallelism.  See also Examples below.
</p>


<h3>Value</h3>

<p>The supplied <code>object</code> is returned, with an additional component
<code>validation</code>, which is a list with components </p>
<table>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>euqals
<code>"CV"</code> for cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>an array with the
cross-validated predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>(only if <code>jackknife</code>
is <code>TRUE</code>) an array with the jackknifed regression coefficients.  The
dimensions correspond to the predictors, responses, number of components,
and segments, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PRESS0</code></td>
<td>
<p>a vector of PRESS values (one for
each response variable) for a model with zero components, i.e., only the
intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PRESS</code></td>
<td>
<p>a matrix of PRESS values for models with 1,
..., <code>ncomp</code> components.  Each row corresponds to one response
variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj</code></td>
<td>
<p>a matrix of adjustment values for calculating bias
corrected MSEP.  <code>MSEP</code> uses this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segments</code></td>
<td>
<p>the list of
segments used in the cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>the number of
components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gammas</code></td>
<td>
<p>if method <code>cppls</code> is used, gamma values for
the powers of each CV segment are returned.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The <code>PRESS0</code> is always cross-validated using leave-one-out
cross-validation.  This usually makes little difference in practice, but
should be fixed for correctness.
</p>
<p>The current implementation of the jackknife stores all jackknife-replicates
of the regression coefficients, which can be very costly for large matrices.
This might change in a future version.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens and Bjørn-Helge Mevik
</p>


<h3>References</h3>

<p>Mevik, B.-H., Cederkvist, H. R. (2004) Mean Squared Error of
Prediction (MSEP) Estimates for Principal Component Regression (PCR) and
Partial Least Squares Regression (PLSR).  <em>Journal of Chemometrics</em>,
<b>18</b>(9), 422–429.
</p>


<h3>See Also</h3>

<p><code>mvr</code> <code>mvrCv</code> <code>cvsegments</code>
<code>MSEP</code> <code>var.jack</code> <code>jack.test</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(yarn)
yarn.pcr &lt;- pcr(density ~ msc(NIR), 6, data = yarn)
yarn.cv &lt;- crossval(yarn.pcr, segments = 10)
## Not run: plot(MSEP(yarn.cv))

## Not run: 
## Parallelised cross-validation, using transient cluster:
pls.options(parallel = 4) # use mclapply (not available on Windows)
pls.options(parallel = quote(parallel::makeCluster(4, type = "PSOCK"))) # parLapply
## A new cluster is created and stopped for each cross-validation:
yarn.cv &lt;- crossval(yarn.pcr)
yarn.loocv &lt;- crossval(yarn.pcr, length.seg = 1)

## Parallelised cross-validation, using persistent cluster:
library(parallel)
## This creates the cluster:
pls.options(parallel = makeCluster(4, type = "FORK")) # not available on Windows
pls.options(parallel = makeCluster(4, type = "PSOCK"))
## The cluster can be used several times:
yarn.cv &lt;- crossval(yarn.pcr)
yarn.loocv &lt;- crossval(yarn.pcr, length.seg = 1)
## The cluster should be stopped manually afterwards:
stopCluster(pls.options()$parallel)

## Parallelised cross-validation, using persistent MPI cluster:
## This requires the packages snow and Rmpi to be installed
library(parallel)
## This creates the cluster:
pls.options(parallel = makeCluster(4, type = "MPI"))
## The cluster can be used several times:
yarn.cv &lt;- crossval(yarn.pcr)
yarn.loocv &lt;- crossval(yarn.pcr, length.seg = 1)
## The cluster should be stopped manually afterwards:
stopCluster(pls.options()$parallel)
## It is good practice to call mpi.exit() or mpi.quit() afterwards:
mpi.exit()

## End(Not run)

</code></pre>


</div>
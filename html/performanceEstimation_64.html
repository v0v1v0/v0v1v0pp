<div class="container">

<table style="width: 100%;"><tr>
<td>standardWF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
A function implementing a standard workflow for prediction tasks
</h2>

<h3>Description</h3>

<p>This function implements a standard workflow for both  classification
and regression tasks. The workflow consists of: (i) learning a
predictive model based on the given training set, (ii) using it to
make predictions for the provided test set,  and finally  (iii)
measuring some evaluation metrics of its performance. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">standardWF(form,train,test,
    learner,learner.pars=NULL,
    predictor='predict',predictor.pars=NULL,
    pre=NULL,pre.pars=NULL,
    post=NULL,post.pars=NULL,
    .fullOutput=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>form</code></td>
<td>

<p>A formula specifying the predictive task.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train</code></td>
<td>

<p>A data frame containing the data set to be used for obtaining the
predictive model (the training set).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>

<p>A data frame containing the data set to be used for testing the
obtained  model (the test set).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>

<p>A character string with the name of a function that is to be used to
obtain the prediction models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learner.pars</code></td>
<td>

<p>A list of parameter values to be passed to the learner (defaults to <code>NULL</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictor</code></td>
<td>

<p>A character string with the name of a function that is to be used to
obtain the predictions for the test set using the obtained model
(defaults to 'predict').
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictor.pars</code></td>
<td>

<p>A list of parameter values to be passed to the predictor (defaults
to <code>NULL</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre</code></td>
<td>

<p>A vector of function names that will be applied in sequence to the train
and test data frames, generating new versions, i.e. a sequence of data
pre-processing functions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre.pars</code></td>
<td>

<p>A named list of parameter values to be passed to the pre-processing functions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post</code></td>
<td>

<p>A vector of function names that will be applied in sequence to the
predictions of the model, generating a new version, i.e. a sequence of data
post-processing functions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post.pars</code></td>
<td>

<p>A named list of parameter values to be passed to the post-processing functions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.fullOutput</code></td>
<td>

<p>A boolean that if set to <code>TRUE</code> will make the function return
more information in the list that results from its execution like for
instance  the  models (defaults  to <code>FALSE</code>).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The main goal of this function is to facilitate the task of the users
of the experimental comparison infra-structure provided by function
<code>performanceEstimation</code>. Namely, this function requires
the users to specify the workflows (solutions to predictive tasks)
whose performance she/he wants to estimate and compare. The user has
the flexibility of writing hers/his own workflow functions, however,
in most situations that is not really necessary. The reason is that
most of the times users just want to compare standard out of the box
learning algorithms on some tasks. In these contexts, the workflow
simply consists of applying some existing learning algorithm to the
training data, and then use it to obtain the predictions of the test
set.  This standard workflow may even include some standard
pre-processing tasks applied to the given data before the model is
learned, and eventually some post processing tasks applied to the
predictions before they are returned to the user. The goal of the
current function is to facilitate evaluating this sort of estimation
experiments. It implements this workflow thus avoiding the need of the
user to write these workflows. 
</p>
<p>Through parameter <code>learner</code> users may indicate the modeling
algorithm to use to obtain the predictive model. This can be any R function,
provided it can be called with a formula on the first argument and a
training set on a parameter named <code>data</code> (as most R modeling functions do). As
usual, these functions may include other arguments that are specific
to the modeling approach (i.e. are parameters of the model). The
values to be used for these parameters are specified as a list through
the parameter <code>learner.pars</code> of function <code>standardWF</code>. The
learning function can return any class of object that represents the
learned model. This object will be used to obtain the predictions in
this standard workflow.
</p>
<p>Equivalently, the user may specify a function for obtaining the
predictions for the test set using the previously learned model. Again
this can be any function, and it is indicated in parameter
<code>predictor</code> (defaulting to the usual <code>predict</code>
function). This function should be prepared to accept in the first
argument the learned model and in the second the test set, and should
return the predictions of the model for this set of data. It may also
have additional parameters whose values are specified as a list in
parameter <code>predictor.pars</code>.
</p>
<p>Additionally, the user may specify a set of data-preprocessing
functions to be applied to both the training and testing sets, through
parameter <code>pre</code> that accepts a vector of function names. These
functions will be applied to both the training and testing sets, in
the sequence provided in the vector of names, before the learning
algorithm is applied to the training set. Once again the user is free
to indicate as pre-processing functions any function, eventually
her/his own functions carrying our any sort of pre-processing
steps. These user-defined pre-processing functions will be applied by
function <code>standardPRE</code>. Check the help page of this
function to know the protocol you need to follow to be able to use
your own pre-processing functions. Still, our infra-structure already
includes some common pre-processing functions so that you do not need
to implement them. The list of these functions is again described in
the help page of <code>standardPRE</code>.
</p>
<p>The predictions obtained by the function specified in parameter
<code>predict</code> may also go through some post-processing steps before
they are return as a result of the <code>standardWF</code> function. Again
the user may specify a vector of post-processing functions to be
applied in sequence, through the parameter <code>post</code>. Parameters to
be passed to these functions can be specified through the parameter
<code>post.pars</code>. The goal of these functions is to obtain a new
version of the predictions of the models after going through some
post-processing steps. These functions will be applied to the
predictions by the function <code>standardPOST</code>. Once again
this function already implements a few standard post-processing steps
but you are free to supply your own post-processing functions provided
they follow the protocol described in the help page of function
<code>standardPOST</code>. 
</p>
<p>Finally, the parameter <code>.fullOutput</code> controls the ammount of
information that is returned by the <code>standardWF</code> function. By
default it is <code>FALSE</code> which means that the workflow will only
return (apart from the predictions) the train, test and total times of
the learning and prediction stages. This information is returned as a
component named "times" of the results list that can be obtained
for instance by using the
<code>getIterationsInfo</code> if the workflow is being used in the
context of an experimental comparison. If <code>.fullOutput</code> is set to
<code>TRUE</code> the workflow will also include information on the
pre-processing steps (in a component named "preprocessing"),
information on the model and predictions of the model (in a component
named "modeling") and information on the post-processing steps (in a
component named "postprocessing").
</p>


<h3>Value</h3>

<p>A list with several components containing the result of runing the
workflow. 
</p>


<h3>Note</h3>

<p>In order to use any of the available learning algorithms in R you must
have previously installed and loaded the respective packages, if necessary.
</p>


<h3>Author(s)</h3>

<p> Luis Torgo <a href="mailto:ltorgo@dcc.fc.up.pt">ltorgo@dcc.fc.up.pt</a> </p>


<h3>References</h3>

<p> Torgo, L. (2014) <em>An Infra-Structure for Performance
Estimation and Experimental Comparison of Predictive Models in R</em>. arXiv:1412.0436 [cs.MS]
<a href="http://arxiv.org/abs/1412.0436">http://arxiv.org/abs/1412.0436</a>  
</p>


<h3>See Also</h3>

<p><code>performanceEstimation</code>,
<code>timeseriesWF</code>,
<code>getIterationsInfo</code>,
<code>getIterationsPreds</code>,
<code>standardPRE</code>,
<code>standardPOST</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(iris)
library(e1071)

## a standard workflow using and SVM with default parameters
w.s &lt;- Workflow(wfID="std.svm",learner="svm")
w.s

irisExp &lt;- performanceEstimation(
  PredTask(Species ~ .,iris),
  w.s,
  EstimationTask("acc"))

getIterationsPreds(irisExp,1,1,it=4)
getIterationsInfo(irisExp,1,1,rep=1,fold=2)

## A more sophisticated standardWF
## - as pre-processing we imput NAs with either the median (numeric
## features) or the mode (nominal features); and we also scale
## (normalize) the numeric predictors
## - as learning algorithm we use and SVM with cost=10 and gamma=0.01
## - as post-processing we scale all predictions into the range [0..50]
w.s2 &lt;- Workflow(pre=c("centralImp","scale"), 
                 learner="svm",
                 learner.pars=list(cost=10,gamma=0.01),
                 post="cast2int",
                 post.pars=list(infLim=0,supLim=50),
                 .fullOutput=TRUE
                )

data(algae,package="DMwR")

a1.res &lt;- performanceEstimation(
            PredTask(a1 ~ ., algae[,1:12],"alga1"),
            w.s2,
            EstimationTask("mse")
            )

## Workflow variants of a standard workflow
ws &lt;- workflowVariants(
                 pre=c("centralImp","scale"), 
                 learner="svm",
                 learner.pars=list(cost=c(1,5,10),gamma=0.01),
                 post="cast2int",
                 post.pars=list(infLim=0,supLim=c(10,50,80)),
                 .fullOutput=TRUE,
                 as.is="pre"
                )
a1.res &lt;- performanceEstimation(
            PredTask(a1 ~ ., algae[,1:12],"alga1"),
            ws,
            EstimationTask("mse")
            )

## An example using GBM that is a bit different in terms of the
## prediction part as it requires to select the number of trees of the
## ensemble to use
data(Boston, package="MASS")
library(gbm)

## A user written predict function to allow for using the standard
## workflows
gbm.predict &lt;- function(model, test, method, ...) {
    best &lt;- gbm.perf(model, plot.it=FALSE, method=method)
    return(predict(model, test, n.trees=best, ...))
}

resG &lt;- performanceEstimation(
             PredTask(medv ~.,Boston),
             Workflow(learner="gbm",
                      learner.pars=list(n.trees=1000, cv.folds=10),
                      predictor="gbm.predict",
                      predictor.pars=list(method="cv")),
             EstimationTask(metrics="mse",method=CV())
        )


## End(Not run)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>power_search</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Search function to find N for desired power</h2>

<h3>Description</h3>

<p>The function that initializes the search process. The <code>powerNLSEM</code> function actually is a wrapper function for <code>power_search</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">power_search(
  POI,
  method,
  lavModel,
  lavModel_Analysis,
  data_transformations,
  search_method,
  power_modeling_method,
  R = 1000,
  power_aim = 0.8,
  alpha = 0.05,
  alpha_power_modeling = 0.05,
  CORES,
  verbose,
  Ns = NULL,
  N_start = nrow(lavModel[lavModel$op != "~1", ]) * 10,
  distRj = "increasing",
  steps = 10,
  nlb = nrow(lavModel[lavModel$op != "~1", ]) * 5,
  switchStep = round(steps/2),
  FSmethod = "SL",
  test = "onesided",
  matchPI = TRUE,
  PIcentering = "doubleMC",
  liberalInspection = FALSE,
  constrainRelChange = TRUE,
  seeds,
  pathLMS = tempdir()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>POI</code></td>
<td>
<p>Parameter Of Interest as a vector of strings. Must be in lavaan-syntax without any spaces. Nonlinear effects should have the same ordering as in model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method used to fit to the data. Can be LMS or UPI.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lavModel</code></td>
<td>
<p>lavModel object describing the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lavModel_Analysis</code></td>
<td>
<p>lavModel object containg the parameters to be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_transformations</code></td>
<td>
<p>Object containing info on data transformations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>search_method</code></td>
<td>
<p>String stating the search method. Default to <code>"adaptive"</code> (synonyme is <code>"smart"</code>). Alternative is <code>"bruteforce"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power_modeling_method</code></td>
<td>
<p>Power modeling method used to model significant parameter estimates. Default to <code>"probit"</code> indicating glm with probit link function with sqrt(n) as predictor. Alternative is <code>"logit"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Total number of models to be fitted. Higher number results in higher precision and longer runtime.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power_aim</code></td>
<td>
<p>Minimal power value to approximate. Default to .8.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Type I-error rate for significance decision. Default to <code>.05</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha_power_modeling</code></td>
<td>
<p>Type I-error rate for confidence band around predicted power rate. Used to ensure that the computed <code>N</code> keeps the desired power value (with the given Type I-error rate <code>alpha_power_modeling</code> divided by 2). If set to 1, no confidence band is used. Default to <code>.05</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CORES</code></td>
<td>
<p>Number of cores used for parallelization. Default to number of available cores - 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical whether progress should be printed in console. Default to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ns</code></td>
<td>
<p>Sample sizes used in power estimation process. Default to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_start</code></td>
<td>
<p>Starting sample size for smart algorithm. Default to  <code>10*nrow(lavModel[lavModel$op != "~1", ])</code> (10 times the number of parameters, excluding the mean structure, without the generation of e.g., factor scores or product indicators).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distRj</code></td>
<td>
<p>Indicator how the samples sizes should be used in the steps of the smart algorithm: <code>"u"</code> for many to few to many, <code>"increasing"</code> for increasing replications and <code>"even"</code> for evenly distributed replications across steps. Default to <code>"u"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>Steps used in <code>search_method = "smart"</code>, i.e., the smart algorithm. This is ignored if bruteforce is used. Default to 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlb</code></td>
<td>
<p>Lower bound of N used in search. Default to <code>5*nrow(lavModel[lavModel$op != "~1", ])</code> (5 times the number of parameters, excluding the mean structure, in the model without the generation of e.g., factor scores or product indicators), however, some methods can deal with much smaller sample sizes so this can be adjusted. The rule of thumb of 5 times number of parameters is motivated by Wolf et al. (2013)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>switchStep</code></td>
<td>
<p>Steps after which smart search method changes from exploration to exploitation. Default to <code>round(steps/2)</code>. Exploration phase searches for the interval for N so that the resulting power is within <code>[.15, .85]</code> since the power curve is steepest at .5 and becomes less step towards plus/min <code>Inf</code>. Exploitation phase searches for an interval for N around the <code>power_aim</code> argument which shrinks from plus/minus .1 to .01. If <code>swicthStep = Inf</code>, then only exploration is used. If <code>switchStep</code> is used then the search process is reset at that point, which results in a new estimation in the bounds of the interval of N independent of the previous ones which might be restricted in change (see also argument( <code>constrainRelChange</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FSmethod</code></td>
<td>
<p>Method to be used to extract factor scores. Default to <code>"SL"</code> for the Skrondal and Laake approach that uses regression (<code>"regression"</code>) factor scores for the independendent variables and <code>"Bartlett"</code> factor scores for the dependent variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>Should the parameter be tested with a directed hypothesis (onesided) or with an undirected hypothesis (twosided, also equivalent to Wald-Test for single parameter). Default to <code>"onesided"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matchPI</code></td>
<td>
<p>Logical passed to <code>semTools::indProd</code> in order to compute the product indicators: Specify TRUE to use match-paired approach (Marsh, Wen, &amp; Hau, 2004). If FALSE, the resulting products are all possible products. Default to <code>TRUE</code>. The observations are matched by order given when specifying the measurement model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PIcentering</code></td>
<td>
<p>String indicating which method of centering should be used when constructing product indicators. String is converted to the arguments <code>meanC</code>, <code>doubleMC</code>, and <code>residualMC</code>, of the <code>semTools::indProd</code> function. Default to <code>"doubleMC"</code> for double mean centering the resulting products (Lin et. al., 2010). Use <code>"meanC"</code> for mean centering the main effect indicator before making the products or <code>"residualC"</code> for residual centering the products by the main effect indicators (Little, Bovaird, &amp; Widaman, 2006). <code>"none"</code> or any other input than the previously described results in no centering (use with caution!).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>liberalInspection</code></td>
<td>
<p>Logical whether the inspection of estimation truthworthiness should be very liberal (i.e., allowing for non-positive definite Hessians in standard error estimation or non-positive residual covariance matrices or latent covariance matrices). Default to <code>FALSE</code>. Being liberal is not adviced and should be checked for a single data set!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constrainRelChange</code></td>
<td>
<p>Logical whether the change in the bounds of the interval for N using the smart algorithm should be constrained. This prevents divergence (which is especially an issue for small effect sizes and small <code>R</code>) but results in biased estimates if the number of steps is too small. Default to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds</code></td>
<td>
<p>Seeds for reproducibility.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pathLMS</code></td>
<td>
<p>path where (temporal) data and scripts for running LMS using Mplus are stored (using <code>MplusAutomation</code>). Default to <code>NULL</code>, then <code>tempdir()</code> is used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a <code>list</code> that includes the results on model-implied simulation-based power estimation.
</p>


<h3>References</h3>

<p>Wolf, E. J., Harrington, K. M., Clark, S. L., &amp; Miller, M. W. (2013). Sample Size Requirements for Structural Equation Models: An Evaluation of Power, Bias, and Solution Propriety. <em>Educational and Psychological Measurement, 76</em>(6), 913â€“934. <a href="https://doi.org/10.1177/0013164413495237">doi:10.1177/0013164413495237</a>
</p>
<p>Irmer, J. P., Klein, A. G., &amp; Schermelleh-Engel, K. (2024).  <em>Behavior Research Methods, 0</em>(00), Advance Online Publication.
</p>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>plm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Panel Data Estimators</h2>

<h3>Description</h3>

<p>Linear models for panel data estimated using the <code>lm</code> function on
transformed data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plm(
  formula,
  data,
  subset,
  weights,
  na.action,
  effect = c("individual", "time", "twoways", "nested"),
  model = c("within", "random", "ht", "between", "pooling", "fd"),
  random.method = NULL,
  random.models = NULL,
  random.dfcor = NULL,
  inst.method = c("bvk", "baltagi", "am", "bms"),
  restrict.matrix = NULL,
  restrict.rhs = NULL,
  index = NULL,
  ...
)

## S3 method for class 'plm.list'
print(
  x,
  digits = max(3, getOption("digits") - 2),
  width = getOption("width"),
  ...
)

## S3 method for class 'panelmodel'
terms(x, ...)

## S3 method for class 'panelmodel'
vcov(object, ...)

## S3 method for class 'panelmodel'
fitted(object, ...)

## S3 method for class 'panelmodel'
residuals(object, ...)

## S3 method for class 'panelmodel'
df.residual(object, ...)

## S3 method for class 'panelmodel'
coef(object, ...)

## S3 method for class 'panelmodel'
print(
  x,
  digits = max(3, getOption("digits") - 2),
  width = getOption("width"),
  ...
)

## S3 method for class 'panelmodel'
update(object, formula., ..., evaluate = TRUE)

## S3 method for class 'panelmodel'
deviance(object, model = NULL, ...)

## S3 method for class 'plm'
formula(x, ...)

## S3 method for class 'plm'
plot(
  x,
  dx = 0.2,
  N = NULL,
  seed = 1,
  within = TRUE,
  pooling = TRUE,
  between = FALSE,
  random = FALSE,
  ...
)

## S3 method for class 'plm'
residuals(object, model = NULL, effect = NULL, ...)

## S3 method for class 'plm'
fitted(object, model = NULL, effect = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a symbolic description for the model to be
estimated,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a <code>data.frame</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>see <code>stats::lm()</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>see <code>stats::lm()</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>see <code>stats::lm()</code>; currently, not fully
supported,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effect</code></td>
<td>
<p>the effects introduced in the model, one of
<code>"individual"</code>, <code>"time"</code>, <code>"twoways"</code>, or
<code>"nested"</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>one of <code>"pooling"</code>, <code>"within"</code>,
<code>"between"</code>, <code>"random"</code> <code>"fd"</code>, or <code>"ht"</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.method</code></td>
<td>
<p>method of estimation for the variance
components in the random effects model, one of <code>"swar"</code>
(default), <code>"amemiya"</code>, <code>"walhus"</code>, <code>"nerlove"</code>; for
Hausman-Taylor estimation set to <code>"ht"</code> (see Details and Examples),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.models</code></td>
<td>
<p>an alternative to the previous argument, the
models used to compute the variance components estimations are
indicated,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.dfcor</code></td>
<td>
<p>a numeric vector of length 2 indicating which
degree of freedom should be used,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inst.method</code></td>
<td>
<p>the instrumental variable transformation: one of
<code>"bvk"</code>, <code>"baltagi"</code>, <code>"am"</code>, or <code>"bms"</code> (see also Details),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restrict.matrix</code></td>
<td>
<p>a matrix which defines linear restrictions
on the coefficients,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restrict.rhs</code></td>
<td>
<p>the right hand side vector of the linear
restrictions on the coefficients,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>the indexes,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, object</code></td>
<td>
<p>an object of class <code>"plm"</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>number of digits for printed output,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>the maximum length of the lines in the printed output,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula.</code></td>
<td>
<p>a new formula for the update method,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evaluate</code></td>
<td>
<p>a boolean for the update method, if <code>TRUE</code> the
updated model is returned, if <code>FALSE</code> the call is returned,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dx</code></td>
<td>
<p>the half–length of the individual lines for the plot
method (relative to x range),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>the number of individual to plot,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>the seed which will lead to individual selection,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>within</code></td>
<td>
<p>if <code>TRUE</code>, the within model is plotted,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pooling</code></td>
<td>
<p>if <code>TRUE</code>, the pooling model is plotted,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>between</code></td>
<td>
<p>if <code>TRUE</code>, the between model is plotted,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>if <code>TRUE</code>, the random effect model is plotted,</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>plm</code> is a general function for the estimation of linear panel
models.  It supports the following estimation methods: pooled OLS
(<code>model = "pooling"</code>), fixed effects (<code>"within"</code>), random effects
(<code>"random"</code>), first–differences (<code>"fd"</code>), and between
(<code>"between"</code>). It supports unbalanced panels and two–way effects
(although not with all methods).
</p>
<p>For random effects models, four estimators of the transformation
parameter are available by setting <code>random.method</code> to one of
<code>"swar"</code> (Swamy and Arora 1972) (default), <code>"amemiya"</code>
(Amemiya 1971), <code>"walhus"</code>
(Wallace and Hussain 1969), or <code>"nerlove"</code>
(Nerlove 1971) (see below for Hausman-Taylor instrumental
variable case).
</p>
<p>The nested random effect model ((Baltagi et al. 2001))
is estimated by setting <code>model = "random"</code> and <code>effect = "nested"</code>,
requiring the data to be indexed by a third index  in which the "individual"
dimension is nested (see section <em>Examples</em> and the vignette
"Estimation of error components models with the plm function".)
</p>
<p>For first–difference models, the intercept is maintained (which
from a specification viewpoint amounts to allowing for a trend in
the levels model). The user can exclude it from the estimated
specification the usual way by adding <code>"-1"</code> to the model formula.
</p>
<p>Instrumental variables estimation is obtained using two–part
formulas, the second part indicating the instrumental variables
used. This can be a complete list of instrumental variables or an
update of the first part. If, for example, the model is <code>y ~ x1 + x2 + x3</code>, with <code>x1</code> and <code>x2</code> endogenous and <code>z1</code> and <code>z2</code> external
instruments, the model can be estimated with:
</p>

<ul>
<li> <p><code>formula = y~x1+x2+x3 | x3+z1+z2</code>,
</p>
</li>
<li> <p><code>formula = y~x1+x2+x3 | . -x1-x2+z1+z2</code>.
</p>
</li>
</ul>
<p>If an instrument variable estimation is requested, argument
<code>inst.method</code> selects the instrument variable transformation
method:
</p>

<ul>
<li> <p><code>"bvk"</code> (default) for Balestra and Varadharajan–Krishnakumar (1987),
</p>
</li>
<li> <p><code>"baltagi"</code> for Baltagi (1981),
</p>
</li>
<li> <p><code>"am"</code> for Amemiya and MaCurdy (1986),
</p>
</li>
<li> <p><code>"bms"</code> for Breusch et al. (1989).
</p>
</li>
</ul>
<p>The Hausman–Taylor estimator (Hausman and Taylor 1981) is
computed with arguments <code>random.method = "ht"</code>, <code>model = "random"</code>,
<code>inst.method = "baltagi"</code> (the other way with only <code>model = "ht"</code>
is deprecated).
</p>
<p>See also the vignettes for introductions to model estimations (and more) with
examples.
</p>


<h3>Value</h3>

<p>An object of class <code>"plm"</code>.
</p>
<p>A <code>"plm"</code> object has the following elements :
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>the vector of coefficients,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>the variance–covariance matrix of the coefficients,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>the vector of residuals (these are the residuals
of the (quasi-)demeaned model),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>(only for weighted estimations) weights as
specified,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p>degrees of freedom of the residuals,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class <code>"Formula"</code> describing the model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>the model frame as a <code>"pdata.frame"</code> containing the
variables used for estimation: the response is in first column followed by
the other variables, the individual and time indexes are in the 'index'
attribute of <code>model</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ercomp</code></td>
<td>
<p>an object of class <code>"ercomp"</code> providing the
estimation of the components of the errors (for random effects
models only),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aliased</code></td>
<td>
<p>named logical vector indicating any aliased
coefficients which are silently dropped by <code>plm</code> due to
linearly dependent terms (see also <code>detect.lindep()</code>),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call.</p>
</td>
</tr>
</table>
<p>It has <code>print</code>, <code>summary</code> and <code>print.summary</code> methods. The
<code>summary</code> method creates an object of class <code>"summary.plm"</code> that
extends the object it is run on with information about (inter alia) F
statistic and (adjusted) R-squared of model, standard errors, t–values, and
p–values of coefficients, (if supplied) the furnished vcov, see
<code>summary.plm()</code> for further details.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>References</h3>

<p>Amemiya T (1971).
“The Estimation of the Variances in a Variance–Components Model.”
<em>International Economic Review</em>, <b>12</b>, 1–13.
</p>
<p>Amemiya T, MaCurdy TE (1986).
“Instrumental-Variable Estimation of an Error-Components Model.”
<em>Econometrica</em>, <b>54</b>(4), 869-80.
</p>
<p>Balestra P, Varadharajan–Krishnakumar J (1987).
“Full Information Estimations of a System of Simultaneous Equations With Error Components.”
<em>Econometric Theory</em>, <b>3</b>, 223–246.
</p>
<p>Baltagi BH (1981).
“Simultaneous Equations With Error Components.”
<em>Journal of Econometrics</em>, <b>17</b>, 21–49.
</p>
<p>Baltagi BH, Song SH, Jung BC (2001).
“The unbalanced nested error component regression model.”
<em>Journal of Econometrics</em>, <b>101</b>, 357-381.
</p>
<p>Baltagi BH (2013).
<em>Econometric Analysis of Panel Data</em>, 5th edition.
John Wiley and Sons ltd.
</p>
<p>Breusch TS, Mizon GE, Schmidt P (1989).
“Efficient Estimation Using Panel Data.”
<em>Econometrica</em>, <b>57</b>(3), 695-700.
</p>
<p>Hausman JA, Taylor WE (1981).
“Panel Data and Unobservable Individual Effects.”
<em>Econometrica</em>, <b>49</b>, 1377–1398.
</p>
<p>Nerlove M (1971).
“Further Evidence on the Estimation of Dynamic Economic Relations from a Time–Series of Cross–Sections.”
<em>Econometrica</em>, <b>39</b>, 359–382.
</p>
<p>Swamy PAVB, Arora SS (1972).
“The Exact Finite Sample Properties of the Estimators of Coefficients in the Error Components Regression Models.”
<em>Econometrica</em>, <b>40</b>, 261–275.
</p>
<p>Wallace TD, Hussain A (1969).
“The Use of Error Components Models in Combining Cross Section With Time Series Data.”
<em>Econometrica</em>, <b>37</b>(1), 55–72.
</p>


<h3>See Also</h3>

<p><code>summary.plm()</code> for further details about the associated
summary method and the "summary.plm" object both of which provide some model
tests and tests of coefficients.  <code>fixef()</code> to compute the fixed
effects for "within" models (=fixed effects models). <code>predict.plm()</code> for
predicted values.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data("Produc", package = "plm")
zz &lt;- plm(log(gsp) ~ log(pcap) + log(pc) + log(emp) + unemp,
          data = Produc, index = c("state","year"))
summary(zz)

# replicates some results from Baltagi (2013), table 3.1
data("Grunfeld", package = "plm")
p &lt;- plm(inv ~ value + capital,
         data = Grunfeld, model = "pooling")

wi &lt;- plm(inv ~ value + capital,
          data = Grunfeld, model = "within", effect = "twoways")

swar &lt;- plm(inv ~ value + capital,
            data = Grunfeld, model = "random", effect = "twoways")

amemiya &lt;- plm(inv ~ value + capital,
               data = Grunfeld, model = "random", random.method = "amemiya",
               effect = "twoways")

walhus &lt;- plm(inv ~ value + capital,
              data = Grunfeld, model = "random", random.method = "walhus",
              effect = "twoways")

# summary and summary with a furnished vcov (passed as matrix, 
# as function, and as function with additional argument)
summary(wi)
summary(wi, vcov = vcovHC(wi))
summary(wi, vcov = vcovHC)
summary(wi, vcov = function(x) vcovHC(x, method = "white2"))


## nested random effect model
# replicate Baltagi/Song/Jung (2001), p. 378 (table 6), columns SA, WH
# == Baltagi (2013), pp. 204-205
data("Produc", package = "plm")
pProduc &lt;- pdata.frame(Produc, index = c("state", "year", "region"))
form &lt;- log(gsp) ~ log(pc) + log(emp) + log(hwy) + log(water) + log(util) + unemp
summary(plm(form, data = pProduc, model = "random", effect = "nested"))
summary(plm(form, data = pProduc, model = "random", effect = "nested",
            random.method = "walhus"))

## Instrumental variable estimations
# replicate Baltagi (2013/2021), p. 133/162, table 7.1
data("Crime", package = "plm")
FE2SLS &lt;- plm(lcrmrte ~ lprbarr + lpolpc + lprbconv + lprbpris + lavgsen +
                ldensity + lwcon + lwtuc + lwtrd + lwfir + lwser + lwmfg + lwfed +
                lwsta + lwloc + lpctymle + lpctmin + region + smsa + factor(year)
              | . - lprbarr - lpolpc + ltaxpc + lmix,
              data = Crime, model = "within")
G2SLS &lt;- update(FE2SLS, model = "random", inst.method = "bvk")
EC2SLS &lt;- update(G2SLS, model = "random", inst.method = "baltagi")

## Hausman-Taylor estimator and Amemiya-MaCurdy estimator
# replicate Baltagi (2005, 2013), table 7.4; Baltagi (2021), table 7.5
data("Wages", package = "plm")
ht &lt;- plm(lwage ~ wks + south + smsa + married + exp + I(exp ^ 2) + 
              bluecol + ind + union + sex + black + ed |
              bluecol + south + smsa + ind + sex + black |
              wks + married + union + exp + I(exp ^ 2), 
          data = Wages, index = 595,
          random.method = "ht", model = "random", inst.method = "baltagi")
summary(ht)

am &lt;- plm(lwage ~ wks + south + smsa + married + exp + I(exp ^ 2) + 
              bluecol + ind + union + sex + black + ed |
              bluecol + south + smsa + ind + sex + black |
              wks + married + union + exp + I(exp ^ 2), 
          data = Wages, index = 595,
          random.method = "ht", model = "random", inst.method = "am")
summary(am)

</code></pre>


</div>
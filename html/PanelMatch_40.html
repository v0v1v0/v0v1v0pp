<div class="container">

<table style="width: 100%;"><tr>
<td>PanelEstimate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PanelEstimate</h2>

<h3>Description</h3>

<p><code>PanelEstimate</code> estimates a causal quantity of interest, including the average treatment effect for
treated or control units (att and atc, respectively), the average effect of treatment reversal on reversed units (art), or average treatment effect (ate), as specified in <code>PanelMatch()</code>.
This is done by estimating the counterfactual outcomes for each treated unit using
matched sets. Users will provide matched sets that were obtained by the
<code>PanelMatch</code> function and obtain point estimates via a
weighted average computation with weighted bootstrap standard errors. Point estimates and standard errors will be
produced for each period in the lead window specified by the <code>lead</code> argument from <code>PanelMatch()</code>.
Users may run multiple estimations by providing lists of each argument to the function.
However, in this format, every argument must be explicitly specified in each configuration
and must adhere to the same data types/structures outlined below.
</p>


<h3>Usage</h3>

<pre><code class="language-R">PanelEstimate(
  sets,
  data,
  number.iterations = 1000,
  df.adjustment = FALSE,
  confidence.level = 0.95,
  moderator = NULL,
  se.method = "bootstrap",
  pooled = FALSE,
  include.placebo.test = FALSE,
  parallel = FALSE,
  num.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sets</code></td>
<td>
<p>A <code>PanelMatch</code> object attained via the
<code>PanelMatch()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The same time series cross sectional data set provided to the <code>PanelMatch()</code> function used to produce
the matched sets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>number.iterations</code></td>
<td>
<p>If using bootstrapping for calculating standard errors, this is the number of bootstrap iterations. Provide as integer. If <code>se.method</code> is not equal to "bootstrap", this argument has no effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.adjustment</code></td>
<td>
<p>A logical value indicating whether or not a
degree-of-freedom adjustment should be performed for the standard error
calculation. The default is <code>FALSE</code>. This parameter is only available for the bootstrap method of standard error calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confidence.level</code></td>
<td>
<p>A numerical value specifying the confidence level and range of interval
estimates for statistical inference. The default is .95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moderator</code></td>
<td>
<p>The name of a moderating variable, provided as a character string. If a moderating variable is provided,the returned object will be a list of <code>PanelEstimate</code> objects. The names of the list will reflect the different values of the moderating variable. More specifically, the moderating variable values will be converted to syntactically proper names using <code>make.names()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.method</code></td>
<td>
<p>Method used for calculating standard errors, provided as a character string. Users must choose between "bootstrap", "conditional", and "unconditional" methods. Default is "bootstrap". "bootstrap" uses a block bootstrapping procedure to calculate standard errors. The conditional method calculates the variance of the estimator, assuming independence across units but not across time. The unconditional method also calculates the variance of the estimator analytically, but makes no such assumptions about independence across units. When the quantity of interest is "att", "atc", or "art", all methods are available. Only "bootstrap" is available for the ate. If <code>pooled</code> argument is TRUE, then only bootstrap is available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pooled</code></td>
<td>
<p>Logical. If TRUE, estimates and standard errors are returned for treatment effects pooled across the entire lead window. Only available for <code>se.method = ``bootstrap''</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.placebo.test</code></td>
<td>
<p>Logical. If TRUE, a placebo test is run and returned in the results. The placebo test uses the same specifications for calculating standard errors as the main results. That is, standard errors are calculated according to the user provided <code>se.method</code> and <code>confidence.level</code> arguments (and, if applicable, parallelization specifications). If these are invalid for some reason, an error will be thrown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Logical. If TRUE and <code>se.method = ``bootstrap''</code>, bootstrap procedure will be parallelized. Default is FALSE. If <code>se.method</code> is not set to <code>bootstrap</code>, this option does nothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.cores</code></td>
<td>
<p>Integer. Specifies the number of cores to use for parallelization. If <code>se.method = ``bootstrap''</code> and <code>parallel = TRUE</code>, then this option will take effect. Otherwise, it will do nothing.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>PanelEstimate</code> returns a list of class
‘PanelEstimate’ containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>estimates</code></td>
<td>
<p>the point estimates of the quantity of interest for the lead periods specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.method</code></td>
<td>
<p>The method used to calculate standard errors. This is the same as the argument provided to the function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrapped.estimates</code></td>
<td>
<p>the bootstrapped point estimate values, when applicable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrap.iterations</code></td>
<td>
<p>the number of iterations used in bootstrapping, when applicable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>refinement method used to create the matched sets from which the estimates were calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag</code></td>
<td>
<p>See PanelMatch() argument <code>lag</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lead</code></td>
<td>
<p>The lead window sequence for which <code>PanelEstimate()</code> is producing point estimates and standard errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confidence.level</code></td>
<td>
<p>the confidence level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qoi</code></td>
<td>
<p>the quantity of interest</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matched.sets</code></td>
<td>
<p>the refined matched sets used to produce the estimations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standard.error</code></td>
<td>
<p>the standard error(s) of the point estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pooled</code></td>
<td>
<p>Logical indicating whether or not estimates were calculated for individual lead periods or pooled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>placebo.test</code></td>
<td>
<p>if <code>include.placebo.test = TRUE</code>, a placebo test is conducted using <code>placebo_test()</code> and returned as a list. See documentation for <code>placebo_test()</code> for more about each individual item.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, Adam Rauh &lt;amrauh@umich.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>


<h3>References</h3>

<p>Imai, Kosuke, In Song Kim, and Erik Wang (2023)
</p>


<h3>Examples</h3>

<pre><code class="language-R">dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2", 
                        treatment = "dem", refinement.method = "ps.match", 
                         data = dem.sub, match.missing = TRUE, covs.formula = ~ tradewb, 
                         size.match = 5, qoi = "att", outcome.var = "y", 
                         lead = 0:4, forbid.treatment.reversal = TRUE)
PE.results &lt;- PanelEstimate(sets = PM.results, data = dem.sub, se.method = "unconditional")

</code></pre>


</div>
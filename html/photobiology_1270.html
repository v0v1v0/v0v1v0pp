<div class="container">

<table style="width: 100%;"><tr>
<td>wls_at_target</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find wavelengths values corresponding to a target spectral value</h2>

<h3>Description</h3>

<p>Find wavelength values corresponding to a target spectral value in a spectrum.
The name of the column of the spectral data to be used is inferred from the
class of <code>x</code> and the argument passed to <code>unit.out</code> or
<code>filter.qty</code> or their defaults that depend on R options set.
</p>


<h3>Usage</h3>

<pre><code class="language-R">wls_at_target(
  x,
  target = NULL,
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...
)

## Default S3 method:
wls_at_target(
  x,
  target = NULL,
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...
)

## S3 method for class 'data.frame'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  x.var.name = NULL,
  y.var.name = NULL,
  ...
)

## S3 method for class 'generic_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  col.name = NULL,
  y.var.name = col.name,
  ...
)

## S3 method for class 'source_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'response_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'filter_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  filter.qty = getOption("photobiology.filter.qty", default = "transmittance"),
  ...
)

## S3 method for class 'reflector_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...
)

## S3 method for class 'solute_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...
)

## S3 method for class 'cps_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...
)

## S3 method for class 'raw_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...
)

## S3 method for class 'generic_mspct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data.frame or spectrum object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>numeric or character vector. A numeric value indicates the spectral
quantity value for which wavelengths are to be searched. A character
string representing a number is converted to numeric. A character value
representing a number followed by a function name, will be also accepted
and decoded, such that <code>"0.1max"</code> is interpreted as targeting one
tenth of the maximum value in the column. The character
strings "half.maximum" and "HM" are synonyms for "0.5max" while
"half.range" and "HR" are synonyms for "0.5range".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolate</code></td>
<td>
<p>logical Indicating whether the nearest wavelength value
in <code>x</code> should be returned or a value calculated by linear
interpolation between wavelength values straddling the target.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idfactor</code></td>
<td>
<p>logical or character Generates an index column of factor
type. If <code>idfactor = TRUE</code> then the column is auto named target.idx.
Alternatively the column name can be directly passed as argument to
<code>idfactor</code> as a character string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be stripped
before searching for the target.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.var.name, y.var.name, col.name</code></td>
<td>
<p>character The name of the columns in
which to search for the target value. Use of <code>col.name</code> is deprecated,
and is a synonym for <code>y.var.name</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit.out</code></td>
<td>
<p>character One of "energy" or "photon"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.qty</code></td>
<td>
<p>character One of "transmittance" or "absorbance"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A data.frame, a spectrum object or a collection of spectra object of
the same class as <code>x</code> with fewer rows, possibly even no rows. If
<code>FALSE</code> is passed to <code>interpolate</code> a subset of <code>x</code> is
returned, otherwise a new object of the same class containing interpolated
wavelengths for the <code>target</code> value is returned. As 'target' accepts
a vector or list as argument, a factor can be added to the output with
the corresponding target value.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>wls_at_target(default)</code>: Default returning always an empty object of the
same class as <code>x</code>.
</p>
</li>
<li> <p><code>wls_at_target(data.frame)</code>: Method for "data.frame" objects.
</p>
</li>
<li> <p><code>wls_at_target(generic_spct)</code>: Method for "generic_spct" objects.
</p>
</li>
<li> <p><code>wls_at_target(source_spct)</code>: Method for "source_spct" objects.
</p>
</li>
<li> <p><code>wls_at_target(response_spct)</code>: Method for "response_spct" objects.
</p>
</li>
<li> <p><code>wls_at_target(filter_spct)</code>: Method for "filter_spct" objects.
</p>
</li>
<li> <p><code>wls_at_target(reflector_spct)</code>: Method for "reflector_spct" objects.
</p>
</li>
<li> <p><code>wls_at_target(solute_spct)</code>: Method for "solute_spct" objects.
</p>
</li>
<li> <p><code>wls_at_target(cps_spct)</code>: Method for "cps_spct" objects.
</p>
</li>
<li> <p><code>wls_at_target(raw_spct)</code>: Method for "raw_spct" objects.
</p>
</li>
<li> <p><code>wls_at_target(generic_mspct)</code>: Method for "generic_mspct" objects.
</p>
</li>
</ul>
<h3>Note</h3>

<p>When interpolation is used, only column <code>w.length</code> and the column
against which the target value was compared are included in the returned
object, otherwise, all columns in <code>x</code> are returned. We implement
support for <code>data.frame</code> to simplify the coding of 'ggplot2' stats
using this function.
</p>


<h3>See Also</h3>

<p>Other peaks and valleys functions: 
<code>find_peaks()</code>,
<code>find_spikes()</code>,
<code>get_peaks()</code>,
<code>peaks()</code>,
<code>replace_bad_pixs()</code>,
<code>spikes()</code>,
<code>valleys()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">wls_at_target(sun.spct, target = 0.1)
wls_at_target(sun.spct, target = 2e-6, unit.out = "photon")
wls_at_target(polyester.spct, target = "HM")
wls_at_target(polyester.spct, target = "HM", interpolate = TRUE)
wls_at_target(polyester.spct, target = "HM", idfactor = "target")
wls_at_target(polyester.spct, target = "HM", filter.qty = "absorbance")

</code></pre>


</div>
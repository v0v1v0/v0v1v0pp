<div class="container">

<table style="width: 100%;"><tr>
<td>griddify</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Ensure that a geo-referenced matrix of environmental grids is rectangular</h2>

<h3>Description</h3>

<p>This function ensures that the coordinates of the supplied geo-referenced matrix of environmental grids constitutes a rectangular grid.</p>


<h3>Usage</h3>

<pre><code class="language-R">griddify(envframe, tol = 0.01, coord = c("X", "Y"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>envframe</code></td>
<td>
<p>The geo-referenced matrix of environmental grids.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The tolerance level within which to correct coordinate errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coord</code></td>
<td>
<p>A vector containing the names of the longitude and latitude coordinates.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The functions in the <code>ppmlasso</code> package require a set of quadrature points along a rectangular grid. At times a set of quadrature points with a desired spatial resolution of <code class="reqn">x_\delta \times y_\delta</code> will have some minor machine error in some coordinates such that the coordinates as supplied do not consistute a rectangular grid. The <code>griddify</code> function corrects this error as follows:
</p>
<p>Let <code class="reqn">\{x_1, x_2, \ldots, x_n\}</code> and <code class="reqn">\{y_1, y_2, \ldots, y_n\}</code> be the supplied coordinates contained in <code>envframe</code>. The function first determines the spatial resolution <code class="reqn">x_\delta \times y_\delta</code> based on the median of the differences in the unique values of <code class="reqn">x_i</code> and <code class="reqn">y_i</code> as well as the coordinates of a rectangular grid with this spatial resolution <code class="reqn">\{x^{grid}_1, x^{grid}_2, \ldots, x^{grid}_n\}</code> and <code class="reqn">\{y^{grid}_1, y^{grid}_2, \ldots, y^{grid}_n\}</code>. Given the tolerance <code class="reqn">\epsilon</code> supplied to <code>tol</code>, any coordinate <code class="reqn">x_i</code> for which <code class="reqn">0 &lt; \left|x_i - x^{grid}_i\right| \leq \epsilon \times x_\delta</code> will be adjusted to <code class="reqn">x^{grid}_i</code>. Likewise, any coordinate <code class="reqn">y_i</code> for which <code class="reqn">0 &lt; \left|y_i - y^{grid}_i\right| \leq \epsilon \times y_\delta</code> will be adjusted to <code class="reqn">y^{grid}_i</code>.
</p>
<p>Any environmental variables contained in <code>envframe</code> are left unchanged.
</p>


<h3>Value</h3>

<p>A data frame containing the coordinates on a rectangular grid as well as any environmental variables left unchanged.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>Examples</h3>

<pre><code class="language-R">X = seq(0, 5, 1)
Y = seq(1, 11, 2)
XY = expand.grid(X, Y) # generate 1 x 2 rectangular grid
names(XY) = c("X", "Y")
#move some coordinates off of rectangular grid
XY$X[1] = XY$X[1] - 0.01
XY$Y[1] = XY$Y[1] - 0.01
XY$X[7] = XY$X[7] + 0.01
XY$Y[7] = XY$Y[7] + 0.01

#generate environmental variables
XY$V1 = 0.1*XY$X + 0.2*XY$Y + rnorm(36, 0, 1)
XY$V2 = -0.2*XY$X + 0.1*XY$Y + 0.05*XY$X*XY$Y + rnorm(36, 0, 5)

XY_grid = griddify(XY)
</code></pre>


</div>
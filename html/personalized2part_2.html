<div class="container">

<table style="width: 100%;"><tr>
<td>fit_subgroup_2part</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting subgroup identification models for semicontinuous positive outcomes</h2>

<h3>Description</h3>

<p>Fits subgroup identification models
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit_subgroup_2part(
  x,
  y,
  trt,
  propensity.func = NULL,
  propensity.func.positive = NULL,
  match.id = NULL,
  augment.func.zero = NULL,
  augment.func.positive = NULL,
  cutpoint = 1,
  larger.outcome.better = TRUE,
  penalize.ate = TRUE,
  y_eps = 1e-06,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The design matrix (not including intercept term)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The nonnegative response vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trt</code></td>
<td>
<p>treatment vector with each element equal to a 0 or a 1, with 1 indicating
treatment status is active.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propensity.func</code></td>
<td>
<p>function that inputs the design matrix x and the treatment vector trt and outputs
the propensity score, ie Pr(trt = 1 | X = x). Function should take two arguments 1) x and 2) trt. See example below.
For a randomized controlled trial this can simply be a function that returns a constant equal to the proportion
of patients assigned to the treatment group, i.e.:
<code>propensity.func = function(x, trt) 0.5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propensity.func.positive</code></td>
<td>
<p>function that inputs the design matrix x and the treatment vector trt and outputs
the propensity score for units with positive outcome values, ie Pr(trt = 1 | X = x, Z = 1). Function should take
two arguments 1) x and 2) trt. See example below.
For a randomized controlled trial this can simply be a function that returns a constant equal to the proportion
of patients assigned to the treatment group, i.e.:
<code>propensity.func = function(x, trt) 0.5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>match.id</code></td>
<td>
<p>a (character, factor, or integer) vector with length equal to the number of observations in <code>x</code>
indicating using integers or levels of a factor vector which patients are
in which matched groups. Defaults to <code>NULL</code> and assumes the samples are not from a matched cohort. Matched
case-control groups can be created using any method (propensity score matching, optimal matching, etc). If each case
is matched with a control or multiple controls, this would indicate which case-control pairs or groups go together.
If <code>match.id</code> is supplied, then it is unecessary to specify a function via the <code>propensity.func</code> argument.
A quick usage example: if the first patient is a case and the second and third are controls matched to it, and the
fouth patient is a case and the fifth through seventh patients are matched with it, then the user should specify
<code>match.id = c(1,1,1,2,2,2,2)</code> or <code>match.id = c(rep("Grp1", 3),rep("Grp2", 4)) </code>
the covariates <code>x</code>, and <code>trt</code> and outputs predicted values (on the probability scale) for the response using a model
constructed with <code>x</code>. <code>augment.func.zero()</code> can also be simply
a function of <code>x</code> and <code>y</code>. This function is used for efficiency augmentation.
When the form of the augmentation function is correct, it can provide efficient estimation of the subgroups. Some examples of possible
augmentation functions are:
</p>
<p>Example 1: <code>augment.func &lt;- function(x, y) {lmod &lt;- glm(y ~ x, family = binomial()); return(fitted(lmod))}</code>
</p>
<p>Example 2:
</p>
<pre>
augment.func &lt;- function(x, y, trt) {
    data &lt;- data.frame(x, y, trt)
    lmod &lt;- glm(y ~ x * trt, family = binomial())
    ## get predictions when trt = 1
    data$trt &lt;- 1
    preds_1  &lt;- predict(lmod, data, type = "response")

    ## get predictions when trt = -1
    data$trt &lt;- -1
    preds_n1 &lt;- predict(lmod, data, type = "response")

    ## return predictions averaged over trt
    return(0.5 * (preds_1 + preds_n1))
}
</pre>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>augment.func.zero</code></td>
<td>
<p>(similar to augment.func.positive) function which inputs the
indicators of whether each response is positive (<code>1*(y &gt; 0)</code>),
the covariates <code>x</code>, and <code>trt</code> for all samples and outputs predicted values (on the link scale) for the response using a model
constructed with <code>x</code>. <code>augment.func.positive()</code> can also be simply
a function of <code>x</code> and <code>y</code>. This function is used for efficiency augmentation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>augment.func.positive</code></td>
<td>
<p>(similar to augment.func.zero) function which inputs the positive part response
(ie all observations in <code>y</code> which are strictly positive),
the covariates <code>x</code>, and <code>trt</code> and outputs predicted values (on the link scale) for the response using a model
constructed with <code>x</code>. <code>augment.func.positive()</code> can also be simply
a function of <code>x</code> and <code>y</code>. This function is used for efficiency augmentation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutpoint</code></td>
<td>
<p>numeric value for patients with benefit scores above which
(or below which if <code>larger.outcome.better = FALSE</code>)
will be recommended to be in the treatment group. Defaults to 1, since the benefit score is a risk ratio</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>larger.outcome.better</code></td>
<td>
<p>boolean value of whether a larger outcome is better/preferable. Set to <code>TRUE</code>
if a larger outcome is better/preferable and set to <code>FALSE</code> if a smaller outcome is better/preferable. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalize.ate</code></td>
<td>
<p>should the treatment main effect (ATE) be penalized too?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y_eps</code></td>
<td>
<p>positive value above which observations in <code>y</code> will be considered positive</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>options to be passed to <code>cv.hd2part</code></p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">
set.seed(42)

dat &lt;- sim_semicontinuous_data(250, n.vars = 15)
x &lt;- dat$x
y &lt;- dat$y
trt &lt;- dat$trt

prop_func &lt;- function(x, trt)
{
    propensmod &lt;- glm(trt ~ x, family = binomial())

    propens &lt;- unname(fitted(propensmod))
    propens
}

fitted_model &lt;- fit_subgroup_2part(x, y, trt, prop_func, prop_func)

fitted_model

## correlation of estimated covariate-conditional risk ratio and truth
cor(fitted_model$benefit.scores, dat$treatment_risk_ratio, method = "spearman")


</code></pre>


</div>
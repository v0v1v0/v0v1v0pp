<div class="container">

<table style="width: 100%;"><tr>
<td>analyze_objects_shp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Analyzes objects using shapefiles</h2>

<h3>Description</h3>

<p>Analyzes objects using shapefiles
</p>


<h3>Usage</h3>

<pre><code class="language-R">analyze_objects_shp(
  img,
  nrow = 1,
  ncol = 1,
  buffer_x = 0,
  buffer_y = 0,
  prepare = FALSE,
  segment_objects = TRUE,
  viewer = get_pliman_viewer(),
  index = "R",
  r = 1,
  g = 2,
  b = 3,
  re = 4,
  nir = 5,
  shapefile = NULL,
  interactive = FALSE,
  plot = FALSE,
  parallel = FALSE,
  workers = NULL,
  watershed = TRUE,
  filter = FALSE,
  object_size = "medium",
  efourier = FALSE,
  object_index = NULL,
  veins = FALSE,
  width_at = FALSE,
  verbose = TRUE,
  invert = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>img</code></td>
<td>
<p>An <code>Image</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrow, ncol</code></td>
<td>
<p>The number of rows and columns to generate the shapefile
when <code>shapefile</code> is not declared. Defaults to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>buffer_x, buffer_y</code></td>
<td>
<p>Buffering factor for the width and height,
respectively, of each individual shape's side. A value between 0 and 0.5 where 0
means no buffering and 0.5 means complete buffering (default: 0). A value of
0.25 will buffer the shape by 25% on each side.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prepare</code></td>
<td>
<p>Logical value indicating whether to prepare the image for
analysis using <code>image_prepare()</code> function. Defaults to <code>FALSE</code>. Set to
<code>TRUE</code> to interactively align and crop the image before processing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segment_objects</code></td>
<td>
<p>Segment objects in the image? Defaults to <code>TRUE</code>. In
this case, objects are segmented using the index defined in the <code>index</code>
argument, and each object is analyzed individually. If <code>segment_objects = FALSE</code> is used, the objects are not segmented and the entire image is
analyzed. This is useful, for example, when analyzing an image without
background, where an <code>object_index</code> could be computed for the entire image,
like the index of a crop canopy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code>get_pliman_viewer()</code>. This option controls the type of viewer to use
for interactive plotting. The available options are "base" and "mapview".
If set to "base", the base R graphics system is used for interactive
plotting. If set to "mapview", the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code>set_pliman_viewer()</code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to "mapview" for
all functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>A character value specifying the target mode for conversion to
binary image when <code>foreground</code> and <code>background</code> are not declared. Defaults
to <code>"NB"</code> (normalized blue). See <code>image_index()</code> for more details. User can
also calculate your own index using the bands names, e.g. <code>index = "R+B/G"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r, g, b, re, nir</code></td>
<td>
<p>The red, green, blue, red-edge, and near-infrared bands
of the image, respectively. Defaults to 1, 2, 3, 4, and 5, respectively. If
a multispectral image is provided (5 bands), check the order of bands,
which are frequently presented in the 'BGR' format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shapefile</code></td>
<td>
<p>(Optional) An object created with <code>image_shp()</code>. If <code>NULL</code>
(default), both <code>nrow</code> and <code>ncol</code> must be declared.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interactive</code></td>
<td>
<p>If <code>FALSE</code> (default) the grid is created automatically
based on the image dimension and number of nrow/columns. If <code>interactive = TRUE</code>, users must draw points at the diagonal of the desired bounding box
that will contain the grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>Plots the processed images? Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>If <code>TRUE</code> processes the images asynchronously (in parallel) in
separate R sessions running in the background on the same machine. It may
speed up the processing time, especially when <code>pattern</code> is used is informed.
When <code>object_index</code> is informed, multiple sections will be used to extract
the RGB values for each object in the image. This may significantly speed up
processing time when an image has lots of objects (say &gt;1000).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the number
of parallel processes that can be active at the same time. By default, the
number of sections is set up to 30% of available cores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>watershed</code></td>
<td>
<p>If <code>TRUE</code> (default) performs watershed-based object
detection. This will detect objects even when they are touching one other.
If <code>FALSE</code>, all pixels for each connected set of foreground pixels are set
to a unique object. This is faster but is not able to segment touching
objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter</code></td>
<td>
<p>Performs median filtering in the binary image? See more at
<code>image_filter()</code>. Defaults to <code>FALSE</code>. Use a positive integer to define the
size of the median filtering. Larger values are effective at removing noise,
but adversely affect edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object_size</code></td>
<td>
<p>Argument to control control the watershed segmentation.
See <code>analyze_objects()</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>efourier</code></td>
<td>
<p>Logical argument indicating if Elliptical Fourier should be
computed for each object. This will call <code>efourier()</code> internally. It
<code>efourier = TRUE</code> is used, both standard and normalized Fourier coefficients
are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object_index</code></td>
<td>
<p>Defaults to <code>FALSE</code>. If an index is informed, the average
value for each object is returned. It can be the R, G, and B values or any
operation involving them, e.g., <code>object_index = "R/B"</code>. In this case, it
will return for each object in the image, the average value of the R/B
ratio. Use <code>pliman_indexes_eq()</code> to see the equations of available indexes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>veins</code></td>
<td>
<p>Logical argument indicating whether vein features are computed.
This will call <code>object_edge()</code> and applies the Sobel-Feldman Operator to
detect edges. The result is the proportion of edges in relation to the
entire area of the object(s) in the image. Note that <strong>THIS WILL BE AN
OPERATION ON AN IMAGE LEVEL, NOT OBJECT!</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width_at</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the widths of the object at a given set
of quantiles of the height are computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invert</code></td>
<td>
<p>Inverts the binary image if desired. This is useful to process
images with a black background. Defaults to <code>FALSE</code>. If <code>reference = TRUE</code>
is use, <code>invert</code> can be declared as a logical vector of length 2 (eg.,
<code style="white-space: pre;">⁠invert = c(FALSE, TRUE⁠</code>). In this case, the segmentation of objects and
reference from the foreground using <code>back_fore_index</code> is performed using the
default (not inverted), and the segmentation of objects from the reference
is performed by inverting the selection (selecting pixels higher than the
threshold).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Aditional arguments passed on to analyze_objects.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>analyze_objects_shp</code> function performs object analysis on an
image and generates shapefiles representing the analyzed objects. The
function first prepares the image for analysis using the <code>image_prepare()</code>
function if the <code>prepare</code> argument is set to <code>TRUE</code>. If a shapefile object is
provided, the number of rows and columns for splitting the image is obtained
from the shapefile. Otherwise, the image is split into multiple sub-images
based on the specified number of rows and columns using the
<code>object_split_shp()</code> function. The objects in each sub-image are analyzed
using the <code>analyze_objects()</code> function, and the results are stored in a list.
If parallel processing is enabled, the analysis is performed in parallel
using multiple workers.
</p>
<p>The output object provides access to various components of the analysis
results, such as the analyzed object coordinates and properties.
Additionally, the shapefiles representing the analyzed objects are included
in the output object for further analysis or visualization.
</p>


<h3>Value</h3>

<p>An object of class <code>anal_obj</code>. See more details in the <code>Value</code>
section of <code>analyze_objects()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(interactive()){
library(pliman)

# Computes the DGCI index for each flax leaf
flax &lt;- image_pliman("flax_leaves.jpg", plot =TRUE)
res &lt;-
   analyze_objects_shp(flax,
                       nrow = 3,
                       ncol = 5,
                       plot = FALSE,
                       object_index = "DGCI")
plot(flax)
plot(res$shapefiles)
plot_measures(res, measure = "DGCI")
}
</code></pre>


</div>
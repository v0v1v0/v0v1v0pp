<div class="container">

<table style="width: 100%;"><tr>
<td>penAFT.coef</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract regression coefficients from fitted model object</h2>

<h3>Description</h3>

<p>A function to extract coefficients along the solution path for the regularized semiparametric acceleratred failure time model estimator.</p>


<h3>Usage</h3>

<pre><code class="language-R">penAFT.coef(fit, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>A fitted model from <code>penAFT</code> or <code>penAFT.cv</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The tuning parameter value at which to extract coefficients. If <code>NULL</code> and <code>fit</code> is a <code>penAFT.cv</code> object, will use the tuning parameter value with minimum cross-validation linear predictor score.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The regression coefficients stored in the fitted model objects coming from <code>penAFT</code> or <code>penAFT.cv</code> will (i) be on the scale of standardized predictors if standardization was used (which is the default) and (ii) are stored as a specific sparse matrix so that coefficient extraction is cumbersome. This function returns the regression coefficient estimates on the original scale of the predictors for a particular tuning parmaeter value. It is important to note that this method does not return an estimate of the intercept: the intercept is absored into the error term as the Gehan loss function is invariant to location change. 
</p>


<h3>Value</h3>

<table><tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>The coefficient estimates</p>
</td>
</tr></table>
<h3>Examples</h3>

<pre><code class="language-R"># --------------------------------------
# Generate data  
# --------------------------------------
set.seed(1)
genData &lt;- genSurvData(n = 100, p = 50, s = 10, mag = 1, cens.quant = 0.6)
X &lt;- genData$X
logY &lt;- genData$logY
delta &lt;- genData$status


# --------------------------------------
# Fit elastic net penalized estimator without CV
# --------------------------------------
fit &lt;- penAFT(X = X, logY = logY, delta = delta,
                   nlambda = 50,
                   penalty = "EN",
                   alpha = 1)

coef.10 &lt;- penAFT.coef(fit, lambda = fit$lambda[10])
coef.20 &lt;- penAFT.coef(fit, lambda = fit$lambda[20])

# Cannot obtain fit at lambda not in fit$lambda
## Not run: coef.error &lt;- penAFT.coef(fit, lambda = 10) # throws error


  # ------------------------------------------
  # Fit elastic net penalized estimator with CV
  # -------------------------------------------
  fit.cv &lt;- penAFT.cv(X = X, logY = logY, delta = delta,
                   nlambda = 50,
                   penalty = "EN", 
                   alpha = 1, nfolds = 5)

  ## --- coefficients at lambda minimizing cross-validation error
  coef.cv &lt;- penAFT.coef(fit.cv) 

  ## ---- coefficients at 10th considered lambda 
  coef.cv10 &lt;- penAFT.coef(fit.cv, lambda = fit.cv$full.fit$lambda[10]) 

  # -------------------------------------------
  # Repeat with sparse group lasso without CV
  # -------------------------------------------
  groups &lt;- rep(1:10, each = 5)
  fit.sg &lt;- penAFT(X = X, logY = logY, delta = delta,
                   nlambda = 50, groups = groups,
                   penalty = "SG",
                   alpha = 0.5)

  coef.sg.10 &lt;- penAFT.coef(fit.sg, lambda = fit.sg$lambda[10])
  coef.sg.20 &lt;- penAFT.coef(fit.sg, lambda = fit.sg$lambda[20])


  # -------------------------------------------
  # Finally, fit sparse group lasso with CV
  # -------------------------------------------
  groups &lt;- rep(1:10, each = 5)
  fit.sg.cv &lt;- penAFT.cv(X = X, logY = logY, delta = delta,
                   nlambda = 50, groups = groups,
                   penalty = "SG",
                   alpha = 0.5, nfolds = 5)

  coef.sg.cv &lt;- penAFT.coef(fit.sg.cv)
  coef.sg.cv10 &lt;- penAFT.coef(fit.sg.cv, lambda = fit.sg$full.fit$lambda[20])


</code></pre>


</div>
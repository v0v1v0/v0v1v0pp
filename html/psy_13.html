<div class="container">

<table style="width: 100%;"><tr>
<td>sphpca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spherical Representation of a Correlation Matrix</h2>

<h3>Description</h3>

<p>Graphical representation of a correlation matrix, similar to principal component analysis (PCA) but the mapping is on a sphere. The information is close to a 3d PCA, the picture is however easier to interpret since the variables are in fact on a 2d map.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sphpca(datafile, h=0, v=0, f=0, cx=0.75, nbsphere=2, back=FALSE, input="data",
       method="approx", maxiter=500, output=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>datafile</code></td>
<td>
<p>name of datafile</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>rotation of the sphere on a horizontal plane (in degres)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>rotation of the sphere on a vertical plane (in degres)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>rotation of the sphere on a frontal plane (in degres)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cx</code></td>
<td>
<p>size of the lettering (0.75 by default, 1 for bigger letters, 0.5 for smaller)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbsphere</code></td>
<td>
<p>two by default: front and back</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>back</code></td>
<td>
<p>"FALSE" by default: the back sphere is not seen through</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>"data" by default: raw data are analysed, if not "data": correlation matrix is expected</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>"approx" by default: the estimation is based on a principal component analysis approximation. If "exact" the "approx" estimation is optimized (may be computationaly consumming). if "rscal" a multidimensional scaling approach is used: distances between points on the sphere are optimized so that they represent at best the original correlations. The scaling that is used leads to angles on the sphere proportional to correlation between variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>maximum number of iterations in the optim process</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>FALSE by default: if TRUE and method="rscal" numerical results are proposed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>There is an isophormism between a correlation matrix and points on the unit hypersphere of Rn. It can be shown that a 3d spherical representation of a correlation matrix is statistically and cognitively interesting (see reference).
The default option method="approx" is based on a principal components approximation (see reference). It is fast and gives rather good results.
If method="exact" the representation is sligthly improved in terms of fit (the sphere minimizes the sum of squared distances between the original variables on the hypersphere and their projections on the sphere).
The option method="rscal" optimizes the representation of correlations between variables with distances between points (in a least squares sense). For convenience, the scaling of points on the sphere is chosen so that angles between points are linearly related to correlations between variables (this is not the case on the hypersphere were d=[2*(1-r)]^0.5).
For method="exact" or method="rscal" computations may be rather lengthy (and not sensible for more than 20-40 variables).
The sphere may be rotated to help in visualising most of variables on a same side (front for example).
By default, the back of the sphere (right plot) is not seen showing through.
</p>


<h3>Value</h3>

<p>A plot.
If method="rscal" and output=TRUE, a list with :
</p>
<table>
<tr style="vertical-align: top;">
<td><code>$stress.before.optim</code></td>
<td>
<p>Stress before optimization. The stress is equal to the sum of squares of differences between distances on the 3d sphere and distances on the hypersphere.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$stress.after.optim</code></td>
<td>
<p>Stress after optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$convergence</code></td>
<td>
<p>If 0, convergence is OK. If not, maxiter may be increased.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$correlations</code></td>
<td>
<p>Correlation matrix of variables (Pearson).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$residuals</code></td>
<td>
<p>Differences between observed correlations (hypersphere) and correlations estimated from points on the 3d sphere.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$mean.abs.resid</code></td>
<td>
<p>Mean of absolute values of residuals.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Bruno Falissard</p>


<h3>References</h3>

<p>Falissard B, A spherical representation of a correlation matrix, Journal of Classification (1996), 13:2, 267-280.</p>


<h3>Examples</h3>

<pre><code class="language-R">data(sleep)
sphpca(sleep[,c(2:5,7:11)])
## spherical representation of ecological and constitutional correlates in mammals

sphpca(sleep[,c(2:5,7:11)],method="rscal",output=TRUE)
## idem, but optimizes the representation of correlations between variables with distances
## between points

corsleep &lt;- as.data.frame(cor(sleep[,c(2:5,7:11)],use="pairwise.complete.obs"))
sphpca(corsleep,input="Cor")
sphpca(corsleep,method="rscal",input="Cor")
## when missing data are numerous, the representation of a pairwise correlation
## matrix may be preferred (even if mathematical properties are not so good...)

sphpca(corsleep,method="rscal",input="Cor",h=180,f=180,nbsphere=1,back=TRUE)
## other option of presentation

##
# library(polycor)
# sleep$Predation &lt;- as.ordered(sleep$Predation)
# sleep$Sleep.exposure &lt;- as.ordered(sleep$Sleep.exposure)
# sleep$Danger &lt;- as.ordered(sleep$Danger)
# corsleeph &lt;- as.data.frame(hetcor(sleep[,c(2:5,7:11)])$correlations)
# sphpca(corsleeph,input="Cor",f=180)
# sphpca(corsleeph,method="rscal",input="Cor",f=180)
## --&gt; Correlations between discrete variables may appear shoking to some statisticians (?)
## --&gt; Representation of polychoric/polyserial correlations could be prefered in this situation
</code></pre>


</div>
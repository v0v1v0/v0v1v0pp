<div class="container">

<table style="width: 100%;"><tr>
<td>cranknic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Crank-Nicolson Method
</h2>

<h3>Description</h3>

<p>The Crank-Nicolson method for solving ordinary differential equations is a
combination of the generic steps of the forward and backward Euler methods.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cranknic(f, t0, t1, y0, ..., N = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>function in the differential equation <code class="reqn">y' = f(x, y)</code>;<br>
defined as a function <code class="reqn">R \times R^m \rightarrow R^m</code>, where
<code class="reqn">m</code> is the number of equations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t0, t1</code></td>
<td>
<p>start and end points of the interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y0</code></td>
<td>
<p>starting values as row or column vector;
for <code class="reqn">m</code> equations <code>y0</code> needs to be a vector of length <code>m</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of steps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters to be passed to the function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Adding together forward and backword Euler method in the <code>cranknic</code>
method is by finding the root of the function merging these two formulas.
</p>
<p>No attempt is made to catch any errors in the root finding functions.
</p>


<h3>Value</h3>

<p>List with components <code>t</code> for grid (or ‘time’) points between <code>t0</code>
and <code>t1</code>, and <code>y</code> an n-by-m matrix with solution variables in
columns, i.e. each row contains one time stamp.
</p>


<h3>Note</h3>

<p>This is for demonstration purposes only; for real problems or applications
please use <code>ode23</code> or <code>rkf54</code>.
</p>


<h3>References</h3>

<p>Quarteroni, A., and F. Saleri (2006). Scientific Computing With MATLAB and
Octave. Second Edition, Springer-Verlag, Berlin Heidelberg.
</p>


<h3>See Also</h3>

<p><code>ode23</code>, <code>newmark</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##  Newton's example
f &lt;- function(x, y) 1 - 3*x + y + x^2 + x*y
sol100  &lt;- cranknic(f, 0, 1, 0, N = 100)
sol1000 &lt;- cranknic(f, 0, 1, 0, N = 1000)

## Not run: 
# Euler's forward approach
feuler &lt;- function(f, t0, t1, y0, n) {
    h &lt;- (t1 - t0)/n;  x &lt;- seq(t0, t1, by = h)
    y &lt;- numeric(n+1); y[1] &lt;- y0
    for (i in 1:n) y[i+1] &lt;- y[i] + h * f(x[i], y[i])
    return(list(x = x, y = y))
}

solode &lt;- ode23(f, 0, 1, 0)
soleul &lt;- feuler(f, 0, 1, 0, 100)

plot(soleul$x, soleul$y, type = "l", col = "blue", 
     xlab = "", ylab = "", main = "Newton's example")
lines(solode$t, solode$y, col = "gray", lwd = 3)
lines(sol100$t, sol100$y, col = "red")
lines(sol1000$t, sol1000$y, col = "green")
grid()

##  System of differential equations
# "Herr und Hund"
fhh &lt;- function(x, y) {
    y1 &lt;- y[1]; y2 &lt;- y[2]
    s &lt;- sqrt(y1^2 + y2^2)
    dy1 &lt;- 0.5 - 0.5*y1/s
    dy2 &lt;- -0.5*y2/s
    return(c(dy1, dy2))
}

sol &lt;- cranknic(fhh, 0, 60, c(0, 10))
plot(sol$y[, 1], sol$y[, 2], type = "l", col = "blue",
     xlab = "", ylab = "", main = '"Herr und Hund"')
grid()
## End(Not run)
</code></pre>


</div>
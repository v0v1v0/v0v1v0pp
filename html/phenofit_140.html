<div class="container">

<table style="width: 100%;"><tr>
<td>season</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Growing season division</h2>

<h3>Description</h3>

<p>Divide growing seasons according to rough fitting (<code>rFUN</code>) result .
</p>
<p>For <code>season</code>, rough fitting is applied for whole.
For <code>season_mov</code> rough fitting is applied in every year, during which
<code>maxExtendMonth</code> is extended.
</p>


<h3>Usage</h3>

<pre><code class="language-R">season(
  INPUT,
  rFUN,
  wFUN,
  iters = 2,
  wmin = 0.1,
  lambda,
  nf = 3,
  frame = floor(INPUT$nptperyear/5) * 2 + 1,
  minpeakdistance = NULL,
  ypeak_min = 0.1,
  r_max = 0.2,
  r_min = 0.05,
  rtrough_max = 0.6,
  MaxPeaksPerYear = 2,
  MaxTroughsPerYear = 3,
  calendarYear = FALSE,
  adj.param = TRUE,
  rm.closed = TRUE,
  is.continuous = TRUE,
  .check_season = TRUE,
  verbose = FALSE,
  ...
)

stat_season(INPUT, d_fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>INPUT</code></td>
<td>
<p>A list object with the elements of <code>t</code>, <code>y</code>, <code>w</code>,
<code>Tn</code> (optional) and <code>ylu</code>, returned by <code>check_input()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rFUN</code></td>
<td>
<p>character, the name of rough curve fitting function, can be one of
c("smooth_wSG", "smooth_wWHIT", "smooth_wHANTS"), which are corresponding to
<code>smooth_wSG()</code>, <code>smooth_wWHIT()</code> and <code>smooth_wHANTS()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wFUN</code></td>
<td>
<p>weights updating function, can be one of .</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iters</code></td>
<td>
<p>integer, the number of rough fitting iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wmin</code></td>
<td>
<p>double, minimum weigth (i.e. weight of snow, ice and cloud).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The smoothing parameter of <code>smooth_wWHIT()</code>. For
<code>season_mov()</code>, if lambda is <code>NULL</code>, <code>init_lambda()</code>
will be used. Generally, it was set as 10000, 15, and 5 for daily, 8-day
and 16-day inputs respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nf</code></td>
<td>
<p>The parameter of <code>smooth_wHANTS()</code>, number of frequencies to be
considered above the zero frequency.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frame</code></td>
<td>
<p>The parameter of <code>smooth_wSG()</code>, moving window size. Suggested by
TIMESAT, default <code>frame = floor(nptperyear/7)*2 + 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minpeakdistance</code></td>
<td>
<p>double, in points (default as
<code>nptperyear/6</code>). The minimum distance of two peaks. If the distance of two
maximum extreme value less than <code>minpeakdistance</code>, only the real maximum
value will be left.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ypeak_min</code></td>
<td>
<p><code>y_peak &gt;= ypeak_min</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_max</code></td>
<td>
<p>Similar as <code>r_min</code>, The maximum threshold should
be greater than <code>r_max</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_min</code></td>
<td>
<p>Threshold is defined as the difference of peak value with
trough value. There are two threshold (left and right). The minimum threshold
should be greater than r_min.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rtrough_max</code></td>
<td>
<p><code>ytrough &lt;= rtrough_max*A</code>, A is the amplitude of y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaxPeaksPerYear</code></td>
<td>
<p>This parameter is used to adjust lambda in iterations.
If PeaksPerYear &gt; MaxPeaksPerYear, then lambda = lambda*2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaxTroughsPerYear</code></td>
<td>
<p>This parameter is used to adjust lambda in iterations.
If TroughsPerYear &gt; MaxTroughsPerYear, then lambda = lambda*2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calendarYear</code></td>
<td>
<p>If true, only one static calendar growing season will be
returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.param</code></td>
<td>
<p>,
.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm.closed</code></td>
<td>
<p>boolean. Whether check the two closest peaks (or troughs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.continuous</code></td>
<td>
<p>boolean. Whether the input is continuous? This parameter
is for fluxsite site-year data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.check_season</code></td>
<td>
<p>not used (only for debug)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>whether to print <code>options_season</code> into console?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d_fit</code></td>
<td>
<p>A data.frame with the columns of <code>t</code>, <code>y</code>, <code>witer...</code> and <code>ziter...</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Before growing season division, <code>INPUT</code> should be added a year in head
and tail first by <code>add_HeadTail</code>.
</p>
<p>Finally, use <code>findpeaks()</code> to get local maximum and local minimum values.
Two local minimum define a growing season.
If two local minimum(maximum) are too closed, then only the smaller(biger)
is left.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>fit</code>: A data.table of Rough fitting result, with the columns of
(<code>t</code>, <code>y</code>, <code>witer1</code>, ..., <code>witerN</code>, <code>ziter1</code>, ..., <code>ziterN</code>).
</p>
</li>
<li> <p><code>dt</code>: A data.table of growing season division information, with the columns
of (<code>beg</code>, <code>peak</code>, <code>end</code>, <code>y_beg</code>, <code>y_peak</code>, <code>y_end</code>, <code>len</code>, <code>year</code>,
<code>season</code>, <code>flag</code>).
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>findpeaks()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("CA_NS6")
d &lt;- CA_NS6

nptperyear &lt;- 23
INPUT &lt;- check_input(d$t, d$y, d$w,
    QC_flag = d$QC_flag,
    nptperyear = nptperyear, south = FALSE,
    maxgap = nptperyear / 4, alpha = 0.02, wmin = 0.2
)
# plot_input(INPUT)

wFUN &lt;- "wTSM"
# all year as a whole
options = list(rFUN = "smooth_wWHIT", wFUN = wFUN, lambda = 10)
brks &lt;- season(INPUT, lambda = 10)
plot_season(INPUT, brks, d)

brks2 = season_input(INPUT, options)
all.equal(brks2, brks)

c(d_fit, info_peak) %&lt;-% roughFit(INPUT)
d_season = find_season.peaks(d_fit, info_peak)

c(t, ypred) %&lt;-% d_fit[, .(t, ziter2)]
d_season = find_season.default(ypred, t)
all.equal(brks$dt, d_season)

# opt &lt;- .options$season
# brks$fit - d_fit # function passed test

# curve fitting by year
brks_mov &lt;- season_mov(INPUT,
    options = list(
        rFUN = "smooth_wWHIT", wFUN = wFUN,
        lambda = 10,
        r_min = 0.05, ypeak_min = 0.05,
        verbose = TRUE
    )
)
plot_season(INPUT, brks_mov)

rfit &lt;- brks2rfit(brks_mov)
r &lt;- get_pheno(rfit)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>SyncBackend</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SyncBackend</h2>

<h3>Description</h3>

<p>This is a concrete implementation of the abstract class <code>Backend</code>
that implements the <code>Service</code> interface. This backend executes
tasks in parallel on a <code>parallel::makeCluster()</code> cluster synchronously (i.e.,
blocking the main <code>R</code> session).
</p>


<h3>Super classes</h3>

<p><code>parabar::Service</code> -&gt; <code>parabar::Backend</code> -&gt; <code>SyncBackend</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SyncBackend-new"><code>SyncBackend$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-finalize"><code>SyncBackend$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-start"><code>SyncBackend$start()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-stop"><code>SyncBackend$stop()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-clear"><code>SyncBackend$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-peek"><code>SyncBackend$peek()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-export"><code>SyncBackend$export()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-evaluate"><code>SyncBackend$evaluate()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-sapply"><code>SyncBackend$sapply()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-lapply"><code>SyncBackend$lapply()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-apply"><code>SyncBackend$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-get_output"><code>SyncBackend$get_output()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-clone"><code>SyncBackend$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-SyncBackend-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>SyncBackend</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$new()</pre></div>



<h5>Returns</h5>

<p>An object of class <code>SyncBackend</code>.
</p>


<hr>
<a id="method-SyncBackend-finalize"></a>



<h4>Method <code>finalize()</code>
</h4>

<p>Destroy the current <code>SyncBackend</code> instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$finalize()</pre></div>



<h5>Returns</h5>

<p>An object of class <code>SyncBackend</code>.
</p>


<hr>
<a id="method-SyncBackend-start"></a>



<h4>Method <code>start()</code>
</h4>

<p>Start the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$start(specification)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification</code></dt>
<dd>
<p>An object of class <code>Specification</code>
that contains the backend configuration.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The resulting backend must be stored in the
<code>.cluster</code> private field on the <code>Backend</code> abstract class,
and accessible to any concrete backend implementations via the active
binding <code>cluster</code>.
</p>


<hr>
<a id="method-SyncBackend-stop"></a>



<h4>Method <code>stop()</code>
</h4>

<p>Stop the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$stop()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-SyncBackend-clear"></a>



<h4>Method <code>clear()</code>
</h4>

<p>Remove all objects from the backend. This function is equivalent to
calling <code>rm(list = ls(all.names = TRUE))</code> on each node in the
backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$clear()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-SyncBackend-peek"></a>



<h4>Method <code>peek()</code>
</h4>

<p>Inspect the backend for variables available in the <code>.GlobalEnv</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$peek()</pre></div>



<h5>Returns</h5>

<p>This method returns a list of character vectors, where each element
corresponds to a node in the backend. The character vectors contain
the names of the variables available in the <code>.GlobalEnv</code> on each
node.
</p>


<hr>
<a id="method-SyncBackend-export"></a>



<h4>Method <code>export()</code>
</h4>

<p>Export variables from a given environment to the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$export(variables, environment)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>variables</code></dt>
<dd>
<p>A character vector of variable names to export.</p>
</dd>
<dt><code>environment</code></dt>
<dd>
<p>An environment object from which to export the
variables. Defaults to the parent frame.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-SyncBackend-evaluate"></a>



<h4>Method <code>evaluate()</code>
</h4>

<p>Evaluate an arbitrary expression on the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$evaluate(expression)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expression</code></dt>
<dd>
<p>An unquoted expression to evaluate on the backend.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns the result of the expression evaluation.
</p>


<hr>
<a id="method-SyncBackend-sapply"></a>



<h4>Method <code>sapply()</code>
</h4>

<p>Run a task on the backend akin to <code>parallel::parSapply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$sapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code>Backend</code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-SyncBackend-lapply"></a>



<h4>Method <code>lapply()</code>
</h4>

<p>Run a task on the backend akin to <code>parallel::parLapply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$lapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code>Backend</code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-SyncBackend-apply"></a>



<h4>Method <code>apply()</code>
</h4>

<p>Run a task on the backend akin to <code>parallel::parApply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$apply(x, margin, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>An array to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>margin</code></dt>
<dd>
<p>A numeric vector indicating the dimensions of <code>x</code> the
<code>fun</code> function should be applied over. For example, for a matrix,
<code>margin = 1</code> indicates applying <code>fun</code> rows-wise, <code>margin = 2</code>
indicates applying <code>fun</code> columns-wise, and <code>margin = c(1, 2)</code>
indicates applying <code>fun</code> element-wise. Named dimensions are also
possible depending on <code>x</code>. See <code>parallel::parApply()</code> and
<code>base::apply()</code> for more details.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to <code>x</code> according to the <code>margin</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code>Backend</code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-SyncBackend-get_output"></a>



<h4>Method <code>get_output()</code>
</h4>

<p>Get the output of the task execution.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$get_output(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments currently not in use.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>This method fetches the output of the task execution after calling
the <code>sapply()</code> method. It returns the output and immediately removes
it from the backend. Therefore, subsequent calls to this method will
return <code>NULL</code>. This method should be called after the execution of a
task.
</p>



<h5>Returns</h5>

<p>A vector, matrix, or list of the same length as <code>x</code>, containing the
results of the <code>fun</code>. The output format differs based on the specific
operation employed. Check out the documentation for the <code>apply</code>
operations of <code>parallel::parallel</code> for more information.
</p>


<hr>
<a id="method-SyncBackend-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p><code>Service</code>, <code>Backend</code>, <code>AsyncBackend</code>, and
<code>Context</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Create a specification object.
specification &lt;- Specification$new()

# Set the number of cores.
specification$set_cores(cores = 2)

# Set the cluster type.
specification$set_type(type = "psock")

# Create a synchronous backend object.
backend &lt;- SyncBackend$new()

# Start the cluster on the backend.
backend$start(specification)

# Check if there is anything on the backend.
backend$peek()

# Create a dummy variable.
name &lt;- "parabar"

# Export the variable from the current environment to the backend.
backend$export("name", environment())

# Remove variable from current environment.
rm(name)

# Run an expression on the backend, using the exported variable `name`.
backend$evaluate({
    # Print the name.
    print(paste0("Hello, ", name, "!"))
})

# Run a task in parallel (i.e., approx. 1.25 seconds).
backend$sapply(
    x = 1:10,
    fun = function(x) {
        # Sleep a bit.
        Sys.sleep(0.25)

        # Compute something.
        output &lt;- x + 1

        # Return the result.
        return(output)
    }
)

# Get the task output.
backend$get_output()

# Clear the backend.
backend$clear()

# Check that there is nothing on the cluster.
backend$peek()

# Stop the backend.
backend$stop()

# Check that the backend is not active.
backend$active

</code></pre>


</div>
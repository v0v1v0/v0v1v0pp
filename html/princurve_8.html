<div class="container">

<table style="width: 100%;"><tr>
<td>principal_curve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a Principal Curve</h2>

<h3>Description</h3>

<p>Fit a principal curve which describes a smooth curve that passes through the <code>middle</code>
of the data <code>x</code> in an orthogonal sense. This curve is a non-parametric generalization
of a linear principal component. If a closed curve is fit (using <code>smoother = "periodic_lowess"</code>)
then the starting curve defaults to a circle, and each fit is followed by a bias correction
suggested by Jeff Banfield.
</p>


<h3>Usage</h3>

<pre><code class="language-R">principal_curve(
  x,
  start = NULL,
  thresh = 0.001,
  maxit = 10,
  stretch = 2,
  smoother = c("smooth_spline", "lowess", "periodic_lowess"),
  approx_points = FALSE,
  trace = FALSE,
  plot_iterations = FALSE,
  ...
)

## S3 method for class 'principal_curve'
lines(x, ...)

## S3 method for class 'principal_curve'
plot(x, ...)

## S3 method for class 'principal_curve'
points(x, ...)

whiskers(x, s, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix of points in arbitrary dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>either a previously fit principal curve, or else a matrix
of points that in row order define a starting curve. If missing or NULL,
then the first principal component is used.  If the smoother is
<code>"periodic_lowess"</code>, then a circle is used as the start.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>convergence threshold on shortest distances to the curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stretch</code></td>
<td>
<p>A stretch factor for the endpoints of the curve,
allowing the curve to grow to avoid bunching at the end.
Must be a numeric value between 0 and 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoother</code></td>
<td>
<p>choice of smoother. The default is
<code>"smooth_spline"</code>, and other choices are <code>"lowess"</code> and
<code>"periodic_lowess"</code>. The latter allows one to fit closed curves.
Beware, you may want to use <code>iter = 0</code> with <code>lowess()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx_points</code></td>
<td>
<p>Approximate curve after smoothing to reduce computational time.
If <code>FALSE</code>, no approximation of the curve occurs. Otherwise,
<code>approx_points</code> must be equal to the number of points the curve
gets approximated to; preferably about 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>If <code>TRUE</code>, the iteration information is printed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_iterations</code></td>
<td>
<p>If <code>TRUE</code> the iterations are plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to the smoothers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>a parametrized curve, represented by a polygon.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>"principal_curve"</code> is returned. For this object
the following generic methods a currently available: <code>plot, points, lines</code>.
</p>
<p>It has components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>a matrix corresponding to <code>x</code>, giving their projections
onto the curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ord</code></td>
<td>
<p>an index, such that <code>s[order, ]</code> is smooth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>for each point, its arc-length from the beginning of the
curve. The curve is parametrized approximately by arc-length, and
hence is <code>unit-speed</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>the sum-of-squared distances from the points to their
projections.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>A logical indicating whether the algorithm converged
or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_iterations</code></td>
<td>
<p>Number of iterations completed before returning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call that created this object; allows it to be
<code>updated()</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Hastie, T. and Stuetzle, W.,
<a href="https://www.jstor.org/stable/2289936">Principal Curves</a>,
JASA, Vol. 84, No. 406 (Jun., 1989), pp. 502-516,
doi: <a href="https://doi.org/10.2307/2289936">10.2307/2289936</a>
(<a href="https://web.stanford.edu/~hastie/Papers/principalcurves.pdf">PDF</a>).
</p>


<h3>See Also</h3>

<p><code>project_to_curve</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- runif(100,-1,1)
x &lt;- cbind(x, x ^ 2 + rnorm(100, sd = 0.1))
fit &lt;- principal_curve(x)
plot(fit)
lines(fit)
points(fit)
whiskers(x, fit$s)
</code></pre>


</div>
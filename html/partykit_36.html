<div class="container">

<table style="width: 100%;"><tr>
<td>cforest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Conditional Random Forests</h2>

<h3>Description</h3>

<p>An implementation of the random forest and bagging ensemble algorithms
utilizing conditional inference trees as base learners.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cforest(formula, data, weights, subset, offset, cluster, strata,
        na.action = na.pass,
	control = ctree_control(teststat = "quad", testtype = "Univ",
            mincriterion = 0, saveinfo = FALSE, ...),
        ytrafo = NULL, scores = NULL, ntree = 500L,
        perturb = list(replace = FALSE, fraction = 0.632),
        mtry = ceiling(sqrt(nvar)), applyfun = NULL, cores = NULL,
        trace = FALSE, ...)
## S3 method for class 'cforest'
predict(object, newdata = NULL,
        type = c("response", "prob", "weights", "node"),
        OOB = FALSE, FUN = NULL, simplify = TRUE, scale = TRUE, ...)
## S3 method for class 'cforest'
gettree(object, tree = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p> a symbolic description of the model to be fit. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> a data frame containing the variables in the model. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting
process. Non-negative integer valued weights are
allowed as well as non-negative real weights.
Observations are sampled (with or without replacement)
according to probabilities <code>weights / sum(weights)</code>.
The fraction of observations to be sampled (without replacement)
is computed based on the sum of the weights if all weights
are integer-valued and based on the number of weights greater zero
else. Alternatively, <code>weights</code> can be a double matrix defining
case weights for all <code>ncol(weights)</code> trees in the forest directly.
This requires more storage but gives the user more control.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p> an optional vector of offset values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p> an optional factor indicating independent clusters.
Highly experimental, use at your own risk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strata</code></td>
<td>
<p> an optional factor for stratified sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain missing value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list with control parameters, see
<code>ctree_control</code>. The default values correspond to those
of the default values used by <code>cforest</code> from the
<code>party</code> package. <code>saveinfo = FALSE</code> leads to less
memory hungry representations of trees. Note that arguments
<code>mtry</code>, <code>cores</code> and <code>applyfun</code> in
<code>ctree_control</code> are ignored for <code>cforest</code>,
because they are already set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ytrafo</code></td>
<td>
<p>an optional named list of functions to be applied to the response
variable(s) before testing their association with the explanatory
variables. Note that this transformation is only
performed once for the root node and does not take weights into account
(which means, the forest bootstrap or subsetting is ignored,
which is almost certainly not a good idea).
Alternatively, <code>ytrafo</code> can be a function of <code>data</code> and
<code>weights</code>. In this case, the transformation is computed for
every node and the corresponding weights. This feature is experimental
and the user interface likely to change.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>an optional named list of scores to be attached to ordered
factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntree</code></td>
<td>

<p>Number of trees to grow for the forest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perturb</code></td>
<td>

<p>a list with arguments <code>replace</code> and <code>fraction</code> determining which type of
resampling with <code>replace = TRUE</code> referring to the n-out-of-n bootstrap and
<code>replace = FALSE</code> to sample splitting. 
<code>fraction</code> is the portion of observations to draw without
replacement. Honesty (experimental): If <code>fraction</code> has two elements, the
first fraction defines the portion of observations to be used for tree
induction, the second fraction defines the portion of observations used
for parameter estimation. The sum of both fractions can be smaller than
one but most not exceed one. Details can be found in Section 2.4 of 
Wager and Athey (2018).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mtry</code></td>
<td>

<p>number of input variables randomly sampled as candidates
at each node for random forest like algorithms. Bagging, as special case
of a random forest without random input variable sampling, can
be performed by setting <code>mtry</code> either equal to <code>Inf</code> or
manually equal to the number of input variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>applyfun</code></td>
<td>
<p>an optional <code>lapply</code>-style function with arguments
<code>function(X, FUN, ...)</code>. It is used for computing the variable selection criterion.
The default is to use the basic <code>lapply</code>
function unless the <code>cores</code> argument is specified (see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>numeric. If set to an integer the <code>applyfun</code> is set to
<code>mclapply</code> with the desired number of <code>cores</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>a logical indicating if a progress bar shall be printed while
the forest grows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>An object as returned by <code>cforest</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>An optional data frame containing test data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>a character string denoting the type of predicted value
returned, ignored when argument <code>FUN</code> is given.  For
<code>"response"</code>, the mean of a numeric response, the predicted
class for a categorical response or the median survival time for a
censored response is returned.  For <code>"prob"</code> the matrix of
conditional class probabilities (<code>simplify = TRUE</code>) or a list
with the conditional class probabilities for each observation
(<code>simplify = FALSE</code>) is returned for a categorical response.
For numeric and censored responses, a list with the empirical
cumulative distribution functions and empirical survivor functions
(Kaplan-Meier estimate) is returned when <code>type = "prob"</code>.
<code>"weights"</code> returns an integer vector of prediction weights.
For <code>type = "where"</code>, a list of terminal node ids for each of the
trees in the forest ist returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OOB</code></td>
<td>

<p>a logical defining out-of-bag predictions (only if <code>newdata = NULL</code>).
If the forest was fitted with honesty, this option is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>

<p>a function to compute summary statistics. Predictions for each node have to be
computed based on arguments <code>(y, w)</code> where <code>y</code> is the response and
<code>w</code> are case weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>

<p>a logical indicating whether the resulting list
of predictions should be converted to a suitable
vector or matrix (if possible).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>a logical indicating scaling of the nearest neighbor weights
by the sum of weights in the corresponding terminal node of
each tree. In the simple regression forest, predicting
the conditional mean by nearest neighbor weights will be
equivalent to (but slower!) the aggregation of means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>
<p> an integer, the number of the tree to extract from the forest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This implementation of the random forest (and bagging) algorithm differs
from the reference implementation in <code>randomForest</code>
with respect to the base learners used and the aggregation scheme applied.
</p>
<p>Conditional inference trees, see <code>ctree</code>, are fitted to each
of the <code>ntree</code> perturbed samples of the learning sample. Most of the hyper parameters in
<code>ctree_control</code> regulate the construction of the conditional inference trees.
</p>
<p>Hyper parameters you might want to change are:
</p>
<p>1. The number of randomly preselected variables <code>mtry</code>, which is fixed
to the square root of the number of input variables.
</p>
<p>2. The number of trees <code>ntree</code>. Use more trees if you have more variables.
</p>
<p>3. The depth of the trees, regulated by <code>mincriterion</code>. Usually unstopped and unpruned
trees are used in random forests. To grow large trees, set <code>mincriterion</code> to a small value.
</p>
<p>The aggregation scheme works by averaging observation weights extracted
from each of the <code>ntree</code> trees and NOT by averaging predictions directly
as in <code>randomForest</code>.
See Hothorn et al. (2004) and Meinshausen (2006) for a description.
</p>
<p>Predictions can be computed using <code>predict</code>. For observations
with zero weights, predictions are computed from the fitted tree
when <code>newdata = NULL</code>.
</p>
<p>Ensembles of conditional inference trees have not yet been extensively
tested, so this routine is meant for the expert user only and its current
state is rather experimental. However, there are some things available
in <code>cforest</code> that can't be done with <code>randomForest</code>,
for example fitting forests to censored response variables (see Hothorn et al., 2004, 2006a) or to
multivariate and ordered responses. Using the rich <code>partykit</code> infrastructure allows
additional functionality in <code>cforest</code>, such as parallel tree growing and probabilistic
forecasting (for example via quantile regression forests). Also plotting of single trees from
a forest is much easier now.
</p>
<p>Unlike <code>cforest</code>, <code>cforest</code> is entirely written in R which
makes customisation much easier at the price of longer computing times. However, trees
can be grown in parallel with this R only implemention which renders speed less of an issue.
Note that the default values are different from those used in package <code>party</code>, most
importantly the default for mtry is now data-dependent. <code>predict(, type = "node")</code> replaces
the <code>where</code> function and <code>predict(, type = "prob")</code> the
<code>treeresponse</code> function.
</p>
<p>Moreover, when predictors vary in their scale of measurement of number
of categories, variable selection and computation of variable importance is biased
in favor of variables with many potential cutpoints in <code>randomForest</code>,
while in <code>cforest</code> unbiased trees and an adequate resampling scheme
are used by default. See Hothorn et al. (2006b) and Strobl et al. (2007)
as well as Strobl et al. (2009).
</p>


<h3>Value</h3>

<p>An object of class <code>cforest</code>.
</p>


<h3>References</h3>

<p>Breiman L (2001).
Random Forests.
<em>Machine Learning</em>, <b>45</b>(1), 5–32.
</p>
<p>Hothorn T, Lausen B, Benner A, Radespiel-Troeger M (2004).
Bagging Survival Trees.
<em>Statistics in Medicine</em>, <b>23</b>(1), 77–91.
</p>
<p>Hothorn T, Buehlmann P, Dudoit S, Molinaro A, Van der Laan MJ (2006a).
Survival Ensembles.
<em>Biostatistics</em>, <b>7</b>(3), 355–373.
</p>
<p>Hothorn T, Hornik K, Zeileis A (2006b).
Unbiased Recursive Partitioning: A Conditional Inference Framework.
<em>Journal of Computational and Graphical Statistics</em>, <b>15</b>(3), 651–674.
</p>
<p>Hothorn T, Zeileis A (2015).
partykit: A Modular Toolkit for Recursive Partytioning in R.
<em>Journal of Machine Learning Research</em>, <b>16</b>, 3905–3909.
</p>
<p>Meinshausen N (2006).
Quantile Regression Forests.
<em>Journal of Machine Learning Research</em>, <b>7</b>, 983–999.
</p>
<p>Strobl C, Boulesteix AL, Zeileis A, Hothorn T (2007).
Bias in Random Forest Variable Importance Measures: Illustrations, Sources and a Solution.
<em>BMC Bioinformatics</em>, <b>8</b>, 25.
<a href="https://doi.org/10.1186/1471-2105-8-25">doi:10.1186/1471-2105-8-25</a>
</p>
<p>Strobl C, Malley J, Tutz G (2009).
An Introduction to Recursive Partitioning: Rationale, Application, and Characteristics of
Classification and Regression Trees, Bagging, and Random Forests.
<em>Psychological Methods</em>, <b>14</b>(4), 323–348.
</p>
<p>Stefan Wager &amp; Susan Athey (2018).
Estimation and Inference of Heterogeneous Treatment Effects using Random
Forests. <em>Journal of the American Statistical Association</em>,
<b>113</b>(523), 1228–1242. <a href="https://doi.org/10.1080/01621459.2017.1319839">doi:10.1080/01621459.2017.1319839</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## basic example: conditional inference forest for cars data
cf &lt;- cforest(dist ~ speed, data = cars)

## prediction of fitted mean and visualization
nd &lt;- data.frame(speed = 4:25)
nd$mean  &lt;- predict(cf, newdata = nd, type = "response")
plot(dist ~ speed, data = cars)
lines(mean ~ speed, data = nd)

## predict quantiles (aka quantile regression forest)
## Note that this works for integer-valued weight w
## Other weights require weighted quantiles, see for example
## Hmisc::wtd.quantile(
myquantile &lt;- function(y, w) quantile(rep(y, w), probs = c(0.1, 0.5, 0.9))
p &lt;- predict(cf, newdata = nd, type = "response", FUN = myquantile)
colnames(p) &lt;- c("lower", "median", "upper")
nd &lt;- cbind(nd, p)

## visualization with conditional (on speed) prediction intervals
plot(dist ~ speed, data = cars, type = "n")
with(nd, polygon(c(speed, rev(speed)), c(lower, rev(upper)),
  col = "lightgray", border = "transparent"))
points(dist ~ speed, data = cars)
lines(mean ~ speed, data = nd, lwd = 1.5)
lines(median ~ speed, data = nd, lty = 2, lwd = 1.5)
legend("topleft", c("mean", "median", "10% - 90% quantile"),
  lwd = c(1.5, 1.5, 10), lty = c(1, 2, 1),
  col = c("black", "black", "lightgray"), bty = "n")

## Not run: 

### honest (i.e., out-of-bag) cross-classification of
### true vs. predicted classes
data("mammoexp", package = "TH.data")
table(mammoexp$ME, predict(cforest(ME ~ ., data = mammoexp, ntree = 50),
                           OOB = TRUE, type = "response"))

### fit forest to censored response
if (require("TH.data") &amp;&amp; require("survival")) {

    data("GBSG2", package = "TH.data")
    bst &lt;- cforest(Surv(time, cens) ~ ., data = GBSG2, ntree = 50)

    ### estimate conditional Kaplan-Meier curves
    print(predict(bst, newdata = GBSG2[1:2,], OOB = TRUE, type = "prob"))

    print(gettree(bst))
}

## End(Not run)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>bootpls</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Non-parametric Bootstrap for PLS models</h2>

<h3>Description</h3>

<p>Provides a wrapper for the bootstrap function <code>boot</code> from the
<code>boot</code> R package.<br> Implements non-parametric bootstraps for PLS
Regression models by either (Y,X) or (Y,T) resampling.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bootpls(
  object,
  typeboot = "plsmodel",
  R = 250,
  statistic = NULL,
  sim = "ordinary",
  stype = "i",
  stabvalue = 1e+06,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>plsRmodel</code> to bootstrap</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typeboot</code></td>
<td>
<p>The type of bootstrap. Either (Y,X) boostrap
(<code>typeboot="plsmodel"</code>) or (Y,T) bootstrap
(<code>typeboot="fmodel_np"</code>). Defaults to (Y,X) resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>The number of bootstrap replicates. Usually this will be a single
positive integer. For importance resampling, some resamples may use one set
of weights and others use a different set of weights. In this case <code>R</code>
would be a vector of integers where each component gives the number of
resamples from each of the rows of weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>A function which when applied to data returns a vector
containing the statistic(s) of interest. <code>statistic</code> must take at least
two arguments. The first argument passed will always be the original data.
The second will be a vector of indices, frequencies or weights which define
the bootstrap sample. Further, if predictions are required, then a third
argument is required which would be a vector of the random indices used to
generate the bootstrap predictions. Any further arguments can be passed to
statistic through the <code>...</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>A character string indicating the type of simulation required.
Possible values are <code>"ordinary"</code> (the default), <code>"balanced"</code>,
<code>"permutation"</code>, or <code>"antithetic"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stype</code></td>
<td>
<p>A character string indicating what the second argument of
<code>statistic</code> represents. Possible values of stype are <code>"i"</code>
(indices - the default), <code>"f"</code> (frequencies), or <code>"w"</code> (weights).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stabvalue</code></td>
<td>
<p>A value to hard threshold bootstrap estimates computed from
atypical resamplings. Especially useful for Generalized Linear Models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other named arguments for <code>statistic</code> which are passed
unchanged each time it is called. Any such arguments to <code>statistic</code>
should follow the arguments which <code>statistic</code> is required to have for
the simulation. Beware of partial matching to arguments of <code>boot</code>
listed above.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>More details on bootstrap techniques are available in the help of the
<code>boot</code> function.
</p>


<h3>Value</h3>

<p>An object of class <code>"boot"</code>. See the Value part of the help of
the function <code>boot</code>.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br><a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br><a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>A. Lazraq, R. Cleroux, and J.-P. Gauchi. (2003). Selecting both
latent and explanatory variables in the PLS1 regression model.
<em>Chemometrics and Intelligent Laboratory Systems</em>, 66(2):117-126.<br> P.
Bastien, V. Esposito-Vinzi, and M. Tenenhaus. (2005). PLS generalised linear
regression. <em>Computational Statistics &amp; Data Analysis</em>, 48(1):17-46.<br>
A. C. Davison and D. V. Hinkley. (1997). <em>Bootstrap Methods and Their
Applications</em>. Cambridge University Press, Cambridge.
</p>


<h3>See Also</h3>

<p><code>boot</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

# Lazraq-Cleroux PLS ordinary bootstrap
set.seed(250)
modpls &lt;- plsR(yCornell,XCornell,3)

#(Y,X) resampling
Cornell.bootYX &lt;- bootpls(modpls, R=250, verbose=FALSE)

#(Y,T) resampling
Cornell.bootYT &lt;- bootpls(modpls, typeboot="fmodel_np", R=250, verbose=FALSE)

# Using the boxplots.bootpls function
boxplots.bootpls(Cornell.bootYX,indices=2:8)
# Confidence intervals plotting
confints.bootpls(Cornell.bootYX,indices=2:8)
plots.confints.bootpls(confints.bootpls(Cornell.bootYX,indices=2:8))
# Graph similar to the one of Bastien et al. in CSDA 2005
boxplot(as.vector(Cornell.bootYX$t[,-1])~factor(rep(1:7,rep(250,7))), 
main="Bootstrap distributions of standardised bj (j = 1, ..., 7).")
points(c(1:7),Cornell.bootYX$t0[-1],col="red",pch=19)



library(boot)
boot.ci(Cornell.bootYX, conf = c(0.90,0.95), type = c("norm","basic","perc","bca"), index=2)
plot(Cornell.bootYX,index=2)
jack.after.boot(Cornell.bootYX, index=2, useJ=TRUE, nt=3)
plot(Cornell.bootYX,index=2,jack=TRUE)

car::dataEllipse(Cornell.bootYX$t[,2], Cornell.bootYX$t[,3], cex=.3, 
levels=c(.5, .95, .99), robust=TRUE)
rm(Cornell.bootYX)


# PLS balanced bootstrap

set.seed(225)
Cornell.bootYX &lt;- bootpls(modpls, sim="balanced", R=250, verbose=FALSE)
boot.array(Cornell.bootYX, indices=TRUE)

# Using the boxplots.bootpls function
boxplots.bootpls(Cornell.bootYX,indices=2:8)
# Confidence intervals plotting
confints.bootpls(Cornell.bootYX,indices=2:8)
plots.confints.bootpls(confints.bootpls(Cornell.bootYX,indices=2:8))
# Graph similar to the one of Bastien et al. in CSDA 2005
boxplot(as.vector(Cornell.bootYX$t[,-1])~factor(rep(1:7,rep(250,7))), 
main="Bootstrap distributions of standardised bj (j = 1, ..., 7).")
points(c(1:7),Cornell.bootYX$t0[-1],col="red",pch=19)


library(boot)
boot.ci(Cornell.bootYX, conf = c(0.90,0.95), type = c("norm","basic","perc","bca"), 
index=2, verbose=FALSE)
plot(Cornell.bootYX,index=2)
jack.after.boot(Cornell.bootYX, index=2, useJ=TRUE, nt=3)
plot(Cornell.bootYX,index=2,jack=TRUE)

rm(Cornell.bootYX)

# PLS permutation bootstrap

set.seed(500)
Cornell.bootYX &lt;- bootpls(modpls, sim="permutation", R=1000, verbose=FALSE)
boot.array(Cornell.bootYX, indices=TRUE)


# Graph of bootstrap distributions
boxplot(as.vector(Cornell.bootYX$t[,-1])~factor(rep(1:7,rep(1000,7))),
main="Bootstrap distributions of standardised bj (j = 1, ..., 7).")
points(c(1:7),Cornell.bootYX$t0[-1],col="red",pch=19)
# Using the boxplots.bootpls function
boxplots.bootpls(Cornell.bootYX,indices=2:8)


library(boot)
plot(Cornell.bootYX,index=2)

qqnorm(Cornell.bootYX$t[,2],ylim=c(-1,1))
abline(h=Cornell.bootYX$t0[2],lty=2)
(sum(abs(Cornell.bootYX$t[,2])&gt;=abs(Cornell.bootYX$t0[2]))+1)/(length(Cornell.bootYX$t[,2])+1)

rm(Cornell.bootYX)


</code></pre>


</div>
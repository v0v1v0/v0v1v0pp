<div class="container">

<table style="width: 100%;"><tr>
<td>plotModelSeries</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model series plot</h2>

<h3>Description</h3>

<p>Produce a graphical output to examine the effect of using different model specifications (design)
on the predictive performance of these models (a model series). Devised to access the results of
<code>buildModelSeries()</code> and <code>statsMS()</code>, but can be easily adapted to
work with any model structure and performance measure.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plotModelSeries(
  obj,
  grid,
  line,
  ind,
  type = c("b", "g"),
  pch = c(20, 2),
  size = 0.5,
  arrange = "desc",
  color = NULL,
  xlim = NULL,
  ylab = NULL,
  xlab = NULL,
  at = NULL,
  ...
)

plotMS(
  obj,
  grid,
  line,
  ind,
  type = c("b", "g"),
  pch = c(20, 2),
  size = 0.5,
  arrange = "desc",
  color = NULL,
  xlim = NULL,
  ylab = NULL,
  xlab = NULL,
  at = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>Object of class <code>data.frame</code>, generally returned by <code>statsMS()</code>,
containing:
</p>

<ol>
<li>
<p> a series of performance statistics of several models, and
</p>
</li>
<li>
<p> the design information of each model.
</p>
</li>
</ol>
<p>See ‘Details’ for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>Vector of integer values or character strings indicating the columns of the
<code>data.frame</code> containing the design data which will be gridded using the function
<code>lattice::levelplot()</code>. See ‘Details’ for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>line</code></td>
<td>
<p>Character string or integer value indicating which of the performance statistics
(usually calculated by <code>statsMS()</code>) should be plotted using the function
<code>lattice::xyplot()</code>. See ‘Details’ for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind</code></td>
<td>
<p>Integer value indicating for which group of models the mean rank is to be calculated.
See ‘Details’ for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Vector of character strings indicating some of the effects to be used when plotting
the performance statistics using <code>lattice::xyplot()</code>. Defaults to <code>type = c("b", "g")</code>. See
<code>lattice::panel.xyplot()</code> for more information on how to set this argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch</code></td>
<td>
<p>Vector with two integer values specifying the symbols to be used to plot points. The
first sets the symbol used to plot the performance statistic, while the second sets the symbol
used to plot the mean rank of the indicator set using argument <code>ind</code>. Defaults to
<code>pch = c(20, 2)</code>. See <code>graphics::points()</code> for possible values and their interpretation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>Numeric value specifying the size of the symbols used for plotting the mean rank of
the indicator set using argument <code>ind</code>. Defaults to <code>size = 0.5</code>. See <code>grid::grid.points()</code> for
more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrange</code></td>
<td>
<p>Character string indicating how the model series should be arranged, which can be
in ascending (<code>"asc"</code>) or descending (<code>"desc"</code>, default) order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>color</code></td>
<td>
<p>Vector defining the colors to be used in the grid produced by function
<code>lattice::levelplot()</code>. If <code>color = NULL</code>, defaults to <code>color = cm.colors(n)</code>, where <code>n</code> is the
number of unique values in the columns defined by argument <code>grid</code>. See <code>grDevices::cm.colors()</code>
to see how to use other color palettes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>Numeric vector of length 2, giving the x coordinates range. If <code>xlim = NULL</code> (which
is the recommended value), defaults to <code>xlim = c(0.5, dim(obj)[1] + 0.5)</code>. This is, so far, the
optimum range for adequate plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>Character vector of length 2, giving the y-axis labels. When <code>obj</code> is a <code>data.frame</code>
returned by <code>statsMS()</code>, and the performance statistic passed to argument
<code>line</code> is one of those calculated by <code>statsMS()</code> (<code>"candidates"</code>, <code>"df"</code>, <code>"aic"</code>,
<code>"rmse"</code>, <code>"nrmse"</code>, <code>"r2"</code>, <code>"adj_r2"</code>, or <code>"ADJ_r2"</code>), the function tries to automatically
identify the correct <code>ylab</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>Character vector of unit length, the x-axis label. Defaults <code>xlab = "Model ranking"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>
<p>Numeric vector indicating the location of tick marks along the x axis (in native
coordinates).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments for plotting, although most of these have no been tested. Argument
<code>asp</code>, for example, is not effective since the function automatically identifies the best aspect
for plotting based on the dimensions of the design data.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This section gives more details about arguments <code>obj</code>, <code>grid</code>, <code>line</code>, <code>arrange</code>, and <code>ind</code>.
</p>


<h4>obj</h4>

<p>The argument <code>obj</code> usually constitutes a <code>data.frame</code> returned by <code>statsMS()</code>.
However, the user can use any <code>data.frame</code> object as far as it contains the two basic units of
information needed:
</p>

<ol>
<li>
<p> design data passed with argument <code>grid</code>
</p>
</li>
<li>
<p> performance statistic passed with argument <code>line</code>
</p>
</li>
</ol>
<h4>grid</h4>

<p>The argument <code>grid</code> indicates the <em>design</em> data which is used to produce the grid output in the
top of the model series plot. By <em>design</em> we mean the data that specify the structure of each
model and how they differ from each other. Suppose that eight linear models were fit using three
types of predictor variables (<code>a</code>, <code>b</code>, and <code>c</code>). Each of these predictor variables is available
in two versions that differ by their accuracy, where <code>0</code> means a less accurate predictor
variable, while <code>1</code> means a more accurate predictor variable. This yields 2^3 = 8 total possible
combinations. The <em>design</em> data would be of the following form:
</p>
<p><code style="white-space: pre;">⁠
&gt; design
  a b c
1 0 0 0
2 0 0 1
3 0 1 0
4 1 0 0
5 0 1 1
6 1 0 1
7 1 1 0
8 1 1 1
⁠</code>
</p>



<h4>line</h4>

<p>The argument <code>line</code> corresponds to the performance statistic that is used to arrange the models
in ascending or descending order, and to produce the line output in the bottom of the model
series plot. For example, it can be a series of values of adjusted coefficient of determination,
one for each model:
</p>
<p><code style="white-space: pre;">⁠
adj_r2 &lt;- c(0.87, 0.74, 0.81, 0.85, 0.54, 0.86, 0.90, 0.89)
⁠</code>
</p>



<h4>arrange</h4>

<p>The argument <code>arrange</code> automatically arranges the model series according to the performance
statistics selected with argument <code>line</code>. If <code>obj</code> is a <code>data.frame</code> returned by
<code>statsMS()</code>, then the function uses standard arranging approaches. For most
performance statistics, the models are arranged in descending order. The exception is when
<code>"r2"</code>, <code>"adj_r2"</code>, or <code>"ADJ_r2"</code> are used, in which case the models are arranged in ascending
order. This means that the model with lowest value appears in the leftmost side of the model
series plot, while the models with the highest value appears in the rightmost side of the plot.
</p>
<p><code style="white-space: pre;">⁠
&gt; arrange(obj, adj_r2)
  id a b c adj_r2
1  5 1 0 1   0.54
2  2 0 0 1   0.74
3  3 1 0 0   0.81
4  4 0 1 0   0.85
5  6 0 1 1   0.86
6  1 0 0 0   0.87
7  8 1 1 1   0.89
8  7 1 1 0   0.90
⁠</code>
</p>
<p>This results suggest that the best performing model is that of <code>id = 7</code>, while the model of
<code>id = 5</code> is the poorest one.
</p>



<h4>ind</h4>

<p>The model series plot allows to see how the design influences model performance. This is achieved
mainly through the use of different colors in the grid output, where each unique value in the
<em>design</em> data is represented by a different color. For the example given above, one could try to
see if the models built with the more accurate versions of the predictor variables have a better
performance by identifying their relative distribution in the model series plot. The models
placed at the rightmost side of the plot are those with the best performance.
</p>
<p>The argument <code>ind</code> provides another tool to help identifying how the design, more specifically
how each variable in the <em>design</em> data, influences model performance. This is done by simply
calculating the mean ranking of the models that were built using the updated version of each
predictor variable. This very same mean ranking is also used to rank the predictor variables and
thus identify which of them is the most important.
</p>
<p>After arranging the <code>design</code> data described above using the adjusted coefficient of
determination, the following mean rank is obtained for each predictor variable:
</p>
<p><code style="white-space: pre;">⁠
&gt; rank_center
     a    b    c
1 5.75 6.25 5.25
⁠</code>
</p>
<p>This result suggests that the best model performance is obtained when using the updated version
of the predictor variable <code>b</code>. In the model series plot, the predictor variable <code>b</code> appears in
the top row, while the predictor variable <code>c</code> appears in the bottom row.
</p>



<h3>Value</h3>

<p>An object of class <code>"trellis"</code> consisting of a model series plot.
</p>


<h3>Dependencies</h3>

<p>The <strong>grDevices</strong> package, provider of graphics devices and support for colours and fonts in R,
is required for <code>plotModelSeries()</code> to work.
</p>
<p>The <strong>grid</strong> package, a rewrite of the graphics layout capabilities in R, is required for
<code>plotModelSeries()</code> to work.
</p>


<h3>Warning</h3>

<p>Use the original functions <code>lattice::xyplot()</code> and <code>lattice::levelplot()</code> for higher
customization.
</p>


<h3>Note</h3>

<p>Some of the solutions used to build this function were found in the source code of the R-package
<strong>mvtsplot</strong>. As such, the author of that package, Roger D. Peng <a href="mailto:rpeng@jhsph.edu">rpeng@jhsph.edu</a>, is
entitled ‘contributors’ to the R-package <strong>pedometrics</strong>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Deepayan Sarkar (2008). <em>Lattice: Multivariate Data Visualization with R.</em> Springer, New York.
ISBN 978-0-387-75968-5.
</p>
<p>Roger D. Peng (2008). <em>A method for visualizing multivariate time series data.</em> Journal of
Statistical Software. v. 25 (Code Snippet), p. 1-17.
</p>
<p>Roger D. Peng (2012). <em>mvtsplot: Multivariate Time Series Plot.</em> R package version 1.0-1.
<a href="https://CRAN.R-project.org/package=mvtsplot">https://CRAN.R-project.org/package=mvtsplot</a>.
</p>
<p>A. Samuel-Rosa, G. B. M. Heuvelink, G. de Mattos Vasques, and L. H. C. dos Anjos, Do more
detailed environmental covariates deliver more accurate soil maps?, <em>Geoderma</em>, vol. 243–244,
pp. 214–227, May 2015, doi: 10.1016/j.geoderma.2014.12.017.
</p>


<h3>See Also</h3>

<p><code>lattice::xyplot()</code> <code>lattice::levelplot()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (all(require(grDevices), require(grid))) {
  # This example follows the discussion in section "Details"
  # Note that the data.frame is created manually
  id &lt;- c(1:8)
  design &lt;- data.frame(a = c(0, 0, 1, 0, 1, 0, 1, 1),
                       b = c(0, 0, 0, 1, 0, 1, 1, 1),
                       c = c(0, 1, 0, 0, 1, 1, 0, 1))
  adj_r2 &lt;- c(0.87, 0.74, 0.81, 0.85, 0.54, 0.86, 0.90, 0.89)
  obj &lt;- cbind(id, design, adj_r2)
  p &lt;- plotModelSeries(obj, grid = c(2:4), line = "adj_r2", ind = 1, 
              color = c("lightyellow", "palegreen"),
              main = "Model Series Plot")
}
</code></pre>


</div>
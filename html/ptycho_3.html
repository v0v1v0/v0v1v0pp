<div class="container">

<table style="width: 100%;"><tr>
<td>createData</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate Data</h2>

<h3>Description</h3>

<p>Create a data object suitable for <code>ptycho.all</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">createData(X, y, omega = NULL, beta = NULL)
createDataBayesModel(mode = c("exchange","pleiotropy","gene"), n, p, q,
                     nreps, tau.min, tau.max, G)
createPubData(mode = c("tinysim","ptychoIn",
                       "exchange","pleiotropy","gene",
                       "actualGeno","actualPheno","corTest",
                       "fixedOmega","uniformEffects"),
              X=NULL, y=NULL, var.detail=NULL, variants=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Design matrix or alist specifying how to generate such a matrix.  If
a list, the first entry is a function name and the second is a list of
arguments to the function.  In <code>createPubData</code>, <code>X</code> is ignored
unless <code>mode</code> is “actualGeno”, “actualPheno”, or
<code>corTest</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>Numeric vector or matrix or list with the following components:
</p>

<dl>
<dt><code>nreps</code></dt>
<dd>
<p>Number of replicates to simulate</p>
</dd>
<dt><code>q</code></dt>
<dd>
<p>Number of responses to generate for each replicate</p>
</dd>
<dt><code>sd</code></dt>
<dd>
<p>Standard deviation of the simulated noise</p>
</dd>
</dl>
<p>In <code>createPubData</code>, <code>y</code> is ignored unless <code>mode</code> is
“actualPheno”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>Numeric vector or matrix or list specifying how to generate a
list with the component <code>omega</code>; see Details for its meaning.  If this
is a list, the first entry is a function name and the second is a list of
arguments to the function, which will be prepended by the number of rows in
output <code>X</code> and the number of columns in output <code>y</code>.  Only used if
<code>y</code> is a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>List specifying how to generate a matrix of effect sizes.  The
first entry of the list is a function name and the second is a list of
arguments to the function, which will be prepended by a matrix specifying
the variables selected and <code>y$sd</code>.  Only used if <code>y</code> is a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of observations to simulate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Number of covariates to simulate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Number of responses to simulate for each replicate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nreps</code></td>
<td>
<p>Number of replicates to simulate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>String specifying type of dataset to create:
</p>

<dl>
<dt><code>tinysim</code></dt>
<dd>
<p>Simulated data included with this package;
equivalent to mode <code>pleiotropy</code> except that the dataset is tiny,
with <code>n=100</code>, <code>p=10</code>, <code>q=5</code>, and <code>nreps=10</code></p>
</dd>
<dt><code>ptychoIn</code></dt>
<dd>
<p>Simulated data included with this package;
equivalent to mode <code>gene</code> except that the dataset is tiny,
with <code>n=3000</code>, <code>p=10</code>, <code>q=1</code>, and <code>nreps=1</code></p>
</dd>
<dt><code>exchange</code></dt>
<dd>
<p>Create orthogonal <code>X</code> and exchangeable
variants; <code>n=5000</code>, <code>p=50</code>, <code>q=5</code>, and <code>nreps=100</code></p>
</dd>
<dt><code>pleiotropy</code></dt>
<dd>
<p>Create orthogonal <code>X</code>, and several variants
have nonzero effects on multiple responses; <code>n=5000</code>, <code>p=50</code>,
<code>q=5</code>, and <code>nreps=100</code></p>
</dd>
<dt><code>gene</code></dt>
<dd>
<p>Create orthogonal <code>X</code>, and each group of variants
typically has either several or no variants that effect a response;
<code>n=5000</code>, <code>p=50</code>, <code>q=5</code>, and <code>nreps=100</code></p>
</dd>
<dt><code>actualGeno</code></dt>
<dd>
<p>Simulate responses for input <code>X</code></p>
</dd>
<dt><code>corTest</code></dt>
<dd>
<p>Simulate <code>q=2</code> responses for input <code>X</code>.
There will be 10 replicates with the first variant in argument
<code>variants</code> causal for both responses, 10 with the second variant
causal, and 20 with variant <code>i</code> causal for response <code>i</code>.  No
other variant will be causal.</p>
</dd>
<dt><code>actualPheno</code></dt>
<dd>
<p>Put input <code>X</code> and <code>y</code> into data
object</p>
</dd>
<dt><code>fixedOmega</code></dt>
<dd>
<p>Create orthogonal <code>X</code>, and each variant has
a certain probability of a nonzero effect size</p>
</dd>
<dt><code>uniformEffects</code></dt>
<dd>
<p>Same as mode <code>fixedOmega</code> except that
effect sizes are uniformly rather than normally distributed</p>
</dd>
</dl>
<p>For <code>createDataBayesModel</code>, <code>mode</code> must be one of
“exchange”, “pleiotropy”, or “gene”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.min, tau.max</code></td>
<td>
<p>Endpoints of uniform distribution from which to draw
<code>tau</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>Number of groups of covariates; unused if <code>mode</code> is not
“gene”</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.detail</code></td>
<td>
<p>Data frame with row names same as column names of <code>X</code>;
must have columns “MAF” and “GENE”.  Ignored unless
<code>mode</code> is “actualGeno”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variants</code></td>
<td>
<p>Character vector containing names of two columns of <code>X</code>;
ignored unless <code>mode</code> is “corTest”.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We describe <code>createData</code> and then describe its wrappers
<code>createDataBayesModel</code> and <code>createPubData</code>.
</p>
<p>Although <code>createData</code> can form the data object required by
<code>ptycho.all</code> when <code>X</code> and <code>y</code> are input, it primarily exists to
simplify simulating data from <code class="reqn">Y=X\beta+\epsilon</code>, where
<code class="reqn">\epsilon</code> is normal with mean zero and specified standard deviation and
<code class="reqn">\beta</code> is sparse with entries simulated as specified.
</p>
<p>The function generates a specified number of replicates, all of which use the
same design matrix <code class="reqn">X</code>.  If this matrix is not input, then its argument
must specify a function call to generate it.  In either case, suppose <code class="reqn">X</code>
has <code class="reqn">n</code> rows and <code class="reqn">p</code> columns.
</p>
<p>If the input <code>y</code> is numeric, then it will be used for the lone replicate.
If it is a matrix, it must have <code class="reqn">n</code> rows; let <code class="reqn">q</code> be its number of
columns.  If input <code>y</code> is a numeric vector, it must have <code class="reqn">n</code> entries
and will be cast as a matrix with <code class="reqn">q=1</code> column.  Otherwise, input <code>y</code>
is a list specifying, along with the arguments <code>omega</code> and <code>beta</code>,
how to simulate the response(s).  Because it is useful in analysis of the
estimation of the marginal posterior distribution, the returned object always
contains, regardless of how <code>X</code> and <code>y</code> are specified, a matrix
<code>eta2</code> with <code class="reqn">(j,k)</code> entry equal to
<code class="reqn">\mathbf{x}_j^T \mathbf{y}_k / (n \mathbf{y}_k^T \mathbf{y}_k)</code>
</p>
<p>If <code>y</code> is to be simulated, the first step is to choose the probability
that each covariate is associated with each reponse as specified by the input
argument <code>omega</code>.  If this argument is a matrix, it must have size
<code class="reqn">p</code>-by-<code class="reqn">q</code>.  If it is not a matrix but is numeric, it will be passed
to <code>matrix</code> to create a matrix of the correct size.  Otherwise,
the matrix for each replicate will be generated by calling the function whose
name is given by <code>omega[[1]]</code> with argument list
<code>(p, q, omega[[2]])</code>.  This function must return a list with component
<code>omega</code> set to a <code class="reqn">p</code>-by-<code class="reqn">q</code> matrix; the list may also contain
additional components.  The package contains several functions whose names
start with “createOmega” that might guide users in writing their own
functions.
</p>
<p>The next step is to draw a <code class="reqn">p</code>-by-<code class="reqn">q</code> matrix <code>indic.var</code> whose
<code class="reqn">(j,k)</code> entry is equal to one with probability <code>omega[j,k]</code> and zero
otherwise.  This matrix will be drawn until all column sums are positive.
</p>
<p>For each entry in <code>indic.var</code> that is equal to one, the effect size must
be drawn.  This is done by calling the function whose name is given by
<code>beta[[1]]</code> with argument list <code>(indic.var, y$sd, beta[[2]])</code>.  This
function must return a list with component <code>beta</code> set to a
<code class="reqn">p</code>-by-<code class="reqn">q</code> matrix; the list may also contain additional components.
If <code>indic.var[j,k]</code> is zero, then <code>beta[j,k]</code> should be zero.  The
package contains functions whose names start with “createBeta” that
might guide users in writing their own functions.
</p>
<p>Finally, an <code class="reqn">n</code>-by-<code class="reqn">q</code> matrix of noise is drawn from
<code class="reqn">N(0,\sigma^2)</code>, where <code class="reqn">\sigma</code> is the input <code>noise.sd</code>, and
added to <code class="reqn">X\beta</code> to obtain <code>y</code>.  The column names of each
response matrix generated will be <code>y1</code>, <code>y2</code>, and so forth.
</p>
<p>The function <code>createPubData</code> generates the data sets used in Stell and
Sabatti (2015).  For <code>mode</code> equal to “exchange”,
“pleiotropy”, or “geno”, it calls <code>createData</code> via
<code>createDataBayesModel</code>; otherwise, it calls <code>createData</code> directly.
These functions also serve as additional examples of the use of
<code>createData</code>.  For reproducibility, <code>createPubData</code> first sets the
random seed to 1234, except that it is set to 4 when <code>mode</code> equals
“ptychoIn” and it does not set it when <code>mode</code> equals
“corTest”.
</p>
<p>In <code>createDataBayesModel</code>, if <code>mode</code> is “exchange”, then
one <code class="reqn">\omega \sim \mbox{Beta}(12,48)</code> is drawn
independently for each trait.  If <code>mode</code> is “pleiotropy”, then one
probability of association for a trait is drawn from Beta(16,55) for each data
set, that probability is used to draw <code>indic.grp</code> for each variant, and
then the probability of nonzero <code>indic.var[j,k]</code> is drawn from
Beta(48,12) for each nonzero <code>indic.grp[j]</code>.  Finally, if <code>mode</code> is
“gene”, the process is analogous to pleiotropy except that each trait
is simulated independently.
</p>


<h3>Value</h3>

<p>List containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Design matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Number of columns in each response</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise.sd</code></td>
<td>
<p>Standard deviation of the simulated noise; <code>NULL</code> if
input <code>y</code> is numeric</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>Input <code>omega</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Input <code>beta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replicates</code></td>
<td>
<p>List of length <code>y$nreps</code> (length 1 if <code>y</code> is
numeric), each entry of which is a list with the following components:
</p>

<dl>
<dt><code>omega</code></dt>
<dd>
<p>Matrix containing probabilities of association between
covariates and responses; row names are <code>colnames(X)</code> and column
names are <code>colnames(y)</code>; <code>NULL</code> if input <code>y</code> is numeric</p>
</dd>
<dt><code>indic.var</code></dt>
<dd>
<p>Matrix containing ones for associations and zeros
otherwise; row and column names are same as for <code>omega</code>;
<code>NULL</code> if input <code>y</code> is numeric</p>
</dd>
<dt><code>beta</code></dt>
<dd>
<p>Matrix of effect sizes; row and column names are same
as for <code>omega</code>; <code>NULL</code> if input <code>y</code> is numeric</p>
</dd>
<dt><code>y</code></dt>
<dd>
<p>Response matrix</p>
</dd>
<dt><code>eta2</code></dt>
<dd>
<p>Matrix with row names equal to <code>colnames(X)</code> and
column names equal to <code>colnames(y)</code></p>
</dd>
</dl>
<p>For <code>createDataBayesModel</code> with <code>mode</code> that uses a second level of
indicator variables, each entry in the <code>replicate</code> list also has
components <code>omega.grp</code> and <code>indic.grp</code> containing the intermediate
steps of drawing the second-level indicator variable before drawing
<code>omega</code>.  If the argument <code>beta</code> to <code>createData</code> is
“createBetaNormal” (which it is when called by
<code>createDataBayesModel</code>), then each replicate will also have a component
<code>tau</code> giving the value drawn by a call to
<code>runif(1, tau.min, tau.max)</code>.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Laurel Stell and Chiara Sabatti<br>
Maintainer: Laurel Stell &lt;lstell@stanford.edu&gt;
</p>


<h3>References</h3>

<p>Stell, L. and Sabatti, C. (2015) Genetic variant selection: learning across
traits and sites, arXiv:1504.00946.
</p>


<h3>See Also</h3>

<p><code>createOrthogonalX</code>, <code>createGroupsSim</code>;
also Data describes <code>tinysim</code> in example below as well as another
object output by <code>createData</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">### EXAMPLE 1
data(tinysim)
# Data generated with mode equal to pleiotropy, so indic.grp exists and
# has an entry for each column in X.
colnames(tinysim$X)
tinysim$replicates[[5]]$indic.grp
# X4, X6, and X9 are associated with some responses.
tinysim$replicates[[5]]$indic.var

### EXAMPLE 2
# Generate miniature data set with information shared across covariates.
set.seed(1234)
tiny1 &lt;- createDataBayesModel(mode="gene", n=100, p=10, q=5, nreps=10,
                              tau.min=0.045, tau.max=0.063, G=2)
# A covariate can only have indic.var=1 if the group it belongs to has
# indic.grp=1.  For example,indic.grp[1,4]=0 implies
# indic.var[groups$group2var[1],4]=0.
tiny1$replicates[[1]]$indic.grp
tiny1$omega[[2]]$groups$group2var[1]
tiny1$replicates[[1]]$indic.var

### EXAMPLE 3
# Alternatively, call createData directly
groups &lt;- createGroupsSim(G=2, p=10)
omegaargs &lt;- list(indic.grp.shape1=16, indic.grp.shape2=55,
                  shape1=48, shape2=12, groups=groups)
betaargs &lt;- list(tau.min=0.045, tau.max=0.063)
set.seed(1234)
tiny2 &lt;- createData(X=list("createOrthogonalX", list(n=100, p=10)),
                    y=list(nreps=10, q=5, sd=1),
                    omega=list("createOmegaCrossVars", omegaargs),
                    beta=list("createBetaNormal", betaargs))
identical(tiny1, tiny2)
### SEE THE CODE FOR createPubData FOR MORE EXAMPLES.
</code></pre>


</div>
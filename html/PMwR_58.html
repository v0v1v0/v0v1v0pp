<div class="container">

<table style="width: 100%;"><tr>
<td>rc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Return Contribution
</h2>

<h3>Description</h3>

<p>Return contribution of portfolio segments.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rc(R, weights, timestamp, segments = NULL,
   R.bm = NULL, weights.bm = NULL,
   method = "contribution",
   linking.method = NULL,
   allocation.minus.bm = TRUE,
   tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>

<p>returns: a numeric matrix
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>the segment weights: a numeric matrix.
<code>weights[i, j]</code> must correspond to <code>R[i, j]</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timestamp</code></td>
<td>

<p>character or numeric
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segments</code></td>
<td>

<p>character. If missing, column names of <code>R</code> or of
<code>weights</code> are used (if they are not <code>NULL</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a string; default is <code>contribution</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linking.method</code></td>
<td>
<p><code>NULL</code> or a string. Currently
supported are <code>0-cumulative, 1-cumulative, 0.5-cumulative</code>
(<code>geometric{0,1,0.5}</code>) and <code>logarithmic</code>. See Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allocation.minus.bm</code></td>
<td>
<p>logical</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>numeric: weights whose absolute value is below
<code>tol</code> are considered zero and not used for
computations. Ignored if <code>NA</code>.
</p>
</td>
</tr>
</table>
<p>If portfolio returns are to be compared against benchmark
returns, benchmark returns and weights must be supplied:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>R.bm</code></td>
<td>

<p>benchmark returns: a numeric matrix
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights.bm</code></td>
<td>

<p>the benchmark weights of segments: a numeric matrix.
<code>weights.bm[i, j]</code> must correspond to <code>R.bm[i, j]</code>
</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p>The function computes segment contribution, potentially
over time.  Returns and weights must be arranged in
matrices, with rows corresponding to time periods and
columns to portfolio segments.  If <code>weights</code> and
<code>R</code> are atomic vectors, then they are interpreted as
cross-sectional weights/returns for a single period,
i.e. they are handled like row vectors.
</p>
<p>Weights can be missing, in which case <code>R</code> is assumed
to already comprise segment returns.
</p>
<p>Note that the segment contributions need not come from
asset classes; the computation works for any additive
single-period decomposition of portfolio returns.
</p>


<h3>Value</h3>


<p>A list of two components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>period_contributions</code></td>
<td>
<p>a data.frame of single-period
contributions, sorted in time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total_contributions</code></td>
<td>
<p>a numeric vector</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>David R. Cariño (1999).
Combining Attribution Effects Over Time.
Journal of Performance Measurement.
<strong>3</strong> (4), 5–14.
</p>
<p>Jon A. Christopherson and David R. Cariño and
Wayne E. Ferson (2009),
<em>Portfolio Performance Measurement and Benchmarking</em>,
McGraw-Hill.
</p>
<p>Feibel, Bruce (2003), <em>Investment Performance Measurement</em>,
Wiley.
</p>
<p>Erik Valtonen (2002).
Incremental Attribution with and without Notional Portfolios.
Journal of Performance Measurement.
<strong>7</strong> (1), 68–83.
</p>
<p><a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#return-contribution">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#return-contribution</a>
</p>


<h3>See Also</h3>

<p><code>returns</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">weights &lt;- rbind(c( 0.25, 0.75),
                 c( 0.40, 0.60),
                 c( 0.25, 0.75))

R &lt;- rbind(c( 1  ,    0),
           c( 2.5, -1.0),
           c(-2  ,  0.5))/100

rc(R, weights, segment = c("equities", "bonds"))



## EXAMPLE of Christopherson et al., ch 19
weights &lt;- cbind(stocks = c(0.5,  0.55),
                 bonds  = c(0.5, 0.45))
##      stocks bonds
## [1,]   0.50  0.50
## [2,]   0.55  0.45

R &lt;- cbind(stocks = c(.4, 0.1),
           bonds  = c(.1, 0.2))
##      stocks bonds
## [1,]    0.4   0.1
## [2,]    0.1   0.2

## ==&gt; contributions grow at portfolio rate-of-return
rc(R, weights, linking.method =  "geometric1")

## ==&gt; contributions are made on top of current portfolio-value
rc(R, weights, linking.method =  "geometric0")

## ==&gt; mixture
rc(R, weights, linking.method =  "geometric0.5")



## EXAMPLE from
## https://quant.stackexchange.com/questions/36520/
##         how-to-calculate-the-annual-contribution-of-a-fund-to-a-portfolio-of-funds/
##         36530#36530
## (unbreak the URL)

weights &lt;- rbind(c( 0.5, 0.5),
                 c( 0.5, 0.5))

R &lt;- rbind(c( 10,   0),
           c( 0 ,  10))/100


rc(R, weights, segment = c("F1", "F2"), timestamp = 1:2,
   linking.method = "geometric1")
## ==&gt; F1 contributed first, and so gets a higher total
##     contribution

rc(R, weights, segment = c("F1", "F2"), timestamp = 1:2,
   linking.method = "geometric0")
## ==&gt; F2 contributed later, and so gets a higher total
##     contribution because it started off a higher base
##     value




## contribution for btest:
##   run a portfolio 10% equities, 90% bonds
P &lt;- as.matrix(merge(DAX, REXP, by = "row.names")[, -1])
(bt &lt;- btest(prices = list(P),
            signal = function() c(0.1, 0.9),
            convert.weights = TRUE,
            initial.cash = 100))

W &lt;- bt$position*P/bt$wealth
rc(returns(P)*W[-nrow(W), ])$total_contributions
</code></pre>


</div>
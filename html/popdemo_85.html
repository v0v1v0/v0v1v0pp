<div class="container">

<table style="width: 100%;"><tr>
<td>tfa_inertia</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Transfer function Analysis</h2>

<h3>Description</h3>

<p>Transfer function analysis of inertia of a population matrix 
projection model using a specified perturbation structure.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tfa_inertia(A, d, e, vector = "n", bound = NULL, prange, digits = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a square, primitive, nonnegative numeric matrix of any dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d, e</code></td>
<td>
<p>numeric vectors that determine the perturbation structure 
(see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vector</code></td>
<td>
<p>(optional) a numeric vector or one-column matrix describing 
the age/stage distribution ('demographic structure') used to calculate the
transfer function of a 'case-specific' inertia</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bound</code></td>
<td>
<p>(optional) specifies whether the transfer funciton of an upper 
or lower bound on inertia should be calculated (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prange</code></td>
<td>
<p>a numeric vector giving the range of perturbation magnitude
(see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>specifies which values of lambda should be excluded from 
analysis to avoid a computationally singular system (see details).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>tfa_inertia</code> calculates the transfer function of inertia of a 
population matrix projection model given a perturbation structure 
(specified using <code>d</code> and <code>e</code>), and a range of desired perturbation
magnitude (<code>prange</code>). Currently <code>tfa_inertia</code> can only work with 
rank-one, single-parameter perturbations (see Hodgson &amp; Townley 2006).
</p>
<p>If <code>vector="n"</code> then either <code>bound="upper"</code> or <code>bound="lower"</code>
must be specified, which calculate the transfer function of the upper or 
lower bound on population inertia (i.e. the largest and smallest values that 
inertia may take) respectively.  Specifying <code>vector</code> overrides 
calculation of a bound, and will yield a transfer function of a 'case-specific'
inertia.
</p>
<p>The perturbation structure is determined by <code>d%*%t(e)</code>. Therefore, 
the rows to be perturbed are determined by <code>d</code> and the columns to be 
perturbed are determined by <code>e</code>. The specific values in d and e will 
determine the relative perturbation magnitude. So for example, if only entry
[3,2] of a 3 by 3 matrix is to be perturbed, then <code>d = c(0,0,1)</code> and 
<code>e = c(0,1,0)</code>. If entries [3,2] and [3,3] are to be perturbed with the 
magnitude of perturbation to [3,2] half that of [3,3] then <code>d = c(0,0,1)</code> 
and <code>e = c(0,0.5,1)</code>. <code>d</code> and <code>e</code> may also be expressed as 
numeric one-column matrices, e.g. <code>d = matrix(c(0,0,1), ncol=1)</code>, 
<code>e = matrix(c(0,0.5,1), ncol=1)</code>. See Hodgson et al. (2006) for more 
information on perturbation structures.
</p>
<p>The perturbation magnitude is determined by <code>prange</code>, a numeric vector 
that gives the continuous range of perterbation magnitude to evaluate over. 
This is usually a sequence (e.g. <code>prange=seq(-0.1,0.1,0.001)</code>), but 
single transfer functions can be calculated using a single perturbation 
magnitude (e.g. <code>prange=-0.1</code>). Because of the nature of the equation
used to calculate the transfer function, <code>prange</code> is used to find a 
range of lambda from which the perturbation magnitudes are back-calculated, 
and matched to their orresponding inertia, so the output perturbation
magnitude <code>p</code> will match <code>prange</code> in length and range but not in
numerical value (see Stott et al. 2012 for more information).
</p>
<p><code>tfa_inertia</code> uses the resolvent matrix in its calculation, which
cannot be computed if any lambda in the equation are equal to the dominant
eigenvalue of <code>A</code>. <code>digits</code> specifies the values of lambda that 
should be excluded in order to avoid a computationally singular system. 
Any values equal to the dominant eigenvalue of <code>A</code> rounded to an 
accuracy of <code>digits</code> are excluded. <code>digits</code> should only need to 
be changed when the system is found to be computationally singular, in 
which case increasing <code>digits</code> should help to solve the problem.
</p>
<p><code>tfa_inertia</code> will not work for reducible matrices.
</p>
<p>There is an S3 plotting method available (see <code>plot.tfa</code> 
and examples below)
</p>


<h3>Value</h3>

<p>A list containing numerical vectors:
</p>

<dl>
<dt>p</dt>
<dd>
<p>perturbation magnitudes</p>
</dd>
<dt>lambda</dt>
<dd>
<p>dominant eigenvalues of perturbed matrices</p>
</dd>
</dl>
<p>iteminertiainertias of perturbed matrices

(Note that <code>p</code> will not be exactly the same as <code>prange</code> when 
<code>prange</code> is specified, as the code calculates p for a given lambda 
rather than the other way around, with <code>prange</code> only used to determine 
max, min and number of lambda values to evaluate.)
</p>


<h3>References</h3>


<ul>
<li>
<p> Stott et al. (2012) Methods Ecol. Evol., 3, 673-684.
</p>
</li>
<li>
<p> Hodgson et al. (2006) J. Theor. Biol., 70, 214-224.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>S3 plotting method: <code>plot.tfa</code>
</p>
<p>Other TransferFunctionAnalyses: 
<code>tfa_lambda()</code>,
<code>tfam_inertia()</code>,
<code>tfam_lambda()</code>,
<code>tfs_inertia()</code>,
<code>tfs_lambda()</code>
</p>
<p>Other PerturbationAnalyses: 
<code>elas()</code>,
<code>sens()</code>,
<code>tfa_lambda()</code>,
<code>tfam_inertia()</code>,
<code>tfam_lambda()</code>,
<code>tfs_inertia()</code>,
<code>tfs_lambda()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Create a 3x3 matrix
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Calculate the transfer function of upper bound on inertia 
  # given a perturbation to A[3,2]
  ( transfer&lt;-tfa_inertia(A, d=c(0,0,1), e=c(0,1,0), bound="upper",
                          prange=seq(-0.6,0.4,0.01)) )

  # Plot the transfer function using the S3 method (defaults to p 
  # and inertia in this case)
  plot(transfer)

  # Plot inertia against lambda using the S3 method
  plot(transfer, xvar="lambda", yvar="inertia")

  # Calculate the transfer function of case-specific inertia 
  # given perturbation to A[3,2] and A[3,3] with perturbation 
  # to A[3,2] half that of A[3,3]
  ( transfer2&lt;-tfa_inertia(A, d=c(0,0,1), e=c(0,0.5,1), vector=initial,
                           prange=seq(-0.6,0.4,0.01)) )

  # Plot inertia against p using the S3 method
  plot(transfer2)

  # Plot inertia against lambda without using the S3 method
  plot(transfer$inertia~transfer$lambda,type="l", 
       xlab=expression(lambda),ylab="inertia")

</code></pre>


</div>
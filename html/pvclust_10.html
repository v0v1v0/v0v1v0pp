<div class="container">

<table style="width: 100%;"><tr>
<td>pvclust</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculating P-values for Hierchical Clustering</h2>

<h3>Description</h3>

<p>calculates <code class="reqn">p</code>-values for hierarchical clustering via
multiscale bootstrap resampling. Hierarchical clustering is done for
given data and <code class="reqn">p</code>-values are computed for each of the clusters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pvclust(data, method.hclust="average",
        method.dist="correlation", use.cor="pairwise.complete.obs",
        nboot=1000, parallel=FALSE, r=seq(.5,1.4,by=.1),
        store=FALSE, weight=FALSE, iseed=NULL, quiet=FALSE)

parPvclust(cl=NULL, data, method.hclust="average",
           method.dist="correlation", use.cor="pairwise.complete.obs",
           nboot=1000, r=seq(.5,1.4,by=.1), store=FALSE, weight=FALSE,
           init.rand=NULL, iseed=NULL, quiet=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>numeric data matrix or data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.hclust</code></td>
<td>

<p>the agglomerative method used in hierarchical clustering. This
should be (an abbreviation of) one of <code>"average"</code>, <code>"ward.D"</code>,
<code>"ward.D2"</code>, <code>"single"</code>, <code>"complete"</code>, <code>"mcquitty"</code>,
<code>"median"</code> or <code>"centroid"</code>. The default is
<code>"average"</code>. See <code>method</code> argument in
<code>hclust</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.dist</code></td>
<td>
<p>the distance measure to be used. This should be
a character string, or a function which returns a <code>dist</code> object.
A character string should be (an abbreviation of)
one of <code>"correlation"</code>, <code>"uncentered"</code>,
<code>"abscor"</code> or those which are allowed for <code>method</code>
argument in <code>dist</code> function. The default is
<code>"correlation"</code>. See <em>details</em> section in this help and
<code>method</code> argument in <code>dist</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.cor</code></td>
<td>
<p>character string which specifies the method for
computing correlation with data including missing values. This
should be (an abbreviation of) one of <code>"all.obs"</code>,
<code>"complete.obs"</code> or <code>"pairwise.complete.obs"</code>. See
the <code>use</code> argument in <code>cor</code> function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nboot</code></td>
<td>
<p>the number of bootstrap replications. The default is
<code>1000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>switch for parallel computation.
If <code>FALSE</code> the computation is done in non-parallel mode.
If <code>TRUE</code> or a positive integer is supplied,
parallel computation is done with automatically generated PSOCK cluster.
Use <code>TRUE</code> for default cluster size (<code>parallel::detectCores() - 1</code>),
or specify the size by an integer.
If a <code>cluster</code> object is supplied the cluster is used for parallel computation.
Note that <code>NULL</code> is currently not allowed for using the default cluster.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>numeric vector which specifies the relative sample sizes of
bootstrap replications. For original sample size <code class="reqn">n</code> and
bootstrap sample size <code class="reqn">n'</code>, this is defined as <code class="reqn">r=n'/n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store</code></td>
<td>
<p>locical. If <code>store=TRUE</code>, all bootstrap replications
are stored in the output object. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>a cluster object created by package <span class="pkg">parallel</span> or <span class="pkg">snow</span>.
If NULL, use the registered default cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>logical. If <code>weight=TRUE</code>, resampling is made by
weight vector instead of index vector. Useful for large <code>r</code>
value (<code>r&gt;10</code>).  Currently, available only for distance
<code>"correlation"</code> and <code>"abscor"</code>.</p>
</td>
</tr>
</table>
<table><tr style="vertical-align: top;">
<td><code>init.rand</code></td>
<td>
<p>logical. If <code>init.rand=TRUE</code>, random number generators are initialized.
Use <code>iseed</code> argument to achieve reproducible results. <strong>This argument is duplicated and will be unavailable in the future.</strong></p>
</td>
</tr></table>
<table>
<tr style="vertical-align: top;">
<td><code>iseed</code></td>
<td>
<p>An integer. If non-<code>NULL</code> value is supplied random number generators are initialized.
It is passed to <code>set.seed</code> or <code>clusterSetRNGStream</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>logical. If <code>TRUE</code> it does not report the progress.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function <code>pvclust</code> conducts multiscale bootstrap resampling to calculate
<code class="reqn">p</code>-values for each cluster in the result of hierarchical
clustering. <code>parPvclust</code> is the parallel version of this
procedure which depends on package <span class="pkg">parallel</span> for parallel computation.
</p>
<p>For data expressed as <code class="reqn">(n \times p)</code> matrix or data frame, we
assume that the data is <code class="reqn">n</code> observations of <code class="reqn">p</code> objects, which
are to be clustered. The <code class="reqn">i</code>'th row vector corresponds to the
<code class="reqn">i</code>'th observation of these objects and the <code class="reqn">j</code>'th column
vector corresponds to a sample of <code class="reqn">j</code>'th object with size <code class="reqn">n</code>.
</p>
<p>There are several methods to measure the dissimilarities between
objects. For data matrix <code class="reqn">X=\{x_{ij}\}</code>,
<code>"correlation"</code>
method takes
</p>
<p style="text-align: center;"><code class="reqn">
    1 - \frac{
      \sum_{i=1}^n (x_{ij} - \bar{x}_j) (x_{ik} - \bar{x}_k)
    }
    {
      \sqrt{\sum_{i=1}^n (x_{ij} - \bar{x}_j)^2}
      \sqrt{\sum_{i=1}^n (x_{ik} - \bar{x}_k)^2}
    }
    </code>
</p>

<p>for dissimilarity between <code class="reqn">j</code>'th and <code class="reqn">k</code>'th object, where
<code class="reqn">\bar{x}_j = \frac{1}{n} \sum_{i=1}^n x_{ij} \mbox{and}
  \bar{x}_k = \frac{1}{n} \sum_{i=1}^n x_{ik}</code>.
</p>
<p><code>"uncentered"</code> takes uncentered sample correlation
</p>
<p style="text-align: center;"><code class="reqn">
    1 - \frac{
      \sum_{i=1}^n x_{ij} x_{ik}
    }
    {
      \sqrt{\sum_{i=1}^n x_{ij}^2}
      \sqrt{\sum_{i=1}^n x_{ik}^2}
    }
    </code>
</p>

<p>and <code>"abscor"</code> takes the absolute value of sample correlation
</p>
<p style="text-align: center;"><code class="reqn">
    1 - \ \Biggl| \frac{
      \sum_{i=1}^n (x_{ij} - \bar{x}_j) (x_{ik} - \bar{x}_k)
    }
    {
      \sqrt{\sum_{i=1}^n (x_{ij} - \bar{x}_j)^2}
      \sqrt{\sum_{i=1}^n (x_{ik} - \bar{x}_k)^2}
    } \Biggl|.
  </code>
</p>



<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>hclust</code></td>
<td>
<p>hierarchical clustering for original data generated by
function <code>hclust</code>. See <code>hclust</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edges</code></td>
<td>
<p>data frame object which contains <code class="reqn">p</code>-values and
supporting informations such as standard errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>count</code></td>
<td>
<p>data frame object which contains primitive information
about the result of multiscale bootstrap resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msfit</code></td>
<td>
<p>list whose elements are results of curve fitting for
multiscale bootstrap resampling, of class <code>msfit</code>. See
<code>msfit</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nboot</code></td>
<td>
<p>numeric vector of number of bootstrap replications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>numeric vector of the relative sample size for bootstrap
replications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store</code></td>
<td>
<p>list contains bootstrap replications if <code>store=TRUE</code>
was given for function <code>pvclust</code> or <code>parPvclust</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>version</code></td>
<td>
<p><code>package_version</code> of pvclust used
to generate this object.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Ryota Suzuki <a href="mailto:suzuki@ef-prime.com">suzuki@ef-prime.com</a></p>


<h3>References</h3>

<p>Suzuki, R. and Shimodaira, H. (2006)
"Pvclust: an R package for assessing the uncertainty in hierarchical clustering",
<em>Bioinformatics</em>, 22 (12): 1540-1542.
</p>
<p>Shimodaira, H. (2004)
"Approximately unbiased tests of regions using multistep-multiscale
bootstrap resampling",
<em>Annals of Statistics</em>, 32, 2616-2641.
</p>
<p>Shimodaira, H. (2002)
"An approximately unbiased test of phylogenetic tree selection",
<em>Systematic Biology</em>, 51, 492-508.
</p>
<p>Suzuki, R. and Shimodaira, H. (2004)
"An application of multiscale bootstrap resampling to hierarchical
clustering of microarray data: How accurate are these clusters?",
<em>The Fifteenth International Conference on Genome Informatics 2004</em>,
P034.
</p>
<p><a href="http://www.sigmath.es.osaka-u.ac.jp/shimo-lab/prog/pvclust/">http://www.sigmath.es.osaka-u.ac.jp/shimo-lab/prog/pvclust/</a>
</p>


<h3>See Also</h3>

<p><code>lines.pvclust</code>, <code>print.pvclust</code>,
<code>msfit</code>, <code>plot.pvclust</code>,
<code>text.pvclust</code>, <code>pvrect</code> and
<code>pvpick</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">### example using Boston data in package MASS
data(Boston, package = "MASS")

## multiscale bootstrap resampling (non-parallel)
boston.pv &lt;- pvclust(Boston, nboot=100, parallel=FALSE)

## CAUTION: nboot=100 may be too small for actual use.
##          We suggest nboot=1000 or larger.
##          plot/print functions will be useful for diagnostics.

## plot dendrogram with p-values
plot(boston.pv)

ask.bak &lt;- par()$ask
par(ask=TRUE)

## highlight clusters with high au p-values
pvrect(boston.pv)

## print the result of multiscale bootstrap resampling
print(boston.pv, digits=3)

## plot diagnostic for curve fitting
msplot(boston.pv, edges=c(2,4,6,7))

par(ask=ask.bak)

## print clusters with high p-values
boston.pp &lt;- pvpick(boston.pv)
boston.pp

### Using a custom distance measure

## Define a distance function which returns an object of class "dist".
## The function must have only one argument "x" (data matrix or data.frame).
cosine &lt;- function(x) {
    x &lt;- as.matrix(x)
    y &lt;- t(x) %*% x
    res &lt;- 1 - y / (sqrt(diag(y)) %*% t(sqrt(diag(y))))
    res &lt;- as.dist(res)
    attr(res, "method") &lt;- "cosine"
    return(res)
}

result &lt;- pvclust(Boston, method.dist=cosine, nboot=100)
plot(result)

## Not run: 
### parallel computation
result.par &lt;- pvclust(Boston, nboot=1000, parallel=TRUE)
plot(result.par)

## End(Not run)

</code></pre>


</div>
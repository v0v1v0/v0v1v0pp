<div class="container">

<table style="width: 100%;"><tr>
<td>pooldata.subset</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a subset of the pooldata object that contains Pool-Seq data as a function of pool and/or SNP indexes</h2>

<h3>Description</h3>

<p>Create a subset of the pooldata object that contains Pool-Seq data as a function of pool and/or SNP indexes
</p>


<h3>Usage</h3>

<pre><code class="language-R">pooldata.subset(
  pooldata,
  pool.index = 1:pooldata@npools,
  snp.index = 1:pooldata@nsnp,
  min.cov.per.pool = -1,
  max.cov.per.pool = 1e+06,
  min.maf = -1,
  cov.qthres.per.pool = c(0, 1),
  return.snp.idx = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pooldata</code></td>
<td>
<p>A pooldata object containing Pool-Seq information</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pool.index</code></td>
<td>
<p>Indexes of the pools (at least two), that should be selected to create the new pooldata object (default=all the pools)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>snp.index</code></td>
<td>
<p>Indexes of the SNPs (at least two), that should be selected to create the new pooldata object (default=all the SNPs)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.cov.per.pool</code></td>
<td>
<p>Minimal allowed read count (per pool). If at least one pool is not covered by at least min.cov.perpool reads, the position is discarded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.cov.per.pool</code></td>
<td>
<p>Maximal allowed read count (per pool). If at least one pool is covered by more than min.cov.perpool reads, the position is discarded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.maf</code></td>
<td>
<p>Minimal allowed Minor Allele Frequency (computed from the ratio over all read counts for the reference allele over the read coverage)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.qthres.per.pool</code></td>
<td>
<p>A two-elements vector containing the minimal (qmin) and maximal (qmax) quantile coverage thresholds applied to each pools (0&lt;=qmin&lt;qmax&lt;=1). See details below</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.snp.idx</code></td>
<td>
<p>If TRUE, the row.names of the snp.info slot of the returned pooldata object are named as "rsx" where x is the index of SNP in the initial pooldata object (default=FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If TRUE return some information</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function allows subsetting a pooldata object by selecting only some pools and/or some SNPs (e.g., based on their position on the genome). Additional filtering steps on SNPs can be carried out on the resulting subset to discard SNP with low polymorphism or poorly or too highly covered. In addition, coverage criteria can be applied on a per-pool basis with the cov.qthres.per.pool argument. 'more specific SNP selection based on their positions on the genome or their characteristics. For instance if qmax=0.95, a position is discarded if in a given pool it has a number of reads higher than the 95-th percentile of the empirical coverage distribution in this same pool (defined over the SNPs selected by snp.index). Similarly, if qmax=0.05, a position is discarded if in a given pool it has a number of reads lower than the 5-th percentile of the empirical coverage distribution in this same pool. This mode of selection may be more relevant when considering pools with heterogeneous read coverages.
</p>


<h3>Value</h3>

<p>A pooldata object with 7 elements:
</p>

<ol>
<li>
<p> "refallele.readcount": a matrix with nsnp rows and npools columns containing read counts for the reference allele (chosen arbitrarily) in each pool
</p>
</li>
<li>
<p> "readcoverage": a matrix with nsnp rows and npools columns containing read coverage in each pool
</p>
</li>
<li>
<p> "snp.info": a matrix with nsnp rows and four columns containing respectively the contig (or chromosome) name (1st column) and position (2nd column) of the SNP; the allele in the reference assembly (3rd column); the allele taken as reference in the refallele matrix.readcount matrix (4th column); and the alternative allele (5th column)
</p>
</li>
<li>
<p> "poolsizes": a vector of length npools containing the haploid pool sizes
</p>
</li>
<li>
<p> "poolnames": a vector of length npools containing the names of the pools
</p>
</li>
<li>
<p> "nsnp": a scalar corresponding to the number of SNPs
</p>
</li>
<li>
<p> "npools": a scalar corresponding to the number of pools
</p>
</li>
</ol>
<h3>See Also</h3>

<p>To generate pooldata object, see <code>vcf2pooldata</code>, <code>popsync2pooldata</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 subset.by.pools=pooldata.subset(pooldata,pool.index=c(1,2))
 subset.by.snps=pooldata.subset(pooldata,snp.index=10:100)
 subset.by.pools.and.snps=pooldata.subset(pooldata,pool.index=c(1,2),snp.index=10:100)
 subset.by.pools.qcov.thr=pooldata.subset(pooldata,pool.index=1:8,cov.qthres.per.pool=c(0.05,0.95)) 
</code></pre>


</div>
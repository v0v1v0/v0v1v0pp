<div class="container">

<table style="width: 100%;"><tr>
<td>lars.c</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constrained LARS Coefficient Function (Equality Constraints)</h2>

<h3>Description</h3>

<p>This function computes the PaC constrained LASSO
coefficient paths following the methodology laid out in the PaC
paper. This function could be called directly as a standalone
function, but the authors recommend using <code>lasso.c</code> for any
implementation. This is because <code>lasso.c</code> has additional checks for
errors across the coefficient paths and allows for users to go
forwards and backwards through the paths if the paths are unable
to compute in a particular direction for a particular run.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lars.c(x, y, C.full, b, l.min = -2, l.max = 6, step = 0.2,
  beta0 = NULL, verbose = F, max.it = 12, intercept = T,
  normalize = T, forwards = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>independent variable matrix of data to be used in calculating PaC coefficient paths</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response vector of data to be used in calculating PaC coefficient paths</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.full</code></td>
<td>
<p>complete constraint matrix C (with constraints of the form <code>C.full</code>*<code>beta</code>=<code>b</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>constraint vector b</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l.min</code></td>
<td>
<p>lowest value of lambda to consider (used as 10^<code>l.min</code>). Default is -2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l.max</code></td>
<td>
<p>largest value of lambda to consider (used as 10^<code>l.max</code>). Default is 6</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>step size increase in lambda attempted at each iteration (by a factor of 10^<code>step</code>). Default is 0.2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta0</code></td>
<td>
<p>initial guess for beta coefficient vector. Default is NULL (indicating
initial vector should be calculated by algorithm)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>should function print output at each iteration (TRUE) or not (FALSE). Default is FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.it</code></td>
<td>
<p>maximum number of times step size is halved before the algorithm terminates and gives a warning. Default is 12</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>should intercept be included in modeling (TRUE) or not (FALSE). Default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>should <code>x</code> data be normalized. Default is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forwards</code></td>
<td>
<p>if <code>forwards</code> = F, then the algorithm starts at 10^<code>l.max</code> and
moves backwards (without the forward step). If <code>forwards</code> = T,
algorithm starts at 10^<code>l.min</code> and works forward. Default is FALSE</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>coefs</code> A <code>p</code> by length(<code>lambda</code>) matrix with each column corresponding to the beta estimate for that lambda
</p>
<p><code>lambda</code> the grid of lambdas used to calculate the coefficients on the coefficient path
</p>
<p><code>intercept</code> vector with each element corresponding to intercept for corresponding lambda
</p>
<p><code>error</code> did the algorithm terminate due to too many iterations (TRUE or FALSE)
</p>
<p><code>b2index</code> the index of the <code>beta2</code> values identified by the algorithm at each lambda
</p>


<h3>References</h3>

<p>Gareth M. James, Courtney Paulson, and Paat Rusmevichientong (JASA, 2019) "Penalized and Constrained Optimization."
(Full text available at http://www-bcf.usc.edu/~gareth/research/PAC.pdf)
</p>


<h3>Examples</h3>

<pre><code class="language-R">random_data = generate.data(n = 500, p = 20, m = 10)
lars_fit = lars.c(random_data$x, random_data$y, random_data$C.full, random_data$b)
lars_fit$lambda
lars_fit$error
### The coefficients for the first lambda value
lars_fit$coefs[1,]
### Example of code where path is unable
### to be finished (only one iteration)
lars_err = lars.c(random_data$x, random_data$y, random_data$C.full,
random_data$b, max.it = 1)
lars_err$error
lars_err$lambda
</code></pre>


</div>
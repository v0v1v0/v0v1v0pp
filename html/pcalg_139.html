<div class="container">

<table style="width: 100%;"><tr>
<td>udag2pdag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Last PC Algorithm Step: Extend Object with Skeleton to Completed PDAG</h2>

<h3>Description</h3>

<p>These functions perform the last step in the PC algorithm:
Transform an object of the class
<code>"pcAlgo"</code> containing a skeleton and corresponding
conditional independence information into a completed partially
directed acyclic graph (CPDAG).  The functions first determine the
v-structures, and then apply the three orientation rules as described
in Sprirtes et al (2000) and Meek (1995) to orient as many of the
remaining edges as possible.
</p>
<p>In the oracle version and when all assumptions hold, all three
functions yield the same CPDAG.  In the sample version, however, the
resulting CPDAG may be invalid in the sense that one cannot extend it
a DAG without additional unshielded colliders by orienting the
undirecting edges.  This can for example happen due to errors in the
conditional indepedence tests or violations of the faithfulness
assumption.  The three functions deal with such conflicts in different
ways, as described in Details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">udag2pdag       (gInput, verbose)
udag2pdagRelaxed(gInput, verbose, unfVect=NULL, solve.confl=FALSE,
  orientCollider = TRUE, rules = rep(TRUE, 3))
udag2pdagSpecial(gInput, verbose, n.max=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>gInput</code></td>
<td>
<p><code>"pcAlgo"</code>-object containing skeleton and
conditional indepedence information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>0: No output; 1: Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unfVect</code></td>
<td>
<p>vector containing numbers that encode ambiguous
triples (as returned by <code>pc.cons.intern</code>).  This is
needed in the conservative and majority rule PC algorithms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solve.confl</code></td>
<td>
<p>if <code>TRUE</code>, the orientation of the v-structures and the
orientation rules work with lists for candidate sets and allow
bi-directed edges to resolve conflicting edge orientations. Note that
therefore the resulting object is order-independent but might not be
a PDAG because bi-directed edges can be present.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.max</code></td>
<td>
<p>maximum number of tries for re-orienting doubly visited
edges in <code>udag2pdagSpecial</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orientCollider</code></td>
<td>
<p>if <code>TRUE</code>, collider are oriented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rules</code></td>
<td>
<p>Array of length 3 containing <code>TRUE</code> or <code>FALSE</code>
for each rule. <code>TRUE</code> in position i means that rule i (Ri) will
be applied.  By default, all rules are used.</p>
</td>
</tr>
</table>
<h3>Details</h3>


<dl>
<dt>for <code>udag2pdag</code>:</dt>
<dd>
<p>If there are edges that are part of more than one v-structure
(i.e., the edge b - c in the v-structures a -&gt; b &lt;- c and b -&gt; c
&lt;- d), earlier edge orientations are simply overwritten by later
ones.  Thus, if a -&gt; b &lt;- c is considered first, the edge b - c is
first oriented as b &lt;- c and later overwritten by b -&gt; c.  The
v-structures are considered in lexicographical ordering.
</p>
<p>If the resulting graph is extendable to a DAG without additional
v-structures, then the rules of Meek (1995) and Spirtes et al
(2000) are applied to obtain the corresponding CPDAG.  Otherwise,
the edges are oriented randomly to obtain a DAG that fits on the
skeleton, discarding all information about the v-structures.  The
resulting DAG is then transformed into its CPDAG.  Note that the
output of <code>udag2pdag</code> is random whenever the initial graph
was not extendable. 
</p>
<p>Although the output of <code>udag2pdag</code> is always
extendable, it is not necessarily a valid CPDAG in the sense that
it describes a Markov equivalence class of DAGs.  For example, two
v-structures a -&gt; b &lt;- c and b -&gt; c &lt;- d (considered in this
order) would yield the output a -&gt; b -&gt; c &lt;- d.  This is
extendable to a DAG (it already <em>is</em> a DAG), but it does not
describe a Markov equivalence class of DAGs, since the DAG a &lt;- b
-&gt; c &lt;- d describes the same conditional independencies.
</p>
</dd>
<dt>for <code>udag2pdagSpecial</code>:</dt>
<dd>
<p>If the graph after orienting the v-structures as in
<code>udag2pdag</code> is extendable to a DAG without additional
v-structures, then the rules of Meek (1995) and Spirtes et al
(2000) are applied to obtain the corresponding CPDAG.  Otherwise,
the algorithm tries at most <code>n.max</code> different random
orderings of the v-structures (hence overwriting orientations in
different orders), until it finds one that yields an extendable
CPDAG.  If this fails, the edges are oriented randomly to obtain a
DAG that fits on the skeleton, discarding all information about
the v-structures.  The resulting DAG is then transformed into its
CPDAG.  Note that the output of <code>udag2pdagSpecial</code> is random
whenever the initial graph was not extendable.
</p>
<p>Although the output of <code>udag2pdag</code> is always
extendable, it is not necessarily a valid CPDAG in the sense that
it describes a Markov equivalence class of DAGs.  For example, two
v-structures a -&gt; b &lt;- c and b -&gt; c &lt;- d (considered in this
order) would yield the output a -&gt; b -&gt; c &lt;- d.  This is
extendable to a DAG (it already IS a DAG), but it does not
describe a Markov equivalence class of DAGs, since the DAG a &lt;- b
-&gt; c &lt;- d describes the same conditional independencies.
</p>
</dd>
<dt>for <code>udag2pdagRelaxed</code>:</dt>
<dd>
<p>This is the default version in the PC/RFCI/FCI algorithm.  It does
<b>not</b> test whether the output is extendable to a DAG without
additional v-structures.
</p>
<p>If <code>unfVect = NULL</code> (no ambiguous triples), the three
orientation rules are applied to each eligible structure until no
more edges can be oriented.  Otherwise, <code>unfVect</code> contains
the numbers of all ambiguous triples in the graph as determined by
<code>pc.cons.intern</code>.  Then the orientation rules take
this information into account.  For example, if a -&gt; b - c and
&lt;a,b,c&gt; is an unambigous triple and a non-v-structure, then rule 1
implies b -&gt; c.  On the other hand, if a -&gt; b - c but &lt;a,b,c&gt; is
an ambiguous triple, then the edge b - c is not oriented.
</p>
<p>If <code>solve.confl = FALSE</code>, earlier edge orientations are
overwritten by later ones as in <code>udag2pdag</code> and
<code>udag2pdagSpecial</code>.
</p>
<p>If <code>solv.confl = TRUE</code>, both the v-structures and the
orientation rules work with lists for the candidate edges and
allow bi-directed edges if there are conflicting orientations. For
example, two v-structures a -&gt; b &lt;- c and b -&gt; c &lt;- d then yield a
-&gt; b &lt;-&gt; c &lt;-d.  This option can be used to get an
order-independent version of the PC algorithm (see Colombo and
Maathuis (2014)).
</p>
<p>We denote bi-directed edges, for example between two variables i
and j, in the adjacency matrix M of the graph as M[i,j]=2 and
M[j,i]=2.  Such edges should be interpreted as indications of
conflicts in the algorithm, for example due to errors in the
conditional independence tests or violations of the faithfulness
assumption.
</p>
</dd>
</dl>
<h3>Value</h3>


<dl>
<dt>for <code>udag2pdag()</code> and <code>udag2pdagRelaxed()</code>:</dt>
<dd>
<p>oriented <code>"pcAlgo"</code>-object.</p>
</dd>
<dt>for <code>udag2pdagSpecial</code>:</dt>
<dd>
<p>a <code>list</code> with
components </p>

<dl>
<dt>pcObj</dt>
<dd>
<p>An oriented <code>"pcAlgo"</code>-object.</p>
</dd>
<dt>evisit</dt>
<dd>
<p>Matrix counting the number of orientation attempts per edge</p>
</dd>
</dl>
<dl>
<dt>xtbl.orig</dt>
<dd>
<p>Logical indicating whether the original graph
with v-structures is extendable.</p>
</dd>
<dt>xtbl</dt>
<dd>
<p>Logical indicating whether the final graph with
v-structures is extendable</p>
</dd>
<dt>amat0</dt>
<dd>
<p>Adjacency matrix of original graph with
v-structures (type amat.cpdag) .</p>
</dd>
<dt>amat1</dt>
<dd>
<p>Adjacency matrix of final graph with v-structures
after changing the ordering in which the v-structures are
considered (type amat.cpdag) .</p>
</dd>
<dt>status</dt>
<dd>
<p>Integer code with values </p>

<dl>
<dt>0:</dt>
<dd>
<p>Original try is extendable;</p>
</dd>
<dt>1:</dt>
<dd>
<p>Reorienting double edge visits helps;</p>
</dd>
<dt>2:</dt>
<dd>
<p>Original try is not extendable; reorienting double
visits does not help; result is acyclic, has original
v-structures, but perhaps additional v-structures.</p>
</dd>
</dl>
</dd>
<dt>counter</dt>
<dd>
<p>Number of orderings of the v-structures until
success or <code>n.max</code>.</p>
</dd>
</dl>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>References</h3>

<p>C. Meek (1995). Causal inference and causal explanation with
background knowledge. In <em>Proceedings of the Eleventh Conference
on Uncertainty in Artificial Intelligence (UAI-95)</em>,
pp. 403-411. Morgan Kaufmann Publishers, Inc.
</p>
<p>P. Spirtes, C. Glymour and R. Scheines (2000)
<em>Causation, Prediction, and Search</em>, 2nd edition, The MIT Press.
</p>
<p>J. Pearl (2000), <em>Causality</em>, Cambridge University Press.
</p>
<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782. 
</p>


<h3>See Also</h3>

<p><code>pc</code>, <code>pdag2dag</code>,
<code>dag2cpdag</code>, <code>udag2pag</code>,
<code>udag2apag</code>, <code>dag2pag</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## simulate data
set.seed(123)
p &lt;- 10
myDAG &lt;- randomDAG(p, prob = 0.2)
trueCPDAG &lt;- dag2cpdag(myDAG)
n &lt;- 1000
d.mat &lt;- rmvDAG(n, myDAG, errDist = "normal")

## estimate skeleton
resU &lt;- skeleton(suffStat = list(C = cor(d.mat), n = n),
                 indepTest = gaussCItest, ## (partial correlations)
                 alpha = 0.05, p=p)

## orient edges using three different methods
resD1 &lt;- udag2pdagRelaxed(resU, verbose=0)
resD2 &lt;- udag2pdagSpecial(resU, verbose=0, n.max=100)
resD3 &lt;- udag2pdag       (resU, verbose=0)

</code></pre>


</div>
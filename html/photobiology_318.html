<div class="container">

<table style="width: 100%;"><tr>
<td>eq_ratio</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Energy:photon ratio</h2>

<h3>Description</h3>

<p>This function returns the energy to mole of photons ratio for each waveband
and a light source spectrum.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eq_ratio(spct, w.band, scale.factor, wb.trim, use.cached.mult, use.hinges, ...)

## Default S3 method:
eq_ratio(spct, w.band, scale.factor, wb.trim, use.cached.mult, use.hinges, ...)

## S3 method for class 'source_spct'
eq_ratio(
  spct,
  w.band = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  naming = "short",
  name.tag = ifelse(naming != "none", "[e:q]", ""),
  ...
)

## S3 method for class 'source_mspct'
eq_ratio(
  spct,
  w.band = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  naming = "short",
  name.tag = ifelse(naming != "none", "[e:q]", ""),
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>spct</code></td>
<td>
<p>source_spct.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.band</code></td>
<td>
<p>waveband or list of waveband objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.cached.mult</code></td>
<td>
<p>logical Flag telling whether multiplier values should
be cached between calls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert "hinges" into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>naming</code></td>
<td>
<p>character one of "long", "default", "short" or "none". Used to
select the type of names to assign to returned value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr2tb</code></td>
<td>
<p>character vector, see <code>add_attr2tb</code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The ratio is based on one photon irradiance and one energy
irradiance, both computed for the same waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{I(s, wb)}{Q(s, wb)}</code>
</p>

<p>The last two parameters control speed optimizations. The defaults should be
suitable in most cases. If you will use repeatedly the same SWFs on many
spectra measured at exactly the same wavelengths you may obtain some speed
up by setting <code>use.cached.mult=TRUE</code>. However, be aware that you are
responsible for ensuring that the wavelengths are the same in each call, as
the only test done is for the length of the <code>w.length</code> vector.#'
@return Computed values are ratios between energy irradiance and photon
irradiance for a given waveband. A named <code>numeric</code> vector in the case
of methods for individual spectra, with one value for each <code>waveband</code>
passed to parameter <code>w.band</code>. A <code>data.frame</code> in the case of
collections of spectra, containing one column for each <code>waveband</code>
object, an index column with the names of the spectra, and optionally
additional columns with metadata values retrieved from the attributes of
the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used, with "[e:q]"
prepended. Units [J mol-1].
</p>


<h3>Value</h3>

<p>Computed values are ratios between energy irradiance and photon
irradiance for a given waveband. A named <code>numeric</code> vector in the case
of methods for individual spectra, with one value for each <code>waveband</code>
passed to parameter <code>w.band</code>. A <code>data.frame</code> in the case of
multiple spectra, containing one column with ratios for each <code>waveband</code>
object, an index column with the names of the spectra, and optionally
additional columns with metadata values retrieved from the attributes of
the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they are expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used, with "[e:q]" prepended.
Units [mol J-1].
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>eq_ratio(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>eq_ratio(source_spct)</code>: Method for <code>source_spct</code> objects
</p>
</li>
<li> <p><code>eq_ratio(source_mspct)</code>: Calculates energy:photon from a <code>source_mspct</code>
object.
</p>
</li>
</ul>
<h3>Performance</h3>

<p>As this method accepts spectra as its input, it
computes irradiances before computing the ratios. If you need to compute
both ratios and irradiances from several hundreds or thousands of spectra,
computing the ratios from previously computed irradiances avoids their
repeated computation. A less dramatic, but still important, increase in
performance is available when computing in the same function call ratios
that share the same denominator.
</p>


<h3>See Also</h3>

<p>Other photon and energy ratio functions: 
<code>e_fraction()</code>,
<code>e_ratio()</code>,
<code>q_fraction()</code>,
<code>q_ratio()</code>,
<code>qe_ratio()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">eq_ratio(sun.spct,
         waveband(c(400,700), wb.name = "White")) # J mol-1
eq_ratio(sun.spct,
         waveband(c(400,700), wb.name = "White"),
         scale.factor = 1e-6) # J umol-1

</code></pre>


</div>
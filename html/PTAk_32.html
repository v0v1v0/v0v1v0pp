<div class="container">

<table style="width: 100%;"><tr>
<td>SINGVA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimisation algorithm RPVSCC</h2>

<h3>Description</h3>

<p>Computes the best rank-one approximation using the RPVSCC algorithm.</p>


<h3>Usage</h3>

<pre><code class="language-R">SINGVA(X,test=1E-12,PTnam="vs111",Maxiter=2000,
                  verbose=getOption("verbose"),file=NULL,
                    smoothing=FALSE,smoo=list(NA),
                     modesnam=NULL,
                      Ini="svds",sym=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>a tensor (as an array) of order <em>k</em>, if non-identity metrics are
used <code>X</code> is a list with <code>data</code>  as the array and
<code>met</code> a list of metrics</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>numerical value to stop optimisation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PTnam</code></td>
<td>
<p>character giving the name of the <em>k</em>-modes Principal Tensor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Maxiter</code></td>
<td>
<p>if <code>iter &gt; Maxiter</code> prompts to carry on or not, then do it
every other 200 iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>control printing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>output printed at the prompt if <code>NULL</code>, or printed in the given  ‘<span class="file">file</span>’</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothing</code></td>
<td>
<p>logical to use smooth functiosns or not (see
<code>SVDgen</code>) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoo</code></td>
<td>
<p>list of functions returning smoothed vectors (see
<code>PTA3</code>) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modesnam</code></td>
<td>
<p>character vector of the names of the modes, if <code>NULL</code> "<code>mo 1</code>" ..."<code>mo k</code>"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ini</code></td>
<td>
<p>method used for initialisation of the algorithm (see <code>INITIA</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sym</code></td>
<td>
<p>description of the symmetry of the tensor <em>e.g.</em> c(1,1,3,4,1) means the
second mode and the fifth are identical to the first </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm termed <em>RPVSCC</em>  in Leibovici(1993) is implemented
to compute the first Principal Tensor (rank-one tensor with its
singular value) of the given tensor <code>X</code>. According to the
decomposition described in Leibovici(1993) and Leibovici and
Sabatier(1998), the function gives a generalisation  to <em>k</em>
modes of the <em>best rank-one approximation</em> issued from SVD whith
2 modes. It is identical to  the PCA-<em>k</em>modes if only 1
dimension is asked in each space, and to PARAFAC/CANDECOMP if the
rank of the approximation is fixed to 1. Then the methods differs,
PTA-<em>k</em>modes will look for best approximation according to the
<em>orthogonal rank</em> (<em>i.e.</em> the rank-one tensors (of the
decomposition) are orthogonal), PCA-<em>k</em>modes will look for best
approximation according to the <em>space ranks</em> (<em>i.e.</em>  ranks
of every bilinear form deducted from the original tensor, that is the
number of components in each space), PARAFAC/CANDECOMP will look for
best approximation according to the <em>rank</em> (<em>i.e.</em> the
rank-one tensors are not necessarily orthogonal).
<br>
Recent work from Tamara G Kolda showed on an example that <em>orthogonal rank</em>
decompositions are not necesseraly nested. This makes PTA-<em>k</em>modes a model with
nested decompositions not giving the exact <em>orthogonal rank</em>.
So PTA-<em>k</em>modes will look for best approximation according to orthogonal tensors in a nested approximmation process.
</p>


<h3>Value</h3>

<p>a <code>PTAk</code> object (without <code>datanam method</code>)</p>


<h3>Note</h3>

<p>The algorithm was derived in generalising the <em>transition
formulae</em> of SVD (Leibovici 1993), can also be understood as a
generalisation of the <em>power method</em> (De Lathauwer et al.
2000). In this paper they also use a similar algorithm  to build
bases in each space, reminiscent of three-modes and <em>n</em>-modes
PCA (Kroonenberg(1980)), <em>i.e.</em> defining what they called a
rank-(R1,R2,...,Rn) approximation (called here <em>space ranks</em>,
see <code>PCAn</code>). <em>RPVSCC</em> stands for  <em>R</em>echerche de la <em>P</em>remi&lt;e8&gt;re
<em>V</em>aleur <em>S</em>inguli&lt;e8&gt;re par <em>C</em>ontraction
<em>C</em>ompl&lt;ea&gt;te.
</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Kroonenberg P (1983) <em>Three-mode Principal Component Analysis:
Theory and Applications</em>. DSWO press. Leiden.
</p>
<p>Leibovici D(1993) <em>Facteurs &lt;e0&gt; Mesures R&lt;e9&gt;p&lt;e9&gt;t&lt;e9&gt;es et Analyses Factorielles :
applications &lt;e0&gt; un suivi &lt;e9&gt;pid&lt;e9&gt;miologique</em>. Universit&lt;e9&gt; de Montpellier
II. PhD Thesis in Math&lt;e9&gt;matiques et Applications (Biostatistiques).
</p>
<p>Leibovici D and Sabatier R (1998) <em>A Singular Value
Decomposition of a k-ways array for a Principal Component Analysis of
multi-way data, the PTA-k</em>. Linear Algebra and its Applications,
269:307-329.
</p>
<p>De Lathauwer L, De Moor B and Vandewalle J (2000) <em>On the best
rank-1 and rank-(R1,R2,...,Rn) approximation of higher-order
tensors</em>. SIAM J. Matrix Anal. Appl. 21,4:1324-1342.
</p>
<p>Kolda T.G (2003)<em> A Counterexample to the Possibility of an Extension of the Eckart-Young Low-Rank Approximation Theorem for the Orthogonal Rank Tensor Decomposition</em>. SIAM J. Matrix Analysis, 24(2):763-767, Jan. 2003.
</p>


<h3>See Also</h3>

<p><code>INITIA</code>, <code>PTAk</code>, <code>PCAn</code>,
<code>CANDPARA</code> </p>


</div>
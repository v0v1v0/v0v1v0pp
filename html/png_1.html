<div class="container">

<table style="width: 100%;"><tr>
<td>readPNG</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Read a bitmap image stored in the PNG format
</h2>

<h3>Description</h3>

<p>Reads an image from a PNG file/content into a raster array.
</p>


<h3>Usage</h3>

<pre><code class="language-R">readPNG(source, native = FALSE, info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>source</code></td>
<td>
<p>Either name of the file to read from or a raw vector
representing the PNG file content.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>native</code></td>
<td>
<p>determines the image representation - if <code>FALSE</code>
(the default) then the result is an array, if <code>TRUE</code> then the
result is a native raster representation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>logical, if <code>TRUE</code> additional <code>"info"</code> attribute
is attached to the result containing information from optional tags
in the file (such as bit depth, resolution, gamma, text etc.). If
the PNG file contains R metadata, it will also contain a
<code>"metadata"</code> attribute with the unserialized R object.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>native</code> is <code>FALSE</code> then an array of the dimensions height
x width x channels. If there is only one channel the result is a
matrix. The values are reals between 0 and 1. If <code>native</code> is
<code>TRUE</code> then an object of the class <code>nativeRaster</code> is
returned instead. The latter cannot be easily computed on but is the
most efficient way to draw using <code>rasterImage</code>.
</p>
<p>Most common files decompress into RGB (3 channels), RGBA (4 channels),
Grayscale (1 channel) or GA (2 channels). Note that G and GA images
cannot be directly used in <code>rasterImage</code> unless
<code>native</code> is set to <code>TRUE</code> because <code>rasterImage</code> requires
RGB or RGBA format (<code>nativeRaster</code> is always 8-bit RGBA).
</p>
<p>As of png 0.1-2 files with 16-bit channels are converted in full
resolution to the array format, but the <code>nativeRaster</code> format only
supports 8-bit and therefore a truncation is performed (eight least
significant bits are dropped) with a warning if <code>native</code> is
<code>TRUE</code>.
</p>


<h3>See Also</h3>

<p><code>rasterImage</code>, <code>writePNG</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># read a sample file (R logo)
img &lt;- readPNG(system.file("img", "Rlogo.png", package="png"))

# read it also in native format
img.n &lt;- readPNG(system.file("img", "Rlogo.png", package="png"), TRUE)

# if your R supports it, we'll plot it
if (exists("rasterImage")) { # can plot only in R 2.11.0 and higher
  plot(1:2, type='n')

  if (names(dev.cur()) == "windows") {
    # windows device doesn't support semi-transparency so we'll need
    # to flatten the image
    transparent &lt;- img[,,4] == 0
    img &lt;- as.raster(img[,,1:3])
    img[transparent] &lt;- NA

    # interpolate must be FALSE on Windows, otherwise R will
    # try to interpolate transparency and fail
    rasterImage(img, 1.2, 1.27, 1.8, 1.73, interpolate=FALSE)

  } else {
    # any reasonable device will be fine using alpha
    rasterImage(img, 1.2, 1.27, 1.8, 1.73)
    rasterImage(img.n, 1.5, 1.5, 1.9, 1.8)

  }
}
</code></pre>


</div>
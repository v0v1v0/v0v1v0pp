<div class="container">

<table style="width: 100%;"><tr>
<td>plot.mob</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Visualization of MOB Trees </h2>

<h3>Description</h3>

<p><code>plot</code> method for <code>mob</code> objects with
extended facilities for plugging in panel functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'mob'
plot(x, terminal_panel = node_bivplot, tnex = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>mob</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminal_panel</code></td>
<td>
<p>a panel function or panel-generating function of
class <code>"grapcon_generator"</code>. See <code>plot.BinaryTree</code> for
more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tnex</code></td>
<td>
<p>a numeric value giving the terminal node extension in relation
to the inner nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> further arguments passed to <code>plot.BinaryTree</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This <code>plot</code> method for <code>mob</code> objects simply calls the
<code>plot.BinaryTree</code> method, setting a different <code>terminal_panel</code>
function by default (<code>node_bivplot</code>) and <code>tnex</code> value.
</p>


<h3>See Also</h3>

<p><code>node_bivplot</code>, <code>node_scatterplot</code>,
<code>plot.BinaryTree</code>, <code>mob</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(290875)

if(require("mlbench")) {

## recursive partitioning of a linear regression model
## load data
data("BostonHousing", package = "mlbench")
## and transform variables appropriately (for a linear regression)
BostonHousing$lstat &lt;- log(BostonHousing$lstat)
BostonHousing$rm &lt;- BostonHousing$rm^2
## as well as partitioning variables (for fluctuation testing)
BostonHousing$chas &lt;- factor(BostonHousing$chas, levels = 0:1, 
                             labels = c("no", "yes"))
BostonHousing$rad &lt;- factor(BostonHousing$rad, ordered = TRUE)

## partition the linear regression model medv ~ lstat + rm
## with respect to all remaining variables:
fm &lt;- mob(medv ~ lstat + rm | zn + indus + chas + nox + age + dis + 
                              rad + tax + crim + b + ptratio,
  control = mob_control(minsplit = 40), data = BostonHousing, 
  model = linearModel)

## visualize medv ~ lstat and medv ~ rm
plot(fm)

## visualize only one of the two regressors
plot(fm, tp_args = list(which = "lstat"), tnex = 2)
plot(fm, tp_args = list(which = 2), tnex = 2)

## omit fitted mean lines
plot(fm, tp_args = list(fitmean = FALSE))

## mixed numerical and categorical regressors 
fm2 &lt;- mob(medv ~ lstat + rm + chas | zn + indus + nox + age + 
                                      dis + rad,
  control = mob_control(minsplit = 100), data = BostonHousing, 
  model = linearModel)
plot(fm2)

## recursive partitioning of a logistic regression model
data("PimaIndiansDiabetes", package = "mlbench")
fmPID &lt;- mob(diabetes ~ glucose | pregnant + pressure + triceps + 
                                  insulin + mass + pedigree + age,
  data = PimaIndiansDiabetes, model = glinearModel, 
  family = binomial())
## default plot: spinograms with breaks from five point summary
plot(fmPID)
## use the breaks from hist() instead
plot(fmPID, tp_args = list(fivenum = FALSE))
## user-defined breaks
plot(fmPID, tp_args = list(breaks = 0:4 * 50))
## CD plots instead of spinograms
plot(fmPID, tp_args = list(cdplot = TRUE))
## different smoothing bandwidth
plot(fmPID, tp_args = list(cdplot = TRUE, bw = 15))

}
</code></pre>


</div>
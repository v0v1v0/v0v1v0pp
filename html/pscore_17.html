<div class="container">

<table style="width: 100%;"><tr>
<td>sumComposite</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Score Data Using a simple sum</h2>

<h3>Description</h3>

<p>Create a composite using summation
</p>


<h3>Usage</h3>

<pre><code class="language-R">sumComposite(
  object,
  transform = c("square", "abs", "none"),
  type = c("sum", "mean"),
  systems
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>CompositeReady</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transform</code></td>
<td>
<p>A character string indicating the type of transformation to use.
One of “square”, “abs”, or “none”, which either sums the raw data,
sums the squared data and then takes the square root, or sums the absolute values of the
data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A character string indicating the type of aggregation to use.
One of “sum” or “mean”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>systems</code></td>
<td>
<p>An optional list where each element is a character vector of the
variable names within a particular system.  If given, scores are first averaged
within a system, before being aggregated across systems.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An S4 object of class <code>SumScores</code>.
</p>


<h3>See Also</h3>

<p>Other composite: 
<code>factorComposite()</code>,
<code>mahalanobisComposite()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># this example creates distances for the built in mtcars data
# see ?mtcars for more details
# The distances are calculated from the "best" in the dataset
# First we create an appropriate CompositeData class object
# higher mpg &amp; hp are better and lower wt &amp; qsec are better
d &lt;- CompositeData(mtcars[, c("mpg", "hp", "wt", "qsec")],
  thresholds = list(one = with(mtcars, c(
    mpg = max(mpg),
    hp = max(hp),
    wt = min(wt),
    qsec = min(qsec)))
  ),
  higherisbetter = c(TRUE, TRUE, FALSE, FALSE))

# create the distance scores
# and the composite
# covariance matrix will be calculated from the data
# and data will be standardized to unit variance by default
dres &lt;- prepareComposite(d)

# see a density plot of the distance scores
dres@distanceDensity
# regular summary of distance scores
summary(dres@distances)

# examine covariance matrix
round(dres@covmat,2)

# now we can create the composite based on summing the (standardized)
# distances from our defined thresholds
# by default, distances are squared, then summed, and then square rooted
# to be back on the original scale
scomp &lt;- sumComposite(dres, "square", "sum")

# view a histogram and summary of the composite scores
scomp@scoreHistogram
summary(scomp@scores)

# calculate average (mean) instead of sum
scomp2 &lt;- sumComposite(dres, "square", "mean")

# view a histogram and summary of the composite scores
scomp2@scoreHistogram
summary(scomp2@scores)

# scores are still the same (just different scaling)
plot(scomp@scores, scomp2@scores)

# first average scores within a system, then sum
# within a system, scores are always averaged, never summed
scomp3 &lt;- sumComposite(dres, "square", "sum",
  systems = list(
    environment = c("mpg"),
    performance = c("hp", "qsec", "wt")))

# view a histogram and summary of the composite scores
scomp3@scoreHistogram
summary(scomp3@scores)

# compare all three scores
# because of the different number of indicators within each system
# there is a re-weighting for S3
plot(data.frame(S1 = scomp@scores, S2 = scomp2@scores, S3 = scomp3@scores))

# cleanup
rm(d, dres, scomp, scomp2, scomp3)
</code></pre>


</div>
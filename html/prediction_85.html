<div class="container">

<table style="width: 100%;"><tr>
<td>prediction-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract Predictions from a Model Object</h2>

<h3>Description</h3>

<p>Extract predicted values via <code>predict</code> from a model object, conditional on data, and return a data frame.
</p>


<h3>Usage</h3>

<pre><code class="language-R">prediction(model, ...)

## Default S3 method:
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = "response",
  vcov = stats::vcov(model),
  calculate_se = TRUE,
  ...
)

## S3 method for class 'Arima'
prediction(model, calculate_se = TRUE, ...)

## S3 method for class 'ar'
prediction(model, data, at = NULL, calculate_se = TRUE, ...)

## S3 method for class 'arima0'
prediction(model, data, at = NULL, calculate_se = TRUE, ...)

## S3 method for class 'betareg'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "link", "precision", "variance", "quantile"),
  calculate_se = FALSE,
  ...
)

## S3 method for class 'bigLm'
prediction(model, data = NULL, calculate_se = FALSE, ...)

## S3 method for class 'bigglm'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = "response",
  calculate_se = TRUE,
  ...
)

## S3 method for class 'biglm'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = "response",
  calculate_se = TRUE,
  ...
)

## S3 method for class 'bruto'
prediction(
  model,
  data = NULL,
  at = NULL,
  type = "fitted",
  calculate_se = FALSE,
  ...
)

## S3 method for class 'clm'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = NULL,
  calculate_se = TRUE,
  category,
  ...
)

## S3 method for class 'coxph'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("risk", "expected", "lp"),
  calculate_se = TRUE,
  ...
)

## S3 method for class 'crch'
prediction(
  model,
  data = find_data(model),
  at = NULL,
  type = c("response", "location", "scale", "quantile"),
  calculate_se = FALSE,
  ...
)

## S3 method for class 'earth'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "link"),
  calculate_se = TRUE,
  category,
  ...
)

## S3 method for class 'fda'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = NULL,
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'Gam'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "link", "terms"),
  calculate_se = TRUE,
  ...
)

## S3 method for class 'gausspr'
prediction(
  model,
  data,
  at = NULL,
  type = NULL,
  calculate_se = TRUE,
  category,
  ...
)

## S3 method for class 'gee'
prediction(model, calculate_se = FALSE, ...)

## S3 method for class 'glimML'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "link"),
  calculate_se = TRUE,
  ...
)

## S3 method for class 'glimQL'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "link"),
  calculate_se = TRUE,
  ...
)

## S3 method for class 'glm'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "link"),
  vcov = stats::vcov(model),
  calculate_se = TRUE,
  ...
)

## S3 method for class 'glmnet'
prediction(
  model,
  data,
  lambda = model[["lambda"]][1L],
  at = NULL,
  type = c("response", "link"),
  calculate_se = FALSE,
  ...
)

## S3 method for class 'glmx'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "link"),
  calculate_se = FALSE,
  ...
)

## S3 method for class 'gls'
prediction(
  model,
  data = find_data(model),
  at = NULL,
  calculate_se = FALSE,
  ...
)

## S3 method for class 'hetglm'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "link", "scale"),
  calculate_se = FALSE,
  ...
)

## S3 method for class 'hurdle'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "count", "prob", "zero"),
  calculate_se = FALSE,
  ...
)

## S3 method for class 'hxlr'
prediction(
  model,
  data = find_data(model),
  at = NULL,
  type = c("class", "probability", "cumprob", "location", "scale"),
  calculate_se = FALSE,
  ...
)

## S3 method for class 'ivreg'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  calculate_se = FALSE,
  ...
)

## S3 method for class 'knnreg'
prediction(model, data, at = NULL, calculate_se = FALSE, ...)

## S3 method for class 'kqr'
prediction(model, data, at = NULL, calculate_se = FALSE, ...)

## S3 method for class 'ksvm'
prediction(
  model,
  data,
  at = NULL,
  type = NULL,
  calculate_se = TRUE,
  category,
  ...
)

## S3 method for class 'lda'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'lm'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = "response",
  vcov = stats::vcov(model),
  calculate_se = TRUE,
  ...
)

## S3 method for class 'lme'
prediction(
  model,
  data = find_data(model),
  at = NULL,
  calculate_se = FALSE,
  ...
)

## S3 method for class 'loess'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = "response",
  calculate_se = TRUE,
  ...
)

## S3 method for class 'lqs'
prediction(
  model,
  data = find_data(model),
  at = NULL,
  calculate_se = FALSE,
  ...
)

## S3 method for class 'mars'
prediction(
  model,
  data = NULL,
  at = NULL,
  type = "fitted",
  calculate_se = FALSE,
  ...
)

## S3 method for class 'mca'
prediction(
  model,
  data = find_data(model),
  at = NULL,
  calculate_se = FALSE,
  ...
)

## S3 method for class 'mclogit'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = "response",
  vcov = stats::vcov(model),
  calculate_se = TRUE,
  ...
)

## S3 method for class 'merMod'
prediction(
  model,
  data = find_data(model),
  at = NULL,
  type = c("response", "link"),
  re.form = NULL,
  calculate_se = FALSE,
  ...
)

## S3 method for class 'mlogit'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'mnlogit'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'mnp'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = NULL,
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'multinom'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = NULL,
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'naiveBayes'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = NULL,
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'nls'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  calculate_se = FALSE,
  ...
)

## S3 method for class 'nnet'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = NULL,
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'plm'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  calculate_se = FALSE,
  ...
)

## S3 method for class 'polr'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = NULL,
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'polyreg'
prediction(
  model,
  data = NULL,
  at = NULL,
  type = "fitted",
  calculate_se = FALSE,
  ...
)

## S3 method for class 'ppr'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  calculate_se = FALSE,
  ...
)

## S3 method for class 'princomp'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  calculate_se = FALSE,
  ...
)

## S3 method for class 'qda'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'rlm'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = "response",
  vcov = stats::vcov(model),
  calculate_se = TRUE,
  ...
)

## S3 method for class 'rpart'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = NULL,
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'rq'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  calculate_se = TRUE,
  ...
)

## S3 method for class 'selection'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = "response",
  calculate_se = FALSE,
  ...
)

## S3 method for class 'speedglm'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "link"),
  calculate_se = FALSE,
  ...
)

## S3 method for class 'speedlm'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  calculate_se = FALSE,
  ...
)

## S3 method for class 'survreg'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "lp", "quantile", "uquantile"),
  calculate_se = TRUE,
  ...
)

## S3 method for class 'svm'
prediction(model, data = NULL, at = NULL, calculate_se = TRUE, category, ...)

## S3 method for class 'svyglm'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "link"),
  calculate_se = TRUE,
  ...
)

## S3 method for class 'train'
prediction(
  model,
  data = find_data(model),
  at = NULL,
  type = c("raw", "prob"),
  ...
)

## S3 method for class 'tree'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = NULL,
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'truncreg'
prediction(model, data, at = NULL, calculate_se = FALSE, ...)

## S3 method for class 'vgam'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "link"),
  calculate_se = FALSE,
  category,
  ...
)

## S3 method for class 'vglm'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "link"),
  calculate_se = TRUE,
  category,
  ...
)

## S3 method for class 'zeroinfl'
prediction(
  model,
  data = find_data(model, parent.frame()),
  at = NULL,
  type = c("response", "count", "prob", "zero"),
  calculate_se = FALSE,
  ...
)

prediction_summary(model, ..., level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A model object, perhaps returned by <code>lm</code> or <code>glm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to <code>predict</code> methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame over which to calculate marginal effects. If missing, <code>find_data</code> is used to specify the data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>
<p>A list of one or more named vectors, specifically values at which to calculate the predictions. These are used to modify the value of <code>data</code> (see <code>build_datalist</code> for details on use).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A character string indicating the type of marginal effects to estimate. Mostly relevant for non-linear models, where the reasonable options are “response” (the default) or “link” (i.e., on the scale of the linear predictor in a GLM). For models of class “polr” (from <code>polr</code>), possible values are “class” or “probs”; both are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>A matrix containing the variance-covariance matrix for estimated model coefficients, or a function to perform the estimation with <code>model</code> as its only argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calculate_se</code></td>
<td>
<p>A logical indicating whether to calculate standard errors for observation-specific predictions and average predictions (if possible). The output will always contain a “calculate_se” column regardless of this value; this only controls the calculation of standard errors. Setting it to <code>FALSE</code> may improve speed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>category</code></td>
<td>
<p>For multi-level or multi-category outcome models (e.g., ordered probit, multinomial logit, etc.), a value specifying which of the outcome levels should be used for the <code>"fitted"</code> column. If missing, some default is chosen automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>For models of class “glmnet”, a value of the penalty parameter at which predictions are required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re.form</code></td>
<td>
<p>An argument passed forward to <code>predict.merMod</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>A numeric value specifying the confidence level for calculating p-values and confidence intervals.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is simply a wrapper around <code>predict</code> that returns a data frame containing the value of <code>data</code> and the predicted values with respect to all variables specified in <code>data</code>.
</p>
<p>Methods are currently implemented for the following object classes:
</p>

<ul>
<li> <p>“lm”, see <code>lm</code>
</p>
</li>
<li> <p>“glm”, see <code>glm</code>, <code>glm.nb</code>, <code>glmx</code>, <code>hetglm</code>, <code>brglm</code>
</p>
</li>
<li> <p>“ar”, see <code>ar</code>
</p>
</li>
<li> <p>“Arima”, see <code>arima</code>
</p>
</li>
<li> <p>“arima0”, see <code>arima0</code>
</p>
</li>
<li> <p>“bigglm”, see <code>bigglm</code>
</p>
</li>
<li> <p>“betareg”, see <code>betareg</code>
</p>
</li>
<li> <p>“bruto”, see <code>bruto</code>
</p>
</li>
<li> <p>“clm”, see <code>clm</code>
</p>
</li>
<li> <p>“coxph”, see <code>coxph</code>
</p>
</li>
<li> <p>“crch”, see <code>crch</code>
</p>
</li>
<li> <p>“earth”, see <code>earth</code>
</p>
</li>
<li> <p>“fda”, see <code>fda</code>
</p>
</li>
<li> <p>“Gam”, see <code>gam</code>
</p>
</li>
<li> <p>“gausspr”, see <code>gausspr</code>
</p>
</li>
<li> <p>“gee”, see <code>gee</code>
</p>
</li>
<li> <p>“glmnet”, see <code>glmnet</code>
</p>
</li>
<li> <p>“gls”, see <code>gls</code>
</p>
</li>
<li> <p>“glimML”, see <code>betabin</code>, <code>negbin</code>
</p>
</li>
<li> <p>“glimQL”, see <code>quasibin</code>, <code>quasipois</code>
</p>
</li>
<li> <p>“hurdle”, see <code>hurdle</code>
</p>
</li>
<li> <p>“hxlr”, see <code>hxlr</code>
</p>
</li>
<li> <p>“ivreg”, see <code>ivreg</code>
</p>
</li>
<li> <p>“knnreg”, see <code>knnreg</code>
</p>
</li>
<li> <p>“kqr”, see <code>kqr</code>
</p>
</li>
<li> <p>“ksvm”, see <code>ksvm</code>
</p>
</li>
<li> <p>“lda”, see <code>lda</code>
</p>
</li>
<li> <p>“lme”, see <code>lme</code>
</p>
</li>
<li> <p>“loess”, see <code>loess</code>
</p>
</li>
<li> <p>“lqs”, see <code>lqs</code>
</p>
</li>
<li> <p>“mars”, see <code>mars</code>
</p>
</li>
<li> <p>“mca”, see <code>mca</code>
</p>
</li>
<li> <p>“mclogit”, see <code>mclogit</code>
</p>
</li>
<li> <p>“mda”, see <code>mda</code>
</p>
</li>
<li> <p>“merMod”, see <code>lmer</code>, <code>glmer</code>
</p>
</li>
<li> <p>“mnp”, see <code>mnp</code>
</p>
</li>
<li> <p>“naiveBayes”, see <code>naiveBayes</code>
</p>
</li>
<li> <p>“nlme”, see <code>nlme</code>
</p>
</li>
<li> <p>“nls”, see <code>nls</code>
</p>
</li>
<li> <p>“nnet”, see <code>nnet</code>
</p>
</li>
<li> <p>“plm”, see <code>plm</code>
</p>
</li>
<li> <p>“polr”, see <code>polr</code>
</p>
</li>
<li> <p>“polyreg”, see <code>polyreg</code>
</p>
</li>
<li> <p>“ppr”, see <code>ppr</code>
</p>
</li>
<li> <p>“princomp”, see <code>princomp</code>
</p>
</li>
<li> <p>“qda”, see <code>qda</code>
</p>
</li>
<li> <p>“rlm”, see <code>rlm</code>
</p>
</li>
<li> <p>“rpart”, see <code>rpart</code>
</p>
</li>
<li> <p>“rq”, see <code>rq</code>
</p>
</li>
<li> <p>“selection”, see <code>selection</code>
</p>
</li>
<li> <p>“speedglm”, see <code>speedglm</code>
</p>
</li>
<li> <p>“speedlm”, see <code>speedlm</code>
</p>
</li>
<li> <p>“survreg”, see <code>survreg</code>
</p>
</li>
<li> <p>“svm”, see <code>svm</code>
</p>
</li>
<li> <p>“svyglm”, see <code>svyglm</code>
</p>
</li>
<li> <p>“tobit”, see <code>tobit</code>
</p>
</li>
<li> <p>“train”, see <code>train</code>
</p>
</li>
<li> <p>“truncreg”, see <code>truncreg</code>
</p>
</li>
<li> <p>“zeroinfl”, see <code>zeroinfl</code>
</p>
</li>
</ul>
<p>Where implemented, <code>prediction</code> also returns average predictions (and the variances thereof). Variances are implemented using the delta method, as described by Xu and Long 2005 <a href="https://doi.org/10.1177/1536867X0500500405">doi:10.1177/1536867X0500500405</a>.
</p>


<h3>Value</h3>

<p>A data frame with class “prediction” that has a number of rows equal to number of rows in <code>data</code>, or a multiple thereof, if <code>!is.null(at)</code>. The return value contains <code>data</code> (possibly modified by <code>at</code> using <code>build_datalist</code>), plus a column containing fitted/predicted values (<code>"fitted"</code>) and a column containing the standard errors thereof (<code>"calculate_se"</code>). Additional columns may be reported depending on the object class. The data frame also carries attributes used by <code>print</code> and <code>summary</code>, which will be lost during subsetting.
</p>


<h3>See Also</h3>

<p><code>find_data</code>, <code>build_datalist</code>, <code>mean_or_mode</code>, <code>seq_range</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require("datasets")
x &lt;- lm(Petal.Width ~ Sepal.Length * Sepal.Width * Species, data = iris)
# prediction for every case
prediction(x)

# prediction for first case
prediction(x, iris[1,])

# basic use of 'at' argument
summary(prediction(x, at = list(Species = c("setosa", "virginica"))))

# basic use of 'at' argument
prediction(x, at = list(Sepal.Length = seq_range(iris$Sepal.Length, 5)))

# prediction at means/modes of input variables
prediction(x, at = lapply(iris, mean_or_mode))

# prediction with multi-category outcome
## Not run: 
  library("mlogit")
  data("Fishing", package = "mlogit")
  Fish &lt;- mlogit.data(Fishing, varying = c(2:9), shape = "wide", choice = "mode")
  mod &lt;- mlogit(mode ~ price + catch, data = Fish)
  prediction(mod)
  prediction(mod, category = 3)

## End(Not run)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>probe_one</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting PaRtitiOned empirical Bayes Ecm (PROBE) algorithm to sparse high-dimensional linear models.</h2>

<h3>Description</h3>

<p>A wrapper function for the one-at-a-time variant of the PROBE algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">probe_one(Y, X, ep = 0.001, maxit = 10000, Y_test = NULL, X_test = NULL, 
verbose = FALSE, signal = NULL, eta_i = NULL, alpha = 0.05, plot_ind = FALSE, 
order.method = "lasso", adj = 10, delta = 0.4, update_order= NULL, beta_start= NULL,
seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>The outcome variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>An <code>n x M</code> matrix of sparse predictors variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ep</code></td>
<td>
<p>Value against which to compare convergence criterion (default = 0.001).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of iterations the algorithm will run for (default = 10000).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y_test</code></td>
<td>
<p>(optional) Test Y data used plotting purposes only (doesn't impact results).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X_test</code></td>
<td>
<p>(optional) Test X data used plotting purposes only (doesn't impact results).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical (true/false) value whether to print algorithm iteration progress and summary quantities (default = FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signal</code></td>
<td>
<p>(optional) A vector of indicies of the true non-null coefficients. This is used to calculate the true and false discovery rates by iteration for simulated data. Used plotting purposes only (doesn't impact results).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta_i</code></td>
<td>
<p>(optional) A vector of the true signal. This is used to calculate the MSE by iteration for simulated data. Used plotting purposes only (doesn't impact results).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>(optional) significance level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_ind</code></td>
<td>
<p>A logical values (True/False) for whether to output plots on algorithm results and progress (default = FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order.method</code></td>
<td>
<p>Updating order and initial values of the algorithm. For <code>lasso</code> (default) or <code>ridge</code>, a lasso or a ridge regression model (fit with 10-fold CV) will be fitted and used. The <code>update_order</code> is defined by the absolute values of the coefficient and <code>beta_start</code> is the coefficient values. When using <code>none</code>, <code>update_order</code> and <code>beta_start</code> must be given. <code>random</code> will randomly select the updating order and use very small values for <code>beta_start</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj</code></td>
<td>
<p>Bandwidth parameter for empirical Bayes E-step. The bandwidth will be equal to <code>adj</code> times Silverman's 'rule of thumb' (default = 10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Learning rate for iteration t is (1 + t)^(-1 + delta) (default delta = 0.4).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update_order</code></td>
<td>
<p>Manual value for the updating order for when <code>order.method = "none"</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_start</code></td>
<td>
<p>Manual value for the starting beta coefficients for when <code>order.method = "none"</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Seed value to ensure reproducibility when <code>order.method = "lasso"</code>, <code>order.method = "ridge"</code>, or <code>order.method = "random"</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list including 
</p>
<p><code>beta_ast_hat</code> MAP estimates of the regression coefficients (<code class="reqn">\beta^\ast</code>),
</p>
<p><code>beta_hat, beta_hat_var</code> MAP estimates of the posterior expectation (beta_hat) and variance (beta_hat_var) of the prior mean (<code class="reqn">\beta</code>) of the regression coefficients assuming <code class="reqn">\gamma=1</code>, 
</p>
<p><code>gamma_hat</code> the posterior expectation of the latent <code class="reqn">\gamma</code> variables, 
</p>
<p><code>sigma2_est</code> MAP estimate of the residual variance, 
</p>
<p><code>E_step</code> full results of the final E_step, 
</p>
<p><code>count</code> the total number of iterations before convergence.
</p>


<h3>References</h3>

<p>McLain, A. C., Zgodic, A., &amp; Bondell, H. (2022). Sparse high-dimensional linear regression with a partitioned empirical Bayes ECM algorithm. arXiv preprint arXiv:2209.08139..
</p>


<h3>See Also</h3>

<p>predict_probe_func to obtain predictions.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Example
data(Sim_data)
data(Sim_data_test)
attach(Sim_data)
attach(Sim_data_test)
plot_ind &lt;- TRUE
adj &lt;- 10

# Run the analysis. Y_test and X_test are included for plotting purposes only
full_res &lt;- probe_one( Y = Y, X = X, Y_test = Y_test, order.method = "random",
X_test = X_test, plot_ind = plot_ind, adj = adj)

# Predicting for test data
pred_res &lt;- predict_probe_func(full_res, X = X_test)
sqrt(mean((Y_test - pred_res$Pred)^2))

# Estimate of the residual variance and true value
full_res$sigma2_est
sigma2_tr

# RMSE of estimated beta coefficients
beta_ast_est &lt;- c(full_res$beta_ast_hat)
sqrt(mean((beta_ast_est - beta_tr)^2))

# Posterior expectation of gamma by true
gamma_est &lt;- full_res$E_step$gamma
table(gamma_est &gt; 0.5, beta_tr &gt; 0)
sum(gamma_est)
sum(gamma_est[beta_tr&gt;0])


</code></pre>


</div>
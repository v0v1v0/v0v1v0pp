<div class="container">

<table style="width: 100%;"><tr>
<td>findpeaks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Find Peaks
</h2>

<h3>Description</h3>

<p>Find peaks (maxima) in a time series.
</p>


<h3>Usage</h3>

<pre><code class="language-R">findpeaks(x, nups = 1, ndowns = nups, zero = "0", peakpat = NULL,
          minpeakheight = -Inf, minpeakdistance = 1,
          threshold = 0, npeaks = 0, sortstr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numerical vector taken as a time series (no NAs allowed)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nups</code></td>
<td>
<p>minimum number of increasing steps before a peak is reached</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndowns</code></td>
<td>
<p>minimum number of decreasing steps after the peak</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero</code></td>
<td>
<p>can be ‘+’, ‘-’, or ‘0’; how to interprete succeeding steps
of the same value: increasing, decreasing, or special</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>peakpat</code></td>
<td>
<p>define a peak as a regular pattern, such as the default
pattern <code>[+]{1,}[-]{1,}</code>; if a pattern is provided, parameters
<code>nups</code> and <code>ndowns</code> are not taken into account</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minpeakheight</code></td>
<td>
<p>the minimum (absolute) height a peak has to have
to be recognized as such</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minpeakdistance</code></td>
<td>
<p>the minimum distance (in indices) peaks have to have
to be counted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>the minimum </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npeaks</code></td>
<td>
<p>the number of peaks to return</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortstr</code></td>
<td>
<p>logical; should the peaks be returned sorted in decreasing
oreder of their maximum value</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is quite general as it relies on regular patterns to determine
where a peak is located, from beginning to end.
</p>


<h3>Value</h3>

<p>Returns a matrix where each row represents one peak found. The first column
gives the height, the second the position/index where the maximum is reached,
the third and forth the indices of where the peak begins and ends — in the
sense of where the pattern starts and ends.
</p>


<h3>Note</h3>

<p>On Matlab Central there are several realizations for finding peaks, for
example “peakfinder”, “peakseek”, or “peakdetect”. And “findpeaks”
is also the name of a function in the Matlab ‘signal’ toolbox.
</p>
<p>The parameter names are taken from the “findpeaks” function in ‘signal’,
but the implementation utilizing regular expressions is unique and fast.
</p>


<h3>See Also</h3>

<p><code>hampel</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- seq(0, 1, len = 1024)
pos &lt;- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt &lt;- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wdt &lt;- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)

pSignal &lt;- numeric(length(x))
for (i in seq(along=pos)) {
	pSignal &lt;- pSignal + hgt[i]/(1 + abs((x - pos[i])/wdt[i]))^4
}
findpeaks(pSignal, npeaks=3, threshold=4, sortstr=TRUE)

## Not run: 
plot(pSignal, type="l", col="navy")
grid()
x &lt;- findpeaks(pSignal, npeaks=3, threshold=4, sortstr=TRUE)
points(x[, 2], x[, 1], pch=20, col="maroon")
## End(Not run)
</code></pre>


</div>
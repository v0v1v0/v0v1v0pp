<div class="container">

<table style="width: 100%;"><tr>
<td>summ_pval</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Summarize distribution with p-value</h2>

<h3>Description</h3>

<p><code>summ_pval()</code> computes p-value(s) based on supplied distribution and observed
value(s). There are several methods of computing p-values ("both", "right",
and "left") as well as several types of multiple comparison adjustments
(using on <code>stats::p.adjust()</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">summ_pval(f, obs, method = "both", adjust = "holm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A pdqr-function representing distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs</code></td>
<td>
<p>Numeric vector of observed values to be used as threshold for
p-value. Can have multiple values, in which case output will be adjusted
for multiple comparisons with p.adjust().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method representing direction of p-value computation. Should be
one of "both", "right", "left".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust</code></td>
<td>
<p>Adjustment method as <code>method</code> argument to <code>p.adjust()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Method "both" for each element in <code>obs</code> computes two-sided p-value
as <code>min(1, 2 * min(right_p_val, left_p_val))</code>, where <code>right_p_val</code> and
<code>left_p_val</code> are right and left one-sided p-values (ones which are computed
with "right" and "left" methods) of <code>obs</code>'s elements correspondingly.
</p>
<p>Method "right" for each element <code>x</code> of <code>obs</code> computes probability of <code>f &gt;= x</code>
being true (more strictly, of random variable, represented by <code>f</code>, being not
less than <code>x</code>). This corresponds to right one-sided p-value.
</p>
<p>Method "left" for each element <code>x</code> of <code>obs</code> computes probability of <code>f &lt;= x</code>,
which is a left one-sided p-value.
</p>
<p><strong>Note</strong> that by default multiple p-values in output are adjusted with
<code style="white-space: pre;">⁠p.adjust(*, method = adjust)⁠</code>. To not do any adjustment, use <code>adjust = "none"</code>.
</p>


<h3>Value</h3>

<p>A numeric vector with the same length as <code>obs</code> representing
corresponding p-values after possible adjustment for multiple comparisons.
</p>


<h3>See Also</h3>

<p>Other summary functions: 
<code>summ_center()</code>,
<code>summ_classmetric()</code>,
<code>summ_distance()</code>,
<code>summ_entropy()</code>,
<code>summ_hdr()</code>,
<code>summ_interval()</code>,
<code>summ_moment()</code>,
<code>summ_order()</code>,
<code>summ_prob_true()</code>,
<code>summ_quantile()</code>,
<code>summ_roc()</code>,
<code>summ_separation()</code>,
<code>summ_spread()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Type "discrete"
d_dis &lt;- new_d(data.frame(x = 1:5, prob = c(1, 2, 3, 2, 1) / 9), "discrete")
summ_pval(d_dis, 3, method = "both")
summ_pval(d_dis, 3, method = "right")
summ_pval(d_dis, 3, method = "left")

# Type "continuous"
d_norm &lt;- as_d(dnorm)
summ_pval(d_norm, 2, method = "both")
summ_pval(d_norm, 2, method = "right")
summ_pval(d_norm, 2, method = "left")

# Adjustment is made for multiple observed values
summ_pval(d_norm, seq(0, 2, by = 0.1))
## Use `adjust = "none"` for to not do any adjustment
summ_pval(d_norm, seq(0, 2, by = 0.1), adjust = "none")
</code></pre>


</div>
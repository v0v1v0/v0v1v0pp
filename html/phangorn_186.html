<div class="container">

<table style="width: 100%;"><tr>
<td>acctran</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parsimony tree.</h2>

<h3>Description</h3>

<p><code>pratchet</code> implements the parsimony ratchet (Nixon, 1999) and is the
preferred way to search for the best parsimony tree. For small number of taxa
the function <code>bab</code> can be used to compute all most parsimonious
trees.
</p>


<h3>Usage</h3>

<pre><code class="language-R">acctran(tree, data)

fitch(tree, data, site = "pscore")

random.addition(data, tree = NULL, method = "fitch")

parsimony(tree, data, method = "fitch", cost = NULL, site = "pscore")

optim.parsimony(tree, data, method = "fitch", cost = NULL, trace = 1,
  rearrangements = "SPR", ...)

pratchet(data, start = NULL, method = "fitch", maxit = 1000,
  minit = 100, k = 10, trace = 1, all = FALSE,
  rearrangements = "SPR", perturbation = "ratchet", ...)

sankoff(tree, data, cost = NULL, site = "pscore")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>
<p>tree to start the nni search from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A object of class phyDat containing sequences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>site</code></td>
<td>
<p>return either 'pscore' or 'site' wise parsimony scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>one of 'fitch' or 'sankoff'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>
<p>A cost matrix for the transitions between two states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>defines how much information is printed during optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rearrangements</code></td>
<td>
<p>SPR or NNI rearrangements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods (e.g.
model="sankoff" and cost matrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>a starting tree can be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximum number of iterations in the ratchet.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minit</code></td>
<td>
<p>minimum number of iterations in the ratchet.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of rounds ratchet is stopped, when there is no improvement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all</code></td>
<td>
<p>return all equally good trees or just one of them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perturbation</code></td>
<td>
<p>whether to use "ratchet", "random_addition" or
"stochastic" (nni) for shuffling the tree.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>parsimony</code> returns the parsimony score of a tree using either the
sankoff or the fitch algorithm.
<code>optim.parsimony</code> optimizes the topology using either Nearest Neighbor
Interchange (NNI) rearrangements or sub tree pruning and regrafting (SPR) and
is used inside <code>pratchet</code>. <code>random.addition</code> can be used to produce
starting trees and is an option for the argument perturbation in
<code>pratchet</code>.
</p>
<p>The "SPR" rearrangements are so far only available for the "fitch" method,
"sankoff" only uses "NNI". The "fitch" algorithm only works correct for
binary trees.
</p>


<h3>Value</h3>

<p><code>parsimony</code> returns the maximum parsimony score (pscore).
<code>optim.parsimony</code> returns a tree after NNI rearrangements.
<code>pratchet</code> returns a tree or list of trees containing the best tree(s)
found during the search.  <code>acctran</code> returns a tree with edge length
according to the ACCTRAN criterion.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Felsenstein, J. (2004). <em>Inferring Phylogenies</em>. Sinauer
Associates, Sunderland.
</p>
<p>Nixon, K. (1999) The Parsimony Ratchet, a New Method for Rapid Parsimony
Analysis. <em>Cladistics</em> <b>15</b>, 407-414
</p>


<h3>See Also</h3>

<p><code>bab</code>, <code>CI</code>, <code>RI</code>,
<code>ancestral.pml</code>, <code>nni</code>, <code>NJ</code>,
<code>pml</code>, <code>getClans</code>, <code>ancestral.pars</code>,
<code>bootstrap.pml</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(3)
data(Laurasiatherian)
dm &lt;- dist.hamming(Laurasiatherian)
tree &lt;- NJ(dm)
parsimony(tree, Laurasiatherian)
treeRA &lt;- random.addition(Laurasiatherian)
treeSPR &lt;- optim.parsimony(tree, Laurasiatherian)

# lower number of iterations for the example (to run less than 5 seconds),
# keep default values (maxit, minit, k) or increase them for real life
# analyses.
treeRatchet &lt;- pratchet(Laurasiatherian, start=tree, maxit=100,
                        minit=5, k=5, trace=0)
# assign edge length (number of substitutions)
treeRatchet &lt;- acctran(treeRatchet, Laurasiatherian)
# remove edges of length 0
treeRatchet &lt;- di2multi(treeRatchet)

plot(midpoint(treeRatchet))
add.scale.bar(0,0, length=100)

parsimony(c(tree,treeSPR, treeRatchet), Laurasiatherian)

</code></pre>


</div>
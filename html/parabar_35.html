<div class="container">

<table style="width: 100%;"><tr>
<td>UserApiConsumer</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>UserApiConsumer</h2>

<h3>Description</h3>

<p>This class is an opinionated interface around the developer API of the
<code>parabar</code> package. See the <strong>Details</strong> section for more
information on how this class works.
</p>


<h3>Details</h3>

<p>This class acts as a wrapper around the <code>R6::R6</code> developer API of the
<code>parabar</code> package. In a nutshell, it provides an opinionated
interface by wrapping the developer API in simple functional calls. More
specifically, for executing a task in parallel, this class performs the
following steps:
</p>

<ul>
<li>
<p> Validates the backend provided.
</p>
</li>
<li>
<p> Instantiates an appropriate <code>parabar</code> context based on the
backend. If the backend supports progress tracking (i.e., the backend is an
instance of <code>AsyncBackend</code>), a progress tracking context (i.e.,
<code>ProgressTrackingContext</code>) is instantiated and used. Otherwise,
a regular context (i.e., <code>Context</code>) is instantiated. A regular
context is also used if the progress tracking is disabled via the
<code>Options</code> instance.
</p>
</li>
<li>
<p> Registers the <code>backend</code> with the context.
</p>
</li>
<li>
<p> Instantiates and configures the progress bar based on the
<code>Options</code> instance in the session <code>base::.Options</code> list.
</p>
</li>
<li>
<p> Executes the task in parallel, and displays a progress bar if appropriate.
</p>
</li>
<li>
<p> Fetches the results from the backend and returns them.
</p>
</li>
</ul>
<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-UserApiConsumer-sapply"><code>UserApiConsumer$sapply()</code></a>
</p>
</li>
<li> <p><a href="#method-UserApiConsumer-lapply"><code>UserApiConsumer$lapply()</code></a>
</p>
</li>
<li> <p><a href="#method-UserApiConsumer-apply"><code>UserApiConsumer$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-UserApiConsumer-clone"><code>UserApiConsumer$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-UserApiConsumer-sapply"></a>



<h4>Method <code>sapply()</code>
</h4>

<p>Execute a task in parallel akin to <code>parallel::parSapply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>UserApiConsumer$sapply(backend, x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>backend</code></dt>
<dd>
<p>An object of class <code>Backend</code> as returned by
the <code>start_backend()</code> function. It can also be <code>NULL</code> to run
the task sequentially via <code>base::sapply()</code>.</p>
</dd>
<dt><code>x</code></dt>
<dd>
<p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A vector of the same length as <code>x</code> containing the results of the
<code>fun</code>. The output format resembles that of <code>base::sapply()</code>.
</p>


<hr>
<a id="method-UserApiConsumer-lapply"></a>



<h4>Method <code>lapply()</code>
</h4>

<p>Execute a task in parallel akin to <code>parallel::parLapply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>UserApiConsumer$lapply(backend, x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>backend</code></dt>
<dd>
<p>An object of class <code>Backend</code> as returned by
the <code>start_backend()</code> function. It can also be <code>NULL</code> to run
the task sequentially via <code>base::lapply()</code>.</p>
</dd>
<dt><code>x</code></dt>
<dd>
<p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list of the same length as <code>x</code> containing the results of the <code>fun</code>.
The output format resembles that of <code>base::lapply()</code>.
</p>


<hr>
<a id="method-UserApiConsumer-apply"></a>



<h4>Method <code>apply()</code>
</h4>

<p>Execute a task in parallel akin to <code>parallel::parApply()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>UserApiConsumer$apply(backend, x, margin, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>backend</code></dt>
<dd>
<p>An object of class <code>Backend</code> as returned by
the <code>start_backend()</code> function. It can also be <code>NULL</code> to run
the task sequentially via <code>base::apply()</code>.</p>
</dd>
<dt><code>x</code></dt>
<dd>
<p>An array to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>margin</code></dt>
<dd>
<p>A numeric vector indicating the dimensions of <code>x</code> the
<code>fun</code> function should be applied over. For example, for a matrix,
<code>margin = 1</code> indicates applying <code>fun</code> rows-wise, <code>margin = 2</code>
indicates applying <code>fun</code> columns-wise, and <code>margin = c(1, 2)</code>
indicates applying <code>fun</code> element-wise. Named dimensions are also
possible depending on <code>x</code>. See <code>parallel::parApply()</code> and
<code>base::apply()</code> for more details.</p>
</dd>
<dt><code>fun</code></dt>
<dd>
<p>A function to apply to <code>x</code> according to the <code>margin</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The dimensions of the output vary according to the <code>margin</code> argument.
Consult the documentation of <code>base::apply()</code> for a detailed
explanation on how the output is structured.
</p>


<hr>
<a id="method-UserApiConsumer-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>UserApiConsumer$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p><code>start_backend()</code>, <code>stop_backend()</code>,
<code>configure_bar()</code>, <code>par_sapply()</code>, and
<code>par_lapply()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Define a simple task.
task &lt;- function(x) {
    # Perform computations.
    Sys.sleep(0.01)

    # Return the result.
    return(x + 1)
}

# Start an asynchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "async")

# Change the progress bar options.
configure_bar(type = "modern", format = "[:bar] :percent")

# Create an user API consumer.
consumer &lt;- UserApiConsumer$new()

# Execute the task using the `sapply` parallel operation.
output_sapply &lt;- consumer$sapply(backend = backend, x = 1:200, fun = task)

# Print the head of the `sapply` operation output.
head(output_sapply)

# Execute the task using the `sapply` parallel operation.
output_lapply &lt;- consumer$lapply(backend = backend, x = 1:200, fun = task)

# Print the head of the `lapply` operation output.
head(output_lapply)

# Stop the backend.
stop_backend(backend)

</code></pre>


</div>
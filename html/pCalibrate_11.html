<div class="container">

<table style="width: 100%;"><tr>
<td>zCalibrate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Calibration of p-values from z-tests

</h2>

<h3>Description</h3>

<p>Transforms one- and two-sided p-values from z-tests to minimum Bayes factors.

</p>


<h3>Usage</h3>

<pre><code class="language-R">zCalibrate(p=NULL, z=p2z(p), type="two.sided",  
           alternative="normal", transform="id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a vector of p-values, default is <code>NULL</code>

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>a vector of z-values, is calculated from <code>p</code>, if necessary.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>either <code>"one.sided"</code> or <code>"two.sided"</code>.
Defaults to <code>"two.sided"</code>.
Specifies if the z-test (and the corresponding p-value) is one-sided or two-sided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>either <code>"simple"</code>, <code>"normal"</code> or <code>"local"</code>.
Defaults to <code>"normal"</code>.
Specifies the alternative hypotheses for the mean to consider.
See Details for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transform</code></td>
<td>

<p>either <code>"id"</code>, <code>"log"</code>, <code>"log2"</code>  or <code>"log10"</code>.
Defaults to <code>"id"</code>.
Specifies how to transform the minimum Bayes factor(s).
<code>"id"</code> corresponds to no transformation.
<code>"log"</code> refers to the natural logarithm, <code>"log2"</code> to the logarithm
to the base 2 and <code>"log10"</code> to the logarithm
to the base 10.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For one-sided z-tests (<code>type="one.sided"</code>), 
<code>alternative="simple"</code> considers all simple
point alternatives for the mean in the specified direction, <code>alternative="normal"</code> all shifted and possibly mirrored (if <code>direction=less</code>)
half-normal distributions with mode at the null value and 
<code>alternative="local"</code> all monotonic density functions with mode at the null value,
which are concentrated on the parameter space of the alternative. 
</p>
<p>For two-sided z-tests (<code>type="two.sided"</code>), <code>alternative="simple"</code> considers all
two-point distributions on the mean
which are symmetric with respect to the null value, <br><code>alternative="normal"</code> 
all normal distributions centered around the null value and 
<br><code>alternative="local"</code> all unimodal symmetric distributions with respect the null value
(i.e. these distributions are non-increasing as a function of the distance to the null value).
</p>
<p>Note that for <code>alternative="normal"</code> and <code>alternative="local"</code>,
the minimum Bayes factor is the same for <code>type="one.sided"</code> and 
<code>type="two.sided"</code>.
</p>
<p>For <code>type="one.sided", alternative="simple"</code> and for <code>alternative="normal"</code>,
the calibrations have closed-form expressions and were proposed in Edwards et al. (1963).<br>
For <code>type="two.sided", alternative="simple"</code>  and for <code>alternative="local"</code>, the calibrations need to be computed by numerical optimization and were derived in 
Berger &amp; Sellke (1987). 
Most of these calibrations are also described in Held &amp; Ott (2018).
</p>
<p>Note that if one considers the class of all alternatives,
the resulting minimum Bayes factor is the same as for 
<code>type="one.sided", alternative="simple"</code>.
</p>
<p>One can show that if one considers the class of all alternatives
which are symmetric around the null value,
one obtains the same minimum Bayes factor as for the subclass of all
symmetric two-point distributions (Berger &amp; Sellke, 1987).
</p>


<h3>Value</h3>

<p>A numeric vector of minimum Bayes factors for the specified p-values 





</p>


<h3>Note</h3>

<p>For small p-values, using the corresponding z-value
as an argument instead of the p-value may lead to more accurate computations.

</p>


<h3>References</h3>

<p>Berger, J. O. and Sellke, T. (1987). Testing a point null hypothesis: The irreconcilability of P
values and evidence (with discussion). <em>Journal of the American Statistical Association</em>, <b>82</b>, 112–139.
</p>
<p>Edwards, W., Lindman, H. and Savage, L. J. (1963). Bayesian statistical inference for psychological research. 
<em>Psychological Review</em>, <b>70</b>, 193–242.
</p>
<p>Held, L. and Ott, M. (2018). On p-values and Bayes factors.
<em>Annual Review of Statistics and Its Application</em>, <b>5</b>, 393–419.

</p>


<h3>See Also</h3>

<p><code>tCalibrate</code> 
for sample-size adjusted calibrations of p-values from t-tests

</p>


<h3>Examples</h3>

<pre><code class="language-R">  
# two-sided alternatives
zCalibrate(p=c(0.05, 0.01, 0.005), alternative="simple")
zCalibrate(p=c(0.05, 0.01, 0.005))
zCalibrate(p=c(0.05, 0.01, 0.005), alternative="local")
zCalibrate(z=c(2, 3, 4), alternative="local")
# one-sided alternatives
zCalibrate(p=c(0.05, 0.01, 0.005), type="one.sided", 
           alternative="simple")
zCalibrate(p=c(0.05, 0.01, 0.005), type="one.sided")
zCalibrate(p=c(0.05, 0.01, 0.005), type="one.sided", 
           alternative="local")

# plot the different calibrations as a function of the p-value
par(las=1)
p &lt;- exp(seq(log(0.0001), log(0.3), by=0.01))
minBF &lt;- matrix(NA, ncol=4, nrow=length(p))
minBF[ ,1] &lt;- zCalibrate(p)
minBF[ ,2] &lt;- zCalibrate(p, type="two.sided", alternative="local")
minBF[ ,3] &lt;- zCalibrate(p, type="two.sided", alternative="simple")
minBF[ ,4] &lt;- zCalibrate(p, type="one.sided", alternative="simple")
matplot(p, minBF, type="l", ylab="Minimum Bayes factor", log="xy", 
        xlab="z-test p-value", lty=1, lwd=2, col=c(1,3,2,4), axes=FALSE)
axis(1, at=c(0.0001, 0.0003, 0.001, 0.003, 0.01, 0.03, 0.1, 0.3), 
     as.character(c(format(c(0.0001,0.0003), nsmall=4, digits=4, 
                  scientific=FALSE), 
                  c(0.001, 0.003, 0.01, 0.03, 0.1, 0.3))))
my.values &lt;- c(3000, 1000, 300, 100, 30, 10, 3, 1)
my.at &lt;- 1/my.values
my.ylegend &lt;- c(paste("1/", my.values[-length(my.values)], sep=""), "1")
axis(2, at=my.at, my.ylegend)
box()
legend("bottomright", lty=1, lwd=2, 
        legend=c("normal", "unimodal symmetric", 
                "two-sided simple", "one-sided simple"), col=c(1,3,2,4))
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>load_dct_dir</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Load DCT specifications from a file or multiple files</h2>

<h3>Description</h3>

<p>These function load DCT specifications from the YAML fragments
in one (<code>load_dct_specs</code>) or multiple files (<code>load_dct_dir</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">load_dct_dir(
  path,
  recursive = TRUE,
  extension = "\\.rock|\\.dct\\.yaml|\\.yaml|\\.yml",
  regex,
  dctContainer = "dct",
  headingLevel = 2,
  delimiterRegEx = "^---$",
  ignoreOddDelimiters = FALSE,
  encoding = "UTF-8",
  sortDecreasing = FALSE,
  silent = TRUE
)

load_dct_specs(
  text,
  file,
  delimiterRegEx = "^---$",
  dctContainer = "dct",
  headingLevel = 2,
  ignoreOddDelimiters = FALSE,
  encoding = "UTF-8",
  silent = TRUE
)

## S3 method for class 'dct_specs'
print(x, ...)

## S3 method for class 'dct_specs'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>The path containing the files to read.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recursive</code></td>
<td>
<p>Whether to also process subdirectories (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extension</code></td>
<td>
<p>The extension of the files to read; files with other extensions will
be ignored. Multiple extensions can be separated by a pipe (<code>|</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regex</code></td>
<td>
<p>Instead of specifing an extension, it's also possible to specify a regular
expression; only files matching this regular expression are read. If specified, <code>regex</code>
takes precedece over <code>extension</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dctContainer</code></td>
<td>
<p>The container of the DCT specifications in the YAML
fragments. Because only DCT specifications are read that are stored in
this container, the files can contain YAML fragments with other data, too,
without interfering with the parsing of the DCT specifications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>headingLevel</code></td>
<td>
<p>The level of the Markdown headings that are produced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delimiterRegEx</code></td>
<td>
<p>The regular expression used to locate YAML
fragments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignoreOddDelimiters</code></td>
<td>
<p>Whether to throw an error (FALSE) or
delete the last delimiter (TRUE) if an odd number of delimiters is
encountered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>encoding</code></td>
<td>
<p>The encoding to use when calling <code>readLines()</code>. Set to
NULL to let <code>readLines()</code> guess.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortDecreasing</code></td>
<td>
<p>Whether to sort the constructs in decreasing order
(<code>TRUE</code>), in increasing order (<code>FALSE</code>), or not at all (<code>NULL</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>Whether to be silent (TRUE) or informative (FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>text, file</code></td>
<td>
<p>As <code>text</code> or <code>file</code>, you can specify a <code>file</code> to read with
encoding <code>encoding</code>, which will then be read using <code>base::readLines()</code>. If the
argument is named <code>text</code>, whether it is the path to an existing file is checked
first, and if it is, that file is read. If the argument is named <code>file</code>, and it
does not point to an existing file, an error is produced (useful if calling
from other functions). A <code>text</code> should be a character vector where every
element is a line of the original source (like provided by <code>base::readLines()</code>);
although if a character vector of one element <em>and</em> including at least one
newline character (<code style="white-space: pre;">⁠\\n⁠</code>) is provided as <code>text</code>, it is split at the newline
characters using <code>base::strsplit()</code>. Basically, this behavior means that the
first argument can be either a character vector or the path to a file; and if
you're specifying a file and you want to be certain that an error is thrown if
it doesn't exist, make sure to name it <code>file</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The parsed <code>parsed_dct</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Any other arguments are passed to the print command.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>load_dct_dir</code> simply identifies all files and then calls
<code>load_dct_specs</code> for each of them. <code>load_dct_specs</code> loads the
YAML fragments containing the DCT specifications using
<code>yum::load_yaml_fragments()</code> and then parses the DCT
specifications into a visual representation as a
DiagrammeR::DiagrammeR graph and Markdown documents with
the instructions for creating measurement instruments or
manipulations, and for coding measurement instruments,
manipulations, or aspects of a construct.
</p>


<h3>Value</h3>

<p>An object with the DiagrammeR::DiagrammeR graph stored
in <code>output$basic_graph</code>, a DiagrammeR::DiagrammeR graph with a summary
of which specifications are provided for each construct in
<code>output$completeness_graph</code> and the instructions in <code>output$instr</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">exampleSpec &lt;-
  system.file("extdata",
              "example.dct.yaml",
              package="psyverse");
dctObject &lt;- load_dct_specs(exampleSpec);

## Not run: 
psyverse::load_dct_dir(path="A:/some/path");

## End(Not run)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>parts</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Enumerate the partitions of an integer

</h2>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><p>Given an integer, return a matrix whose columns enumerate various
partitions.
</p>
<p>Function <code>parts()</code> returns the unrestricted partitions; function
<code>diffparts()</code> returns the unequal partitions; function
<code>restrictedparts()</code> returns the restricted partitions; function
<code>blockparts()</code> returns the partitions subject to specified
maxima; and function <code>compositions()</code> returns all compositions
of the argument.
</p>


<h3>Usage</h3>

<pre><code class="language-R">parts(n)
diffparts(n)
restrictedparts(n, m, include.zero=TRUE, decreasing=TRUE)
blockparts(f, n=NULL, include.fewer=FALSE)
compositions(n, m=NULL, include.zero=TRUE)
multiset(v,n=length(v))
mset(v)
multinomial(v)
allbinom(n,k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Integer to be partitioned.  In function <code>blockparts()</code>,
the default of <code>NULL</code> means to return all partitions of any size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>In functions <code>restrictedparts()</code> and
<code>compositions()</code>, the order of the partition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.zero</code></td>
<td>
<p>In functions <code>restrictedparts()</code> and
<code>compositions()</code>, Boolean with default <code>FALSE</code> meaning to
include only partitions of <i>n</i> into <em>exactly</em> <i>m</i>
parts; and <code>TRUE</code> meaning to include partitions of <i>n</i> into
<em>at most</em> <i>m</i> parts (because zero parts are included)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.fewer</code></td>
<td>
<p>In function <code>blockparts()</code>, Boolean with
default <code>FALSE</code> meaning to return vectors whose sum is
<em>exactly</em> <code>n</code> and <code>TRUE</code> meaning to return partitions
whose sum is <em>at most</em> <code>n</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p>In <code>restrictedparts()</code>, Boolean with default
<code>TRUE</code> meaning to return partitions whose parts are in
decreasing order and <code>FALSE</code> meaning to return partitions in
lexicographical order, as appearing in Hindenburg's
algorithm.   Note that setting to <code>decreasing</code> to <code>FALSE</code>
has the effect of making <code>conjugate()</code> return garbage</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>In function <code>blockparts()</code>, a vector of strictly
positive integers that gives the maximal number of blocks; see
details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>In function <code>multiset()</code>, an integer vector representing
a multiset.  Argument <code>n</code> is the size of the sample to be
taken</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>In function <code>allbinom()</code>, the size of the set to be
chosen; arguments match those of <code>choose()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li>
<p> Function <code>parts()</code> uses the algorithm in Andrews.
Function <code>diffparts()</code> uses a very similar algorithm that I
have not seen elsewhere.  These functions behave strangely if given
an argument of zero.
</p>
</li>
<li>
<p> Function <code>restrictedparts()</code> uses the algorithm in
Andrews, originally due to Hindenburg.  For partitions into at most
<i>m</i> parts, the same Hindenburg's algorithm is used but with a
start vector of <code>c(rep(0,m-1),n)</code>.
</p>
<p>Functions <code>parts()</code> and <code>restrictedparts()</code> overlap in
functionality.  Note, however, that they can return identical
partitions but in a different order: <code>parts(6)</code> and
<code>restrictedparts(6,6)</code> for example.
</p>
<p>If \(m&gt;n\), the partitions are padded with zeros.
</p>
</li>
<li>
<p> Function <code>blockparts()</code> enumerates the compositions of an
integer subject to a maximum criterion: given vector
\(y=(y_1,\ldots,y_n)\) all sets of
\(a=(a_1,\ldots,a_n)\) satisfying
\(\sum_{i=1}^pa_i=n\) subject to \(0\leq a_i\leq
    y_i\) for all <i>i</i> are given in lexicographical
order.  If argument <code>y</code> includes zero elements, these are
treated consistently (ie a position with zero capacity).
</p>
<p>If <code>n</code> takes its default value of <code>NULL</code>, then the
restriction \(\sum_{i=1}^pa_i=n\) is relaxed (so that
the numbers may sum to anything).  Note that these solutions are not
necessarily in standard form, so functions <code>durfee()</code> and
<code>conjugate()</code> may fail.
</p>
</li>
<li>
<p> With a single argument, <code>compositions(n)</code> returns
all \(2^{n-1}\) ways of partitioning an integer; thus
<code>4+1+1</code> is distinct from <code>1+4+1</code> or <code>1+1+4</code>.
</p>
<p>With two arguments, <code>compositions(n,m)</code> returns all
nonnegative solutions to \(x_1+\cdots+x_m=n\).
</p>
<p>This function is different from all the others in the package in
that it is written in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>; it is not clear that C would be any
faster.
</p>
</li>
<li>
<p> Function <code>multiset()</code> returns all ways of ordering a
multiset (<code>mset()</code> is a low-level helper function).
</p>
</li>
<li>
<p> Function <code>multinomial(v)</code> returns all ways of
partitioning a set into <em>distinguishable</em> boxes of capacities
<code>v[1], v[2],...,v[n]</code>.  The number of columns is given by the
multinomial coefficient \({\sum v_i\choose
	v_1\,v_2\,\ldots\,v_n}\).
</p>
</li>
<li>
<p> Function <code>allbinom(n,k)</code> is provided for convenience; it
enumerates the ways of choosing <i>k</i> objects from <code>n</code>.
</p>
</li>
</ul>
<h3>Note</h3>

<p>These vectorized functions return a matrix whose columns are the
partitions.  If this matrix is too large, consider enumerating the
partitions individually using the functionality documented in
<code>nextpart.Rd</code>.
</p>
<p>One commonly encountered idiom is <code>blockparts(rep(n,n),n)</code>, which
is equivalent to <code>compositions(n,n)</code> [Sloane's <code>A001700</code>].
</p>
<p>If you have a <em>minimum</em> number of balls in each block, a
construction like
</p>
<pre>x &lt;- c(1, 1, 2, 1)
y &lt;- c(2, 3, 4, 5)
sweep(blockparts(y - x, 7 - sum(x)), 1, x, "+")
                      
##: [1,] 2 1 2 1 1 2 1 1 1
##: [2,] 2 3 1 2 1 1 2 1 1
##: [3,] 2 2 3 3 4 2 2 3 2
##: [4,] 1 1 1 1 1 2 2 2 3
</pre>

<p>can be helpful (that is, subtract off the minimum number of balls and
add them back again at the end).
</p>
<pre>
    blockparts(c(4,3,3,2),5)  # Knuth's example, pre-fascicle 3a, p16
    multiset(c(1,2,2,3))      # also Knuth
  </pre>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p> G. E. Andrews. “The theory of partitions”,
Cambridge University Press, 1998
</p>
</li>
<li>
<p> R. K. S. Hankin 2006.  “Additive integer partitions in
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>”. <em>Journal of Statistical Software</em>, Volume 16, code
snippet 1 
</p>
</li>
<li>
<p> R. K. S. Hankin 2007.  “Urn sampling without
replacement: enumerative combinatorics in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>”. <em>Journal of
Statistical Software</em>, Volume 17, code snippet 1
</p>
</li>
<li>
<p> R. K. S. Hankin 2007.  “Set partitions in
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>”. <em>Journal of Statistical Software</em>, Volume
23, code snippet 2
</p>
</li>
<li>
<p> N. J. A. Sloane, 2008, The On-Line Encyclopedia of Integer
Sequences.  Sequence A001700
</p>
</li>
<li>
<p> D. Knuth, 2004.  The art of computer programming, pre-fascicle
2B “Generating all permutations”
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>nextpart</code></p>


<h3>Examples</h3>

<pre><code class="language-R">parts(7)
                                  
##: [1,] 7 6 5 5 4 4 4 3 3 3 3 2 2 2 1
##: [2,] 0 1 2 1 3 2 1 3 2 2 1 2 2 1 1
##: [3,] 0 0 0 1 0 1 1 1 2 1 1 2 1 1 1
##: [4,] 0 0 0 0 0 0 1 0 0 1 1 1 1 1 1
##: [5,] 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1
##: [6,] 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1
##: [7,] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
P(7)
##: [1] 15
diffparts(9)
                    
##: [1,] 9 8 7 6 6 5 5 4
##: [2,] 0 1 2 3 2 4 3 3
##: [3,] 0 0 0 0 1 0 1 2
Q(9)
##: [1] 8
restrictedparts(9, 4)
                                        
##: [1,] 9 8 7 6 5 7 6 5 4 5 4 3 6 5 4 4 3 3
##: [2,] 0 1 2 3 4 1 2 3 4 2 3 3 1 2 3 2 3 2
##: [3,] 0 0 0 0 0 1 1 1 1 2 2 3 1 1 1 2 2 2
##: [4,] 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 2
R(4, 9, include.zero = TRUE)
##: [1] 18
blockparts(1:4, 5)
                                                
##: [1,] 1 1 0 1 1 0 1 0 1 1 0 1 0 0 1 0 1 0 0 1 0 0
##: [2,] 2 1 2 2 1 2 0 1 2 1 2 0 1 0 1 2 0 1 0 0 1 0
##: [3,] 2 3 3 1 2 2 3 3 0 1 1 2 2 3 0 0 1 1 2 0 0 1
##: [4,] 0 0 0 1 1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 4 4 4
S(1:4, 5)
##: [1] 22
compositions(5, 3)
                                              
##: [1,] 5 4 3 2 1 0 4 3 2 1 0 3 2 1 0 2 1 0 1 0 0
##: [2,] 0 1 2 3 4 5 0 1 2 3 4 0 1 2 3 0 1 2 0 1 0
##: [3,] 0 0 0 0 0 0 1 1 1 1 1 2 2 2 2 3 3 3 4 4 5
S(rep(5, 3), 5)
##: [1] 21
setparts(4)
                                  
##: [1,] 1 1 1 1 2 1 1 1 1 1 1 2 2 2 1
##: [2,] 1 1 1 2 1 2 1 2 2 1 2 1 1 3 2
##: [3,] 1 2 1 1 1 2 2 1 3 2 1 3 1 1 3
##: [4,] 1 1 2 1 1 1 2 2 1 3 3 1 3 1 4
setparts(c(1, 2, 2))
                                  
##: [1,] 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3
##: [2,] 2 2 3 1 1 1 2 2 3 2 2 3 1 1 1
##: [3,] 3 2 2 3 2 2 1 1 1 3 2 2 2 1 2
##: [4,] 2 3 2 2 3 2 3 2 2 1 1 1 2 2 1
##: [5,] 1 1 1 2 2 3 2 3 2 2 3 2 1 2 2
multinomial(c(a = 1, b = 2, c = 1))
                         
##: a 1 1 1 2 2 3 4 3 4 2 3 4
##: b 2 2 3 1 1 1 1 1 1 3 2 2
##: b 3 4 4 3 4 2 2 4 3 4 4 3
##: c 4 3 2 4 3 4 3 2 2 1 1 1
</code></pre>


</div>
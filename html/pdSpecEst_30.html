<div class="container">

<table style="width: 100%;"><tr>
<td>WavTransf2D</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Forward AI wavelet transform for surface of HPD matrices</h2>

<h3>Description</h3>

<p><code>WavTransf2D</code> computes a forward intrinsic average-interpolation (AI) wavelet transform for a
rectangular surface in the manifold of HPD matrices equipped with a metric specified by the user, such as the
affine-invariant Riemannian metric, as described in Chapter 5 of (Chau 2018).
</p>


<h3>Usage</h3>

<pre><code class="language-R">WavTransf2D(P, order = c(3, 3), jmax, metric = "Riemannian", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>a (<code class="reqn">d,d,n1,n2</code>)-dimensional array of HPD matrices corresponding to a rectangular surface of <code class="reqn">(d,d)</code>-dimensional HPD matrices
of size <code class="reqn">n_1 \times n_2</code>, with <code class="reqn">n_1 = 2^{J_1}</code> and <code class="reqn">n_2 = 2^{J_2}</code> for some <code class="reqn">J_1, J_2 &gt; 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>a 2-dimensional numeric vector <code class="reqn">(1,1) \le</code> <code>order</code> <code class="reqn">\le (9,9)</code> corresponding to the marginal
orders of the intrinsic 2D AI refinement scheme, defaults to <code>order = c(3, 3)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jmax</code></td>
<td>
<p>the maximum scale up to which the wavelet coefficients are computed. If <code>jmax</code> is not
specified, it is set equal to the maximum possible scale <code>jmax = max(J1, J2) - 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>the metric that the space of HPD matrices is equipped with. The default choice is <code>"Riemannian"</code>,
but this can be one of: <code>"Riemannian"</code>, <code>"logEuclidean"</code>, <code>"Cholesky"</code>, <code>"rootEuclidean"</code> or
<code>"Euclidean"</code>. See also the Details section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments for internal use.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The 4-dimensional array <code>P</code> corresponds to a discretized rectangular surface of <code class="reqn">(d,d)</code>-dimensional
HPD matrices. The rectangular surface is of size <code class="reqn">n_1</code> by <code class="reqn">n_2</code>, where both <code class="reqn">n_1</code> and
<code class="reqn">n_2</code> are supposed to be dyadic numbers. <code>WavTransf2D</code> then computes the intrinsic AI wavelet transform
of <code>P</code> based on the given refinement orders and the chosen metric. The marginal refinement orders should be
smaller or equal to 9, and the function computes the wavelet transform using a fast wavelet refinement scheme based on weighted
intrinsic averages with pre-determined weights as explained in Chapter 5 of (Chau 2018). By default <code>WavTransf2D</code>
computes the intrinsic 2D AI wavelet transform equipping the space of HPD matrices with (i) the affine-invariant Riemannian metric as
detailed in e.g., (Bhatia 2009)[Chapter 6] or (Pennec et al. 2006). Instead, the space of HPD matrices
can also be equipped with one of the following metrics; (ii) the Log-Euclidean metric, the Euclidean inner product between matrix
logarithms; (iii) the Cholesky metric, the Euclidean inner product between Cholesky decompositions; (iv) the Euclidean metric and
(v) the root-Euclidean metric. The default choice of metric (affine-invariant Riemannian) satisfies several useful properties
not shared by the other metrics, see (Chau 2018) for more details. Note that this comes at the cost of increased computation
time in comparison to one of the other metrics.
</p>


<h3>Value</h3>

<p>The function returns a list with three components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>D </code></td>
<td>
<p> the 2D pyramid of wavelet coefficients. This is a list of arrays, where each 4-dimensional array contains the
(<code class="reqn">d,d</code>)-dimensional wavelet coefficients in a 2D grid of locations from the coarsest wavelet scale <code>j = 0</code>
up to the finest wavelet scale <code>j = jmax</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D.white </code></td>
<td>
<p> the 2D pyramid of whitened wavelet coefficients. The structure of <code>D.white</code> is the same as
<code>D</code>, but with the wavelet coefficients replaced by their whitened counterparts as explained in Chapter 5 of
(Chau 2018).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M0 </code></td>
<td>
<p> a numeric array containing the midpoint(s) at the coarsest scale <code>j = 0</code> in the 2D midpoint pyramid.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The function does not check for positive definiteness of the input matrices, and (depending on the
specified metric) may fail if matrices are close to being singular.
</p>


<h3>References</h3>

<p>Bhatia R (2009).
<em>Positive Definite Matrices</em>.
Princeton University Press, New Jersey.<br><br> Chau J (2018).
<em>Advances in Spectral Analysis for Multivariate, Nonstationary and Replicated Time Series</em>.
phdthesis, Universite catholique de Louvain.<br><br> Pennec X, Fillard P, Ayache N (2006).
“A Riemannian framework for tensor computing.”
<em>International Journal of Computer Vision</em>, <b>66</b>(1), 41–66.
</p>


<h3>See Also</h3>

<p><code>InvWavTransf2D</code>, <code>pdSpecEst2D</code>, <code>pdNeville</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">P &lt;- rExamples2D(c(2^4, 2^4), 2, example = "tvar")
P.wt &lt;- WavTransf2D(P$f)

</code></pre>


</div>
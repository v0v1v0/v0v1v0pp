<div class="container">

<table style="width: 100%;"><tr>
<td>disCItest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>G square Test for (Conditional) Independence of Discrete Variables</h2>

<h3>Description</h3>

<p><code class="reqn">G^2</code> test for (conditional) independence of <em>discrete</em>
(each with a <em>finite</em> number of “levels”)
variables <code class="reqn">X</code> and <code class="reqn">Y</code> given the (possibly empty) set of
discrete variables <code class="reqn">S</code>.
</p>
<p><code>disCItest()</code> is a wrapper of <code>gSquareDis()</code>, to be easily
used in <code>skeleton</code>, <code>pc</code> and <code>fci</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gSquareDis(x, y, S, dm, nlev, adaptDF = FALSE, n.min = 10*df, verbose = FALSE)
disCItest (x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x,y</code></td>
<td>
<p>(integer) position of variable <code class="reqn">X</code> and <code class="reqn">Y</code>,
respectively, in the adjacency matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>(integer) positions of zero or more conditioning variables in the
adjacency matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dm</code></td>
<td>
<p>data matrix (rows: samples, columns: variables) with integer
entries; the k levels for a given column must be coded by the integers
0,1,...,k-1. (see example)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlev</code></td>
<td>
<p>optional vector with numbers of levels for each variable
in <code>dm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptDF</code></td>
<td>
<p>logical specifying if the degrees of freedom should be
lowered by one for each zero count.  The value for the degrees of
freedom cannot go below 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.min</code></td>
<td>
<p>the smallest <code class="reqn">n</code> (number of observations,
<code>nrow(dm)</code>) for which the G^2 test is computed; for smaller
<code class="reqn">n</code>, independence is assumed (<code class="reqn">G^2 := 1</code>) with a warning.  The
default is <code class="reqn">10 m</code>, where <code class="reqn">m</code> is the degrees of freedom
assuming no structural zeros, here, the product of all the number of
levels <code>(nlev[x]-1) * (nlev[y]-1) * prod(nlev[S])</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical or integer indicating that increased diagnostic output is to
be provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffStat</code></td>
<td>
<p>a <code>list</code> with three elements, <code>"dm"</code>,
<code>"nlev"</code>, <code>"adaptDF"</code>; each corresponding to the above
arguments of <code>gSquareDis()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code class="reqn">G^2</code> statistic is used to test for (conditional) independence
of X and Y given a set S (can be <code>NULL</code>).  If only binary
variables are involved, <code>gSquareBin</code> is a specialized
(a bit more efficient) alternative to <code>gSquareDis()</code>.
</p>


<h3>Value</h3>

<p>The p-value of the test.
</p>


<h3>Author(s)</h3>

<p>Nicoletta Andri and Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>).
</p>


<h3>References</h3>

<p>R.E. Neapolitan (2004).
Learning Bayesian Networks. <em>Prentice Hall Series in Artificial
Intelligence</em>. Chapter 10.3.1
</p>


<h3>See Also</h3>

<p><code>gSquareBin</code> for a (conditional) independence test
for binary variables.
</p>
<p><code>dsepTest</code>, <code>gaussCItest</code> and
<code>binCItest</code> for similar functions for a d-separation
oracle, a conditional independence test for gaussian variables and a
conditional independence test for binary variables, respectively.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simulate data
n &lt;- 100
set.seed(123)
x &lt;- sample(0:2, n, TRUE) ## three levels
y &lt;- sample(0:3, n, TRUE) ## four levels
z &lt;- sample(0:1, n, TRUE) ## two levels
dat &lt;- cbind(x,y,z)

## Analyze data
gSquareDis(1,3, S=2, dat, nlev = c(3,4,2)) # but nlev is optional:
gSquareDis(1,3, S=2, dat, verbose=TRUE, adaptDF=TRUE)
## with too little data, gives a warning (and p-value 1):
gSquareDis(1,3, S=2, dat[1:60,], nlev = c(3,4,2))

suffStat &lt;- list(dm = dat, nlev = c(3,4,2), adaptDF = FALSE)
disCItest(1,3,2,suffStat)
</code></pre>


</div>
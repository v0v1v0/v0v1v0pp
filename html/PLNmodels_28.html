<div class="container">

<table style="width: 100%;"><tr>
<td>Networkfamily</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>An R6 Class to virtually represent a collection of network fits</h2>

<h3>Description</h3>

<p>The functions <code>PLNnetwork()</code> and <code>ZIPLNnetwork()</code> both produce an instance of this class, which can be thought of as a vector of <code>PLNnetworkfit</code>s <code>ZIPLNfit_sparse</code>s (indexed by penalty parameter)
</p>
<p>This class comes with a set of methods mostly used to compare
network fits (in terms of goodness of fit) or extract one from
the family (based on penalty parameter and/or goodness of it).
See the documentation for <code>getBestModel()</code>,
<code>getModel()</code> and plot() for the user-facing ones.
</p>


<h3>Super class</h3>

<p><code>PLNmodels::PLNfamily</code> -&gt; <code>Networkfamily</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>penalties</code></dt>
<dd>
<p>the sparsity level of the network in the successively fitted models</p>
</dd>
<dt><code>stability_path</code></dt>
<dd>
<p>the stability path of each edge as returned by the stars procedure</p>
</dd>
<dt><code>stability</code></dt>
<dd>
<p>mean edge stability along the penalty path</p>
</dd>
<dt><code>criteria</code></dt>
<dd>
<p>a data frame with the values of some criteria (variational log-likelihood, (E)BIC, ICL and R2, stability) for the collection of models / fits
BIC, ICL and EBIC are defined so that they are on the same scale as the model log-likelihood, i.e. with the form, loglik - 0.5 penalty</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Networkfamily-new"><code>Networkfamily$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-optimize"><code>Networkfamily$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-coefficient_path"><code>Networkfamily$coefficient_path()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-getBestModel"><code>Networkfamily$getBestModel()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-plot"><code>Networkfamily$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-plot_stars"><code>Networkfamily$plot_stars()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-plot_objective"><code>Networkfamily$plot_objective()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-show"><code>Networkfamily$show()</code></a>
</p>
</li>
<li> <p><a href="#method-Networkfamily-clone"><code>Networkfamily$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="getModel"><a href="../../PLNmodels/html/PLNfamily.html#method-PLNfamily-getModel"><code>PLNmodels::PLNfamily$getModel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="postTreatment"><a href="../../PLNmodels/html/PLNfamily.html#method-PLNfamily-postTreatment"><code>PLNmodels::PLNfamily$postTreatment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="PLNmodels" data-topic="PLNfamily" data-id="print"><a href="../../PLNmodels/html/PLNfamily.html#method-PLNfamily-print"><code>PLNmodels::PLNfamily$print()</code></a></span></li>
</ul></details><hr>
<a id="method-Networkfamily-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Initialize all models in the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$new(penalties, data, control)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>penalties</code></dt>
<dd>
<p>a vector of positive real number controlling the level of sparsity of the underlying network.</p>
</dd>
<dt><code>data</code></dt>
<dd>
<p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>control</code></dt>
<dd>
<p>a list for controlling the optimization.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Update all network fits in the family with smart starting values
</p>


<hr>
<a id="method-Networkfamily-optimize"></a>



<h4>Method <code>optimize()</code>
</h4>

<p>Call to the C++ optimizer on all models of the collection
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$optimize(data, config)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt>
<dd>
<p>a named list used internally to carry the data matrices</p>
</dd>
<dt><code>config</code></dt>
<dd>
<p>a list for controlling the optimization.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Networkfamily-coefficient_path"></a>



<h4>Method <code>coefficient_path()</code>
</h4>

<p>Extract the regularization path of a <code>Networkfamily</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$coefficient_path(precision = TRUE, corr = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>precision</code></dt>
<dd>
<p>Logical. Should the regularization path be extracted from the precision matrix Omega (<code>TRUE</code>, default) or from the variance matrix Sigma (<code>FALSE</code>)</p>
</dd>
<dt><code>corr</code></dt>
<dd>
<p>Logical. Should the matrix be transformed to (partial) correlation matrix before extraction? Defaults to <code>TRUE</code></p>
</dd>
</dl>
</div>


<hr>
<a id="method-Networkfamily-getBestModel"></a>



<h4>Method <code>getBestModel()</code>
</h4>

<p>Extract the best network in the family according to some criteria
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$getBestModel(crit = c("BIC", "EBIC", "StARS"), stability = 0.9)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>crit</code></dt>
<dd>
<p>character. Criterion used to perform the selection. If "StARS" is chosen but <code style="white-space: pre;">⁠$stability⁠</code> field is empty, will compute stability path.</p>
</dd>
<dt><code>stability</code></dt>
<dd>
<p>Only used for "StARS" criterion. A scalar indicating the target stability (= 1 - 2 beta) at which the network is selected. Default is <code>0.9</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For BIC and EBIC criteria, higher is better.
</p>


<hr>
<a id="method-Networkfamily-plot"></a>



<h4>Method <code>plot()</code>
</h4>

<p>Display various outputs (goodness-of-fit criteria, robustness, diagnostic) associated with a collection of network fits (a <code>Networkfamily</code>)
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$plot(
  criteria = c("loglik", "pen_loglik", "BIC", "EBIC"),
  reverse = FALSE,
  log.x = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>criteria</code></dt>
<dd>
<p>vector of characters. The criteria to plot in <code>c("loglik", "pen_loglik", "BIC", "EBIC")</code>. Defaults to all of them.</p>
</dd>
<dt><code>reverse</code></dt>
<dd>
<p>A logical indicating whether to plot the value of the criteria in the "natural" direction
(loglik - 0.5 penalty) or in the "reverse" direction (-2 loglik + penalty). Default to FALSE, i.e use the
natural direction, on the same scale as the log-likelihood.</p>
</dd>
<dt><code>log.x</code></dt>
<dd>
<p>logical: should the x-axis be represented in log-scale? Default is <code>TRUE</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a <code>ggplot</code> graph
</p>


<hr>
<a id="method-Networkfamily-plot_stars"></a>



<h4>Method <code>plot_stars()</code>
</h4>

<p>Plot stability path
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$plot_stars(stability = 0.9, log.x = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stability</code></dt>
<dd>
<p>scalar: the targeted level of stability using stability selection. Default is <code>0.9</code>.</p>
</dd>
<dt><code>log.x</code></dt>
<dd>
<p>logical: should the x-axis be represented in log-scale? Default is <code>TRUE</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a <code>ggplot</code> graph
</p>


<hr>
<a id="method-Networkfamily-plot_objective"></a>



<h4>Method <code>plot_objective()</code>
</h4>

<p>Plot objective value of the optimization problem along the penalty path
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$plot_objective()</pre></div>



<h5>Returns</h5>

<p>a <code>ggplot</code> graph
</p>


<hr>
<a id="method-Networkfamily-show"></a>



<h4>Method <code>show()</code>
</h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$show()</pre></div>


<hr>
<a id="method-Networkfamily-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Networkfamily$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p>The functions <code>PLNnetwork()</code>, <code>ZIPLNnetwork()</code> and the classes <code>PLNnetworkfit</code>, <code>ZIPLNfit_sparse</code>
</p>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>joinPolys</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Join One or Two PolySets using a Logic Operation
</h2>

<h3>Description</h3>

<p>Join one or two PolySets using a logic operation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">joinPolys(polysA, polysB=NULL, operation="INT")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>polysA</code></td>
<td>
<p>PolySet to join.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>polysB</code></td>
<td>
<p>optional second PolySet with which to join.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>operation</code></td>
<td>
<p>one of <code>"DIFF"</code>, <code>"INT"</code>, <code>"UNION"</code>,
or <code>"XOR"</code>, representing difference, intersection, union, and
exclusive-or, respectively.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function interfaces with the first version of the Clipper Library, 
specifically version 6.2.1 released 2014-10-31, developed by Angus Johnson.
Angus now offers <a href="https://www.angusj.com/clipper2/Docs/Overview.htm">Clipper 2 Library</a>.
Prior to 2013-03-23, <code>'joinPolys'</code> used the General Polygon Clipper library
by Alan Murta at the University of Manchester.
We keep this historic reference to GPC because <code>'joinPolys'</code> remains faithful
to Murta's definition of a generic polygon, which we describe below.
</p>
<p>Murta (2004) defines a <em>generic polygon</em> (or <em>polygon set</em>)
as zero or more disjoint boundaries of arbitrary configuration.  He
relates a <em>boundary</em> to a contour, where each may be convex,
concave or self-intersecting. In a PolySet, the polygons associated
with each unique <code>PID</code> loosely correspond to a generic polygon,
as they can represent both inner and outer boundaries.  Our use of the
term <em>generic polygon</em> includes the restrictions imposed by a
PolySet.  For example, the polygons for a given <code>PID</code> cannot
be arranged arbitrarily.
</p>
<p>If <code>'polysB'</code> is <code>NULL</code>, this function sequentially applies
the logic <code>'operation'</code> between the generic polygons in <code>'polysA'</code>.
For example, suppose <code>'polysA'</code> contains three generic polygons (A, B, C).
The function outputs the PolySet containing ((A <em>op</em> B) <em>op</em> C).
</p>
<p>If <code>'polysB'</code> is not <code>NULL</code>, this function applies the logic <code>'operation'</code>
between each generic polygon in <code>'polysA'</code> and each one in <code>'polysB'</code>.
For example, suppose <code>'polysA'</code> contains two generic polygons <code>(A, B)</code>
and <code>'polysB'</code> contains two generic polygons <code>(C, D)</code>.
The function's output is the concatenation of
A <em>op</em> C, B <em>op</em> C, A <em>op</em> D, B <em>op</em> D, with <code>PID</code>s 1 to 4, respectively.
Generally there are <em>n</em> times <em>m</em> comparisons, where <em>n</em> = number of polygons
in <code>'polysA'</code> and <em>m</em> = number of polygons in <code>'polysB'</code>.
If <code>'polysB'</code> contains only one generic polygon, the function
maintains the <code>PID</code>s from <code>'polysA'</code>.
It also maintains them when <code>'polysA'</code> contains only one generic polygon and
the <code>'operation'</code> is <code>"DIFF"</code> (difference).
Otherwise, if <code>'polysA'</code> contains only one generic polygon, it maintains
the <code>PID</code>s from <code>'polysB'</code>.
</p>


<h3>Value</h3>

<p>If <code>'polysB'</code> is <code>NULL</code>, the resulting PolySet contains
a single generic polygon (one <code>PID</code>), possibly with several
components (<code>SID</code>s).
The function recalculates the <code>PID</code> and <code>SID</code> columns.
</p>
<p>If <code>'polysB'</code> is not <code>NULL</code>, the resulting PolySet contains one or more
generic polygons (<code>PID</code>s), each with possibly several components (<code>SID</code>s).
The function recalculates the <code>SID</code> column, and depending on the input,
it may recalculate the <code>PID</code> column.
</p>


<h3>Author(s)</h3>

<p>C code: <a href="https://www.angusj.com/clipper2/Docs/Overview.htm">Angus Johnson</a>, Computer Programmer
</p>
<p>Implementation: <a href="https://github.com/boersn/">Nicholas M. Boers</a>, Staff Software Engineer<br>
Jobber, Edmonton AB
</p>
<p>Maintainer: <a href="mailto:rowan.haigh@dfo-mpo.gc.ca">Rowan Haigh</a>, Program Head – Offshore Rockfish<br>
Pacific Biological Station (PBS), Fisheries &amp; Oceans Canada (DFO), Nanaimo BC<br><em>locus opus</em>: Remote office, Vancouver BC<br>
Last modified <code>Rd: 2024-09-03</code>
</p>


<h3>References</h3>

<p>Murta, A. (2004) <em>A General Polygon Clipping Library</em>. Accessed: Jul 29, 2004.
</p>
<p>Johnson, A. (2014) <em>Clipper</em> – an open source freeware library for clipping and offsetting lines and polygons. Accessed: Oct 31, 2014.
</p>


<h3>See Also</h3>

<p>In package <span class="pkg">PBSmapping</span>:<br><code>addPolys</code>,
<code>appendPolys</code>,
<code>clipPolys</code>,
<code>closePolys</code>,
<code>fixBound</code>,
<code>fixPOS</code>,
<code>locatePolys</code>,
<code>plotMap</code>,
<code>plotPoints</code>,
<code>thickenPolys</code>,
<code>thinPolys</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">local(envir=.PBSmapEnv,expr={
  oldpar = par(no.readonly=TRUE)
  #--- load the data (if using R)
  if (!is.null(version$language) &amp;&amp; (version$language=="R"))
    data(nepacLL,envir=.PBSmapEnv)

  ### Example 1. Cut a triangle out of Vancouver Island
  par(mfrow=c(1,1))
  #--- create a triangle to use in clipping
  polysB &lt;- data.frame(PID=rep(1, 3), POS=1:3,
    X=c(-127.5, -124.5, -125.6), Y = c(49.2, 50.3, 48.6))
  #--- intersect nepacLL with the single polygon, and plot the result
  plotMap(joinPolys(nepacLL, polysB), col="cyan")
  #--- add nepacLL in a different line type to emphasize the intersection
  addPolys(nepacLL, border="purple", lty=3, density=0)
  box()

  ### Example 2. Cut Texada and Lasqueti Islands out of Boxes
  xlim = list(box1=c(-124.8,-124),box2=c(-124,-123.9))
  ylim = list(box1=c(49.4,49.85), box2=c(49.85,49.9))
  Xlim = extendrange(xlim); Ylim=extendrange(ylim)
  polyA = as.PolySet(data.frame(
    PID = rep(1:2,each=4), POS = rep(1:4,2),
    X = as.vector(sapply(xlim,function(x){x[c(1,1,2,2)]})),
    Y = as.vector(sapply(ylim,function(x){x[c(1,2,2,1)]}))
    ), projection="LL")
  data(nepacLLhigh,envir=.PBSmapEnv)
  polyB = nepacLLhigh[is.element(nepacLLhigh$PID,c(736,1912)),]
  polyC = joinPolys(polyA, polyB, "DIFF")
  par(mfrow=c(2,2),cex=1,mgp=c(2,0.5,0))
  plotMap(polyA,col="lightblue",xlim=Xlim,ylim=Ylim)
  addPolys(polyB,col="gold");
  text(mean(Xlim)-0.05,Ylim-0.04,"Boxes (A,B)  and  Isles (C,D)")
  labs = calcCentroid(polyA)
  labs[1,c("X","Y")] = labs[2,c("X","Y")]+c(-0.1,-0.05)
  text(labs[,"X"],labs[,"Y"],c("A","B"),font=2)
  plotMap(polyC[is.element(polyC$PID,1),],col="pink",xlim=Xlim,ylim=Ylim)
  text(mean(Xlim)-0.05,Ylim-0.04,"Box A  \"DIFF\"  Isle C")
  plotMap(polyC[is.element(polyC$PID,3),],col="green",xlim=Xlim,ylim=Ylim)
  text(mean(Xlim)-0.05,Ylim-0.04,"Box A  \"DIFF\"  Isle D")
  plotMap(polyC[is.element(polyC$PID,c(1,3)),],col="cyan",xlim=Xlim,ylim=Ylim)
  text(mean(Xlim)-0.05,Ylim-0.04,"Box A  \"DIFF\"  Isles (C,D)")
  par(oldpar)
})
</code></pre>


</div>
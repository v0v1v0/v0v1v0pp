<div class="container">

<table style="width: 100%;"><tr>
<td>pal_numeric</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Colour vector and colour palette mapping</h2>

<h3>Description</h3>

<p>Conveniently maps data values (numeric or factor/character) to colours
according to a given colour vector or colour palette.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pal_numeric(
  palette,
  domain,
  na.color = "#808080",
  alpha = FALSE,
  reverse = FALSE
)

pal_bin(
  palette,
  domain,
  bins = 7,
  pretty = TRUE,
  na.color = "#808080",
  alpha = FALSE,
  reverse = FALSE,
  right = FALSE
)

pal_quantile(
  palette,
  domain,
  n = 4,
  probs = seq(0, 1, length.out = n + 1),
  na.color = "#808080",
  alpha = FALSE,
  reverse = FALSE,
  right = FALSE
)

pal_factor(
  palette,
  domain,
  levels = NULL,
  ordered = FALSE,
  na.color = "#808080",
  alpha = FALSE,
  reverse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>palette</code></td>
<td>
<p>An object of class <code>palettes_colour</code> or
<code>palettes_colour</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>domain</code></td>
<td>
<p>The possible values that can be mapped.
</p>
<p>For <code>pal_numeric</code> and <code>pal_bin</code>, this can be a simple numeric
range (e.g. <code>c(0, 100)</code>); <code>pal_quantile</code> needs representative
numeric data; and <code>pal_factor</code> needs categorical data.
</p>
<p>If <code>NULL</code>, then whenever the resulting colour function is called, the
<code>x</code> value will represent the domain. This implies that if the function
is invoked multiple times, the encoding between values and colours may not
be consistent; if consistency is needed, you must provide a non-<code>NULL</code>
domain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.color</code></td>
<td>
<p>The colour to return for <code>NA</code> values. Note that
<code>na.color = NA</code> is valid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Whether alpha channels should be respected or ignored. If <code>TRUE</code>
then colors without explicit alpha information will be treated as fully
opaque.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse</code></td>
<td>
<p>Whether the colours in <code>palette</code> should be
used in reverse order. For example, if the default order of a palette goes
from blue to green, then <code>reverse = TRUE</code> will result in the colors going
from green to blue.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bins</code></td>
<td>
<p>Either a numeric vector of two or more unique cut points or a
single number (greater than or equal to 2) giving the number of intervals
into which the domain values are to be cut.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pretty</code></td>
<td>
<p>Whether to use the function <code>pretty()</code> to generate
the bins when the argument <code>bins</code> is a single number. When
<code>pretty = TRUE</code>, the actual number of bins may not be the number of
bins you specified. When <code>pretty = FALSE</code>, <code>seq()</code> is used
to generate the bins and the breaks may not be "pretty".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>right</code></td>
<td>
<p>parameter supplied to <code>base::cut()</code>. See Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of equal-size quantiles desired. For more precise control,
use the <code>probs</code> argument instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>See <code>stats::quantile()</code>. If provided, the <code>n</code>
argument is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>An alternate way of specifying levels; if specified, domain is
ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>
<p>If <code>TRUE</code> and <code>domain</code> needs to be coerced to a
factor, treat it as already in the correct order</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>pal_numeric</code> is a simple linear mapping from continuous numeric
data to an interpolated palette.
</p>
<p><code>pal_bin</code> also maps continuous numeric data, but performs
binning based on value (see the <code>base::cut()</code> function). <code>pal_bin</code>
defaults for the <code>cut</code> function are <code>include.lowest = TRUE</code> and
<code>right = FALSE</code>.
</p>
<p><code>pal_quantile</code> similarly bins numeric data, but via the
<code>stats::quantile()</code> function.
</p>
<p><code>pal_factor</code> maps factors to colours. If the palette is
discrete and has a different number of colours than the number of factors,
interpolation is used.
</p>


<h3>Value</h3>

<p>A function that takes a single parameter <code>x</code>; when called with a
vector of numbers (except for <code>pal_factor</code>, which expects
factors/characters), #RRGGBB colour strings are returned (unless
<code>alpha = TRUE</code> in which case #RRGGBBAA may also be possible).
</p>


<h3>See Also</h3>

<p><code>scales::col_numeric()</code>
</p>
<p><code>scales::col_bin()</code>
</p>
<p><code>scales::col_quantile()</code>
</p>
<p><code>scales::col_factor()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">pal &lt;- pal_bin(met_palettes$Tam, domain = 0:100)
plot(as_colour(pal(sort(runif(16, 0, 100)))))

# Exponential distribution, mapped continuously
pal &lt;- pal_numeric(met_palettes$Tam, domain = NULL)
plot(as_colour(pal(sort(rexp(16)))))

# Exponential distribution, mapped by interval
pal &lt;- pal_bin(met_palettes$Tam, domain = NULL, bins = 4)
plot(as_colour(pal(sort(rexp(16)))))

# Exponential distribution, mapped by quantile
pal &lt;- pal_quantile(met_palettes$Tam, domain = NULL)
plot(as_colour(pal(sort(rexp(16)))))

# Categorical data; by default, the values being coloured span the gamut...
pal &lt;- pal_factor(met_palettes$Java, domain = NULL)
plot(as_colour(pal(LETTERS[1:5])))

# ...unless the data is a factor, without droplevels...
pal &lt;- pal_factor(met_palettes$Java, domain = NULL)
plot(as_colour(pal(factor(LETTERS[1:5], levels = LETTERS))))

# ...or the domain is stated explicitly.
pal &lt;- pal_factor(met_palettes$Java, domain = NULL, levels = LETTERS)
plot(as_colour(pal(LETTERS[1:5])))
</code></pre>


</div>
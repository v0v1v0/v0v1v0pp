<div class="container">

<table style="width: 100%;"><tr>
<td>Socp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Second-order Cone Programming</h2>

<h3>Description</h3>

<p>The function solves second-order cone problem by
primal-dual interior point method. It is a wrapper function to the
<code>C</code>-routines written by Lobo, Vandenberghe and Boyd (see
reference below).
</p>


<h3>Usage</h3>

<pre><code class="language-R">Socp(f, A, b, C, d, N,
     x = NULL, z = NULL, w = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>Vector defining linear objective, <code>length(f)==length(x)</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Matrix with the <code class="reqn">A_i</code> vertically stacked:  <code class="reqn">A = [
  A_1; A_2; \ldots; A_L]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Vector with the <code class="reqn">b_i</code> vertically stacked: <code class="reqn">b = [ b_1;
  b_2; \ldots; b_L]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p> Matrix with the <code class="reqn">c_i'</code> vertically stacked: <code class="reqn">C = [ c_1';
        c_2'; \ldots; c_L']</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>Vector with the <code class="reqn">d_i</code> vertically stacked: <code class="reqn">d = [ d_1;
  d_2; \ldots;  d_L]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Vector of size <code>L</code>, defining the size of each constraint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Primal feasible initial point. Must satisfy: <code class="reqn">|| A_i*x +
  b_i || &lt; c_i' * x + d_i</code> for <code class="reqn">i = 1, \ldots, L</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>Dual feasible initial point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>Dual feasible initial point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of control parameters.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The primal formulation of an SOCP is given as:
</p>
<p style="text-align: center;"><code class="reqn">minimise f' * x</code>
</p>

<p>subject to
</p>
<p style="text-align: center;"><code class="reqn">||A_i*x + b_i|| &lt;= c_i' * x + d_i</code>
</p>

<p>for <code class="reqn">i = 1,\ldots, L</code>. Here, <code class="reqn">x</code> is the <code class="reqn">(n \times 1)</code>
vector to be optimised. The dual form of an SOCP is expressed as:
</p>
<p style="text-align: center;"><code class="reqn">maximise \sum_{i = 1}^L -(b' * z_i + d_i * w_i)</code>
</p>

<p>subject to
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i = 1}^L (A_i' * z_i + c_i * w_i) = f</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">||z_i || = w_i</code>
</p>

<p>for <code class="reqn">i = 1,\ldots, L</code>, given strictly feasible primal and dual
initial points.<br></p>
<p>The algorithm stops, if one of the following criteria is met:
</p>

<ol>
<li> <p><code>abs.tol</code> – maximum absolute error in objective
function; guarantees that for any x:  <code class="reqn">abs(f'*x - f'*x\_opt) &lt;=
    abs\_tol</code>. 
</p>
</li>
<li> <p><code>rel.tol</code> – maximum relative error in objective
function; guarantees that for any x: <code class="reqn">abs(f'*x -
    f'*x\_opt)/(f'*x\_opt) &lt;= rel\_tol  (if f'*x\_opt &gt; 0)</code>. Negative
value has special meaning, see target next.
</p>
</li>
<li> <p><code>target</code> – if <code class="reqn">rel\_tol&lt;0</code>, stops when
<code class="reqn">f'*x &lt; target or -b'*z &gt;= target</code>.
</p>
</li>
<li> <p><code>max.iter</code> – limit on number of algorithm outer iterations.
Most problems can be solved in less than 50 iterations. Called with
<code>max_iter = 0</code> only checks feasibility of <code>x</code> and <code>z</code>,
(and returns gap and deviation from centrality).
</p>
</li>
<li>
<p> The target value is reached. <code>rel\_tol</code> is negative and
the primal objective <code class="reqn">p</code> is less than the <code>target</code>.  
</p>
</li>
</ol>
<h3>Value</h3>

<p>A <code>list</code>-object with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Solution to the primal problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>Solution to the dual problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hist</code></td>
<td>
<p>see <code>out_mode</code> in <code>SocpControl</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>A logical code. <code>TRUE</code> indicates successful
convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>A numerical code. It indicates if the convergence was
successful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>A character string giving any additional information
returned by the optimiser.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function has been ported from the <span class="pkg">Rsocp</span> package contained
in the Rmetrics-Project on R-Forge. In contrast to the former
implementation, allowance is made for specifying more than one cone
constraint. 
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff
</p>


<h3>References</h3>

<p>Lobo, M. and Vandenberghe, L. and Boyd, S., <em>SOCP: Software for
Second-order Cone Programming, User's Guide</em>, Beta Version, April
1997, Stanford University.
</p>


<h3>See Also</h3>

<p><code>SocpPhase1</code>, <code>SocpPhase2</code>, <code>SocpControl</code>
</p>


</div>
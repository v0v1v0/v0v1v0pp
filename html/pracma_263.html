<div class="container">

<table style="width: 100%;"><tr>
<td>newmark</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Newmark Method
</h2>

<h3>Description</h3>

<p>Newmark's is a method to solve higher-order differential equations
without passing through the equivalent first-order system.
It generalizes the so-called ‘leap-frog’ method.
Here it is restricted to second-order equations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">newmark(f, t0, t1, y0, ..., N = 100, zeta = 0.25, theta = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>function in the differential equation <code class="reqn">y'' = f(x, y, y')</code>;<br>
defined as a function <code class="reqn">R \times R^2 \rightarrow R</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t0, t1</code></td>
<td>
<p>start and end points of the interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y0</code></td>
<td>
<p>starting values as row or column vector;
<code>y0</code> needs to be a vector of length 2, the first component
representing <code>y(t0)</code>, the second <code>dy/dt(t0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of steps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeta, theta</code></td>
<td>
<p>two non-negative real numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters to be passed to the function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Solves second order differential equations using the Newmark method
on an equispaced grid of <code>N</code> steps.
</p>
<p>Function <code>f</code> must return a vector, whose elements hold the evaluation
of <code>f(t,y)</code>, of the same dimension as <code>y0</code>. Each row in the
solution array Y corresponds to a time returned in <code>t</code>.
</p>
<p>The method is ‘implicit’ unless <code>zeta=theta=0</code>, second order if
<code>theta=1/2</code> and first order accurate if <code>theta!=1/2</code>.
<code>theta&gt;=1/2</code> ensures stability.
The condition set <code>theta=1/2; zeta=1/4</code> (the defaults) is a popular
approach that is unconditionally stable, but introduces oscillatory
spurious solutions on long time intervals.
(For these simulations it is preferable to use <code>theta&gt;1/2</code> and
<code>zeta&gt;(theta+1/2)^(1/2)</code>.)
</p>
<p>No attempt is made to catch any errors in the root finding functions.
</p>


<h3>Value</h3>

<p>List with components <code>t</code> for grid (or ‘time’) points between <code>t0</code>
and <code>t1</code>, and <code>y</code> an n-by-2 matrix with solution variables in
columns, i.e. each row contains one time stamp.
</p>


<h3>Note</h3>

<p>This is for demonstration purposes only; for real problems or applications
please use <code>ode23</code> or <code>rk4sys</code>.
</p>


<h3>References</h3>

<p>Quarteroni, A., R. Sacco, and F. Saleri (2007). Numerical Mathematics.
Second Edition, Springer-Verlag, Berlin Heidelberg.
</p>


<h3>See Also</h3>

<p><code>ode23</code>, <code>cranknic</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Mathematical pendulum  m l y'' + m g sin(y) = 0
pendel &lt;- function(t, y)  -sin(y[1])
sol &lt;- newmark(pendel, 0, 4*pi, c(pi/4, 0))

## Not run: 
plot(sol$t, sol$y[, 1], type="l", col="blue",
     xlab="Time", ylab="Elongation/Speed", main="Mathematical Pendulum")
lines(sol$t, sol$y[, 2], col="darkgreen")
grid()
## End(Not run)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>Repulsive force</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Repulsive force calculations and plots for vowel systems.</h2>

<h3>Description</h3>

<p>For each point, calculates the sum of inverse squared distances to
all points that are not of the same type.</p>


<h3>Usage</h3>

<pre><code class="language-R">    repulsiveForce(x, y, type, xform=log, exclude.inf=TRUE)
    repulsiveForceHeatmap(x, y, type=NULL, xform=log, 
                          exclude.inf=TRUE, resolution=10,
                          colormap=NULL, fast=FALSE, ...)
    repulsiveForceHeatmapLegend(x, y, labels=c("low", "high"),
                                pos=c(1, 3), colormap=NULL,
                                smoothness=50, lend=2, lwd=12, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x,y</code></td>
<td>
<p>Numeric vector of x and y values (e.g., F2 and F1 frequencies), or
in the case of <code>repulsiveForceHeatmapLegend</code>, length-2 vectors
specifying the endpoints of the legend colorbar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Attribute of the <code>(x, y)</code> points used to interpolate values
for intermediate points. In typical linguistic usage of this
function, <code>type</code> would be the vowel identities of the F2
and F1 values passed to <code>x</code> and <code>y</code> (respectively).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xform</code></td>
<td>
<p>A function to apply to the calculated force values before applying
the colormap. Default is to use the <code>log</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude.inf</code></td>
<td>
<p>Logical; should infinite force values be excluded? If true,
force for points with identical <code>x</code> and <code>y</code> values
but different values of <code>type</code> will be calculated as if
the distance between those points was half as long as the
smallest non-zero distance in the data (instead of 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resolution</code></td>
<td>
<p>Number of points to interpolate between each axis unit.
Higher resolution yields smoother heatmaps at the cost of
increased computational time. NOTE: in typical linguistic
usage, an appropriate <code>resolution</code> value will depend
on the type of units used to plot the formant data (e.g.,
you will need higher resolution for vowels plotted on the
Bark scale to get an equivalently smooth heatmap to one
plotted with lower resolution on a Hertz scale.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colormap</code></td>
<td>
<p>Colormap to use when drawing the heatmap and legend (see
<code>color.scale</code>. Note that although the
heatmap may use semi-transparent colors, this transparency
does not usually translate well to the <code>force.legend</code>
colorbar, due to the way that
<code>color.scale.lines</code> works. In short:
the legend colorbar is made of lots of little segments that
don't quite touch when plotted, leaving thin gaps in the
colorbar where the background shows through. In phonR this
has been avoided by adding a square cap to the line ends of
each segment in the colorbar, causing neighboring segments
to overlap. This overlapping is not noticeable when the
<code>force.colormap</code> uses fully opaque colors, but usually
yields a colorbar that looks opaque even when the
<code>force.colormap</code> colors are semi-transparent. For better
results, generate the <code>force.colmap</code> with pale, opaque
colors instead of intense colors that are semi-transparent.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast</code></td>
<td>
<p>Logical; should an interpolation algorithm be used instead of the
normal repulsive force function when assigning force values to grid
points? If <code>FALSE</code>, the function assigns each grid point a vowel
identity based on its nearest neighbor and assigns a color value
based on the repulsive force that would occur for a vowel at that
location (if it had existed in the dataset). If <code>TRUE</code>, the
function performs a Delaunay triangulation of the vowel space using
the vowel points in the dataset, and then uses Juan Pineda's triangle
filling algorithm to interpolate force values for grid points inside
the triangles. This method is fast even at high resolutions, but may
appear discontinuous at the edges of adjacent triangles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>Vector of strings (length 2); the labels to write at each end of
the force legend color bar. Ignored if <code>heatmap.legend</code> is
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos</code></td>
<td>
<p>Vector of integers (length 2); position codes for the colorbar
labels. See the <code>pos</code> argument of <code>text</code>
for explanation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothness</code></td>
<td>
<p>Number of color steps to use when drawing the legend
colorbar. Limited by the number of colors specified in
<code>colormap</code>; values larger than <code>length(colormap)</code>
will be ignored and use <code>length(colormap)</code> instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lend</code></td>
<td>
<p>End-cap style for the individual segments of the colorbar. See
<code>par</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd</code></td>
<td>
<p>Width of the colorbar. See <code>par</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to <code>image</code> by
<code>repulsiveForceHeatmap</code>, or passed to
<code>color.scale.lines</code> by
<code>repulsiveForceHeatmapLegend</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given endpoints <code>x</code> and <code>y</code>, <code>forceHeatmapLegend</code> draws
a colorbar legend with <code>smoothness</code> number of steps using the
provided colormap (or defaults to grayscale if <code>colormap</code> is
<code>NULL</code>.</p>


<h3>Value</h3>

<p><code>repulsiveForce</code> returns the sum of the repulsive forces calculated
at each point <code>(x,y)</code>.</p>


<h3>Author(s)</h3>

<p>McCloy, Daniel <a href="mailto:drmccloy@uw.edu">drmccloy@uw.edu</a></p>


<h3>References</h3>

<p>Liljencrants, J., &amp; Lindblom, B. 1972 “Numerical simulation of vowel quality systems: The role of perceptual contrast”. <em>Language</em>, 48(4), 839-862. <a href="http://www.jstor.org/stable/411991">http://www.jstor.org/stable/411991</a>
</p>
<p>McCloy, D. R., Wright, R. A., &amp; Souza, P. E. 2014 “Talker versus dialect effects on speech intelligibility: A symmetrical study”. <em>Language and Speech</em>. <a href="http://dx.doi.org/10.1177/0023830914559234">http://dx.doi.org/10.1177/0023830914559234</a>
</p>
<p>Pineda, J. 1988 “A parallel algorithm for polygon rasterization”. <em>ACM SIGGRAPH Computer Graphics</em>, 22(4), 17-20. <a href="http://dx.doi.org/10.1145/378456.378457">http://dx.doi.org/10.1145/378456.378457</a>
</p>


<h3>See Also</h3>

<p><code>plotVowels</code></p>


<h3>Examples</h3>

<pre><code class="language-R">    require(plotrix)
    data(indoVowels)
    force &lt;- with(indo[indo$subj==indo$subj[1],], 
                  repulsiveForce(f2, f1, vowel))
    colmap &lt;- color.scale(x=0:100, cs1=c(0, 180), cs2=100, 
                          cs3=c(25, 100), color.spec='hcl')
    with(indo[indo$subj==indo$subj[1],],
        repulsiveForceHeatmap(f2, f1, type=vowel, resolution=10,
                              colormap=colmap, add=FALSE))
    xl &lt;- rep(max(range(indo$f2)), 2)
    yl &lt;- range(indo$f1) + c(abs(diff(range(indo$f1)) / 2), 0)
    repulsiveForceHeatmapLegend(xl, yl, colormap=colmap, useRaster=TRUE)
</code></pre>


</div>
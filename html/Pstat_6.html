<div class="container">

<table style="width: 100%;"><tr>
<td>ReistTrans</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Reist standardization
</h2>

<h3>Description</h3>

<p>'ReistTrans' calculates residuals (size adjusted measurements) from Reist tranformations to eliminate any variation resulting from allometric growth. There is a single regressor (one of the quantitative traits).
</p>


<h3>Usage</h3>

<pre><code class="language-R">ReistTrans(data, reg, Rp = 0, Ri = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>a dataframe with as many rows as individuals. The first column contains the name of the population to which the individual belongs, the others contain quantitative variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reg</code></td>
<td>

<p>the name (or the rank) of the variable chosen as the explanatory variable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rp</code></td>
<td>

<p>a vector containing the names of the populations to be deleted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ri</code></td>
<td>

<p>a vector containing each number of individual to be deleted. The vector Ri must contain existent individuals, each of them once.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>the data frame of adjusted variables, the column containing the quantitative trait used as a regressor being deleted.
</p>


<h3>Note</h3>

<p>dispensable quantitative measures can easily be deleted in the main functions of R.
</p>


<h3>Author(s)</h3>

<p>Blondeau Da Silva Stephane - Da Silva Anne. 
</p>


<h3>References</h3>

<p>Reist J.D., 1985. An empirical evaluation of several univariate methods that adjust for size variation in morphometric data. Canadian Journal Zoology 63, 1429-1439.
</p>
<p>Kaeuffer R. et al., 2012. Parallel and nonparallel aspects of ecological, phenotypic, and genetic divergence across replicate population pairs of lake and stream stickleback. Evolution 66(2), 402-418.
</p>
<p>He Y. et al., 2013. Morphological Variation Among Wild Populations of Chinese Rare Minnow (Gobiocypris rarus): Deciphering the Role of Evolutionary Processes. Zoological Science 30, 475-483.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(test)
names(test)[9]
ReistTrans(test,reg=9)

## The function is currently defined as
function (data, reg, Rp = 0, Ri = 0) 
{
    dat.rem.ind.pop &lt;- function(data, ind = 0, pop = 0) {
        data = as.data.frame(data)
        dat.rem.ind &lt;- function(dat, ind) {
            nb.rem.ind = length(ind)
            nb.ind = dim(dat)[1]
            for (i in 1:nb.rem.ind) dat = dat[row.names(dat)[1:(nb.ind - 
                i + 1)] != ind[i], ]
            return(dat)
        }
        dat.rem.pop &lt;- function(dat, pop) {
            nb.rem.pop = length(pop)
            for (i in 1:nb.rem.pop) dat = dat[dat[, 1] != pop[i], 
                ]
            return(dat)
        }
        if (ind[1] != 0) 
            data = dat.rem.ind(data, ind)
        if (pop[1] != 0) 
            data = dat.rem.pop(data, pop)
        return(data)
    }
    Reitra.va &lt;- function(dat, clm, re) {
        dat = dat[is.finite(dat[, re]), ]
        log.dat = dat
        mea = mean(dat[is.finite(dat[, clm]), re])
        log.dat[, clm] = log(dat[, clm], base = 10)
        log.dat[, re] = log(dat[, re], base = 10)
        mea.clm = mean(log.dat[is.finite(log.dat[, clm]), clm], 
            na.rm = TRUE)
        mea.reg = mean(log.dat[is.finite(log.dat[, clm]), re], 
            na.rm = TRUE)
        a = sum((log.dat[is.finite(log.dat[, clm]), re] - mea.reg) * 
            log.dat[is.finite(log.dat[, clm]), clm])/sum((log.dat[is.finite(log.dat[, 
            clm]), re] - mea.reg) * (log.dat[is.finite(log.dat[, 
            clm]), re] - mea.reg))
        dat[, clm] = log.dat[, clm] - a * (log.dat[, re] - log(mea, 
            base = 10))
        return(dat)
    }
    nb.var = dim(data)[2] - 1
    for (i in 1:nb.var) {
        if (names(data)[i + 1] == reg) 
            reg = i
    }
    if (is.numeric(reg) == FALSE) 
        return("reg value does not exist!")
    data = dat.rem.ind.pop(data, ind = Ri, pop = Rp)
    if (reg == 1) 
        for (i in 2:nb.var) data = Reitra.va(data, clm = i + 
            1, re = 2)
    else {
        for (i in 2:reg) data = Reitra.va(data, clm = i, re = reg + 
            1)
        if (reg &lt; nb.var) 
            for (j in (reg + 1):nb.var) data = Reitra.va(data, 
                clm = j + 1, re = reg + 1)
    }
    return(data[-(reg + 1)])
  }
</code></pre>


</div>
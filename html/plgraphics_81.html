<div class="container">

<table style="width: 100%;"><tr>
<td>plregr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Diagnostic Plots for Regr Objects</h2>

<h3>Description</h3>

<p>Diagnostic plots for fitted regression models:
Residuals versus fit (Tukey-Anscombe plot) and/or target variable
versus fit;
Absolute residuals versus fit to assess equality of error variances;
Normal Q-Q plot (for ordinary regression models);
Residuals versus leverages to identify influential observations;
Residuals versus sequence (if requested);
and residuals versus explanatory variables.
These plots are adjusted to the type of regression model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plregr(x, data = NULL, plotselect = NULL, xvar = TRUE,
  transformed = NULL, sequence = FALSE, weights = NULL,
  addcomp = NULL, smooth = 2, smooth.legend = FALSE, markextremes = NA,
  plargs = NULL, ploptions = NULL, assign = TRUE, ...)

plresx(x, data = NULL, xvar = TRUE, transformed = NULL,
  sequence = FALSE, weights = NULL,
  addcomp = NULL, smooth = 2, smooth.legend = FALSE, markextremes = NA,
  plargs = NULL, ploptions = NULL, assign = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>"regr"</code> (or also <code>lm</code> or <code>glm</code>)
object, result of a call to <code>regr()</code> from package <span class="pkg">regr</span>.
This is the only argument needed.  All others have useful defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data set where explanatory variables and the following
possible arguments are found: <code>weights, plweights, pch, plabs</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotselect</code></td>
<td>
<p>which plots should be shown? See Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xvar</code></td>
<td>
<p>if TRUE, residuals will be plotted versus all
explanatory variables (or terms, according to argument 'transformed')
in the model (<code>plregr</code> will call <code>plresx</code>).<br>
If it is a character vector, it contains the variables to be used.<br>
If it is a formula, its right hand side contains these variables.
The model formula is updated by such a formula.
Whence, the use of <code>\~{}.+</code> adds variables to those in the
model.<br>
If any variables are not be contained in the model, the argument
<code>data</code> is needed.
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>transformed</code></td>
<td>
<p>logical: should residuals be shown against
transformed explanatory variables? If <code>TRUE</code>, the variables are
transformed as implied by the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sequence</code></td>
<td>
<p>if TRUE, residuals will be plotted versus the
sequence as they appear in the data.
If another explanatory variable is monotone increasing or
decreasing, the plot is not shown, but a warning is given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>if TRUE, residuals will be plotted versus
<code>x$weights</code>. Alternatively, a vector of weights can be specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addcomp</code></td>
<td>
<p> logical: should component effects be added to
residuals for residuals versus input variables plots? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth</code></td>
<td>
<p>logical: should a smooth line be added?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.legend</code></td>
<td>
<p>When a grouping factor is used
(argument <code>smooth.group</code>, see below),
this argument determines whether and where the legend
for identifying the groups should be shown, see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>markextremes</code></td>
<td>
<p>proportion of extreme residuals to be labeled.
If all points should be labeled, let <code>markextremes=1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plargs</code></td>
<td>
<p>result of calling <code>pl.control</code>.
If <code>NULL</code>, <code>pl.control</code> will be called to generate it.
If not null, arguments given in <code>...</code> will be ignored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ploptions</code></td>
<td>
<p>list of pl options.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assign</code></td>
<td>
<p>logical: Should the plargs be stored
in the <code>pl.envir</code> environment?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Many further arguments are available to customize the plots,
see below for some of the most useful ones, and
<code>plregr.control</code> for a complete list.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Argument <code>plotselect</code> is used to determine which plots will be
shown. It should be a named vector of numbers indicating
</p>

<dl>
<dt>0</dt>
<dd>
<p>do not show</p>
</dd>
<dt>1</dt>
<dd>
<p>show without smooth</p>
</dd>
<dt>2</dt>
<dd>
<p>show with smooth (not for <code>qq</code> nor <code>leverage</code>)</p>
</dd>
<dt>3</dt>
<dd>
<p>show with smooth and smooth band (only for <code>resfit</code>
in <code>plregr</code> and in <code>plresx</code>)</p>
</dd>
</dl>
<p>The default is
<code>c( yfit=0, resfit=smdef, absresfit = NA, absresweights = NA, qq = NA,
    leverage = 2, resmatrix = 1, qqmult = 3)</code>, where
<code>smdef</code> is 3 (actually argument <code>smooth</code> of
<code>plregr.control</code> plus 1) for normal random deviations and
one less (no band) for others.
</p>
<p>Modify this vector to change the selection and the sequence in
which the plots appear.
Alternatively, provide a named vector defining all plots that should
be shown on a different level than the default indicates,
like <code>plotselect = c(resfit = 2, leverage = 1)</code>.
Adding an element <code>default = 0</code> suppresses all plots not
mentioned. This is useful to select single plots, like
<code>plotselect = c(resfit = 3, default = 0)</code>
</p>
<p>The names of <code>plotselect</code> refer to:
</p>

<dl>
<dt>yfit</dt>
<dd>
<p>response versus fitted values</p>
</dd>
<dt>resfit</dt>
<dd>
<p>residuals versus fitted values (Tukey-Anscombe plot)</p>
</dd>
<dt>absresfit</dt>
<dd>
<p>residuals versus fitted values, defaults to TRUE for
ordinary regression, FALSE for glm and others</p>
</dd>
<dt>absresweights</dt>
<dd>
<p>residuals versus weights</p>
</dd>
<dt>qq</dt>
<dd>
<p>normal Q-Q plot, defaults to TRUE for
ordinary regression, FALSE for glm and others</p>
</dd>
<dt>leverage</dt>
<dd>
<p>residuals versus leverage (hat diabgonal)</p>
</dd>
<dt>resmatrix</dt>
<dd>
<p>scatterplot matrix of residuals for
multivariate regression</p>
</dd>
<dt>qqmult</dt>
<dd>
<p>qq plot for Mahlanobis lengths versus sqrt of chisquare
quantiles.</p>
</dd>
</dl>
<p>In the 'resfit' (Tukey-Anscombe) plot, the reference line indicates
a "contour" line with constant values of the response variable,
<code class="reqn">Y=\widehat y+r=</code> constant. It has slope <code>-1</code>.
It is useful to judge whether any curvature shown by the smooth
might disappear after a nonlinear, monotone transformation of the
response.
</p>
<p>If <code>smresid</code> is true, the 'absresfit' plot uses modified
residuals: differences between the ordinary residuals and the smooth
appearing in the 'resfit' plot.
Analogously, the 'qq' plot is then based on yet another modification
of these modified residuals: they are scaled by the smoothed scale
shown in the 'absresfit' plot, after these scales have been
standardized to have a median of 0.674 (=<code>qnorm(0.75)</code>).
</p>
<p>The smoothing function used by default is <code>smoothRegr</code>,
which calls <code>loess</code>. This can be changed by setting
<code>ploptions(smooth.function=&lt;func&gt;)</code>, which must have the same
arguments as <code>smoothRegr</code>.
</p>
<p>The arguments <code>lty, lwd, colors</code> characterize how the graphical
elements in the plot are shown.
They should be three vectors of length 9 each, defining the
line types, line widths, and colors to be used for ...
</p>

<dl>
<dt>[1] </dt>
<dd>
<p>observations;</p>
</dd>
<dt>[2] </dt>
<dd>
<p>reference lines;</p>
</dd>
<dt>[3] </dt>
<dd>
<p>smooth;</p>
</dd>
<dt>[4] </dt>
<dd>
<p>simulated smooths;</p>
</dd>
<dt>[5] </dt>
<dd>
<p>component effects in plresx;</p>
</dd>
<dt>[6] </dt>
<dd>
<p>confidence bands of component effects.</p>
</dd>
</dl>
<p>In the case of <code>glm.restype="cond.quant"</code>
</p>
<dl>
<dt>[7] </dt>
<dd>
<p>(random) observations;</p>
</dd>
<dt>[8] </dt>
<dd>
<p>conditional medians;</p>
</dd>
<dt>[9] </dt>
<dd>
<p>bars showing conditional quantiles.</p>
</dd>
</dl>
<p>If smooths are shown according to groups (given in
<code>smooth.group</code>), then a legend can be required and positioned
in the respecive plots by using the argument <code>smooth.legend</code>.
If it is <code>TRUE</code>, then the legend will be placed in the
<code>"bottomright"</code> corner.
Alternatively, the corner can be specified as
"bottomright", "bottomleft", "topleft", or "topright".
A coordinate pair may also be given.
These possibilities can be used individually for each plot by
giving a named vector or a named list, where the names are
one of "yfit", "resfit", "absresfit", "absresweight", ".xvar." or
names of x variables provided by the <code>xvar</code> argument.
A component ".xvar." selects the first x variable.
</p>
<p>There is an hidden argument <code>innerrange.fit</code> that allows
for fixing an inner range for plotting the fitted values.
</p>


<h3>Value</h3>

<p>The list of the evaluations of all arguments and some more useful
items is returned invisibly.
</p>


<h3>Note</h3>

<p>This is a function under development. Future versions may behave
differently and may not be compatible with this version.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code>plregr.control, plot.lm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(LifeCycleSavings, package="datasets")
r.savings &lt;- lm(sr ~ pop15 + pop75 + dpi + ddpi, data = LifeCycleSavings)
plregr(r.savings)

## --- *transformed* linear model
data(d.blast)
r.blast &lt;-
     lm(log10(tremor) ~ location+log10(distance)+log10(charge),
          data=d.blast)
plregr(r.blast, sequence=TRUE, transformed=TRUE)
plregr(r.blast, xvar=FALSE, innerrange.fit=c(0.3,1.2))


## --- multivariate regression
data(d.fossileSamples)
r.foss &lt;-
  lm(cbind(sAngle,lLength,rWidth) ~ SST+Salinity+lChlorophyll+Region+N,
  data=d.fossileSamples)
plregr(r.foss, plotselect=c(resfit=3, resmatrix=1, qqmult=1))


## --- logistic regression
data(d.babysurvival)
rr &lt;- glm(Survival ~ Weight+Age+Apgar1, data=d.babysurvival, family=binomial)
plregr(rr, xvar= ~Weight, cex.plab=0.7, ylim=c(-5,5))
plregr(rr, condquant=FALSE)

## --- ordinal regression
if(requireNamespace("MASS")) {
data(housing, package="MASS")
rr &lt;- MASS::polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
plregr(rr, factor.show="jitter")
}
</code></pre>


</div>
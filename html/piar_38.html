<div class="container">

<table style="width: 100%;"><tr>
<td>elemental_index</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make elemental price indexes</h2>

<h3>Description</h3>

<p>Compute period-over-period (chainable) or fixed-base (direct) elemental
price indexes, with optional percent-change contributions for each
product.
</p>


<h3>Usage</h3>

<pre><code class="language-R">elemental_index(x, ...)

## Default S3 method:
elemental_index(x, ...)

## S3 method for class 'numeric'
elemental_index(
  x,
  ...,
  period = gl(1, length(x)),
  ea = gl(1, length(x)),
  weights = NULL,
  product = NULL,
  chainable = TRUE,
  na.rm = FALSE,
  contrib = FALSE,
  r = 0
)

## S3 method for class 'data.frame'
elemental_index(x, formula, ..., weights = NULL, product = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Period-over-period or fixed-base price relatives. Currently there
are methods for numeric vectors (which can be made with
<code>price_relative()</code>) and data frames.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or used by methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving
the time period associated with each price relative in <code>x</code>. The
ordering of time periods follows of the levels of <code>period</code>, to agree
with <code>cut()</code>. The default makes an index for one time period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ea</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving the
elemental aggregate associated with each price relative in <code>x</code>. The
default makes an index for one elemental aggregate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>A numeric vector of weights for the price relatives in <code>x</code>,
or something that can be coerced into one. The default is equal weights.
This is evaluated in <code>x</code> for the data frame method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>product</code></td>
<td>
<p>A character vector of product names, or something that can
be coerced into one, for each price relative in <code>x</code> when making
percent-change contributions. The default uses the names of <code>x</code>, if any;
otherwise, elements of <code>x</code> are given sequential names within each elemental
aggregate. This is evaluated in <code>x</code> for the data frame method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chainable</code></td>
<td>
<p>Are the price relatives in <code>x</code> period-over-period
relatives that are suitable for a chained calculation (the default)? This
should be <code>FALSE</code> when <code>x</code> contains fixed-base relatives.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Should missing values be removed? By default, missing values
are not removed. Setting <code>na.rm = TRUE</code> is equivalent to overall mean
imputation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrib</code></td>
<td>
<p>Should percent-change contributions be calculated? The
default does not calculate contributions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Order of the generalized mean to aggregate price relatives. 0 for a
geometric index (the default for making elemental indexes), 1 for an
arithmetic index (the default for aggregating elemental indexes and
averaging indexes over subperiods), or -1 for a harmonic index (usually for
a Paasche index). Other values are possible; see
<code>gpindex::generalized_mean()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A two-sided formula with price relatives on the left-hand
side, and time periods and elemental aggregates (in that order) on the
right-hand side.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When supplied with a numeric vector, <code>elemental_index()</code> is a simple
wrapper that applies
<code>gpindex::generalized_mean(r)()</code> and
<code>gpindex::contributions(r)()</code> (if <code>contrib = TRUE</code>)
to <code>x</code> and <code>weights</code> grouped by <code>ea</code> and <code>period</code>. That
is, for every combination of elemental aggregate and time period,
<code>elemental_index()</code> calculates an index based on a generalized mean of
order <code>r</code> and, optionally, percent-change contributions. Product names should
be unique within each time period when making contributions, and, if not, are
passed to <code>make.unique()</code> with a warning. The default
(<code>r = 0</code> and no weights) makes Jevons elemental indexes. See chapter 8
(pp. 175â€“190) of the CPI manual (2020) for more detail about making
elemental indexes, and chapter 5 of Balk (2008).
</p>
<p>The default method simply coerces <code>x</code> to a numeric vector prior to
calling the method above. The data frame method provides a formula interface
to specify columns of price relatives, time periods, and elemental
aggregates and call the method above.
</p>
<p>The interpretation of the index depends on how the price relatives in
<code>x</code> are made. If these are period-over-period relatives, then the
result is a collection of period-over-period (chainable) elemental indexes;
if these are fixed-base relatives, then the result is a collection of
fixed-base (direct) elemental indexes. For the latter, <code>chainable</code>
should be set to <code>FALSE</code> so that no subsequent methods assume that a
chained calculation should be used.
</p>
<p>By default, missing price relatives in <code>x</code> will propagate throughout
the index calculation. Ignoring missing values with <code>na.rm = TRUE</code> is
the same as overall mean (parental) imputation, and needs to be explicitly
set in the call to <code>elemental_index()</code>. Explicit imputation of missing
relatives, and especially imputation of missing prices, should be done prior
to calling <code>elemental_index()</code>.
</p>
<p>Indexes based on nested generalized means, like the Fisher index (and
superlative quadratic mean indexes more generally), can be calculated by
supplying the appropriate weights with <code>gpindex::nested_transmute()</code>; see the
example below. It is important to note that there are several ways to
make these weights, and this affects how percent-change contributions
are calculated.
</p>


<h3>Value</h3>

<p>A price index that inherits from <code>piar_index</code>. If
<code>chainable = TRUE</code> then this is a period-over-period index that also
inherits from <code>chainable_piar_index</code>; otherwise, it is a
fixed-based index that inherits from <code>direct_piar_index</code>.
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>IMF, ILO, OECD, Eurostat, UNECE, and World Bank. (2020).
<em>Consumer Price Index Manual: Concepts and Methods</em>.
International Monetary Fund.
</p>
<p>von der Lippe, P. (2007). <em>Index Theory and Price Statistics</em>. Peter Lang.
</p>


<h3>See Also</h3>

<p><code>price_relative()</code> for making price relatives for the same products over
time, and <code>carry_forward()</code> and <code>shadow_price()</code> for
imputation of missing prices.
</p>
<p><code>as_index()</code> to turn pre-computed (elemental) index values into an
index object.
</p>
<p><code>chain()</code> for chaining period-over-period indexes, and
<code>rebase()</code> for rebasing an index.
</p>
<p><code>aggregate()</code> to aggregate elemental indexes
according to an aggregation structure.
</p>
<p><code>as.matrix()</code> and
<code>as.data.frame()</code> for coercing an index
into a tabular form.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(gpindex)

prices &lt;- data.frame(
  rel = 1:8,
  period = rep(1:2, each = 4),
  ea = rep(letters[1:2], 4)
)

# Calculate Jevons elemental indexes

elemental_index(prices, rel ~ period + ea)

# Same as using lm() or tapply()

exp(coef(lm(log(rel) ~ ea:factor(period) - 1, prices)))

with(
  prices,
  t(tapply(rel, list(period, ea), geometric_mean, na.rm = TRUE))
)

# A general function to calculate weights to turn the geometric
# mean of the arithmetic and harmonic mean (i.e., Fisher mean)
# into an arithmetic mean

fw &lt;- grouped(nested_transmute(0, c(1, -1), 1))

# Calculate a CSWD index (same as the Jevons in this example)
# as an arithmetic index by using the appropriate weights

elemental_index(
  prices,
  rel ~ period + ea,
  weights = fw(rel, group = interaction(period, ea)),
  r = 1
)

</code></pre>


</div>
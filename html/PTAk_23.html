<div class="container">

<table style="width: 100%;"><tr>
<td>preprocessings</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Few useful functions for preprocessing arrays </h2>

<h3>Description</h3>

<p>Choices of centering or detrending  and scaling are important preprocessings for multiway analysis.</p>


<h3>Usage</h3>

<pre><code class="language-R">Multcent(dat,bi=c(1,2),by=3,
          centre=mean,
           centrebyBA=c(TRUE,FALSE),scalebyBA=c(TRUE,FALSE))
IterMV(n=10,dat,Mm=c(1,3),Vm=c(2,3),
               fFUN=mean,usetren=FALSE,
                  tren=function(x)smooth.spline(as.vector(x),df=5)$y,
                   rsd=TRUE)
Detren(dat,Mm=c(1,3),rsd=TRUE,
         tren=function(x)smooth.spline(as.vector(x),df=5)$y )
Susan1D(y,x=NULL,sigmak=NULL,sigmat=NULL,
          ker=list(function(u)return(exp(-0.5*u**2))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>array</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bi</code></td>
<td>
<p>vector defining the "centering, bicentering or multi-centering" one wants
to operate crossed with <code>by</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>number or vector defining the entries used "with" in
the other operations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centre</code></td>
<td>
<p>function used as <code>FUN</code> in applying
"multi-centering"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centrebyBA</code></td>
<td>
<p>a bolean vector for "centering" with <code>centre</code> Before and After
according to <code>by</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scalebyBA</code></td>
<td>
<p>idem as centrebyBA, for scaling operation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of iterations between "centering" and scaling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mm</code></td>
<td>
<p>margins to performs <code>Detren</code> or <code>fFUN</code> on</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vm</code></td>
<td>
<p>margins to scale</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fFUN</code></td>
<td>
<p>function to use as <code>FUN</code> if <code>usetren</code> is
<code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>usetren</code></td>
<td>
<p>logical, to use <code>Detren</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tren</code></td>
<td>
<p>function to use in <code>Detren</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rsd</code></td>
<td>
<p>logical passed into <code>Detren</code> (only) to detrend or not</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>vector (length <code>n</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector of same length, if <code>NULL</code> it is <code>1:n</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmak</code></td>
<td>
<p>parameter related to kernel bandwidth with <code>y</code>
values (default is <code>1/2*range</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmat</code></td>
<td>
<p>parameter related to kernel bandwidth with  <code>x</code>
values (default value is <code>8*n^{-1/5}</code>, with a minimum number of
neigbours set as one apart)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ker</code></td>
<td>
<p>a list of two kernels <code>list("t"=function "k"=function
      ) </code> for each weightings (if only one given it is used for
both)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>Multcent</code> performs in order "centering" by <code>by</code>;
"multicentering" for every <code>bi</code> with <code>by</code>; then scale
(standard deviation) to one by <code>by</code>.
</p>
<p><code>IterMV</code> performs an iterative "detrending" and scaling
according to te margins defined (see Leibovici(2000) and references
in it).
</p>
<p><code>Detren</code> detrends (or smooths if <code>rsd</code> is <code>FALSE</code>)
the data accoding to th margins given.
</p>
<p><code>Susan1D</code> performs a non-linear kernel smoothing  of <code>y</code>
against <code>x</code> (both reordered in the function according to orders
of <code>x</code>) with an usual kernel (<code>t</code>) as for kernel
regression and a kernel (<code>t</code>) for the values of <code>y</code> (the
product of the kernels constitutes the non-linear weightings. This
function is adapted from SUSAN algorithm (see references).
</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Smith S.M. and J.M. Brady (1997) <em>SUSAN - a new approach to low level image processing</em>.
International Journal of Computer Vision, 23(1):45-78, May 1997.
</p>


</div>
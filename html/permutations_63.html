<div class="container">

<table style="width: 100%;"><tr>
<td>fbin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
The fundamental bijection
</h2>

<h3>Description</h3>

<p>Stanley defines the <dfn>fundamental bijection</dfn> on page 30. 
</p>
<p>Given <code class="reqn">w=(14)(2)(375)(6)</code>, Stanley writes it in standard form
(specifically: each cycle is written with its largest element first;
cycles are written in increasing order of their largest element).  Thus
we obtain <code class="reqn">(2)(41)(6)(753)</code>.
</p>
<p>Then we obtain <code class="reqn">w^*</code> from <code class="reqn">w</code> by writing it in standard form
an erasing the parentheses (that is, viewing the numbers as a
<em>word</em>); here <code class="reqn">w^*=2416753</code>.
</p>
<p>Given this, <code class="reqn">w</code> may be recovered by inserting a left parenthesis
preceding every left-to-right maximum, and right parentheses where
appropriate.
</p>
<p>Function <code>standard()</code> takes an object of class <code>cycle</code> and
returns a list of cyclists.  NB this does not return an object of class
“cycle” because <code>cycle()</code> calls <code>nicify()</code>.
</p>
<p>Function <code>standard_cyclist()</code> retains length-one cycles (compare
<code>nicify_cyclist()</code>, which does not).
</p>


<h3>Usage</h3>

<pre><code class="language-R">standard(cyc,n=NULL)
standard_cyclist(x,n=NULL)
fbin_single(vec)
fbin(W)
fbin_inv(cyc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>vec</code></td>
<td>
<p>In function <code>fbin_single()</code>, an integer vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>In functions <code>fbin()</code> and <code>fbin_inv()</code>, an object
of class permutation, coerced to word and cycle form respectively</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cyc</code></td>
<td>
<p>In functions <code>fbin_single()</code> and <code>standard()</code>,
permutation object coerced to cycle form</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>In function <code>standard()</code> and <code>standard_cyclist()</code>,
size of the partition to assume, with default <code>NULL</code> meaning to
use the largest element of any cycle</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>In function <code>standard_cyclist()</code>, a cyclist</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The user-friendly functions are <code>fbin()</code> and <code>fbin_inv()</code>
which perform Stanley's “fundamental bijection”.  Function
<code>fbin()</code> takes a word object and returns a cycle; function
<code>fbin_inv()</code> takes a cycle and returns a word.
</p>
<p>The other functions are low-level helper functions that are not really
intended for the user (except possibly <code>standard()</code>, which puts a
cycle object in standard order in list form).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>References</h3>

<p>R. P. Stanley 2011 <em>Enumerative Combinatorics</em>
</p>


<h3>See Also</h3>

<p><code>nicify_cyclist</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
# Stanley's example w:
standard(cycle(list(list(c(1,4),c(3,7,5)))))

standard_cyclist(list(c(4, 6), c(7), c(2, 5, 1), c(8, 3)))


w_hat &lt;- c(2,4,1,6,7,5,3)

fbin(w_hat)
fbin_inv(fbin(w_hat))


x &lt;- rperm(40,9)
stopifnot(all(fbin(fbin_inv(x))==x))
stopifnot(all(fbin_inv(fbin(x))==x))

</code></pre>


</div>
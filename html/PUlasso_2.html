<div class="container">

<table style="width: 100%;"><tr>
<td>cv.grpPUlasso</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation for PUlasso</h2>

<h3>Description</h3>

<p>Do a n-fold cross-validation for PUlasso.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.grpPUlasso(
  X,
  z,
  py1,
  initial_coef = NULL,
  group = 1:p,
  penalty = NULL,
  lambda = NULL,
  nlambda = 100,
  lambdaMinRatio = ifelse(N &lt; p, 0.05, 0.005),
  maxit = ifelse(method == "CD", 1000, N * 10),
  weights = NULL,
  eps = 1e-04,
  inner_eps = 0.01,
  verbose = FALSE,
  stepSize = NULL,
  stepSizeAdjustment = NULL,
  batchSize = 1,
  updateFrequency = N,
  samplingProbabilities = NULL,
  method = c("CD", "GD", "SGD", "SVRG", "SAG"),
  nfolds = 10,
  fitInd = 1:nfolds,
  nCores = 1,
  trace = c("none", "param", "fVal", "all")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Input matrix; each row is an observation. Can be a matrix or a sparse matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>Response vector representing whether an observation is labeled or unlabeled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>py1</code></td>
<td>
<p>True prevalence Pr(Y=1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_coef</code></td>
<td>
<p>A vector representing an initial point where we start PUlasso algorithm from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>A vector representing grouping of the coefficients. For the least ambiguity, it is recommended if group is provided in the form of vector of consecutive ascending integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>penalty to be applied to the model. Default is sqrt(group size) for each of the group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied sequence of lambda values. If unspecified, the function automatically generates its own lambda sequence based on nlambda and lambdaMinRatio.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of lambda values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaMinRatio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of lambda.max which leads to the intercept only model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>observation weights. Default is 1 for each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Convergence threshold for the outer loop. The algorithm iterates until the maximum change in coefficients is less than eps in the outer loop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inner_eps</code></td>
<td>
<p>Convergence threshold for the inner loop. The algorithm iterates until the maximum change in coefficients is less than eps in the inner loop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical value. if TRUE, the function prints out the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepSize</code></td>
<td>
<p>A step size for gradient-based optimization. if NULL, a step size is taken to be stepSizeAdj/mean(Li) where Li is a Lipschitz constant for ith sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepSizeAdjustment</code></td>
<td>
<p>A step size adjustment. By default, adjustment is 1 for GD and SGD, 1/8 for SVRG and 1/16 for SAG.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batchSize</code></td>
<td>
<p>A batch size. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>updateFrequency</code></td>
<td>
<p>An update frequency of full gradient for method =="SVRG"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplingProbabilities</code></td>
<td>
<p>sampling probabilities for each of samples for stochastic gradient-based optimization. if NULL, each sample is chosen proportionally to Li.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Optimization method. Default is Coordinate Descent. CD for Coordinate Descent, GD for Gradient Descent, SGD for Stochastic Gradient Descent, SVRG for Stochastic Variance Reduction Gradient, SAG for Stochastic Averaging Gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>Number of cross-validation folds to be created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitInd</code></td>
<td>
<p>A vector of indices of cross-validation models which will be fitted. Default is to fit the model for each of the cross-validation fold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nCores</code></td>
<td>
<p>Number of threads to be used for parallel computing. If nCores=0, it is set to be (the number of processors available-1) . Default value is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>An option for saving intermediate quantities when fitting a full dataset.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>cvm Mean cross-validation error
</p>
<p>cvsd Estimate of standard error of cvm
</p>
<p>cvcoef Coefficients for each of the fitted CV models
</p>
<p>cvstdcoef Coefficients in a standardized scale for each of the fitted CV models
</p>
<p>lambda The actual sequence of lambda values used.
</p>
<p>lambda.min Value of lambda that gives minimum cvm.
</p>
<p>lambda.1se The largest value of lambda such that the error is within 1 standard error of the minimum cvm.
</p>
<p>PUfit A fitted PUfit object for the full data
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("simulPU")
fit&lt;-cv.grpPUlasso(X=simulPU$X,z=simulPU$z,py1=simulPU$truePY1)
</code></pre>


</div>
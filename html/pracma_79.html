<div class="container">

<table style="width: 100%;"><tr>
<td>cutpoints</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Find Cutting Points
</h2>

<h3>Description</h3>

<p>Finds cutting points for vector s of real numbers.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cutpoints(x, nmax = 8, quant = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector of real values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmax</code></td>
<td>
<p>the maximum number of cutting points to choose</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quant</code></td>
<td>
<p>quantile of the gaps to consider for cuts.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Finds cutting points for vector s of real numbers, based on the gaps in
the values of the vector. The number of cutting points is derived from a
quantile of gaps in the values. The user can set a lower limit for this
number of gaps.
</p>


<h3>Value</h3>

<p>Returns a list with components <code>cutp</code>, the cutting points selected,
and <code>cutd</code>, the gap between values of <code>x</code> at this cutting point.
</p>


<h3>Note</h3>

<p>Automatically finding cutting points is often requested in Data Mining.
If a target attribute is available, Quinlan's C5.0 does a very good job
here. Unfortunately, the ‘C5.0’ package (of the R-Forge project “Rulebased
Models”) is quite cumbersome to use.
</p>


<h3>References</h3>

<p>Witten, I. H., and E. Frank (2005). Data Mining: Practical Machine
Learning Tools and Techniques. Morgan Kaufmann Publishers, San Francisco.
</p>


<h3>See Also</h3>

<p><code>cut</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">N &lt;- 100; x &lt;- sort(runif(N))
cp &lt;- cutpoints(x, 6, 0.9)
n &lt;- length(cp$cutp)

# Print out
nocp &lt;- rle(findInterval(x, c(-Inf, cp$cutp, Inf)))$lengths
cbind(c(-Inf, cp$cutp), c(cp$cutp, Inf), nocp)

# Define a factor from the cutting points
fx &lt;- cut(x, breaks = c(-Inf, cp$cutp, Inf))

## Not run: 
# Plot points and cutting points
plot(x, rep(0, N), col="gray", ann = FALSE)
points(cp$cutp, rep(0, n), pch="|", col=2)

# Compare with k-means clustering
km &lt;- kmeans(x, n)
points(x, rep(0, N), col = km$cluster, pch = "+")

##  A 2-dimensional example
x &lt;- y &lt;- c()
for (i in 1:9) {
  for (j in 1:9) {
    x &lt;- c(x, i + rnorm(20, 0, 0.2))
    y &lt;- c(y, j + rnorm(20, 0, 0.2))
  }
}
cpx &lt;- cutpoints(x, 8, 0)
cpy &lt;- cutpoints(y, 8, 0)

plot(x, y, pch = 18, col=rgb(0.5,0.5,0.5), axes=FALSE, ann=FALSE)
for (xi in cpx$cutp) abline(v=xi, col=2, lty=2)
for (yi in cpy$cutp) abline(h=yi, col=2, lty=2)

km &lt;- kmeans(cbind(x, y), 81)
points(x, y, col=km$cluster)

## End(Not run)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>project</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Project population dynamics</h2>

<h3>Description</h3>

<p>Project dynamics of a specified population matrix projection model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">project(
  A,
  vector = "n",
  time = 100,
  standard.A = FALSE,
  standard.vec = FALSE,
  return.vec = TRUE,
  Aseq = "unif",
  Astart = NULL,
  draws = 1000,
  alpha.draws = "unif",
  PREcheck = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a matrix, or list of matrices. If <code>A</code> is a matrix, then 
<code>project</code> performs a 'deterministic' projection, where the matrix
does not change with each timestep. If <code>A</code> is a list of matrices, then 
<code>project</code> performs a 'stochastic' projection where the matrix varies 
with each timestep. The sequence of matrices is determined using <code>Aseq</code>. 
Matrices must be square, non-negative and numeric. If <code>A</code> is a list, 
all matrices must have the same dimension. 'Projection' objects inherit
names from <code>A</code>: if <code>A</code> is a matrix, stage names (in mat and 
vec slots) are inherited from its column names..</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vector</code></td>
<td>
<p>(optional) a numeric vector or matrix describing 
the age/stage distribution(s) used to calculate the projection. Single
population vectors can be given either as a numeric vector or 
one-column matrix. Multiple vectors are specified as a matrix, where 
each column describes a single population vector. Therefore the number
of rows of the matrix should be equal to the matrix dimension, whilst the 
number of columns gives the number of vectors to project. <code>vector</code> may
also take either "n" (default) to calculate the set of stage-biased projections 
(see details), or "diri" to project random population vectors drawn from a 
dirichlet distribution (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>the number of projection intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standard.A</code></td>
<td>
<p>(optional) if <code>TRUE</code>, scales each matrix in <code>A</code>
by dividing all elements by the dominant eigenvalue. This standardises 
asymptotic dynamics: the dominant eigenvalue of the scaled matrix is 1. 
Useful for assessing transient dynamics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standard.vec</code></td>
<td>
<p>(optional) if <code>TRUE</code>, standardises each <code>vector</code> 
to sum to 1, by dividing each vector by its sum. Useful for assessing projection
relative to initial population size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.vec</code></td>
<td>
<p>(optional) if <code>TRUE</code>, returns the time series of 
demographic (st)age vectors as well as overall population size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Aseq</code></td>
<td>
<p>(optional, for stochastic projections only) the sequence of 
matrices in a stochastic projection. 
<code>Aseq</code> may be either:
</p>

<ul>
<li>
<p> "unif" (default), which results in every matrix in <code>A</code> having an 
equal, random chance of being chosen at each timestep.
</p>
</li>
<li>
<p> a square, nonnegative left-stochastic matrix describing a first-order 
Markov chain used to choose the matrices. The transitions are defined COLUMNWISE: 
each column j describes the probability of choosing stage (row) i at time t+1, 
given that stage (column) j was chosen at time t. <code>Aseq</code>  should have the 
same dimension as the number of matrices in <code>A</code>. 
</p>
</li>
<li>
<p> a numeric vector giving a specific sequence which corresponds to the
matrices in <code>A</code>.
</p>
</li>
<li>
<p> a character vector giving a specific sequence which corresponds to the
names of the matrices in <code>A</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Astart</code></td>
<td>
<p>(optional) in a stochastic projection, the matrix with which to
initialise the projection (either numeric, corresponding to the matrices in 
<code>A</code>, or character, corresponding to the names of matrices in <code>A</code>). 
When <code>Astart = NULL</code> (the default), a random initial matrix is chosen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>draws</code></td>
<td>
<p>if <code>vector="diri"</code>, the number of population vectors drawn
from dirichlet.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.draws</code></td>
<td>
<p>if <code>vector="diri"</code>, the alpha values passed to 
<code>rdirichlet</code>: used to bias draws towards or away from a certain population
structure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PREcheck</code></td>
<td>
<p>many functions in <code>popdemo</code> first check Primitivity, 
Reducibility and/or Ergodicity of matrices, with associated warnings and/or 
errors if a matrix breaks any assumptions. Set <code>PREcheck=FALSE</code> if you
want to bypass these checks.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>vector</code> is specified, <code>project</code> will calculate population 
dynamics through time by projecting this vector / these vectors through 
<code>A</code>. If multiple vectors are specified, a separate population projection
is calculated for each.
</p>
<p>If <code>vector="n"</code>, <code>project</code> will automatically project the set of 
'stage-biased' vectors of <code>A</code>. Effectively, each vector is a population
consisting of all individuals in one stage. These projections are achieved using a 
set of standard basis vectors equal in number to the dimension of <code>A</code>.
The vectors have every element equal to 0, except for a single element equal to 1,  
i.e. for a matrix of dimension 3, the set of stage-biased vectors are: 
<code>c(1,0,0)</code>, <code>c(0,1,0)</code> and <code>c(0,0,1)</code>. Stage-biased projections are 
useful for seeing how extreme transient dynamics can be.
</p>
<p>If <code>vector="diri"</code>, <code>project</code> draws random population vectors from 
the dirichlet distribution. <code>draws</code> gives the number of population vectors
to draw. <code>alpha.draws</code> gives the parameters for the dirichlet and can be
used to bias the draws towards or away from certain population structures.
The default is <code>alpha.draws="unif"</code>, which passes <code>rep(1,dim)</code> (where
dim is the dimension of the matrix), resulting in an equal probability of 
any random population vector. Relative values in the vector give the population
structure to focus the distribution on, and the absolute value of the vector
entries (and their sum) gives the strength of the distribution: values greater
than 1 make it more likely to draw from nearby that population structure, 
whilst values less than 1 make it less likely to draw from nearby that population
structure.
</p>
<p>Projections returned are of length <code>time+1</code>, as the first element 
represents the population at <code>t=0</code>.
</p>
<p>Projections have their own plotting method (see <code>Projection-plots</code>)
to enable easy graphing.
</p>
<p>In addition to the examples below, see the "Deterministic population dynamics" 
and "Stochastic population dynamics" vignettes for worked examples that use 
the <code>project</code> function.
</p>


<h3>Value</h3>

<p>A <code>Projection-class</code> item. 
'Projection' objects inherit from a standard array, and can be treated as 
such. Therefore, if if <code>vector</code> is specified, the 'Projection' object will 
behave as: 
</p>

<ul>
<li>
<p> if a single <code>vector</code> is given, a numeric vector of population sizes 
of length <code>time+1</code>
</p>
</li>
<li>
<p> if multiple <code>vector</code>s are given, a numeric matrix of population 
projections where each column represents a single population projection and 
is of length <code>time+1</code>
</p>
</li>
<li>
<p> if <code>vector="n"</code>, a numeric matrix of population projections where each column 
represents a single stage-biased projection and is of length <code>time+1</code>.
</p>
</li>
<li>
<p> if <code>vector="diri"</code>, a numeric matrix of population projections where each 
column represents projection of a single vector draw and each column is of 
length <code>time+1</code>
</p>
</li>
</ul>
<p>See documentation on <code>Projection-class</code> objects to understand how 
to access other slots (e.g. (st)age vectors through the population projection) 
and for S4 methods (e.g. plotting projections).
Some examples for understanding the structure of 3D arrays returned when 
<code>return.vec=TRUE</code>: when projecting a 3 by 3 matrix for &gt;10 time intervals 
(see examples), element [11,3,2] represents the density of stage 3 at time 10 
for either vector 2 (multiple vectors), stage-bias 2 (<code>vector="n"</code>) or draw 2 
(<code>vector="diri"</code>); note that because element 1 represents t=0, then t=10 
is found at element 11. The vector [,3,2] represents the time series of densities 
of stage 3 in the projection of vector 2 / stage-bias 2 / draw 2. The matrix [,,2] 
represents the time series of all stages in the projection of vector 2 / stage-bias 
2 / draw 2.
</p>
<p>Note that the projections inherit the labelling from <code>A</code> and <code>vector</code>, if
it exists. Both stage and vector names are taken from the COLUMN names of <code>A</code> 
and <code>vector</code> respectively. These may be useful for selecting from the
<code>projection</code> object, and for labelling graphs when plotting Projection
objects.
</p>


<h3>See Also</h3>

<p><code>Projection-class</code> <code>Projection-plots</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  ### USING PROJECTION OBJECTS

  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Project stage-biased dynamics of A over 70 intervals
  ( pr &lt;- project(A, vector="n", time=70) )
  plot(pr)

  # Access other slots
  vec(pr)  #time sequence of population vectors
  bounds(pr)  #bounds on population dynamics
  mat(pr)  #matrix used to create projection
  Aseq(pr)  #sequence of matrices (more useful for stochastic projections)
  projtype(pr)  #type of projection
  vectype(pr)  #type of vector(s) initiating projection

  # Extra information on the projection
  nproj(pr)  #number of projections
  nmat(pr)  #number of matrices (more usefulk for stochastic projections)
  ntime(pr)  #number of time intervals
  
  # Select the projection of stage 2 bias
  pr[,2]

  # Project stage-biased dynamics of standardised A over 30 intervals
  ( pr2 &lt;- project(A, vector="n", time=30, standard.A=TRUE) )
  plot(pr2)

  #Select the projection of stage 2 bias
  pr2[,2]

  # Select the density of stage 3 in bias 2 at time 10
  vec(pr2)[11,3,2]

  # Select the time series of densities of stage 2 in bias 1
  vec(pr2)[,2,1]

  #Select the matrix of population vectors for bias 2
  vec(pr2)[,,2]

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Project A over 50 intervals using a specified population structure
  ( pr3 &lt;- project(A, vector=initial, time=50) )
  plot(pr3)

  # Project standardised dynamics of A over 10 intervals using 
  # standardised initial structure and return demographic vectors
  ( pr4 &lt;- project(A, vector=initial, time=10, standard.vec=TRUE, 
                   standard.A=TRUE, return.vec=TRUE) )
  plot(pr4)

  # Select the time series for stage 1
  vec(pr4)[,1]

  ### DETERMINISTIC PROJECTIONS

  # Load the desert Tortoise matrix
  data(Tort)

  # Create an initial stage structure
  Tortvec1 &lt;- c(8, 7, 6, 5, 4, 3, 2, 1)
  
  # Create a projection over 30 time intervals
  ( Tortp1 &lt;- project(Tort, vector = Tortvec1, time = 10) )

  # plot p1
  plot(Tortp1)
  plot(Tortp1, bounds = TRUE) #with bounds
 
  # new display parameters
  plot(Tortp1, bounds = TRUE, col = "red", bty = "n", log = "y", 
       ylab = "Number of individuals (log scale)",
       bounds.args = list(lty = 2, lwd = 2) )

  # multiple vectors
  Tortvec2 &lt;- cbind(Tortvec1, c(1, 2, 3, 4, 5, 6, 7, 8))
  plot(project(Tort, vector = Tortvec2), log = "y")
  plot(project(Tort, vector = Tortvec2), log = "y", labs = FALSE) #no labels

  # dirichlet distribution 
  # darker shading indicates more likely population size
  Tortshade &lt;- project(Tort, time = 30, vector = "diri", standard.A = TRUE,
               draws = 500, alpha.draws = "unif")
  plot(Tortshade, plottype = "shady", bounds = TRUE)
  
  ### STOCHASTIC PROJECTIONS
  # load polar bear data
  data(Pbear)
  
  # project over 50 years with uniform matrix selection
  Pbearvec &lt;- c(0.106, 0.068, 0.106, 0.461, 0.151, 0.108)
  p2 &lt;- project(Pbear, Pbearvec, time = 50, Aseq = "unif")

  # stochastic projection information
  Aseq(p2)
  projtype(p2)
  nmat(p2)
  
  # plot
  plot(p2, log = "y")
  
</code></pre>


</div>
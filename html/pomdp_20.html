<div class="container">

<table style="width: 100%;"><tr>
<td>gridworld</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Helper Functions for Gridworld MDPs</h2>

<h3>Description</h3>

<p>Helper functions for gridworld MDPs to convert between state names and
gridworld positions, and for visualizing policies.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gridworld_init(
  dim,
  action_labels = c("up", "right", "down", "left"),
  unreachable_states = NULL,
  absorbing_states = NULL,
  labels = NULL
)

gridworld_maze_MDP(
  dim,
  start,
  goal,
  walls = NULL,
  action_labels = c("up", "right", "down", "left"),
  goal_reward = 1,
  step_cost = 0,
  restart = FALSE,
  discount = 0.9,
  horizon = Inf,
  info = NULL,
  name = NA
)

gridworld_s2rc(s)

gridworld_rc2s(rc)

gridworld_matrix(model, epoch = 1L, what = "states")

gridworld_plot_policy(
  model,
  epoch = 1L,
  actions = "character",
  states = FALSE,
  labels = TRUE,
  absorbing_state_action = FALSE,
  main = NULL,
  cex = 1,
  offset = 0.5,
  lines = TRUE,
  ...
)

gridworld_plot_transition_graph(
  x,
  hide_unreachable_states = TRUE,
  remove.loops = TRUE,
  vertex.color = "gray",
  vertex.shape = "square",
  vertex.size = 10,
  vertex.label = NA,
  edge.arrow.size = 0.3,
  margin = 0.2,
  main = NULL,
  ...
)

gridworld_animate(x, method, n, zlim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>vector of length two with the x and y extent of the gridworld.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>action_labels</code></td>
<td>
<p>vector with four action labels that move the agent up, right, down,
and left.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unreachable_states</code></td>
<td>
<p>a vector with state labels for unreachable states.
These states will be excluded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>absorbing_states</code></td>
<td>
<p>a vector with state labels for absorbing states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>logical; show state labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start, goal</code></td>
<td>
<p>labels for the start state and the goal state.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>walls</code></td>
<td>
<p>a vector with state labels for walls. Walls will
become unreachable states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>goal_reward</code></td>
<td>
<p>reward to transition to the goal state.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step_cost</code></td>
<td>
<p>cost of each action that does not lead to the goal state.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restart</code></td>
<td>
<p>logical; if <code>TRUE</code> then the problem automatically restarts when
the agent reaches the goal state.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discount, horizon</code></td>
<td>
<p>MDP discount factor, and horizon.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>A list with additional information. Has to contain the gridworld
dimensions as element <code>gridworld_dim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>a string to identify the MDP problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>a state label.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rc</code></td>
<td>
<p>a vector of length two with the row and column coordinate of a
state in the gridworld matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model, x</code></td>
<td>
<p>a solved gridworld MDP.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epoch</code></td>
<td>
<p>epoch for unconverged finite-horizon solutions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>What should be returned in the matrix. Options are:
<code>"states"</code>, <code>"labels"</code>, <code>"values"</code>, <code>"actions"</code>, <code>"absorbing"</code>, and
<code>"reachable"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>actions</code></td>
<td>
<p>how to show actions. Options are:
simple <code>"character"</code>, <code>"unicode"</code> arrows (needs to be supported by the used font),
<code>"label"</code> of the action, and  <code>"none"</code> to suppress showing the action.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>states</code></td>
<td>
<p>logical; show state names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>absorbing_state_action</code></td>
<td>
<p>logical; show the value and the action for absorbing states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>a main title for the plot. Defaults to the name of the problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex</code></td>
<td>
<p>expansion factor for the action.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>move the state labels out of the way (in fractions of a character width).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lines</code></td>
<td>
<p>logical; draw lines to separate states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments are passed on to <code>igraph::plot.igraph()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hide_unreachable_states</code></td>
<td>
<p>logical; do not show unreachable states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove.loops</code></td>
<td>
<p>logical; do not show transitions from a state back to itself.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertex.color, vertex.shape, vertex.size, vertex.label, edge.arrow.size</code></td>
<td>
<p>see <code>igraph::igraph.plotting</code> for details. Set <code>vertex.label = NULL</code> to show the
state labels on the graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margin</code></td>
<td>
<p>a single number specifying the margin of the plot. Can be used if the
graph does not fit inside the plotting area.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a MDP solution method for <code>solve_MDP()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of iterations to animate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zlim</code></td>
<td>
<p>limits for visualizing the state value.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Gridworlds are implemented with state names <code>s(row,col)</code>, where
<code>row</code> and <code>col</code> are locations in the matrix representing the gridworld.
The actions are <code>"up"</code>, <code>"right"</code>,  <code>"down"</code>, and  <code>"left"</code>.
</p>
<p><code>gridworld_init()</code> initializes a new gridworld creating a matrix
of states with the given dimensions. Other action names
can be specified, but they must have the same effects in the same order
as above. Unreachable states (walls) and absorbing state can be defined.
This information can be used to build a custom gridworld MDP.
</p>
<p>Several helper functions are provided
to use states, look at the state layout, and plot policies on the
gridworld.
</p>
<p><code>gridworld_maze_MDP()</code> helps to easily define maze-like gridworld MDPs.
By default, the goal state is absorbing, but with <code>restart = TRUE</code>, the
agent restarts the problem at the start state every time it reaches the goal
and receives the reward. Note that this implies that the goal state itself
becomes unreachable.
</p>
<p><code>gridworld_animate()</code> applies algorithms from <code>solve_MDP()</code> iteration
by iteration and visualized the state utilities. This helps to understand
how the algorithms work.
</p>


<h3>See Also</h3>

<p>Other gridworld: 
<code>Cliff_walking</code>,
<code>Maze</code>,
<code>Windy_gridworld</code>
</p>
<p>Other MDP: 
<code>MDP()</code>,
<code>MDP2POMDP</code>,
<code>MDP_policy_functions</code>,
<code>accessors</code>,
<code>actions()</code>,
<code>add_policy()</code>,
<code>reachable_and_absorbing</code>,
<code>regret()</code>,
<code>simulate_MDP()</code>,
<code>solve_MDP()</code>,
<code>transition_graph()</code>,
<code>value_function()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Defines states, actions and a transition model for a standard gridworld
gw &lt;- gridworld_init(dim = c(7,7),
                unreachable_states = c("s(2,2)", "s(7,3)", "s(3,6)"),
                absorbing_states = "s(4,4)",
                labels = list("s(4,4)" = "Black Hole")
                )

gw$states
gw$actions
gw$info

# display the state labels in the gridworld
gridworld_matrix(gw)
gridworld_matrix(gw, what = "label")
gridworld_matrix(gw, what = "reachable")
gridworld_matrix(gw, what = "absorbing")

# a transition function for regular moves in the gridworld is provided
gw$transition_prob("right", "s(1,1)", "s(1,2)")
gw$transition_prob("right", "s(2,1)", "s(2,2)")  ### we cannot move into an unreachable state
gw$transition_prob("right", "s(2,1)", "s(2,1)")  ### but the agent stays in place

# convert between state names and row/column indices
gridworld_s2rc("s(1,1)")
gridworld_rc2s(c(1,1))

# The information in gw can be used to build a custom MDP.

# We modify the standard transition function so there is a 50% chance that
# you will get sucked into the black hole from the adjacent squares.
trans_black_hole &lt;- function(action = NA, start.state = NA, end.state = NA) {
  # ignore the action next to the black hole
  if (start.state %in% c("s(3,3)", "s(3,4)", "s(3,5)", "s(4,3)", "s(4,5)",
                         "s(5,3)", "s(5,4)", "s(5,5)")) {
        if(end.state == "s(4,4)")
            return(.5)
        else
            return(gw$transition_prob(action, start.state, end.state) * .5)
  }

  # use the standard gridworld movement
  gw$transition_prob(action, start.state, end.state)
}

black_hole &lt;- MDP(states = gw$states,
  actions = gw$actions,
  transition_prob = trans_black_hole,
  reward = rbind(R_(value = +1), R_(end.state = "s(4,4)", value = -100)),
  info = gw$info,
  name = "Black hole"
  )

black_hole

gridworld_plot_transition_graph(black_hole)

# solve the problem
sol &lt;- solve_MDP(black_hole)
gridworld_matrix(sol, what = "values")
gridworld_plot_policy(sol)
# the optimal policy is to fly around, but avoid the black hole.

# Build a Maze: The Dyna Maze from Chapter 8 in the RL book

Dyna_maze &lt;- gridworld_maze_MDP(
                dim = c(6,9),
                start = "s(3,1)",
                goal = "s(1,9)",
                walls = c("s(2,3)", "s(3,3)", "s(4,3)",
                          "s(5,6)",
                          "s(1,8)", "s(2,8)", "s(3,8)"),
                restart = TRUE,
                discount = 0.95,
                name = "Dyna Maze",
                )
Dyna_maze

gridworld_matrix(Dyna_maze)
gridworld_matrix(Dyna_maze, what = "labels")

gridworld_plot_transition_graph(Dyna_maze)
# Note that the problems resets if the goal state would be reached.

sol &lt;- solve_MDP(Dyna_maze)

gridworld_matrix(sol, what = "values")
gridworld_matrix(sol, what = "actions")
gridworld_plot_policy(sol)
gridworld_plot_policy(sol, actions = "label", cex = 1, states = FALSE)

# visualize the first 3 iterations of value iteration
gridworld_animate(Dyna_maze, method = "value", n = 3)
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>ped_internal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Internal ordering of pedigree members</h2>

<h3>Description</h3>

<p>These functions give access to - and enable modifications of - the order in
which the members of a pedigree are stored. (This is the order in which the
members are listed when a <code>ped</code> object is printed to the screen.)
</p>


<h3>Usage</h3>

<pre><code class="language-R">reorderPed(x, neworder = NULL, internal = FALSE)

parentsBeforeChildren(x)

hasParentsBeforeChildren(x)

foundersFirst(x)

internalID(x, ids, errorIfUnknown = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>ped</code> object. Most of these functions also accepts ped lists.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neworder</code></td>
<td>
<p>A permutation of <code>labels(x)</code> (or a subset of this),
indicating the new internal ordering. If <code>internal = TRUE</code>, <code>neworder</code>
refers to the internal ordering, so must be numeric. <code>1:pedsize(x)</code>. By
default, the natural order of the ID labels is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>internal</code></td>
<td>
<p>A logical (default: FALSE). If TRUE, <code>neworder</code> is
interpreted as referring to the internal ordering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ids</code></td>
<td>
<p>A character vector (or coercible to one) of original ID labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>errorIfUnknown</code></td>
<td>
<p>A logical. If TRUE (default), the function stops with
an error if not all elements of <code>ids</code> are recognised as names of members in
<code>x</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The internal ordering is usually of little importance for end users, with one
important exception: Certain pedigree-traversing algorithms require parents
to precede their children. A special function, <code>parentsBeforeChildren()</code> is
provided for this purpose. This is a wrapper of the more general
<code>reorderPed()</code> which allows any permutation of the members.
</p>
<p>It should be noted that <code>ped()</code> by default calls <code>parentsBeforeChildren()</code>
whenever a pedigree is created, unless explicitly avoided with <code>reorder = FALSE</code>.
</p>
<p><code>hasParentsBeforeChildren()</code> can be used as a quick test to decide if it is
necessary to call <code>parentsBeforeChildren()</code>.
</p>
<p>The <code>foundersFirst()</code> function reorders the pedigree so that all the founders
come first.
</p>
<p>The utility <code>internalID()</code> converts ID labels to indices in the internal
ordering. If <code>x</code> is a list of pedigrees, the output is a data frame
containing both the component number and internal ID (within the component).
</p>


<h3>See Also</h3>

<p><code>ped()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x = ped(id = 3:1, fid = c(1,0,0), mid = c(2,0,0), sex = c(1,2,1), reorder = FALSE)
x

# The 'ids' argument is converted to character, hence these are the same:
internalID(x, ids = 3)
internalID(x, ids = "3")

hasParentsBeforeChildren(x)

# Put parents first
parentsBeforeChildren(x)

# Typical use of reorderPed: Swap sibling plot order
y = nuclearPed(2) |&gt; reorderPed(4:3)
plot(y)


### If labels are numeric, argument `internal` is important
z = singleton(1) |&gt; addParents(1)
z
reorderPed(z, 1:3, internal = FALSE) # ID order = "1","2","3"
reorderPed(z, 1:3, internal = TRUE)  # index order: 1,2,3 (i.e., no change)

</code></pre>


</div>
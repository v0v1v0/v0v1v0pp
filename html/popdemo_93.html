<div class="container">

<table style="width: 100%;"><tr>
<td>tfs_inertia</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate sensitivity of inertia using transfer functions</h2>

<h3>Description</h3>

<p>Calculate the sensitivity of population inertia of a population matrix 
projection model using differentiation of the transfer function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tfs_inertia(A, d=NULL, e=NULL, vector="n", bound=NULL, startval=0.001, 
            tolerance=1e-10,return.fit=FALSE,plot.fit=FALSE)
tfsm_inertia(A,vector="n",bound=NULL,startval=0.001,tolerance=1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a square, primitive, nonnegative numeric matrix of any dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d, e</code></td>
<td>
<p>numeric vectors that determine the perturbation structure 
(see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vector</code></td>
<td>
<p>(optional) a numeric vector or one-column matrix describing 
the age/stage distribution ('demographic structure') used to calculate the
transfer function of a 'case-specific' inertia</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bound</code></td>
<td>
<p>(optional) specifies whether the transfer funciton of an upper 
or lower bound on inertia should be calculated (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startval</code></td>
<td>
<p><code>tfs_inertia</code> calculates the limit of the derivative 
of the transfer function as lambda of the perturbed matrix approaches the 
dominant eigenvalue of <code>A</code> (see details). <code>startval</code> provides a 
starting value for the algorithm: the smaller <code>startval</code> is, the quicker 
the algorithm should converge.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>the tolerance level for determining convergence (see
details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.fit</code></td>
<td>
<p>if <code>TRUE</code> (and only if <code>d</code> and <code>e</code> are
specified), the lambda and sensitivity values obtained
from the convergence algorithm are returned alongside the sensitivity at the
limit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.fit</code></td>
<td>
<p>if <code>TRUE</code> then convergence of the algorithm is plotted
as sensitivity~lambda.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>tfs_inertia</code> and <code>tfsm_inertia</code> differentiate a transfer function to
find sensitivity of population inertia to perturbations.
</p>
<p><code>tfs_inertia</code> evaluates the transfer function of a specific perturbation 
structure. The perturbation structure is determined by <code>d%*%t(e)</code>. 
Therefore, the rows to be perturbed are determined by <code>d</code> and the 
columns to be perturbed are determined by <code>e</code>. The values in d and e 
determine the relative perturbation magnitude. For example, if only entry
[3,2] of a 3 by 3 matrix is to be perturbed, then <code>d = c(0,0,1)</code> and 
<code>e = c(0,1,0)</code>. If entries [3,2] and [3,3] are to be perturbed with the 
magnitude of perturbation to [3,2] half that of [3,3] then <code>d = c(0,0,1)</code> 
and <code>e = c(0,0.5,1)</code>. <code>d</code> and <code>e</code> may also be expressed as 
numeric one-column matrices, e.g. <code>d = matrix(c(0,0,1), ncol=1)</code>, 
<code>e = matrix(c(0,0.5,1), ncol=1)</code>. See Hodgson et al. (2006) for more 
information on perturbation structures.
</p>
<p><code>tfsm_inertia</code> returns a matrix of sensitivity values for observed
transitions (similar to that obtained when using <code>sens</code> to
evaluate sensitivity of asymptotic growth), where a separate transfer function 
for each nonzero element of <code>A</code> is calculated (each element perturbed 
independently of the others).
</p>
<p>The formula used by <code>tfs_inertia</code> and <code>tfsm_inertia</code> cannot be
evaluated at lambda-max, therefore it is necessary to find the limit of the
formula as lambda approaches lambda-max. This is done using a bisection
method, starting at a value of lambda-max + <code>startval</code>. <code>startval</code>
should be small, to avoid the potential of false convergence. The algorithm
continues until successive sensitivity calculations are within an accuracy
of one another, determined by <code>tolerance</code>: a <code>tolerance</code> of 1e-10
means that the sensitivity calculation should be accurate to 10 decimal
places. However, as the limit approaches lambda-max, matrices are no longer
invertible (singular): if matrices are found to be singular then
<code>tolerance</code> should be relaxed and made larger.
</p>
<p>For <code>tfs_inertia</code>, there is an extra option to return and/or plot the above
fitting process using <code>return.fit=TRUE</code> and <code>plot.fit=TRUE</code>
respectively.
</p>


<h3>Value</h3>

<p>For <code>tfs_inertia</code>, the sensitivity of inertia (or its bound) to 
the specified perturbation structure. If <code>return.fit=TRUE</code> a list 
containing components:
</p>

<dl>
<dt>sens</dt>
<dd>
<p>the sensitivity of inertia (or its bound) to the specified 
perturbation structure</p>
</dd>
<dt>lambda.fit</dt>
<dd>
<p>the lambda values obtained in the fitting process</p>
</dd>
<dt>sens.fit</dt>
<dd>
<p>the sensitivity values obtained in the fitting process.</p>
</dd>
</dl>
<p><br>
For <code>tfsm_inertia</code>, a matrix containing sensitivity of inertia
(or its bound) to each separate element of <code>A</code>.

</p>


<h3>References</h3>


<ul><li>
<p> Stott et al. (2012) Methods Ecol. Evol., 3, 673-684.
</p>
</li></ul>
<h3>See Also</h3>

<p>Other TransferFunctionAnalyses: 
<code>tfa_inertia()</code>,
<code>tfa_lambda()</code>,
<code>tfam_inertia()</code>,
<code>tfam_lambda()</code>,
<code>tfs_lambda()</code>
</p>
<p>Other PerturbationAnalyses: 
<code>elas()</code>,
<code>sens()</code>,
<code>tfa_inertia()</code>,
<code>tfa_lambda()</code>,
<code>tfam_inertia()</code>,
<code>tfam_lambda()</code>,
<code>tfs_lambda()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Create a 3x3 matrix
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create an initial stage structure    
  ( initial &lt;- c(1,3,2) )

  # Calculate the sensitivity matrix for the upper bound on inertia
  tfsm_inertia(A, bound="upper",tolerance=1e-7)

  # Calculate the sensitivity of simultaneous perturbation to 
  # A[1,3] and A[2,3] for the lower bound on inertia
  tfs_inertia(A, d=c(1,0,0), e=c(0,1,1), bound="lower")

  # Calculate the sensitivity of simultaneous perturbation to 
  # A[1,3] and A[2,3] for specified initial stage structure
  # and return and plot the fitting process
  tfs_inertia(A, d=c(1,0,0), e=c(0,1,1), vector=initial,tolerance=1e-7,
              return.fit=TRUE,plot.fit=TRUE)

</code></pre>


</div>
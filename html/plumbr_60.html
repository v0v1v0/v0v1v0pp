<div class="container">

<table style="width: 100%;"><tr>
<td>Selection-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Selection</h2>

<h3>Description</h3>

<p>A virtual base class for data models that store a selection, which
might be of items, regions, or whatever.  Clients can register
handlers for selection changes and can create proxy models to
transform selections, link across datasets and map selections to
actions on the data.
</p>
<p><strong>This design is preliminary and subject to change.</strong>
</p>


<h3>Interpreting The Selection</h3>

<p>Internally, the selection may be stored as any object, including as a
function that is invoked whenever the selection is stored or
retrieved. The function allows dynamic mapping of selections. Due to
this generality, the client should not access the selection
directly. Instead, it should explicitly coerce the selection object to
an interpretable representation. The set of supported coercions
depends on the subclass.  For example,
<code>ItemSelection</code> has a <code>as.logical</code> method that
coerces it to a logical vector, where an element is <code>TRUE</code> if the
corresponding element in the dataset is selected.
</p>


<h3>Responding to Selection Changes</h3>

<p>Whenever the selection is changed, the <code>changed</code> signal is
emitted. The signal has zero arguments. See the <code>objectSignals</code>
package for details on using signals.
</p>
<p>Eventually, a selection leads to the execution of some action by the
application. In interactive graphics, that action usually involves
scaling/transforming the selection to a modification on the data. The
<code>x$scale(scaler, data)</code> method tries to facilitate these
operaitons. All it does is create a handler for the <code>changed</code>
signal on <code>x</code> that passes <code>x</code> and <code>data</code> to the function
<code>scaler</code>, which implements the change.
</p>


<h3>The Selection Calculus</h3>

<p>Since any type of object can represent a selection, setting the
selection has very few constraints. There are several ways to modify
the selection. Not all of them will be supported by every subclass. In
the code snippets below, <code>x</code> represents a <code>Selection</code> object
and <code>selection</code> represents the primary representation of a
selection, like a logical vector.
</p>

<dl>
<dt>Replacement</dt>
<dd>
<p><code>x$replace(selection)</code>: this is supported by all
implementations.</p>
</dd>
<dt>Or/Addition</dt>
<dd>
<p><code>x$add(selection)</code>: the result contains the
union of the original selection and <code>selection</code>.</p>
</dd>
<dt>Setdiff/Subtract</dt>
<dd>
<p><code>x$subtract(selection)</code>: the result
contains the original selection except that indicated
by <code>selection</code>.</p>
</dd>
<dt>And/Intersect</dt>
<dd>
<p><code>x$intersect(selection)</code>: the result
contains the intersection of the original selection and
<code>selection</code>.</p>
</dd>
<dt>Xor/Toggle</dt>
<dd>
<p><code>x$toggle(selection)</code>: 
The intersection of the original selection and <code>selection</code> is
deselected, that only in <code>selection</code> is selected.</p>
</dd>
</dl>
<h3>Linking Selections</h3>

<p>In interactive graphics, it is often necessary to link selections
within and across datasets. The <code>x$link(linker)</code> method creates a
new <code>Selection</code> object that proxies <code>x</code> and maps the
selection in <code>x</code> through <code>linker</code>. Changes to the selection
in <code>x</code> will propagate via <code>linker</code> to changes in the
proxy. Analogously, the <code>linker</code> will pass modifications to the
proxy down to <code>x</code>.
</p>
<p>The <code>linker</code> may be provided as an integer vector, like that
returned by <code>match</code>, but it is usually a function, as that
allows very general linking strategies. As an example, let us consider
a simple linker between two datasets based on key matching. We assume
that the keys, <code>source_keys</code> and <code>dest_keys</code>, are in the
enclosure of our linker function.
</p>
<pre>
    function(source_selection, new_dest_value) {
      if (missing(new_dest_value))
        dest_keys 
      else source_keys 
    }
  </pre>
<p>The <code>linker</code> function takes one or two arguments, depending on
whether the selection is being retrieved or stored. When the selection
is being retrieved, <code>source_selection</code> is passed as the only
argument. The duty of the <code>linker</code> is then to retrieve the
underlying selection from <code>source_selection</code> (through coercion,
see above) and figure out which keys in the destination selection
match the selected source keys. The <code>new_dest_value</code> argument is
provided whenever the selection is being stored/set. In that case, the
analogous operation is performed, in the opposite direction. The
symmetry here is fairly obvious, and <code>duplex_data_linker</code>
is a utility for facilitating the implementation of such two-way
linking functions.
</p>


<h3>Author(s)</h3>

<p>Michael Lawrence</p>


<h3>See Also</h3>

<p>The <code>ItemSelection</code> and <code>RegionSelection</code>
subclasses, which have examples.</p>


</div>
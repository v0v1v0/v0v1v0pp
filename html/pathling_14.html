<div class="container">

<table style="width: 100%;"><tr>
<td>pathling_connect</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create or retrieve the Pathling context</h2>

<h3>Description</h3>

<p>Creates a Pathling context with the given configuration options.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pathling_connect(
  spark = NULL,
  max_nesting_level = 3,
  enable_extensions = FALSE,
  enabled_open_types = c("boolean", "code", "date", "dateTime", "decimal", "integer",
    "string", "Coding", "CodeableConcept", "Address", "Identifier", "Reference"),
  enable_terminology = TRUE,
  terminology_server_url = "https://tx.ontoserver.csiro.au/fhir",
  terminology_verbose_request_logging = FALSE,
  terminology_socket_timeout = 60000,
  max_connections_total = 32,
  max_connections_per_route = 16,
  terminology_retry_enabled = TRUE,
  terminology_retry_count = 2,
  enable_cache = TRUE,
  cache_max_entries = 2e+05,
  cache_storage_type = StorageType$MEMORY,
  cache_storage_path = NULL,
  cache_default_expiry = 600,
  cache_override_expiry = NULL,
  token_endpoint = NULL,
  enable_auth = FALSE,
  client_id = NULL,
  client_secret = NULL,
  scope = NULL,
  token_expiry_tolerance = 120,
  accept_language = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>spark</code></td>
<td>
<p>A pre-configured SparkSession instance, use this if you need to control the way
that the session is set up</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_nesting_level</code></td>
<td>
<p>Controls the maximum depth of nested element data that is encoded
upon import. This affects certain elements within FHIR resources that contain recursive
references, e.g., QuestionnaireResponse.item.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>enable_extensions</code></td>
<td>
<p>Enables support for FHIR extensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>enabled_open_types</code></td>
<td>
<p>The list of types that are encoded within open types, such as
extensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>enable_terminology</code></td>
<td>
<p>Enables the use of terminology functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminology_server_url</code></td>
<td>
<p>The endpoint of a FHIR terminology service (R4) that the server
can use to resolve terminology queries.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminology_verbose_request_logging</code></td>
<td>
<p>Setting this option to TRUE will enable additional
logging of the details of requests to the terminology service.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminology_socket_timeout</code></td>
<td>
<p>The maximum period (in milliseconds) that the server should
wait for incoming data from the HTTP service</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_connections_total</code></td>
<td>
<p>The maximum total number of connections for the client</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_connections_per_route</code></td>
<td>
<p>The maximum number of connections per route for the client</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminology_retry_enabled</code></td>
<td>
<p>Controls whether terminology requests that fail for possibly
transient reasons should be retried</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminology_retry_count</code></td>
<td>
<p>The number of times to retry failed terminology requests</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>enable_cache</code></td>
<td>
<p>Set this to FALSE to disable caching of terminology requests</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cache_max_entries</code></td>
<td>
<p>Sets the maximum number of entries that will be held in memory</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cache_storage_type</code></td>
<td>
<p>The type of storage to use for the terminology cache</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cache_storage_path</code></td>
<td>
<p>The path on disk to use for the cache</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cache_default_expiry</code></td>
<td>
<p>The default expiry time for cache entries (in seconds)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cache_override_expiry</code></td>
<td>
<p>If provided, this value overrides the expiry time provided by the
terminology server</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>token_endpoint</code></td>
<td>
<p>An OAuth2 token endpoint for use with the client credentials grant</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>enable_auth</code></td>
<td>
<p>Enables authentication of requests to the terminology server</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>client_id</code></td>
<td>
<p>A client ID for use with the client credentials grant</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>client_secret</code></td>
<td>
<p>A client secret for use with the client credentials grant</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scope</code></td>
<td>
<p>A scope value for use with the client credentials grant</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>token_expiry_tolerance</code></td>
<td>
<p>The minimum number of seconds that a token should have before
expiry when deciding whether to send it with a terminology request</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accept_language</code></td>
<td>
<p>The default value of the Accept-Language HTTP header passed to the
terminology server</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If no Spark session is provided and there is not one already present in this process, a new
one will be created.
</p>
<p>If a SparkSession is not provided, and one is already running within the current process, it
will be reused.
</p>
<p>It is assumed that the Pathling library API JAR is already on the classpath. If you are running 
your own cluster, make sure it is on the list of packages.
</p>


<h3>Value</h3>

<p>A Pathling context instance initialized with the specified configuration
</p>


<h3>See Also</h3>

<p>Other context lifecycle functions: 
<code>pathling_disconnect()</code>,
<code>pathling_disconnect_all()</code>,
<code>pathling_spark()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Create PathlingContext for an existing Spark connecton.
sc &lt;- sparklyr::spark_connect(master = "local")
pc &lt;- pathling_connect(spark = sc)
pathling_disconnect(pc)

# Create PathlingContext with a new Spark connection.
pc &lt;- pathling_connect()
spark &lt;- pathling_spark(pc)
pathling_disconnect_all()

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>eval_feature_representation_summary</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Evaluate feature representation by solution</h2>

<h3>Description</h3>

<p>Calculate how well features are represented by a solution
to a conservation planning problem.
These summary statistics are reported for each and every feature,
and each and every zone, within a conservation planning problem.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eval_feature_representation_summary(x, solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>problem()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solution</code></td>
<td>
<p><code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code>terra::rast()</code>, or <code>sf::sf()</code> object.
The argument should be in the same format as the planning unit cost
data in the argument to <code>x</code>.
See the Solution format section for more information.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>tibble::tibble()</code> object describing feature representation.
Here, each row describes a specific summary statistic
(e.g., different management zone) for a specific feature.
It contains the following columns:
</p>

<dl>
<dt>summary</dt>
<dd>
<p><code>character</code> description of the summary statistic.
The statistic associated with the <code>"overall"</code> value
in this column is calculated using the entire solution
(including all management zones if there are multiple zones).
If multiple management zones are present, then summary statistics
are also provided for each zone separately
(indicated using zone names).</p>
</dd>
<dt>feature</dt>
<dd>
<p><code>character</code> name of the feature.</p>
</dd>
<dt>total_amount</dt>
<dd>
<p><code>numeric</code> total amount of each feature available
in the entire conservation planning problem
(not just planning units selected within the solution).
It is calculated as the sum of the feature data,
supplied when creating a <code>problem()</code> object
(e.g., presence/absence values).</p>
</dd>
<dt>absolute_held</dt>
<dd>
<p><code>numeric</code> total amount of each feature secured within
the solution. It is calculated as the sum of the feature data,
supplied when creating a <code>problem()</code> object
(e.g., presence/absence values), weighted by the status of each
planning unit in the solution (e.g., selected or not for
prioritization).</p>
</dd>
<dt>relative_held</dt>
<dd>
<p><code>numeric</code> proportion of
each feature secured within the solution. It is calculated
by dividing values in the <code>"absolute_held"</code> column by those in the
<code>"total_amount"</code> column.</p>
</dd>
</dl>
<h3>Solution format</h3>

<p>Broadly speaking, the argument to <code>solution</code> must be in the same format as
the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt>
<code>x</code> has <code>numeric</code> planning units</dt>
<dd>
<p>The argument to <code>solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>solution</code>.
</p>
</dd>
<dt>
<code>x</code> has <code>matrix</code> planning units</dt>
<dd>
<p>The argument to <code>solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>solution</code>.
</p>
</dd>
<dt>
<code>x</code> has <code>terra::rast()</code> planning units</dt>
<dd>
<p>The argument to <code>solution</code>
be a <code>terra::rast()</code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>solution</code>.
</p>
</dd>
<dt>
<code>x</code> has <code>data.frame</code> planning units</dt>
<dd>
<p>The argument to <code>solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code>sf::sf()</code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
<dt>
<code>x</code> has <code>sf::sf()</code> planning units</dt>
<dd>
<p>The argument to <code>solution</code> must be
a <code>sf::sf()</code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code>sf::sf()</code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
</dl>
<h3>See Also</h3>

<p>See summaries for an overview of all functions for summarizing solutions.
</p>
<p>Other summaries: 
<code>eval_asym_connectivity_summary()</code>,
<code>eval_boundary_summary()</code>,
<code>eval_connectivity_summary()</code>,
<code>eval_cost_summary()</code>,
<code>eval_n_summary()</code>,
<code>eval_target_coverage_summary()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# create a simple conservation planning dataset so we can see exactly
# how feature representation is calculated
pu &lt;- data.frame(
  id = seq_len(10),
  cost = c(0.2, NA, runif(8)),
  spp1 = runif(10),
  spp2 = c(rpois(9, 4), NA)
)

# create problem
p1 &lt;-
  problem(pu, c("spp1", "spp2"), cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create a solution
# specifically, a data.frame with a single column that contains
# binary values indicating if each planning units was selected or not
s1 &lt;- data.frame(s = c(1, NA, rep(c(1, 0), 4)))
print(s1)

# calculate feature representation
r1 &lt;- eval_feature_representation_summary(p1, s1)
print(r1)

# let's verify that feature representation calculations are correct
# by manually performing the calculations and compare the results with r1
## calculate total amount for each feature
print(
  setNames(
    c(sum(pu$spp1, na.rm = TRUE), sum(pu$spp2, na.rm = TRUE)),
    c("spp1", "spp2")
  )
)

## calculate absolute amount held for each feature
print(
  setNames(
    c(sum(pu$spp1 * s1$s, na.rm = TRUE), sum(pu$spp2 * s1$s, na.rm = TRUE)),
    c("spp1", "spp2")
  )
)

## calculate relative amount held for each feature
print(
  setNames(
    c(
      sum(pu$spp1 * s1$s, na.rm = TRUE) / sum(pu$spp1, na.rm = TRUE),
      sum(pu$spp2 * s1$s, na.rm = TRUE) / sum(pu$spp2, na.rm = TRUE)
    ),
    c("spp1", "spp2")
  )
)

# solve problem using an exact algorithm solver
s1_2 &lt;- solve(p1)
print(s1_2)

# calculate feature representation in this solution
r1_2 &lt;- eval_feature_representation_summary(
  p1, s1_2[, "solution_1", drop = FALSE]
)
print(r1_2)

# build minimal conservation problem with raster data
p2 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# print solution
print(s2)

# calculate feature representation in the solution
r2 &lt;- eval_feature_representation_summary(p2, s2)
print(r2)

# plot solution
plot(s2, main = "solution", axes = FALSE)

# build minimal conservation problem with polygon data
p3 &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# print first six rows of the attribute table
print(head(s3))

# calculate feature representation in the solution
r3 &lt;- eval_feature_representation_summary(p3, s3[, "solution_1"])
print(r3)

# plot solution
plot(s3[, "solution_1"], main = "solution", axes = FALSE)

# build multi-zone conservation problem with raster data
p4 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s4 &lt;- solve(p4)

# print solution
print(s4)

# calculate feature representation in the solution
r4 &lt;- eval_feature_representation_summary(p4, s4)
print(r4)

# plot solution
plot(category_layer(s4), main = "solution", axes = FALSE)

# build multi-zone conservation problem with polygon data
p5 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s5 &lt;- solve(p5)

# print first six rows of the attribute table
print(head(s5))

# calculate feature representation in the solution
r5 &lt;- eval_feature_representation_summary(
  p5, s5[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
print(r5)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s5$solution &lt;- category_vector(
  s5[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
s5$solution &lt;- factor(s5$solution)

# plot solution
plot(s5[, "solution"])

## End(Not run)
</code></pre>


</div>
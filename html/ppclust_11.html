<div class="container">

<table style="width: 100%;"><tr>
<td>gg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Gath-Geva Clustering Algorithm</h2>

<h3>Description</h3>

<p>Partitions a numeric data set by using the Gath-Geva (GG) clustering algorithm (Gath &amp; Geva, 1989). The function <code>gg</code> is based on the code in <code>fuzzy.GG</code> function of the package <span class="pkg">advclust</span> by Bagus and Pramana (2016) with some more extended initialization methods and distance metrics.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gg(x, centers, memberships, m=2, ggversion="simple", 
   dmetric="sqeuclidean", pw = 2, alginitv="kmpp", 
   alginitu="imembrand", nstart=1, iter.max=1e03, con.val=1e-09, 
   fixcent=FALSE, fixmemb=FALSE, stand=FALSE, numseed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector, data frame or matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centers</code></td>
<td>
<p>an integer specifying the number of clusters or a numeric matrix containing the initial cluster centers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>memberships</code></td>
<td>
<p>a numeric matrix containing the initial membership degrees. If missing, it is internally generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ggversion</code></td>
<td>
<p>a string for the version of Gath-Geva algorithm. The default is <span class="option">simple</span> for the simplified version (Hoepner et al (1999). Use <span class="option">original</span> for the original Gath-Geva algorithm (Gath &amp; Geva, 1989).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>a number greater than 1 to be used as the fuzziness exponent or fuzzifier. The default is 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dmetric</code></td>
<td>
<p>a string for the distance metric. The default is <span class="option">sqeuclidean</span> for the squared Euclidean distances. See <code>get.dmetrics</code> for the alternative options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pw</code></td>
<td>
<p>a number for the power of Minkowski distance calculation. The default is 2 if the <code>dmetric</code> is <span class="option">minkowski</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alginitv</code></td>
<td>
<p>a string for the initialization of cluster prototypes matrix. The default is <span class="option">kmpp</span> for K-means++ initialization method (Arthur &amp; Vassilvitskii, 2007). For the list of alternative options see <code>get.algorithms</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alginitu</code></td>
<td>
<p>a string for the initialization of memberships degrees matrix. The default is <span class="option">imembrand</span> for random sampling of initial membership degrees.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart</code></td>
<td>
<p>an integer for the number of starts for clustering. The default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max</code></td>
<td>
<p>an integer for the maximum number of iterations allowed. The default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con.val</code></td>
<td>
<p>a number for the convergence value between the iterations. The default is 1e-09.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixcent</code></td>
<td>
<p>a logical flag to make the initial cluster centers not changed along the different starts of the algorithm. The default is <code>FALSE</code>. If it is <code>TRUE</code>, the initial centers are not changed in the successive starts of the algorithm when the <code>nstart</code> is greater than 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixmemb</code></td>
<td>
<p>a logical flag to make the initial membership degrees not changed along the different starts of the algorithm. The default is <code>FALSE</code>. If it is <code>TRUE</code>, the initial memberships are not changed in the successive starts of the algorithm when the <code>nstart</code> is greater than 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stand</code></td>
<td>
<p>a logical flag to standardize data. Its default value is <code>FALSE</code>. If its value is <code>TRUE</code>, the data matrix <code>x</code> is standardized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numseed</code></td>
<td>
<p>a seeding number to set the seed of R's random number generator.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Gath and Geva (1989) proposed that the fuzzy maximum likelihood estimates (FMLE) clustering algorithm can be used to detect clusters of varying shapes, sizes and densities. Instead of using Euclidean distance as in FCM, Gath-Geva (GG) algorithm uses a distance norm based on fuzzy maximum likelihood estimates as described by Bezdek &amp; Dunn (1975). These are the Gauss distances, and hence, GG is also so-called Gaussian Mixture Decomposition.  
</p>
<p>The objective function of GG is:
</p>
<p><code class="reqn">J_{GG}(\mathbf{X}; \mathbf{V}, \mathbf{A}, \mathbf{U}) = \sum\limits_{i=1}^n \sum\limits_{j=1}^k  u_{ij}^m d_{A_j}(\vec{x}_i, \vec{v}_j)</code>
</p>
<p>In the above equation, <code class="reqn">d_{A_j}(\vec{x}_i, \vec{v}_j)</code> is the Gauss distance between the object <code class="reqn">\vec{x}_j</code> and cluster prototype <code class="reqn">\vec{v}_i</code>. 
</p>
<p><code class="reqn">d_{A_j}(\vec{x}_i, \vec{v}_j) = \frac{(2 \pi)^{\frac{n}{2}}\sqrt{\det{\mathbf{A}_j}}}{\alpha_j} \; exp\big(\frac{1}{2} (\vec{x}_i - \vec{v}_j)^T \mathbf{A}_j^{-1}(\vec{x}_i - \vec{v}_j)\big)</code>
</p>
<p><code class="reqn">\mathbf{A}_j = \frac{\sum\limits_{i=1}^n u_{ij}^m (\vec{x}_i - \vec{v}_j)^T (\vec{x}_i - \vec{v}_j)}{\sum\limits_{i=1}^n u_{ij}^m} \;;\; 1 \leq j \leq k</code>
</p>
<p>The argument <code class="reqn">\alpha_j</code> is the prior probability for belonging <code class="reqn">\vec{x}_i</code> to the cluster <code class="reqn">j</code>:
</p>
<p><code class="reqn">{\alpha_j} = \frac{\sum\limits_{i=1}^n u_{ij}^m}{n}</code>
</p>
<p>The argument <code class="reqn">\alpha_j</code> is used to evaluate the size of a cluster since bigger clusters attract more elements.
</p>
<p><code class="reqn">m</code> is the fuzzifier to specify the amount of fuzziness for the clustering. Although it is 1 in the original FMLE algorithm (Bezdek &amp; Dunn, 1975) a higher value of it (<code class="reqn">1\leq m\leq \infty</code>) can be used to make the partition more fuzzy compensating the exponential term of the distance norm (Balasko et al, 2005).  
</p>
<p>The objective function of GG is minimized by using the following update equations:
</p>
<p><code class="reqn">u_{ij} =\Bigg[\sum\limits_{j=1}^k \Big(\frac{d_{A_j}(\vec{x}_i, \vec{v}_j)}{d_{A_l}(\vec{x}_i, \vec{v}_l)}\Big)^{1/(m-1)} \Bigg]^{-1} \;\;; 1 \leq i \leq n,\; 1 \leq l \leq k</code>
</p>
<p><code class="reqn">\vec{v}_{j} =\frac{\sum\limits_{i=1}^n u_{ij}^m \vec{x}_i}{\sum\limits_{i=1}^n u_{ij}^m} \;\;; 1 \leq j \leq k</code>
</p>


<h3>Value</h3>

<p>an object of class ‘ppclust’, which is a list consists of the following items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric matrix containing the processed data set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>a numeric matrix containing the final cluster prototypes (centers of clusters).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>a numeric matrix containing the fuzzy memberships degrees of the data objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>a numeric matrix containing the distances of objects to the final cluster prototypes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>an integer for the number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>a number for the fuzzifier.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>a numeric vector containing the cluster labels found by defuzzying the fuzzy membership degrees of the objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>csize</code></td>
<td>
<p>a numeric vector containing the number of objects in the clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>an integer vector for the number of iterations in each start of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.start</code></td>
<td>
<p>an integer for the index of start that produced the minimum objective functional.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func.val</code></td>
<td>
<p>a numeric vector for the objective function values in each start of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comp.time</code></td>
<td>
<p>a numeric vector for the execution time in each start of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stand</code></td>
<td>
<p>a logical value, <code>TRUE</code> shows that data set <code>x</code> contains the standardized values of raw data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wss</code></td>
<td>
<p>a number for the within-cluster sum of squares for each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bwss</code></td>
<td>
<p>a number for the between-cluster sum of squares.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tss</code></td>
<td>
<p>a number for the total within-cluster sum of squares.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>twss</code></td>
<td>
<p>a number for the total sum of squares.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>a string for the name of partitioning algorithm. It is ‘FCM’ with this function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>a string for the matched function call generating this ‘ppclust’ object.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Due to the exponential distance norm, this algorithm needs a good initialization since it converges to a near local optimum. So, usually another clustering algorithm, i.e. FCM, is used to initialize the partition matrix <code class="reqn">\mathbf{U}</code> (Balasko et al, 2005).
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci
</p>


<h3>References</h3>

<p>Arthur, D. &amp; Vassilvitskii, S. (2007). K-means++: The advantages of careful seeding, in <em>Proc. of the 18th Annual ACM-SIAM Symposium on Discrete Algorithms</em>, p. 1027-1035. &lt;<a href="http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf">http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf</a>&gt;
</p>
<p>Bezdek, J.C. &amp; Dunn J.C. (1975). Optimal fuzzy partitions: A heuristic for estimating the parameters in a mixture of normal dustrubutions. <em>IEEE Transactions on Computers</em>, C-24(8):835-838. &lt;doi: 10.1109/T-C.1975.224317&gt;
</p>
<p>Gath, I. &amp; Geva, A.B. (1989). Unsupervised optimal fuzzy clustering. <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, 11 (7): 773-781. &lt;doi:10.1109/34.192473&gt;
</p>
<p>Hoeppner, F., Klawonn, F., Kruse, R. &amp; Runkler, T. (1999). <em>Fuzzy cluster analysis</em>. New York: John Wiley and Sons. &lt;ISBN:0471988642&gt;
</p>
<p>Balasko, B., Abonyi, J. &amp; Feil, B. (2005). Fuzzy clustering and data analysis toolbox. Department of Process Eng., Univ. of Veszprem, Veszprem.
</p>
<p>Bagus, A. F. &amp; Pramana, S. (2016). advclust: Object Oriented Advanced Clustering. R package version 0.4. <a href="https://CRAN.R-project.org/package=advclust">https://CRAN.R-project.org/package=advclust</a>
</p>


<h3>See Also</h3>

<p><code>ekm</code>,
<code>fcm</code>,
<code>fcm2</code>,
<code>fpcm</code>,
<code>fpppcm</code>,
<code>gk</code>,
<code>gkpfcm</code>,
<code>hcm</code>,
<code>pca</code>,
<code>pcm</code>,
<code>pcmr</code>,
<code>pfcm</code>,
<code>upfc</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Load dataset iris 
data(iris)
x &lt;- iris[,-5]

# Initialize the prototype matrix using Inofrep algorithm
v &lt;- inaparc::inofrep(x, k=3)$v
# Initialize the memberships degrees matrix 
u &lt;- inaparc::imembrand(nrow(x), k=3)$u

# Run Gath &amp; Geva with the initial prototypes and memberships
gg.res &lt;- gg(x, centers=v, memberships=u, m=2)

# Show the fuzzy memberships degrees for the top 5 objects
head(gg.res$u, 5)

## End(Not run)
</code></pre>


</div>
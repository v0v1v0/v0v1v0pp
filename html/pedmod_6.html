<div class="container">

<table style="width: 100%;"><tr>
<td>eval_pedigree_ll</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Approximate the Log Marginal Likelihood</h2>

<h3>Description</h3>

<p>Approximate the log marginal likelihood and the derivatives with
respect to the model parameters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eval_pedigree_ll(
  ptr,
  par,
  maxvls,
  abs_eps,
  rel_eps,
  indices = NULL,
  minvls = -1L,
  do_reorder = TRUE,
  use_aprx = FALSE,
  n_threads = 1L,
  cluster_weights = NULL,
  standardized = FALSE,
  method = 0L,
  use_tilting = FALSE,
  vls_scales = NULL
)

eval_pedigree_grad(
  ptr,
  par,
  maxvls,
  abs_eps,
  rel_eps,
  indices = NULL,
  minvls = -1L,
  do_reorder = TRUE,
  use_aprx = FALSE,
  n_threads = 1L,
  cluster_weights = NULL,
  standardized = FALSE,
  method = 0L,
  use_tilting = FALSE,
  vls_scales = NULL
)

eval_pedigree_hess(
  ptr,
  par,
  maxvls,
  abs_eps,
  rel_eps,
  indices = NULL,
  minvls = -1L,
  do_reorder = TRUE,
  use_aprx = FALSE,
  n_threads = 1L,
  cluster_weights = NULL,
  standardized = FALSE,
  method = 0L,
  use_tilting = FALSE,
  vls_scales = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ptr</code></td>
<td>
<p>object from <code>pedigree_ll_terms</code> or
<code>pedigree_ll_terms_loadings</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>numeric vector with parameters. For an object from
<code>pedigree_ll_terms</code> these are the fixed effect coefficients and
log scale parameters. The log scale parameters should be last. For an object
from <code>pedigree_ll_terms_loadings</code> these are the fixed effects
and the coefficients for scale parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxvls</code></td>
<td>
<p>maximum number of samples in the approximation for each
marginal likelihood term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abs_eps</code></td>
<td>
<p>absolute convergence threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel_eps</code></td>
<td>
<p>relative convergence threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indices</code></td>
<td>
<p>zero-based vector with indices of which log marginal
likelihood terms to include. Use <code>NULL</code> if all indices should be
used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minvls</code></td>
<td>
<p>minimum number of samples for each
marginal likelihood term. Negative values provides a
default which depends on the dimension of the integration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do_reorder</code></td>
<td>
<p><code>TRUE</code> if a heuristic variable reordering should
be used. <code>TRUE</code> is likely the best value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_aprx</code></td>
<td>
<p><code>TRUE</code> if a less precise approximation of
<code>pnorm</code> and <code>qnorm</code> should be used. This may
reduce the computation time while not affecting the result much.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_threads</code></td>
<td>
<p>number of threads to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_weights</code></td>
<td>
<p>numeric vector with weights for each cluster. Use
<code>NULL</code> if all clusters have weight one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized</code></td>
<td>
<p>logical for whether to use the standardized or direct
parameterization. See <code>standardized_to_direct</code> and the vignette
at <code>vignette("pedmod", package = "pedmod")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>integer with the method to use. Zero yields randomized Korobov
lattice rules while one yields scrambled Sobol sequences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_tilting</code></td>
<td>
<p><code>TRUE</code> if the minimax tilting method suggested
by Botev (2017) should be used. See <a href="https://doi.org/10.1111/rssb.12162">doi:10.1111/rssb.12162</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vls_scales</code></td>
<td>
<p>can be a numeric vector with a positive scalar for each
cluster. Then <code>vls_scales[i] * minvls</code> and
<code>vls_scales[i] * maxvls</code> is used for cluster <code>i</code> rather than
<code>minvls</code> and <code>maxvls</code>. Set <code>vls_scales = NULL</code> if the latter
should be used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>eval_pedigree_hess</code> is only implemented for objects from
<code>pedigree_ll_terms</code>.
</p>


<h3>Value</h3>

<p><code>eval_pedigree_ll</code>:
a scalar with the log marginal likelihood approximation.
It has an attribute called <code>"n_fails"</code> which shows the number of
log marginal likelihood term approximations which do not satisfy
the <code>abs_eps</code> and <code>rel_eps</code> criteria and an attribute called
<code>std</code> with a standard error estimate based on the delta rule.
</p>
<p><code>eval_pedigree_grad</code>: a vector with the derivatives with
respect to <code>par</code>. An attribute called <code>"logLik"</code> contains the
log marginal likelihood approximation. There will also be <code>"n_fails"</code>
attribute like for <code>eval_pedigree_ll</code> and an attribute called
<code>"std"</code> which first element is the standard error estimate of the
log likelihood based on the delta method and the last elements are the
standard error estimates of the gradient. The latter ignores the Monte Carlo
error from the likelihood approximation.
</p>
<p><code>eval_pedigree_hess</code>: a matrix with the hessian with
respect to <code>par</code>.
An attribute called <code>"logLik"</code> contains the
log marginal likelihood approximation and an attribute called <code>"grad"</code>
contains the gradientÂ·
The attribute <code>"hess_org"</code> contains the Hessian with the scale
parameter on the identity scale rather than the log scale.
<code>"vcov"</code> and <code>"vcov_org"</code> are
the covariance matrices from the hessian and <code>"hess_org"</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># three families as an example
fam_dat &lt;- list(
  list(
    y = c(FALSE, TRUE, FALSE, FALSE),
    X = structure(c(
      1, 1, 1, 1, 1.2922654151273, 0.358134905909256, -0.734963997107464,
      0.855235473516044, -1.16189500386223, -0.387298334620742,
      0.387298334620742, 1.16189500386223),
      .Dim = 4:3, .Dimnames = list( NULL, c("(Intercept)", "X1", ""))),
    rel_mat = structure(c(
      1, 0.5, 0.5, 0.125, 0.5, 1, 0.5, 0.125, 0.5, 0.5,
      1, 0.125, 0.125, 0.125, 0.125, 1), .Dim = c(4L, 4L)),
    met_mat = structure(c(1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1),
                        .Dim = c(4L, 4L))),
  list(
    y = c(FALSE, FALSE, FALSE),
    X = structure(c(
      1, 1, 1, -0.0388728997202442, -0.0913782435233639,
      -0.0801619722392612, -1, 0, 1), .Dim = c(3L, 3L)),
    rel_mat = structure(c(
      1, 0.5, 0.125, 0.5, 1, 0.125, 0.125, 0.125, 1), .Dim = c(3L, 3L)),
    met_mat = structure(c(
      1, 1, 0, 1, 1, 0, 0, 0, 1), .Dim = c(3L, 3L))),
  list(
    y = c(TRUE, FALSE),
    X = structure(c(
      1, 1, 0.305275750370738, -1.49482995913648,  -0.707106781186547,
      0.707106781186547),
      .Dim = 2:3, .Dimnames = list( NULL, c("(Intercept)", "X1", ""))),
    rel_mat = structure(c(1, 0.5,  0.5, 1), .Dim = c(2L, 2L)),
    met_mat = structure(c(1, 1, 1, 1), .Dim = c(2L,  2L))))

# get the data into the format needed for the package
dat_arg &lt;- lapply(fam_dat, function(x){
  # we need the following for each family:
  #   y: the zero-one outcomes.
  #   X: the design matrix for the fixed effects.
  #   scale_mats: list with the scale matrices for each type of effect.
  list(y = as.numeric(x$y), X = x$X,
       scale_mats = list(x$rel_mat, x$met_mat))
})

# get a pointer to the C++ object
ptr &lt;- pedigree_ll_terms(dat_arg, max_threads = 1L)

# approximate the log marginal likelihood
beta &lt;- c(-1, 0.3, 0.2) # fixed effect coefficients
scs &lt;- c(0.5, 0.33)     # scales parameters

set.seed(44492929)
system.time(ll1 &lt;- eval_pedigree_ll(
  ptr = ptr, par = c(beta, log(scs)), abs_eps = -1, maxvls = 1e5,
  rel_eps = 1e-5, minvls = 2000, use_aprx = FALSE))
ll1 # the approximation

# with the approximation of pnorm and qnorm
system.time(ll2 &lt;- eval_pedigree_ll(
  ptr = ptr, par = c(beta, log(scs)), abs_eps = -1, maxvls = 1e5,
  rel_eps = 1e-5, minvls = 2000, use_aprx = TRUE))
all.equal(ll1, ll2, tolerance = 1e-5)

# cluster weights can be used as follows to repeat the second family three
# times and remove the third
system.time(deriv_w_weight &lt;- eval_pedigree_grad(
  ptr = ptr, par = c(beta, log(scs)), abs_eps = -1, maxvls = 1e6,
  rel_eps = 1e-3, minvls = 2000, use_aprx = TRUE,
  cluster_weights = c(1, 3, 0)))

# the same as manually repeating second cluster and not including the third
dum_dat &lt;- dat_arg[c(1, 2, 2, 2)]
dum_ptr &lt;- pedigree_ll_terms(dum_dat, 1L)
system.time(deriv_dum &lt;- eval_pedigree_grad(
  ptr = dum_ptr, par = c(beta, log(scs)), abs_eps = -1, maxvls = 1e6,
  rel_eps = 1e-3, minvls = 2000, use_aprx = TRUE))
all.equal(deriv_dum, deriv_w_weight, tolerance = 1e-3)

# the hessian is computed on the scale parameter scale rather than on the
# log of the scale parameters
system.time(hess_w_weight &lt;- eval_pedigree_hess(
  ptr = ptr, par = c(beta, log(scs)), abs_eps = -1, maxvls = 1e6,
  rel_eps = 1e-3, minvls = 2000, use_aprx = TRUE,
  cluster_weights = c(1, 3, 0)))

system.time(hess_dum &lt;- eval_pedigree_hess(
  ptr = dum_ptr, par = c(beta, log(scs)), abs_eps = -1, maxvls = 1e6,
  rel_eps = 1e-3, minvls = 2000, use_aprx = TRUE))
attr(hess_w_weight, "n_fails") &lt;- attr(hess_dum, "n_fails") &lt;- NULL
all.equal(hess_w_weight, hess_dum, tolerance = 1e-3)

# the results are consistent with the gradient output
all.equal(attr(deriv_dum, "logLik"), attr(hess_dum, "logLik"),
          tolerance = 1e-5)

hess_grad &lt;- attr(hess_dum, "grad")
all.equal(hess_grad, deriv_dum, check.attributes = FALSE,
          tolerance = 1e-3)

# with loadings
dat_arg_loadings &lt;- lapply(fam_dat, function(x){
  list(y = as.numeric(x$y), X = x$X, Z = x$X[, 1:2],
       scale_mats = list(x$rel_mat, x$met_mat))
})

ptr_loadings &lt;-
  pedigree_ll_terms_loadings(dat_arg_loadings, max_threads = 1L)

scs &lt;- c(log(0.5) / 2, 0.1, log(0.33) / 2, 0.2) # got more scales parameters
eval_pedigree_ll(
  ptr = ptr_loadings, par = c(beta, scs), abs_eps = -1, maxvls = 1e4,
  rel_eps = 1e-3, minvls = 2000, use_aprx = TRUE)
eval_pedigree_grad(
  ptr = ptr_loadings, par = c(beta, scs), abs_eps = -1, maxvls = 1e4,
  rel_eps = 1e-3, minvls = 2000, use_aprx = TRUE)

# can recover the result from before
scs &lt;- c(log(0.5) / 2, 0, log(0.33) / 2, 0)
ll3 &lt;- eval_pedigree_ll(
  ptr = ptr_loadings, par = c(beta, scs), abs_eps = -1, maxvls = 1e4,
  rel_eps = 1e-3, minvls = 2000, use_aprx = TRUE)
all.equal(ll1, ll3, tolerance = 1e-5)

</code></pre>


</div>
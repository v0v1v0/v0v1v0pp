<div class="container">

<table style="width: 100%;"><tr>
<td>form_trans</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Transform pdqr-function</h2>

<h3>Description</h3>

<p>Perform a transformation of pdqr-function(s) (which assumed to be
independent).
</p>


<h3>Usage</h3>

<pre><code class="language-R">form_trans(f_list, trans, ..., method = "random", n_sample = 10000,
  args_new = list())

form_trans_self(f, trans, ..., method = "random", args_new = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f_list</code></td>
<td>
<p>A list consisting from pdqr-function(s) and/or single
number(s). Should have at least one pdqr-function (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>
<p>Transformation function. Should take as many (vectorized)
arguments as there are elements in <code>f_list</code> or a single argument for
<code>form_trans_self()</code>. Should return numeric or logical values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Extra arguments to <code>trans</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Transformation method. One of "random" or "bruteforce".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_sample</code></td>
<td>
<p>Number of elements to sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args_new</code></td>
<td>
<p>List of extra arguments for new_*() to control
<code>density()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A pdqr-function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>form_trans_self()</code> is a thin wrapper for <code>form_trans()</code> that
accepts a single pdqr-function instead of a list of them.
</p>
<p>Class of output is chosen as class of first pdqr-function in
<code>f_list</code>. Type of output is chosen to be "discrete" in case
all input pdqr-functions have "discrete" type, and "continuous" otherwise.
</p>
<p>Method "random" performs transformation using random generation of samples:
</p>

<ul>
<li> <p><strong>Generates a sample of size <code>n_sample</code> from every element of <code>f_list</code></strong>
(if element is single number, it is repeated <code>n_sample</code> times).
</p>
</li>
<li> <p><strong>Calls <code>trans</code></strong> with all generated samples (in order aligned with
<code>f_list</code>). <strong>Note</strong> that output should be either numeric or logical and have
<code>n_sample</code> elements (one for each combination of input values in "vectorized"
fashion). So, for example, using <code>sum</code> directly is not possible as it returns
only single number.
</p>
</li>
<li> <p><strong>Creates output pdqr-function</strong>. If output is logical, probability of
being true is estimated as share of <code>TRUE</code> in output, and boolean
pdqr-function is created (type "discrete" with "x" values equal to 0 and 1,
and probabilities of being false and true respectively). If output is
numeric, one of <code style="white-space: pre;">⁠new_*()⁠</code> (suitable for output class) is called with
arguments from <code>args_new</code> list.
</p>
</li>
</ul>
<p>Method "bruteforce":
</p>

<ul>
<li> <p><strong>Retypes input</strong> pdqr-function to "discrete"
type (using "piecelin" method).
</p>
</li>
<li> <p><strong>Computes output for every combination of "x" values</strong> (probability of
which will be a product of corresponding probabilities).
</p>
</li>
<li> <p><strong>Creates pdqr-function of type "discrete"</strong> with suitable <code style="white-space: pre;">⁠new_*()⁠</code>
function.
</p>
</li>
<li> <p><strong>Possibly retypes to "continuous" type</strong> if output should have it (also
with "piecelin" method).
</p>
</li>
</ul>
<p><strong>Notes</strong> about "bruteforce" method:
</p>

<ul>
<li>
<p> Its main advantage is that it is not random.
</p>
</li>
<li>
<p> It may start to be very memory consuming very quickly.
</p>
</li>
<li>
<p> It is usually useful when type of output function is "discrete". In case of
"continuous" type, retyping from "discrete" to "continuous" might introduce
big errors.
</p>
</li>
<li>
<p> Used "discrete" probabilities shouldn't be very small because they will be
directly multiplied, which might cause numerical accuracy issues.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A pdqr-function for transformed random variable.
</p>


<h3>See Also</h3>

<p>Pdqr methods for S3 group generic functions
for more accurate implementations of most commonly used functions. Some of
them are direct (without randomness) and some of them use <code>form_trans()</code>
with "random" method.
</p>
<p><code>form_regrid()</code> to increase/decrease granularity of pdqr-functions for method
"bruteforce".
</p>
<p>Other form functions: 
<code>form_estimate()</code>,
<code>form_mix()</code>,
<code>form_regrid()</code>,
<code>form_resupport()</code>,
<code>form_retype()</code>,
<code>form_smooth()</code>,
<code>form_tails()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Default "random" transformation
d_norm &lt;- as_d(dnorm)
## More accurate result would give use of `+` directly with: d_norm + d_norm
d_norm_2 &lt;- form_trans(list(d_norm, d_norm), trans = `+`)
plot(d_norm_2)
lines(as_d(dnorm, sd = sqrt(2)), col = "red")

## Input list can have single numbers
form_trans(list(d_norm, 100), trans = `+`)

## Output of `trans` can be logical. Next example is random version of
## `d_norm &gt;= 0`.
form_trans(list(d_norm, 0), trans = `&gt;=`)

# Transformation with "bruteforce" method
power &lt;- function(x, n = 1) {
  x^n
}
p_dis &lt;- new_p(
  data.frame(x = 1:3, prob = c(0.1, 0.2, 0.7)),
  type = "discrete"
)

p_dis_sq &lt;- form_trans_self(
  p_dis, trans = power, n = 2, method = "bruteforce"
)
meta_x_tbl(p_dis_sq)
## Compare with "random" method
p_dis_sq_rand &lt;- form_trans_self(p_dis, trans = power, n = 2)
meta_x_tbl(p_dis_sq_rand)

# `form_trans_self()` is a wrapper for `form_trans()`
form_trans_self(d_norm, trans = function(x) {
  2 * x
})
</code></pre>


</div>
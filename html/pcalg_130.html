<div class="container">

<table style="width: 100%;"><tr>
<td>skeleton</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate (Initial) Skeleton of a DAG using the PC / PC-Stable Algorithm</h2>

<h3>Description</h3>

<p>Estimate the skeleton of a DAG without latent and selection
variables using the PC Algorithm or
estimate an initial skeleton of a DAG with arbitrarily many latent and
selection variables using the FCI and the RFCI algorithms.
</p>
<p>If used in the PC algorithm, it estimates the order-independent
“PC-stable” (<code>"stable"</code>) or original PC (<code>"original"</code>)
“skeleton” of a directed acyclic graph (DAG) from observational
data.
</p>
<p>When used in the FCI and RFCI algorithms, this function estimates
only an initial order-independent (or PC original) “skeleton”.
Because of the presence of latent and selection variables, to find the
final skeleton those algorithms need to perform additional tests later on and
consequently some edges can be further deleted.
</p>


<h3>Usage</h3>

<pre><code class="language-R">skeleton(suffStat, indepTest, alpha, labels, p,
         method = c("stable", "original", "stable.fast"), m.max = Inf,
         fixedGaps = NULL, fixedEdges = NULL, NAdelete = TRUE,
         numCores = 1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>suffStat</code></td>
<td>
<p>Sufficient statistics: List containing all necessary
elements for the conditional independence decisions in the
function <code>indepTest</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indepTest</code></td>
<td>
<p>Predefined <code>function</code> for testing
conditional independence.  The function is internally called as
<code>indepTest(x,y,S,suffStat)</code> and tests conditional independence
of <code>x</code> and <code>y</code> given <code>S</code>.  Here, <code>x</code> and
<code>y</code> are variables, and <code>S</code> is a (possibly empty) vector of
variables (all variables are denoted by their column numbers
in the adjacency matrix). <code>suffStat</code> is a list containing
all relevant elements for the conditional independence decisions.
The return value of <code>indepTest</code> is the p-value of the test for
conditional independence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>significance level (number in <code class="reqn">(0,1)</code> for the
individual conditional independence tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>(optional) character vector of variable (or
“node”) names.  Typically preferred to specifying <code>p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>(optional) number of variables (or nodes).  May be specified
if <code>labels</code> are not, in which case <code>labels</code> is set to
<code>1:p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Character string specifying method; the default,
<code>"stable"</code> provides an <em>order-independent</em> skeleton, see
‘Details’ below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.max</code></td>
<td>
<p>Maximal size of the conditioning sets that are considered in the
conditional independence tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedGaps</code></td>
<td>
<p>logical <em>symmetric</em> matrix of dimension p*p.  If entry
<code>[i,j]</code> is true, the edge <code class="reqn">i--j</code> is removed before
starting the algorithm.  Therefore, this edge is guaranteed to be
<em>absent</em> in the resulting graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedEdges</code></td>
<td>
<p>a logical <em>symmetric</em> matrix of dimension p*p.  If entry
<code>[i,j]</code> is true, the edge <code class="reqn">i--j</code> is never considered
for removal.  Therefore, this edge is guaranteed to be <em>present</em> in
the resulting graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NAdelete</code></td>
<td>
<p>logical needed for the case <code>indepTest(*)</code>
returns <code>NA</code>.  If it is true, the corresponding edge is
deleted, otherwise not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numCores</code></td>
<td>
<p>number of processor cores to use for parallel computation.
Only available for <code>method = "stable.fast"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, detailed output is provided.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Under the assumption that the distribution of the observed variables
is faithful to a DAG and that there are <b>no</b> latent and selection
variables, this function estimates the skeleton of the DAG.  The
skeleton of a DAG is the undirected graph resulting from removing all
arrowheads from the DAG.  Edges in the skeleton of a DAG have the
following interpretation:
<br>
There is an edge between <code class="reqn">i</code> and <code class="reqn">j</code>, <code class="reqn">i</code> – <code class="reqn">j</code>,
if and only if variables <code class="reqn">i</code> and <code class="reqn">j</code> are conditionally
dependent given <code class="reqn">S</code> for all possible subsets <code class="reqn">S</code> of the
remaining nodes.
</p>
<p>On the other hand, the distribution of the observed variables
is faithful to a DAG with <b>arbitrarily many</b> latent and selection
variables, <code>skeleton()</code> estimates the initial skeleton of the
DAG.  Edges in this initial skeleton of a DAG have the
following interpretation:
<br>
There is an edge <code class="reqn">i</code> – <code class="reqn">j</code> if and only if variables <code class="reqn">i</code> and
<code class="reqn">j</code> are conditionally dependent given <code class="reqn">S</code> for all possible
subsets <code class="reqn">S</code> of the neighbours of <code class="reqn">i</code> and the neighbours of
<code class="reqn">j</code>.
</p>
<p>The data are not required to follow a specific distribution,
but one should make sure that the conditional indepedence test used in
<code>indepTest</code> is appropriate for the data.  Pre-programmed versions
of <code>indepTest</code> are available for Gaussian data
(<code>gaussCItest</code>), discrete data (<code>disCItest</code>),
and binary data (see <code>binCItest</code>).  Users may also specify
their own <code>indepTest</code> function.
</p>
<p>The PC algorithm (Spirtes, Glymour and Scheines, 2000)
(<code>method = "original"</code>) is known to be order-dependent, in the
sense that the output may depend on the order in which the variables
are given.  Therefore, Colombo and Maathuis (2014) proposed a simple
modification, called “PC-stable”, which yields
order-independent adjacencies in the skeleton, provided by <code>pc()</code>
with the new default <code>method = "stable"</code>.  This stable variant
of the algorithm is also available with the <code>method = "stable.fast"</code>:
it runs the algorithm of Colombo and Maathuis (2014) faster than
<code>method = "stable"</code> in general, but should be regarded as an
experimental option at the moment.
</p>
<p>The algorithm starts with a complete undirected graph.  In each
step, it visits all pairs <code class="reqn">(i,j)</code> of adjacent nodes in the
current graph, and determines based on conditional independence tests
whether the edge <code class="reqn">i--j</code> should be removed.  In particular, for each step
<code class="reqn">m</code> (<code class="reqn">m=0,1,\dots</code>) of the size of the conditioning sets, the
algorithm at first determines the neighbours <code class="reqn">a(i)</code> of each node
<code class="reqn">i</code> in the graph.  Then, the algorithm visits all pairs <code class="reqn">(i,j)</code>
of adjacent nodes in the current graph, and the edge <code class="reqn">i--j</code> is
kept if and only if the null hypothesis
<br><em><code class="reqn">i</code> and <code class="reqn">j</code> are conditionally independent given S</em>
<br>
rejected at significance level <code>alpha</code> for all subsets <code class="reqn">S</code> of size
<code class="reqn">m</code> of <code class="reqn">a(i)</code> and of <code class="reqn">a(j)</code> (as judged by the function
<code>indepTest</code>).  For the <code>"stable"</code> method, the neighborhoods
<code class="reqn">a(i)</code> are kept fixed within each value of <code class="reqn">m</code>, and this
makes the algorithm order-independent.  Method <code>"original"</code>,
the original PC algorithm would update the neighbour list after each
edge change.
</p>
<p>The algorithm stops when <code class="reqn">m</code> is larger than the largest
neighbourhood size of all nodes, or when <code class="reqn">m</code> has reached the limit
<code>m.max</code> which may be set by the user.
</p>
<p>Since the FCI (Spirtes, Glymour and Scheines, 2000) and RFCI (Colombo
et al., 2012) algorithms are built up from the PC algorithm, they are also
order-dependent in the skeleton.  To resolve their order-dependence
issues in the skeleton is more involved, see Colombo and Maathuis
(2014).  However now, with <code>method = "stable"</code>, this function
estimates an initial order-independent skeleton in these algorithms
(for additional details on how to make the final skeleton of FCI fully
order-independent see <code>fci</code> and Colombo and Maathuis (2014)).
</p>
<p>The information in <code>fixedGaps</code> and <code>fixedEdges</code> is used as follows.
The gaps given in <code>fixedGaps</code> are introduced in the very beginning of
the algorithm by removing the corresponding edges from the complete
undirected graph.  Pairs <code class="reqn">(i,j)</code> in <code>fixedEdges</code> are skipped
in all steps of the algorithm, so that these edges remain in the graph.
</p>


<p>Note: Throughout, the algorithm works with the column positions of
the variables in the adjacency matrix, and not with the names of
the variables.
</p>


<h3>Value</h3>

<p>An object of <code>class</code> <code>"pcAlgo"</code> (see
<code>pcAlgo</code>) containing an estimate of the skeleton of
the underlying DAG, the conditioning sets (<code>sepset</code>) that led to
edge removals and several other parameters.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>), Martin Maechler,
Alain Hauser, and Diego Colombo.
</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782. 
</p>
<p>D. Colombo, M. H. Maathuis, M. Kalisch, T. S. Richardson
(2012). Learning high-dimensional directed acyclic graphs with latent
and selection variables. <em>Ann. Statist.</em> <b>40</b>, 294-321.
</p>
<p>M. Kalisch and P. Buehlmann (2007).
<em>Estimating high-dimensional directed acyclic graphs with the
PC-algorithm</em>, JMLR <b>8</b> 613-636.
</p>
<p>P. Spirtes, C. Glymour and R. Scheines (2000).
<em>Causation, Prediction, and Search</em>, 2nd edition, MIT Press.
</p>


<h3>See Also</h3>

<p><code>pc</code> for generating a partially directed graph
using the PC algorithm; <code>fci</code> for generating a partial
ancestral graph using the FCI algorithm; <code>rfci</code> for
generating a partial ancestral graph using the RFCI algorithm;
<code>udag2pdag</code> for converting the skeleton to a CPDAG.
</p>
<p>Further, <code>gaussCItest</code>, <code>disCItest</code>,
<code>binCItest</code> and <code>dsepTest</code> as examples for
<code>indepTest</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">##################################################
## Using Gaussian Data
##################################################
## Load predefined data
data(gmG)
n &lt;- nrow    (gmG8$x)
V &lt;- colnames(gmG8$x) # labels aka node names

## estimate Skeleton
skel.fit &lt;- skeleton(suffStat = list(C = cor(gmG8$x), n = n),
                     indepTest = gaussCItest, ## (partial correlations)
                     alpha = 0.01, labels = V, verbose = TRUE)
if (require(Rgraphviz)) {
  ## show estimated Skeleton
  par(mfrow=c(1,2))
  plot(skel.fit, main = "Estimated Skeleton")
  plot(gmG8$g, main = "True DAG")
}

##################################################
## Using d-separation oracle
##################################################

## define sufficient statistics (d-separation oracle)
Ora.stat &lt;- list(g = gmG8$g, jp = RBGL::johnson.all.pairs.sp(gmG8$g))
## estimate Skeleton
fit.Ora &lt;- skeleton(suffStat=Ora.stat, indepTest = dsepTest, labels = V,
                    alpha=0.01) # &lt;- irrelevant as dsepTest returns either 0 or 1

if (require(Rgraphviz)) {
  ## show estimated Skeleton
  plot(fit.Ora, main = "Estimated Skeleton (d-sep oracle)")
  plot(gmG8$g, main = "True DAG")
}
##################################################
## Using discrete data
##################################################
## Load data
data(gmD)
V &lt;- colnames(gmD$x) # labels aka node names

## define sufficient statistics
suffStat &lt;- list(dm = gmD$x, nlev = c(3,2,3,4,2), adaptDF = FALSE)

## estimate Skeleton
skel.fit &lt;- skeleton(suffStat,
                     indepTest = disCItest, ## (G^2 statistics independence test)
                     alpha = 0.01, labels = V, verbose = TRUE)
if (require(Rgraphviz)) {
  ## show estimated Skeleton
  par(mfrow = c(1,2))
  plot(skel.fit, main = "Estimated Skeleton")
  plot(gmD$g, main = "True DAG")
}

##################################################
## Using binary data
##################################################
## Load binary data
data(gmB)
X &lt;- gmB$x

## estimate Skeleton
skel.fm2 &lt;- skeleton(suffStat = list(dm = X, adaptDF = FALSE),
                     indepTest = binCItest, alpha = 0.01,
                     labels = colnames(X), verbose = TRUE)
if (require(Rgraphviz)) {
  ## show estimated Skeleton
  par(mfrow = c(1,2))
  plot(skel.fm2, main = "Binary Data 'gmB': Estimated Skeleton")
  plot(gmB$g, main = "True DAG")
}
</code></pre>


</div>
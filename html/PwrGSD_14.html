<div class="container">

<table style="width: 100%;"><tr>
<td>Haybittle</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Haybittle method of Boundary Construction</h2>

<h3>Description</h3>

<p>The function <code>Haybittle</code> is used in calls to the functions <code>GrpSeqBnds</code> and
<code>PwrGSD</code> as a possible setting for the argument <code>EfficacyBoundary</code>. NOTE: the
Haybittle method is not implemented as a futility boundary method The Haybittle method
is one of four currently availiable choices (efficacy only), the others being
<code>LanDemets</code>, <code>SC</code> (stochastic curtailment), and user specified.  </p>


<h3>Usage</h3>

<pre><code class="language-R">  Haybittle(alpha, b.Haybittle, from = NULL, to = NULL) </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The total probability of type I error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.Haybittle</code></td>
<td>
<p>User specified efficacy boundary at all but the
last analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>WARNING EXPERIMENTAL: See the documentation under
<code>LanDemets</code> or <code>SC</code>. I'm not quite sure if this works
or even makes sense. Don't use it, ok?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>See above.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Haybittle approach is conceptually the simplest of all methods for efficacy boundary
construction. However, as it spends nearly no alpha until the end, is for all practical
purposes equivalent to a single analysis design and to be considered overly
conservative. This method sets all the boundary points equal to <code>b.Haybittle</code>, a
user specified value (try 3) for all analyses except the last, which is calculated so as
to result in the total type I error, set with the argument <code>alpha</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>boundary.construction.method</code> which is really a list
with the following components. The print method displays the original
call.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Gives the boundary construction method type, which is the character
string "Haybittle"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The numeric value passed to the argument 'alpha' which is
the total probability of type I error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.Haybittle</code></td>
<td>
<p>The numeric value passed to the argument 'b.Haybittle' which is
the user specified efficacy boundary at all but the
last analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>Description of 'comp2'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>You're not using this, right? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>see above.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The print method returns the call by default</p>


<h3>Author(s)</h3>

<p>Grant Izmirlian</p>


<h3>References</h3>

<p>see references under <code>PwrGSD</code></p>


<h3>See Also</h3>

<p><code>LanDemets</code>, <code>SC</code>, <code>GrpSeqBnds</code>, and 
<code>PwrGSD</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## example 1: what is the result of calling a Boundary Construction Method function
    ## A call to 'Haybittle' just returns the call
    Haybittle(alpha=0.05, b.Haybittle=3)
    
    ## It does arguement checking...this results in an error
    ## Not run: 
      Haybittle(alpha=0.05)
    
## End(Not run)
    
    ## but really its value is a list with the a component containing
    ## the boundary method type, "LanDemts", and components for each
    ## of the arguments.
    names(Haybittle(alpha=0.05, b.Haybittle=3))

    Haybittle(alpha=0.05, b.Haybittle=3)$type
    Haybittle(alpha=0.05, b.Haybittle=3)$alpha
    Haybittle(alpha=0.05, b.Haybittle=3)$b.Haybittle
    Haybittle(alpha=0.05, b.Haybittle=3)$call

## example 2: ...But the intended purpose of the spending functions 
## is in constructing calls to 'GrpSeqBnds' and to 'PwrGSD':
     

    frac &lt;- c(0.07614902,0.1135391,0.168252,0.2336901,0.3186155,
              0.4164776,0.5352199,0.670739,0.8246061,1)

    test &lt;- GrpSeqBnds(frac=frac, EfficacyBoundary=Haybittle(alpha=0.025, b.Haybittle=3))
</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>psp_global</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parameter Space Partitioning</h2>

<h3>Description</h3>

<p>An all-purpose implementation of the Parameter Space Partitioning MCMC
Algorithm described by Pitt, Kim, Navarro, Myung (2006).
</p>


<h3>Usage</h3>

<pre><code class="language-R">psp_global(fn, control = psp_control(), ..., quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>The ordinal function. It should take a numeric vector (parameter set)
as its argument, and return an ordinal response pattern as character (e.g.
"A &gt; B"). NA values are not currently allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control parameters, see <code>psp_control</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to <code>fn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>If <code>FALSE</code> (default), print the total number of patterns
found up to the current iteration. If <code>TRUE</code>, do not print anything.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function implements the Parameter Space Partitioning algorithm
desribed by Pitt et al. (2006). The algorithm is as follows:
</p>
<p>0. Initialize parameter space.
</p>
<p>0. Select first set of parameters, and evaluate the model on this set. Its
ordinal output will become the first ordinal pattern and the first region
in the parameter space.
</p>
<p>1. Pick a random jumping distribution from for each ordinal pattern from the
sampling region defined by a hypershere with a center of the last recorded
parameter set for a given pattern.
</p>
<p>2. Evaluate model on all new parameter sets.
</p>
<p>3. Record new patterns and their corresponding parameter sets. If the
parameter sets returns an already discovered pattern, add parameter set
to their records. Return to Step 1.
</p>
<p>This process runs can run in parallel for each discovered pattern.
</p>


<h3>Value</h3>

<p>The output of function <code>psp</code> is a member of the <code>S3</code> class
of <code>PSP</code>. A <code>PSP</code> object is a list with the following items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>ps_partitions</code></td>
<td>
<p>A <code>data.table</code> containing coordinates from the
parameter space and their corresponding ordinal response pattern output by
<code>fn</code>. Columns include (in this order): parameter coordinates,
their ordinal pattern output by <code>fn</code>, the global iteration of the
MCMC. Each row corresponds with the evaluation of a single set of
parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ps_patterns</code></td>
<td>
<p>A table with the ordinal patterns discovered and the
population of their corresponding region - the number of parameter sets
discovered to produce the ordinal pattern.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ps_ordinal</code></td>
<td>
<p>A list (if ordinal patterns are multidimensional objects)
or character vector (if ordinal patterns are strings or other single values)
with the ordinal patterns found. The place of the ordinal pattern
corresponds to the names in ps_patterns.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Pitt, M. A., Kim, W., Navarro, D. J., &amp; Myung, J. I. (2006). Global model analysis by parameter space partitioning. Psychological Review, 113(1), 57.
</p>
<p>Weisstein, Eric W. "Hypersphere Point Picking." From MathWorldâ€“A Wolfram Web Resource. https://mathworld.wolfram.com/HyperspherePointPicking.html
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(psp)

#' euclidean distance
#'
#' @param a vector coordinate 1
#' @param b vector coordinate 2
#' @return euclidean distance between coordinates
euclidean &lt;- function(a, b) sqrt(sum((a - b)^2))

# define center points for the 10 regions in a two-dimensional space
positions &lt;- NULL
for (i in seq_len(2)) positions &lt;- cbind(positions, sample(500, 10))

#' dummy hypercube model to test the PSP function
#' The model takes in a set of coordinates, calculates its distance from all
#' all of available coordinates, then return closest region number.
#' This model generalizes to n-dimensions
#'
#' @param x a vector of coordinates
#' @return The number of the region as character
#' @examples
#' model(runif(5))
model &lt;- function(par) {
    areas &lt;- NULL
    for (i in seq_along(par)) {
        range &lt;- c(1, 0)
        if (i %% 2 == 0) {
            range &lt;- c(0, 1)
        }
        areas &lt;- cbind(areas,
                       seq(range[1], range[2], length.out = 500)[positions[,i]])
    }
    dist &lt;- apply(areas, 1, function(x) euclidean(par, x))
    return(as.character(which.min(dist)))
}

# run Parameter Space Partitioning with some default settings
# Here we run the MCMC for 400 iterations, but the partitioning
# will stop if the population of all regions reach 200.
# Note that we have to load our utility function into
# the clusters, because PSPglobal is currently parallelized.
out &lt;- psp_global(model, psp_control(lower = rep(0, 2),
                                   upper = rep(1, 2),
                                   init = rep(0.5, 2),
                                   radius = rep(0.25, 2),
                                   pop = 100,
                                   parallel = FALSE,
                                   iterations = 100))

print(out)

</code></pre>


</div>
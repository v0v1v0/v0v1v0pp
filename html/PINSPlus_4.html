<div class="container">

<table style="width: 100%;"><tr>
<td>PerturbationClustering</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perturbation clustering</h2>

<h3>Description</h3>

<p>Perform subtyping using one type of high-dimensional data
</p>


<h3>Usage</h3>

<pre><code class="language-R">PerturbationClustering(
  data,
  kMin = 2,
  kMax = 5,
  k = NULL,
  verbose = T,
  ncore = 1,
  clusteringMethod = "kmeans",
  clusteringFunction = NULL,
  clusteringOptions = NULL,
  perturbMethod = "noise",
  perturbFunction = NULL,
  perturbOptions = NULL,
  PCAFunction = NULL,
  iterMin = 20,
  iterMax = 200,
  madMin = 0.001,
  msdMin = 1e-06,
  sampledSetSize = 2000,
  knn.k = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Input matrix. The rows represent items while the columns represent features.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kMin</code></td>
<td>
<p>The minimum number of clusters used for automatically detecting the number of clusters. Default value is <code>2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kMax</code></td>
<td>
<p>The maximum number of clusters used for automatically detecting the number of clusters. Default value is <code>5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of clusters. If k is set then kMin and kMax will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Boolean value indicating the algorithm to run with or without logging. Default value is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore</code></td>
<td>
<p>Number of cores that the algorithm should use. Default value is <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusteringMethod</code></td>
<td>
<p>The name of built-in clustering algorithm that PerturbationClustering will use. Currently supported algorithm are <code>kmeans</code>, <code>pam</code> and <code>hclust</code>. Default value is "<code>kmeans</code>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusteringFunction</code></td>
<td>
<p>The clustering algorithm function that will be used instead of built-in algorithms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusteringOptions</code></td>
<td>
<p>A list of parameter will be passed to the clustering algorithm in <code>clusteringMethod</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perturbMethod</code></td>
<td>
<p>The name of built-in perturbation method that PerturbationClustering will use, currently supported methods are <code>noise</code> and <code>subsampling</code>. Default value is "<code>noise</code>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perturbFunction</code></td>
<td>
<p>The perturbation method function that will be used instead of built-in ones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perturbOptions</code></td>
<td>
<p>A list of parameter will be passed to the perturbation method in <code>perturbMethod</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PCAFunction</code></td>
<td>
<p>The customized PCA function that user can manually define.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterMin</code></td>
<td>
<p>The minimum number of iterations. Default value is <code>20</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterMax</code></td>
<td>
<p>The maximum number of iterations. Default value is <code>200</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>madMin</code></td>
<td>
<p>The minimum of Mean Absolute Deviation of <code>AUC</code> of Connectivity matrix for each <code>k</code>. Default value is <code>1e-03</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msdMin</code></td>
<td>
<p>The minimum of Mean Square Deviation of <code>AUC</code> of Connectivity matrix for each <code>k</code>. Default value is <code>1e-06</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampledSetSize</code></td>
<td>
<p>The number of sample size used for the sampling process when dataset is big. Default value is <code>2000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knn.k</code></td>
<td>
<p>The value of k of the k-nearest neighbors algorithm. If knn.k is not set then it will be used the elbow method to calculate k.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>PerturbationClustering implements the Perturbation Clustering algorithm of Nguyen et al. (2017),  Nguyen et al. (2019), and Nguyen et al. (2021).
It aims to determine the optimum cluster number and location of each sample in the clusters in an unsupervised analysis.
</p>
<p>PerturbationClustering takes input as a numerical matrix or data frame of items as rows and features as columns.
It uses a clustering algorithm as the based algorithm.
Current built-in algorithms that users can use directly are <code>kmeans</code>, <code>pam</code> and <code>hclust</code>.
The default parameters for built-in <code>kmeans</code> are <code>nstart = 20 and iter.max = 1000</code>.
Users can change the parameters of built-in clustering algorithm by passing the value into <code>clusteringOptions</code>.
</p>
<p>PerturbationClustering also allows users to pass their own clustering algorithm instead of using built-in ones by using <code>clusteringFunction</code> parameter. 
Once <code>clust?eringFunction</code> is specified, <code>clusteringMethod</code> will be skipped.
The value of <code>clusteringFunction</code> must be a function that takes two arguments: <code>data</code> and <code>k</code>, 
where <code>data</code> is a numeric matrix or data frame containing data that need to be clustered, and <code>k</code> is the number of clusters.
<code>clusteringFunction</code> must return a vector of labels indicating the cluster to which each sample is allocated.
</p>
<p>PerturbationClustering uses a perturbation method to perturb clustering input data.
There are two built-in methods are <code>noise</code> and <code>subsampling</code> that users can use directly by passing to <code>perturbMethod</code> parameter.
Users can change the default value of built-in perturbation methods by passing new value into <code>perturbOptions</code>:
</p>
<p>1. <code>noise</code> perturbation method takes two arguments: <code>noise</code> and <code>noisePercent</code>. The default values are <code>noise = NULL and noisePercent = "median"</code>.
If <code>noise</code> is specified. <code>noisePercent</code> will be skipped.<br>
2. <code>subsampling</code> perturbation method takes one argument <code>percent</code> which has default value of <code>80</code>
</p>
<p>Users can also use their own perturbation methods by passing them into <code>perturbFunction</code>. 
Once <code>perturbFunction</code> is specified, <code>perturbMethod</code> will be skipped.
The value of <code>perturbFunction</code> must be a function that takes one argument <code>data</code>
- a numeric matrix or data frame containing data that need to be perturbed.
<code>perturbFunction</code> must return an object list which is as follows:
</p>
<p>1. <code>data</code>: the perturbed data<br>
2. <code>ConnectivityMatrixHandler</code>: a function that takes three arguments:
<code>connectivityMatrix</code> - the connectivity matrix generated after clustering returned <code>data</code>, 
<code>iter</code> - the current iteration and <code>k</code> - the number of cluster. 
This function must return a compatible connectivity matrix with the original connectivity matrix. 
This function aims to correct the <code>connectivityMatrix</code> if needed and returns the corrected version of it.<br>
3. <code>MergeConnectivityMatrices</code>: a function that takes four arguments: <code>oldMatrix</code>, <code>newMatrix</code>, <code>k</code> and <code>iter</code>. 
The <code>oldMatrix</code> and <code>newMatrix</code> are two connectivity matrices that need to be merged,
<code>k</code> is the cluster number and <code>iter</code> is the current number of iteration.
This function must returns a connectivity matrix that is merged from <code>oldMatrix</code> and <code>newMatrix</code>
</p>
<p>The parameters <code>sampledSetSize</code> and <code>knn.k</code> are used for subsampling procedure when clustering big data. Please consult Nguyen et al. (2021) for details.
</p>


<h3>Value</h3>

<p><code>PerturbationClustering</code> returns a list with at least the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The optimal number of clusters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>A vector of labels indicating the cluster to which each sample is allocated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origS</code></td>
<td>
<p>A list of original connectivity matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pertS</code></td>
<td>
<p>A list of perturbed connectivity matrices</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>1. H Nguyen, S Shrestha, S Draghici, &amp; T Nguyen. PINSPlus: a tool for tumor subtype discovery in integrated genomic data. Bioinformatics, 35(16), 2843-2846, (2019).
</p>
<p>2. T Nguyen, R Tagett, D Diaz, S Draghici. A novel method for data integration and disease subtyping. Genome Research, 27(12):2025-2039, 2017.
</p>
<p>3. T. Nguyen, "Horizontal and vertical integration of bio-molecular data", PhD thesis, Wayne State University, 2017.
</p>
<p>4. H Nguyen, D Tran, B Tran, M Roy, A Cassell, S Dascalu, S Draghici &amp; T Nguyen. SMRT: Randomized Data Transformation for Cancer Subtyping and Big Data Analysis. Frontiers in oncology. 2021.
</p>


<h3>See Also</h3>

<p><code>kmeans</code>, <code>pam</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Load the dataset AML2004
data(AML2004)
data &lt;- as.matrix(AML2004$Gene)
# Perform the clustering
result &lt;- PerturbationClustering(data = data)

# Plot the result
condition = seq(unique(AML2004$Group[, 2]))
names(condition) &lt;- unique(AML2004$Group[, 2])
plot(
    prcomp(data)$x,
    col = result$cluster,
    pch = condition[AML2004$Group[, 2]],
    main = "AML2004"
)
legend(
    "bottomright",
    legend = paste("Cluster ", sort(unique(result$cluster)), sep = ""),
    fill = sort(unique(result$cluster))
)
legend("bottomleft", legend = names(condition), pch = condition)

# Change kmeans parameters
result &lt;- PerturbationClustering(
    data = data,
    clusteringMethod = "kmeans",
    clusteringOptions = list(
        iter.max = 500,
        nstart = 50
    )
)

# Change to use pam
result &lt;- PerturbationClustering(data = data, clusteringMethod = "pam")

# Change to use hclust
result &lt;- PerturbationClustering(data = data, clusteringMethod = "hclust")

# Pass a user-defined clustering algorithm
result &lt;- PerturbationClustering(data = data, clusteringFunction = function(data, k){
    # this function must return a vector of cluster
    kmeans(x = data, centers = k, nstart = k*10, iter.max = 2000)$cluster
})      

# Use noise as the perturb method
result &lt;- PerturbationClustering(data = data, 
                                 perturbMethod = "noise", 
                                 perturbOptions = list(noise = 0.3))
# or
result &lt;- PerturbationClustering(data = data, 
                                 perturbMethod = "noise", 
                                 perturbOptions = list(noisePercent = 10))

# Change to use subsampling
result &lt;- PerturbationClustering(data = data, 
                                 perturbMethod = "subsampling", 
                                 perturbOptions = list(percent = 90))

# Users can pass their own perturb method
result &lt;- PerturbationClustering(data = data, perturbFunction = function(data){
   rowNum &lt;- nrow(data)
   colNum &lt;- ncol(data)
   epsilon &lt;-
       matrix(
           data = rnorm(rowNum * colNum, mean = 0, sd = 1.234),
           nrow = rowNum,
           ncol = colNum
       )
   
   list(
       data = data + epsilon,
       ConnectivityMatrixHandler = function(connectivityMatrix, ...) {
           connectivityMatrix
       },
       MergeConnectivityMatrices = function(oldMatrix, newMatrix, iter, ...){
           return((oldMatrix*(iter-1) + newMatrix)/iter)
       }
   )
})

# Clustering on simulation data
# Load necessary library

if (!require("mclust")) install.packages("mclust")
library(mclust)
library(irlba)

#Generate a simulated data matrix with the size of 50,000 x 5,000
sampleNum &lt;- 50000 # Number of samples
geneNum &lt;- 5000 # Number of genes
subtypeNum &lt;- 3 # Number of subtypes

# Generate expression matrix
exprs &lt;- matrix(rnorm(sampleNum*geneNum, 0, 1), nrow = sampleNum, ncol = geneNum) 
rownames(exprs) &lt;- paste0("S", 1:sampleNum) # Assign unique names for samples

# Generate subtypes
group &lt;- sort(rep(1:subtypeNum, sampleNum/subtypeNum + 1)[1:sampleNum])
names(group) &lt;- rownames(exprs)

# Make subtypes separate
for (i in 1:subtypeNum) {
   exprs[group == i, 1:100 + 100*(i-1)] &lt;- exprs[group == i, 1:100 + 100*(i-1)] + 2
}

# Plot the data
library(irlba)
exprs.pca &lt;- irlba::prcomp_irlba(exprs, n = 2)$x
plot(exprs.pca, main = "PCA")

#Run PINSPlus clustering:

set.seed(1)
t1 &lt;- Sys.time()
result &lt;- PerturbationClustering(data = exprs.pca, ncore = 1)
t2 &lt;- Sys.time()


#Print out the running time:

time&lt;- t2-t1

#Print out the number of clusters:

result$k

#Get cluster assignment

subtype &lt;- result$cluster

# Here we assess the clustering accurracy using Adjusted Rand Index (ARI). 
#ARI takes values from -1 to 1 where 0 stands for a random clustering and 1 
#stands for a perfect partition result. 
if (!require("mclust")) install.packages("mclust")
library(mclust)
ari &lt;- mclust::adjustedRandIndex(subtype, group)

#Plot the cluster assginments

colors &lt;- as.numeric(as.character(factor(subtype)))

plot(exprs.pca, col = colors, main = "Cluster assigments for simulation data")

legend("topright", legend = paste("ARI:", ari))

legend("bottomright", fill = unique(colors),
      legend = paste("Group ", 
                     levels(factor(subtype)), ": ", 
                     table(subtype)[levels(factor(subtype))], sep = "" )
)

</code></pre>


</div>
<div class="container">

<table style="width: 100%;"><tr>
<td>generatedata_mpin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation of MPIN model data</h2>

<h3>Description</h3>

<p>Generates a <code>dataset</code> object or a <code>data.series</code> object (a list
of <code>dataset</code> objects) storing simulation parameters as well as aggregate
daily buys and sells simulated following the assumption of the <code>MPIN</code> model
of (Ersan 2016).
</p>


<h3>Usage</h3>

<pre><code class="language-R">generatedata_mpin(series = 1, days = 60, layers = NULL,
                         parameters = NULL, ranges = list(), ...,
                         verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>series</code></td>
<td>
<p>The number of datasets to generate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>days</code></td>
<td>
<p>The number of trading days for which aggregated buys and
sells are generated. Default value is <code>60</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layers</code></td>
<td>
<p>The number of information layers to be included in the
simulated data. Default value is <code>NULL</code>.
If <code>layers</code> is omitted or set to <code>NULL</code>, the number of layers is uniformly
selected from the set <code>{1, ..., maxlayers}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>A vector of model parameters of size <code>3J+2</code>
where <code>J</code> is the number of information layers and it has the
following form
{<code class="reqn">\alpha</code><sub>1</sub>,
...,<code class="reqn">\alpha</code><sub>J</sub>,
<code class="reqn">\delta</code><sub>1</sub>,...,
<code class="reqn">\delta</code><sub>J</sub>,
<code class="reqn">\mu</code><sub>1</sub>,...,
<code class="reqn">\mu</code><sub>J</sub>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>}.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranges</code></td>
<td>
<p>A list of ranges for the different simulation
parameters having named elements <code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>,
and <code class="reqn">\mu</code>.
The value of each element is a vector of two numbers: the first one is the
minimal value <code>min_v</code> and the second one is the maximal value <code>max_v</code>.
If the element corresponding to a given parameter is missing, the default
range for that parameter is used. If the argument <code>ranges</code> is an empty
list and <code>parameters</code> is <code>NULL</code>, the default ranges for the parameters
are used. The simulation parameters are uniformly drawn from the interval
(<code>min_v</code>, <code>max_v</code>) for the specified parameters.
The default value is <code>list()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed on to the function
<code>generatedata_mpin()</code>. The recognized arguments are <code>confidence</code>,
<code>maxlayers</code>, <code>eps_ratio</code>, <code>mu_ratio</code>.
</p>

<ul>
<li> <p><code>confidence</code> (<code>numeric</code>) denotes the range of the confidence interval
associated with each layer such that all observations within the layer <code>j</code>
lie in the theoretical confidence interval of the Skellam distribution
centered on the mean order imbalance, at the level <code>'confidence'</code>.
The default value is <code>0.99</code>.
</p>
</li>
<li> <p><code>maxlayers</code> (<code>integer</code>) denotes the upper limit of number of layers
for the generated datasets. If the argument <code>layers</code> is missing, the layers
of the simulated datasets will be uniformly drawn from
<code>{1,..., maxlayers}</code>. When missing, <code>maxlayers</code> takes the default
value of <code>5</code>.
</p>
</li>
<li> <p><code>eps_ratio</code> (<code>numeric</code>) specifies the admissible range for the value
of the ratio <code class="reqn">\epsilon</code><sub>s</sub>/<code class="reqn">\epsilon</code><sub>b</sub>, It can be a two-value vector or just a single value.
If <code>eps_ratio</code> is a vector of two values: the first one is the minimal value
and the second one is the maximal value; and the function tries to generate
<code class="reqn">\epsilon</code><sub>s</sub> and <code class="reqn">\epsilon</code><sub>b</sub> satisfying that their ratios <code class="reqn">\epsilon</code><sub>s</sub>/<code class="reqn">\epsilon</code><sub>b</sub> lies within the interval
<code>eps_ratio</code>. If <code>eps_ratio</code> is a single number, then the function tries to
generate <code class="reqn">\epsilon</code><sub>s</sub> and <code class="reqn">\epsilon</code><sub>b</sub> satisfying <code class="reqn">\epsilon</code><sub>s</sub> = <code class="reqn">\epsilon</code><sub>b</sub> x <code>eps_ratio</code>. If this range
conflicts with other arguments such as <code>ranges</code>, a warning is displayed.
The default value is <code>c(0.75, 1.25)</code>.
</p>
</li>
<li> <p><code>mu_ratio</code> (<code>numeric</code>) it is the minimal value of the ratio between
two consecutive values of the vector <code>mu</code>. If <code>mu_ratio = 1.25</code> e.g., then
<code class="reqn">\mu</code><sub>j+1</sub> should be larger than
<code>1.25</code>* <code class="reqn">\mu</code><sub>j</sub> for all
<code style="white-space: pre;">⁠j = 1, .., J⁠</code>. If <code>mu_ratio</code> conflicts with other arguments such as <code>ranges</code>
or <code>confidence</code>, a warning is displayed. The default value is <code>NULL</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>(<code>logical</code>) a binary variable that determines whether detailed
information about the progress of the data generation is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An information layer refers to a given type of information event existing
in the data. The <code>PIN</code> model assumes a single type of information events
characterized by three parameters for <code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, and
<code class="reqn">\mu</code>. The <code>MPIN</code> model relaxes the assumption, by relinquishing the
restriction on the number of information event types. When <code>layers = 1</code>,
generated data fit the assumptions of the <code>PIN</code> model.
</p>
<p>If the argument <code>parameters</code> is missing, then the simulation parameters are
generated using the ranges specified in the argument <code>ranges</code>.
If the argument <code>ranges</code> is <code>list()</code>, default ranges are used. Using the
default ranges, the simulation parameters are obtained using the following
procedure:
</p>

<ul>
<li> <p><code class="reqn">\alpha()</code>: a vector of length <code>layers</code>, where each
<code class="reqn">\alpha</code><sub>j</sub> is uniformly
distributed on <code>(0, 1)</code> subject to the condition:
<code class="reqn">\sum \alpha</code><sub>j</sub><code class="reqn">&lt; 1</code>.
</p>
</li>
<li> <p><code class="reqn">\delta()</code>: a vector of length <code>layers</code>, where each
<code class="reqn">\delta</code><sub>j</sub> uniformly distributed
on <code>(0, 1)</code>.
</p>
</li>
<li> <p><code class="reqn">\mu()</code>: a vector of length <code>layers</code>, where each
<code class="reqn">\mu</code><sub>j</sub> is uniformly distributed
on the interval <code style="white-space: pre;">⁠(0.5 max(⁠</code><code class="reqn">\epsilon</code><sub>b</sub><code style="white-space: pre;">⁠,⁠</code> <code class="reqn">\epsilon</code><sub>s</sub><code style="white-space: pre;">⁠), 5 max(⁠</code><code class="reqn">\epsilon</code><sub>b</sub><code style="white-space: pre;">⁠,⁠</code> <code class="reqn">\epsilon</code><sub>s</sub><code style="white-space: pre;">⁠))⁠</code>.
The <code class="reqn">\mu</code>:s are then sorted so the excess trading increases in the
information layers, subject to the condition that the ratio of two
consecutive <code class="reqn">\mu</code>'s should be at least <code>1.25</code>.
</p>
</li>
<li> <p><code class="reqn">\epsilon</code><sub>b</sub>: an integer drawn uniformly from the interval <code>(100, 10000)</code>
with step <code>50</code>.
</p>
</li>
<li> <p><code class="reqn">\epsilon</code><sub>s</sub>: an integer uniformly drawn from (<code>(3/4)</code><code class="reqn">\epsilon</code><sub>b</sub>, <code>(5/4)</code><code class="reqn">\epsilon</code><sub>b</sub>) with step
<code>50</code>.
</p>
</li>
</ul>
<p>Based on the simulation parameters <code>parameters</code>, daily buys and sells are
generated by the assumption that buys and sells
follow Poisson distributions with mean parameters (<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>) on days with no
information; with mean parameters
(<code class="reqn">\epsilon</code><sub>b</sub> + <code class="reqn">\mu</code><sub>j</sub>, <code class="reqn">\epsilon</code><sub>s</sub>) on days
with good information of layer <code class="reqn">j</code> and
(<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub> + <code class="reqn">\mu</code><sub>j</sub>) on days
with bad information of layer <code class="reqn">j</code>.
</p>
<p><strong>Considerations for the ranges of simulation parameters:</strong> While
<code>generatedata_mpin()</code> function enables the user to simulate data series
with any set of theoretical parameters,
we strongly recommend the use of parameter sets satisfying below conditions
which are in line with the nature of empirical data and the theoretical
models used within this package.
When parameter values are not assigned by the user, the function, by default,
simulates data series that are in line with these criteria.
</p>

<ul>
<li> <p><em>Consideration 1</em>: any <code class="reqn">\mu</code>'s value separable from <code class="reqn">\epsilon</code><sub>b</sub> and <code class="reqn">\epsilon</code><sub>s</sub>
values, as well as other <code class="reqn">\mu</code> values. Otherwise, the <code>PIN</code> and <code>MPIN</code>
estimation would not yield expected results.<br>
[x] Sharp example.1: <code class="reqn">\epsilon</code><sub>b</sub><code class="reqn"> = 1000</code>; <code class="reqn">\mu = 1</code>. In this case, no
information layer can be captured in a healthy way by the use of the models
which relies on Poisson distributions.<br>
[x] Sharp example.2: <code class="reqn">\epsilon</code><sub>s</sub><code class="reqn"> = 1000</code>,
<code class="reqn">\mu</code><sub>1</sub><code class="reqn"> = 1000</code>,
and <code class="reqn">\mu</code><sub>2</sub><code class="reqn"> = 1001</code>.
Similarly, no distinction can be
made on the two simulated layers of informed trading. In real life, this
entails that there is only one type of information which would also be the
estimate of the <code>MPIN</code> model. However, in the simulated data properties,
there would be 2 layers which will lead the user to make a wrong
evaluation of model performance.
</p>
</li>
<li> <p><em>Consideration 2</em>: <code class="reqn">\epsilon</code><sub>b</sub> and <code class="reqn">\epsilon</code><sub>s</sub> being relatively close to each other.
When they are far from each other, that would indicate that there is
substantial asymmetry between buyer and seller initiated trades, being a
strong signal for informed trading.
There is no theoretical evidence to indicate that the uninformed trading in
buy and sell sides deviate much from each other in real life.
Besides, numerous papers that work with <code>PIN</code> model provide close to
each other uninformed intensities.
when no parameter values are assigned by the user, the function generates
data with the condition of sell side uninformed trading to be in the range of
<code style="white-space: pre;">⁠(4/5):=80%⁠</code> and <code style="white-space: pre;">⁠(6/5):=120%⁠</code> of buy side uninformed rate.<br>
[x] Sharp example.3: <code class="reqn">\epsilon</code><sub>b</sub><code class="reqn"> = 1000</code>, <code class="reqn">\epsilon</code><sub>s</sub><code class="reqn"> = 10000</code>. In this
case, the <code>PIN</code> and <code>MPIN</code> models would tend to consider some of the trading
in sell side to be informed (which should be the actual case).
Again, the estimation results would deviate much from the simulation
parameters being a good news by itself but a misleading factor in model
evaluation.
See for example Cheng and Lai (2021) as a
misinterpretation of comparative performances. The paper's findings highly
rely on the simulations with extremely different <code class="reqn">\epsilon</code><sub>b</sub> and <code class="reqn">\epsilon</code><sub>s</sub> values
(813-8124 pair and 8126-812).
</p>
</li>
</ul>
<h3>Value</h3>

<p>Returns an object of class <code>dataset</code> if <code>series=1</code>, and an
object of class <code>data.series</code> if <code>series&gt;1</code>.
</p>


<h3>References</h3>

<p>Cheng T, Lai H (2021).
“Improvements in estimating the probability of informed trading models.”
<em>Quantitative Finance</em>, <b>21</b>(5), 771-796.<br><br> Ersan O (2016).
“Multilayer Probability of Informed Trading.”
<em>Available at SSRN 2874420</em>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># ------------------------------------------------------------------------ #
# There are different scenarios of using the function generatedata_mpin()  #
# ------------------------------------------------------------------------ #

# With no arguments, the function generates one dataset object spanning
# 60 days, containing a number of information layers uniformly selected
# from `{1, 2, 3, 4, 5}`, and where the parameters are chosen as
# described in the details.

sdata &lt;- generatedata_mpin()

# The number of layers can be deduced from the simulation parameters, if
# fed directly to the function generatedata_mpin() through the argument
# 'parameters'. In this case, the output is a dataset object with one
# information layer.

givenpoint &lt;- c(0.4, 0.1, 800, 300, 200)
sdata &lt;- generatedata_mpin(parameters = givenpoint)

# The number of layers can alternatively be set directly through the
# argument 'layers'.

sdata &lt;- generatedata_mpin(layers = 2)

# The simulation parameters can be randomly drawn from their corresponding
# ranges fed through the argument 'ranges'.

sdata &lt;- generatedata_mpin(ranges = list(alpha = c(0.1, 0.7),
                                        delta = c(0.2, 0.7),
                                        mu = c(3000, 5000)))

# The value of a given simulation parameter can be set to a specific value by
# setting the range of the desired parameter takes a unique value, instead of
# a pair of values.

sdata &lt;- generatedata_mpin(ranges = list(alpha = 0.4, delta = c(0.2, 0.7),
                                        eps.b = c(100, 7000),
                                        mu = c(8000, 12000)))

# If both arguments 'parameters', and 'layers' are simultaneously provided,
# and the number of layers detected from the length of the argument
# 'parameters' is different from the argument 'layers', the former is used
# and a warning is displayed.

sim.params &lt;- c(0.4, 0.2, 0.9, 0.1, 400, 700, 300, 200)
sdata &lt;- generatedata_mpin(days = 120, layers = 3, parameters = sim.params)

# Display the details of the generated data

show(sdata)

# ------------------------------------------------------------------------ #
# Use generatedata_mpin() to compare the accuracy of estimation methods    #
# ------------------------------------------------------------------------ #

# The example below illustrates the use of the function 'generatedata_mpin()'
# to compare the accuracy of the functions 'mpin_ml()', and 'mpin_ecm()'.

# The example will depend on three variables:
# n: the number of datasets used
# l: the number of layers in each simulated datasets
# xc : the number of extra clusters used in initials_mpin

# For consideration of speed, we will set n = 2, l = 2, and xc = 2
# These numbers can change to fit the user's preferences
n &lt;- l &lt;- xc &lt;- 2

# We start by generating n datasets simulated according to the
# assumptions of the MPIN model.

dataseries &lt;- generatedata_mpin(series = n, layers = l, verbose = FALSE)

# Store the estimates in two different lists: 'mllist', and 'ecmlist'

mllist &lt;- lapply(dataseries@datasets, function(x)
  mpin_ml(x@data, xtraclusters = xc, layers = l, verbose = FALSE))

ecmlist &lt;- lapply(dataseries@datasets, function(x)
  mpin_ecm(x@data, xtraclusters = xc, layers = l, verbose = FALSE))

# For each estimate, we calculate the absolute difference between the
# estimated mpin, and empirical mpin computed using dataset parameters.
# The absolute differences are stored in 'mldmpin' ('ecmdpin') for the
# ML (ECM) method,

mldpin &lt;- sapply(1:n,
 function(x) abs(mllist[[x]]@mpin - dataseries@datasets[[x]]@emp.pin))

ecmdpin &lt;- sapply(1:n,
 function(x) abs(ecmlist[[x]]@mpin - dataseries@datasets[[x]]@emp.pin))

# Similarly, we obtain vectors of running times for both estimation methods.
# They are stored in 'mltime' ('ecmtime') for the ML (ECM) method.

mltime &lt;- sapply(mllist, function(x) x@runningtime)
ecmtime &lt;- sapply(ecmlist, function(x) x@runningtime)

# Finally, we calculate the average absolute deviation from empirical PIN
# as well as the average running time for both methods. This allows us to
# compare them in terms of accuracy, and speed.

accuracy &lt;- c(mean(mldpin), mean(ecmdpin))
timing &lt;- c(mean(mltime), mean(ecmtime))
comparison &lt;- as.data.frame(rbind(accuracy, timing))
colnames(comparison) &lt;- c("ML", "ECM")
rownames(comparison) &lt;- c("Accuracy", "Timing")

show(round(comparison, 6))

</code></pre>


</div>
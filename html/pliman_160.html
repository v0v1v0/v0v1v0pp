<div class="container">

<table style="width: 100%;"><tr>
<td>utils_polygon</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Utilities for Polygons</h2>

<h3>Description</h3>

<p>Several useful functions for analyzing polygons. All of them are based on a
set of coordinate points that describe the edge of the object(s). If a list
of polygons is provided, it loops through the list and computes what is
needed for each element of the list.
</p>

<ul>
<li>
<p> Polygon measures
</p>

<ul>
<li> <p><code>conv_hull()</code> Computes the convex hull of a set of points.
</p>
</li>
<li> <p><code>conv_hull_unified()</code> Computes the convex hull of a set of points. Compared
to <code>conv_hull()</code>, <code>conv_hull_unified()</code> binds (unifies) the coordinates when
x is a list of coordinates.
</p>
</li>
<li> <p><code>poly_area()</code> Computes the area of a polygon given by the vertices in the
vectors x and y using the Shoelace formula, as follows (Lee and Lim,
2017): </p>
<p style="text-align: center;"><code class="reqn">A=\frac{1}{2}\left|\sum_{i=1}^{n}\left(x_{i} y_{i+1}-x_{i+1}
y_{i}\right)\right|</code>
</p>
<p> where <code>x</code> and <code>y</code> are the coordinates that form the
corners of a polygon, and <code>n</code> is the number of coordinates.
</p>
</li>
<li> <p><code>poly_angles()</code> Calculates the internal angles of the polygon using the
law of cosines.
</p>
</li>
<li> <p><code>poly_lw()</code> Returns the length and width of a polygon based on its
alignment to the y-axis (with poly_align()). The length is defined as the
range along the x-axis, and the width is defined as the range on the y-axis.
</p>
</li>
<li> <p><code>poly_mass()</code> Computes the center of mass of a polygon given by the
vertices in the vectors in <code>x</code>.
</p>
</li>
<li> <p><code>poly_solidity()</code> Computes the solidity of a shape as the ratio of
the shape area and the convex hull area.
</p>
</li>
</ul>
</li>
<li>
<p> Perimeter measures
</p>

<ul>
<li> <p><code>poly_slide()</code> Slides the coordinates of a polygon given by the vertices
in the vectors x and y so that the id-th point becomes the first one.
</p>
</li>
<li> <p><code>poly_distpts()</code> Computes the Euclidean distance between every point
of a polygon given by the vertices in the vectors x and y.
</p>
</li>
<li> <p><code>poly_centdist()</code> Computes the Euclidean distance between every point on
the perimeter and the centroid of the object.
</p>
</li>
<li> <p><code>poly_perimeter()</code> Computes the perimeter of a polygon given by the
vertices in the vectors x and y.
</p>
</li>
<li> <p><code>poly_caliper()</code> Computes the caliper (also called the Feret's diameter)
of a polygon given by the vertices in the vectors x and y.
</p>
</li>
</ul>
</li>
<li>
<p> Circularity measures (Montero et al. 2009).
</p>

<ul>
<li> <p><code>poly_circularity()</code> computes the circularity (C), also called shape
compactness or roundness measure, of an object. It is given by <code>C = P^2 / A</code>,
where P is the perimeter and A is the area of the object.
</p>
</li>
<li> <p><code>poly_circularity_norm()</code> computes the normalized circularity (Cn), which
is unity for a circle. This measure is invariant under translation,
rotation, scaling transformations, and is dimensionless. It is given by:
<code>Cn = P^2 / 4*pi*A</code>.
</p>
</li>
<li> <p><code>poly_circularity_haralick()</code> computes Haralick's circularity (CH). The
method is based on computing all Euclidean distances from the object
centroid to each boundary pixel. With this set of distances, the mean (<code>m</code>)
and the standard deviation (<code>sd</code>) are computed. These statistical parameters
are used to calculate the circularity, CH, of a shape as <code>CH = m/sd</code>.
</p>
</li>
<li> <p><code>poly_convexity()</code> computes the convexity of a shape using the ratio
between the perimeter of the convex hull and the perimeter of the polygon.
</p>
</li>
<li> <p><code>poly_eccentricity()</code> computes the eccentricity of a shape using the
ratio of the eigenvalues (inertia axes of coordinates).
</p>
</li>
<li> <p><code>poly_elongation()</code> computes the elongation of a shape as <code>1 - width / length</code>.
</p>
</li>
</ul>
</li>
<li>
<p> Utilities for polygons
</p>

<ul>
<li> <p><code>poly_check()</code> Checks a set of coordinate points and returns a matrix
with x and y columns.
</p>
</li>
<li> <p><code>poly_is_closed()</code> Returns a logical value indicating if a polygon is
closed.
</p>
</li>
<li> <p><code>poly_close()</code> and <code>poly_unclose()</code> close and unclose a polygon,
respectively.
</p>
</li>
<li> <p><code>poly_rotate() </code>Rotates the polygon coordinates by an angle (0-360
degrees) in the counterclockwise direction.
</p>
</li>
<li> <p><code>poly_flip_x()</code>, <code>poly_flip_y()</code> flip shapes along the x-axis and y-axis,
respectively.
</p>
</li>
<li> <p><code>poly_align()</code> Aligns the coordinates along their longer axis using the
var-cov matrix and eigen values.
</p>
</li>
<li> <p><code>poly_center()</code> Centers the coordinates on the origin.
</p>
</li>
<li> <p><code>poly_sample()</code> Samples n coordinates from existing points. Defaults
to 50.
</p>
</li>
<li> <p><code>poly_sample_prop()</code> Samples a proportion of coordinates from existing
points. Defaults to 0.1.
</p>
</li>
<li> <p><code>poly_spline()</code> Interpolates the polygon contour.
</p>
</li>
<li> <p><code>poly_smooth()</code> Smooths the polygon contour using a simple moving average.
</p>
</li>
<li> <p><code>poly_jitter()</code> Adds a small amount of noise to a set of point
coordinates. See <code>base::jitter()</code> for more details.
</p>
</li>
</ul>
</li>
<li> <p><code>poly_measures()</code> Is a wrapper around the <code style="white-space: pre;">⁠poly_*()⁠</code> functions.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">poly_check(x)

poly_is_closed(x)

poly_close(x)

poly_unclose(x)

poly_angles(x)

poly_limits(x)

conv_hull(x)

conv_hull_unified(x)

poly_area(x)

poly_slide(x, fp = 1)

poly_distpts(x)

poly_centdist(x)

poly_perimeter(x)

poly_rotate(x, angle, plot = TRUE)

poly_align(x, plot = TRUE)

poly_center(x, plot = TRUE)

poly_lw(x)

poly_eccentricity(x)

poly_convexity(x)

poly_caliper(x)

poly_elongation(x)

poly_solidity(x)

poly_flip_y(x)

poly_flip_x(x)

poly_sample(x, n = 50)

poly_sample_prop(x, prop = 0.1)

poly_jitter(x, noise_x = 1, noise_y = 1, plot = TRUE)

poly_circularity(x)

poly_circularity_norm(x)

poly_circularity_haralick(x)

poly_mass(x)

poly_spline(x, vertices = 100, k = 2)

poly_smooth(x, niter = 10, n = NULL, prop = NULL, plot = TRUE)

poly_measures(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A 2-column matrix with the <code>x</code> and <code>y</code> coordinates. If <code>x</code> is a list
of vector coordinates, the function will be applied to each element using
<code>base::lapply()</code> or <code>base::sapply()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fp</code></td>
<td>
<p>The ID of the point that will become the new first point. Defaults
to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>angle</code></td>
<td>
<p>The angle (0-360) to rotate the object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>Should the object be plotted? Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n, prop</code></td>
<td>
<p>The number and proportion of coordinates to sample from the
perimeter coordinates. In<code> poly_smooth()</code>, these arguments can be used to
sample points from the object's perimeter before smoothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise_x, noise_y</code></td>
<td>
<p>A numeric factor to define the noise added to the <code>x</code>
and <code>y</code> axes, respectively. See <code>base::jitter()</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertices</code></td>
<td>
<p>The number of spline vertices to create.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of points to wrap around the ends to obtain a smooth
periodic spline.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>An integer indicating the number of smoothing iterations.</p>
</td>
</tr>
</table>
<h3>Value</h3>


<ul>
<li> <p><code>conv_hull()</code> and <code>poly_spline()</code> returns a matrix with <code>x</code> and <code>y</code>
coordinates for the convex hull/smooth line in clockwise order. If <code>x</code> is a
list, a list of points is returned.
</p>
</li>
<li> <p><code>poly_area()</code> returns a <code>double</code>, or a numeric vector if <code>x</code> is a list of
vector points.
</p>
</li>
<li> <p><code>poly_mass()</code> returns a <code>data.frame</code> containing the coordinates for the
center of mass, as well as for the maximum and minimum distance from contour
to the center of mass.
</p>
</li>
<li> <p><code>poly_slides()</code>, <code>poly_distpts()</code>, <code>poly_spline()</code>, <code>poly_close()</code>,
<code>poly_unclose()</code>, <code>poly_rotate()</code>, <code>poly_jitter()</code>, <code>poly_sample()</code>,
<code>poly_sample_prop()</code>, and <code>poly_measures</code> returns a <code>data.frame</code>.
</p>
</li>
<li> <p><code>poly_perimeter()</code>, <code>poly_lw()</code>, <code>poly_eccentricity()</code>,
<code>poly_convexity()</code>, <code>poly_caliper()</code>, <code>poly_elongation()</code>,
<code>poly_circularity_norm()</code>, <code>poly_circularity_haralick()</code> returns a <code>double</code>.
</p>
</li>
</ul>
<h3>References</h3>

<p>Lee, Y., &amp; Lim, W. (2017). Shoelace Formula: Connecting the Area of a
Polygon and the Vector Cross Product. The Mathematics Teacher, 110(8),
631–636. <a href="https://doi.org/10.5951/mathteacher.110.8.0631">doi:10.5951/mathteacher.110.8.0631</a>
</p>
<p>Montero, R. S., Bribiesca, E., Santiago, R., &amp; Bribiesca, E. (2009). State
of the Art of Compactness and Circularity Measures. International
Mathematical Forum, 4(27), 1305–1335.
</p>
<p>Chen, C.H., and P.S.P. Wang. 2005. Handbook of Pattern Recognition and
Computer Vision. 3rd ed. World Scientific.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(pliman)
# A 2 x 2 square
df &lt;- draw_square(side = 2)

# square area
poly_area(df)

# polygon perimeter
poly_perimeter(df)

# center of mass of the square
cm &lt;- poly_mass(df)
plot_mass(cm)

# The convex hull will be the vertices of the square
(conv_square &lt;- conv_hull(df) |&gt; poly_close())
plot_contour(conv_square,
             col = "blue",
             lwd = 6)
poly_area(conv_square)


################### Example with a polygon ##################
x &lt;- c(0, 1,   2, 3,  5, 2, -1, 0, 0)
y &lt;- c(5, 6.5, 7, 3,  1, 1,  0, 2, 5)
df_poly &lt;- cbind(x, y)

# area of the polygon
plot_polygon(df_poly, fill = "red")
poly_area(df_poly)

# perimeter of the polygon
poly_perimeter(df_poly)

# center of mass of polygon
cm &lt;- poly_mass(df_poly)
plot_mass(cm,  col = "blue")

# vertices of the convex hull
(conv_poly &lt;- conv_hull(df_poly))

# area of the convex hull
poly_area(conv_poly)

plot_polygon(conv_poly,
             fill = "red",
             alpha = 0.2,
             add = TRUE)


############ example of circularity measures ################
tri &lt;- draw_circle(n = 200, plot = FALSE)
plot_polygon(tri, aspect_ratio = 1)
poly_circularity_norm(tri)

set.seed(1)
tri2 &lt;-
  draw_circle(n = 200, plot = FALSE) |&gt;
  poly_jitter(noise_x = 100, noise_y = 100, plot = FALSE)

plot_polygon(tri2, aspect_ratio = 1)
poly_circularity_norm(tri2)

</code></pre>


</div>
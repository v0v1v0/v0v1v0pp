<div class="container">

<table style="width: 100%;"><tr>
<td>calPlot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calibration plots for right censored data</h2>

<h3>Description</h3>

<p>Calibration plots for risk prediction models in right censored survival and
competing risks data
</p>


<h3>Usage</h3>

<pre><code class="language-R">calPlot(
  object,
  time,
  formula,
  data,
  splitMethod = "none",
  B = 1,
  M,
  pseudo,
  type,
  showPseudo,
  pseudo.col = NULL,
  pseudo.pch = NULL,
  method = "nne",
  round = TRUE,
  bandwidth = NULL,
  q = 10,
  bars = FALSE,
  hanging = FALSE,
  names = "quantiles",
  showFrequencies = FALSE,
  jack.density = 55,
  plot = TRUE,
  add = FALSE,
  diag = !add,
  legend = !add,
  axes = !add,
  xlim = c(0, 1),
  ylim = c(0, 1),
  xlab,
  ylab,
  col,
  lwd,
  lty,
  pch,
  cause = 1,
  percent = TRUE,
  giveToModel = NULL,
  na.action = na.fail,
  cores = 1,
  verbose = FALSE,
  cex = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A named list of prediction models, where allowed
entries are (1) R-objects for which a predictSurvProb method
exists (see details), (2) a <code>call</code> that evaluates to such an
R-object (see examples), (3) a matrix with predicted probabilities
having as many rows as <code>data</code> and as many columns as
<code>times</code>. For cross-validation all objects in this list must
include their <code>call</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>The evaluation time point at predicted event
probabilities are plotted against pseudo-observed event status.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A survival or event history formula. The left hand
side is used to compute the expected event status. If
<code>formula</code> is <code>missing</code>, try to extract a formula from the
first element in object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame in which to validate the prediction models
and to fit the censoring model. If <code>data</code> is missing, try to
extract a data set from the first element in object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splitMethod</code></td>
<td>
<p>Defines the internal validation design:
</p>
<p><code>none/noPlan</code>: Assess the models in the give <code>data</code>, usually
either in the same data where they are fitted, or in independent test data.
</p>
<p><code>BootCv</code>: Bootstrap cross validation. The prediction models
are trained on <code>B</code> bootstrap samples, that are either drawn
with replacement of the same size as the original data or without
replacement from <code>data</code> of the size <code>M</code>.  The models are
assessed in the observations that are NOT in the bootstrap sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>The number of cross-validation steps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>The size of the subsamples for cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pseudo</code></td>
<td>
<p>Logical. Determines the method for estimating expected event status:
</p>
<p><code>TRUE</code>: Use average pseudo-values.  <code>FALSE</code>: Use
the product-limit estimate, i.e., apply the Kaplan-Meier method for
right censored survival and the Aalen-Johansen method for right
censored competing risks data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Either "risk" or "survival".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showPseudo</code></td>
<td>
<p>If <code>TRUE</code> the
pseudo-values are shown as dots on the plot (only when <code>pseudo=TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pseudo.col</code></td>
<td>
<p>Colour for pseudo-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pseudo.pch</code></td>
<td>
<p>Dot type (see par) for pseudo-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The method for estimating the calibration curve(s):
</p>
<p><code>"nne"</code>: The expected event status is obtained in the nearest
neighborhood around the predicted event probabilities.
</p>
<p><code>"quantile"</code>: The expected event status is obtained in groups
defined by quantiles of the predicted event probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>round</code></td>
<td>
<p>If <code>TRUE</code> predicted probabilities are rounded to
two digits before smoothing. This may have a considerable effect on
computing efficiency in large data sets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p>The bandwidth for <code>method="nne"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>The number of quantiles for <code>method="quantile"</code> and <code>bars=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bars</code></td>
<td>
<p>If <code>TRUE</code>, use barplots to show calibration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hanging</code></td>
<td>
<p>Barplots only. If <code>TRUE</code>, hang bars corresponding to observed frequencies
at the value of the corresponding prediction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>Barplots only. Names argument passed to <code>names.arg</code> of <code>barplot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showFrequencies</code></td>
<td>
<p>Barplots only. If <code>TRUE</code>, show frequencies above the bars.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jack.density</code></td>
<td>
<p>Gray scale for pseudo-observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>If <code>FALSE</code>, do not plot the results, just return a plottable object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>If <code>TRUE</code> the line(s) are added to an existing
plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>
<p>If <code>FALSE</code> no diagonal line is drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>If <code>FALSE</code> no legend is drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axes</code></td>
<td>
<p>If <code>FALSE</code> no axes are drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>Limits of x-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>Limits of y-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>Label for y-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>Label for x-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>Vector with colors, one for each element of
object. Passed to <code>lines</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd</code></td>
<td>
<p>Vector with line widths, one for each element of
object. Passed to <code>lines</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p>lwd Vector with line style, one for each element of
object.  Passed to <code>lines</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch</code></td>
<td>
<p>Passed to <code>points</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cause</code></td>
<td>
<p>For competing risks models, the cause of failure or
event of interest</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>percent</code></td>
<td>
<p>If TRUE axes labels are multiplied by 100 and thus
interpretable on a percent scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>giveToModel</code></td>
<td>
<p>List of with exactly one entry for each entry in
<code>object</code>. Each entry names parts of the value of the fitted
models that should be extracted and added to the value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>Passed to <code>model.frame</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Number of cores for parallel computing.  Passed as
value of argument <code>mc.cores</code> to <code>mclapply</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code> report details of the progress,
e.g. count the steps in cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex</code></td>
<td>
<p>Default cex used for legend and labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Used to control the subroutines: plot, axis, lines, barplot,
legend. See <code>SmartControl</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For method "nne" the optimal bandwidth with respect to is obtained with the
function <code>dpik</code> from the package <code>KernSmooth</code> for a box
kernel function.
</p>


<h3>Value</h3>

<p>list with elements: time, pseudoFrame and bandwidth (NULL for method
quantile).
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(prodlim)
library(lava)
library(riskRegression)
library(survival)
# survival
dlearn &lt;- SimSurv(40)
dval &lt;- SimSurv(100)
f &lt;- coxph(Surv(time,status)~X1+X2,data=dlearn,x=TRUE,y=TRUE)
cf=calPlot(f,time=3,data=dval)
print(cf)
plot(cf)

g &lt;- coxph(Surv(time,status)~X2,data=dlearn,x=TRUE,y=TRUE)
cf2=calPlot(list("Cox regression X1+X2"=f,"Cox regression X2"=g),
    time=3,
    type="risk",
    data=dval)
print(cf2)
plot(cf2)
calPlot(f,time=3,data=dval,type="survival")
calPlot(f,time=3,data=dval,bars=TRUE,pseudo=FALSE)
calPlot(f,time=3,data=dval,bars=TRUE,type="risk",pseudo=FALSE)

## show a red line which follows the hanging bars
calPlot(f,time=3,data=dval,bars=TRUE,hanging=TRUE)
a &lt;- calPlot(f,time=3,data=dval,bars=TRUE,hanging=TRUE,abline.col=NULL)
lines(c(0,1,ceiling(a$xcoord)),
      c(a$offset[1],a$offset,a$offset[length(a$offset)]),
      col=2,lwd=5,type="s")

calPlot(f,time=3,data=dval,bars=TRUE,type="risk",hanging=TRUE)

set.seed(13)
m &lt;- crModel()
regression(m, from = "X1", to = "eventtime1") &lt;- 1
regression(m, from = "X2", to = "eventtime1") &lt;- 1
m &lt;- addvar(m,c("X3","X4","X5"))
distribution(m, "X1") &lt;- binomial.lvm()
distribution(m, "X4") &lt;- binomial.lvm()
d1 &lt;- sim(m,100)
d2 &lt;- sim(m,100)
csc &lt;- CSC(Hist(time,event)~X1+X2+X3+X4+X5,data=d1)
fgr &lt;- FGR(Hist(time,event)~X1+X2+X3+X4+X5,data=d1,cause=1)
if ((requireNamespace("cmprsk",quietly=TRUE))){
predict.crr &lt;- cmprsk:::predict.crr
cf3=calPlot(list("Cause-specific Cox"=csc,"Fine-Gray"=fgr),
        time=5,
        legend.x=-0.3,
        legend.y=1.35,
        ylab="Observed event status",
        legend.legend=c("Cause-specific Cox regression","Fine-Gray regression"),
        legend.xpd=NA)
print(cf3)
plot(cf3)

b1 &lt;- calPlot(list("Fine-Gray"=fgr),time=5,bars=TRUE,hanging=FALSE)
print(b1)
plot(b1)

calPlot(fgr,time=5,bars=TRUE,hanging=TRUE)
}

</code></pre>


</div>